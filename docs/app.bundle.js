/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9lNDhiIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLE9BQU8sR0FBR0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLEVBQS9CLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFFBQU0sSUFBSUMsS0FBSixDQUFV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QyxHQUFSLEdBQWNKLElBQWQ7QUFDQTNDLE9BQU8sQ0FBQ2dELGNBQVIsR0FBeUJMLElBQXpCO0FBQ0EzQyxPQUFPLENBQUNpRCxrQkFBUixHQUE2Qk4sSUFBN0I7QUFDQTNDLE9BQU8sQ0FBQ2tELElBQVIsR0FBZVAsSUFBZjtBQUNBM0MsT0FBTyxDQUFDbUQsZUFBUixHQUEwQlIsSUFBMUI7QUFDQTNDLE9BQU8sQ0FBQ29ELG1CQUFSLEdBQThCVCxJQUE5Qjs7QUFFQTNDLE9BQU8sQ0FBQ3FELFNBQVIsR0FBb0IsVUFBVUMsSUFBVixFQUFnQjtBQUFFLFNBQU8sRUFBUDtBQUFXLENBQWpEOztBQUVBdEQsT0FBTyxDQUFDdUQsT0FBUixHQUFrQixVQUFVRCxJQUFWLEVBQWdCO0FBQzlCLFFBQU0sSUFBSWhELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sT0FBTyxDQUFDd0QsR0FBUixHQUFjLFlBQVk7QUFBRSxTQUFPLEdBQVA7QUFBWSxDQUF4Qzs7QUFDQXhELE9BQU8sQ0FBQ3lELEtBQVIsR0FBZ0IsVUFBVUMsR0FBVixFQUFlO0FBQzNCLFFBQU0sSUFBSXBELEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFHQU4sT0FBTyxDQUFDMkQsS0FBUixHQUFnQixZQUFXO0FBQUUsU0FBTyxDQUFQO0FBQVcsQ0FBeEMiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/process/browser.js\n");

/***/ }),

/***/ "../node_modules/setimmediate/setImmediate.js":
/*!****************************************************!*\
  !*** ../node_modules/setimmediate/setImmediate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function (handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function (event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function (handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function (handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function (handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function (handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"../node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/ODVlNSJdLCJuYW1lcyI6WyJnbG9iYWwiLCJ1bmRlZmluZWQiLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsImRvY3VtZW50IiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJjYWxsYmFjayIsIkZ1bmN0aW9uIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1biIsImFwcGx5IiwicnVuSWZQcmVzZW50Iiwic2V0VGltZW91dCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwiTWF0aCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImV2ZW50Iiwic291cmNlIiwiZGF0YSIsImluZGV4T2YiLCJzbGljZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInRvU3RyaW5nIiwiY2FsbCIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFDLGtFQUFVQSxNQUFWLEVBQWtCQyxTQUFsQixFQUE2QjtBQUMxQjs7QUFFQSxNQUFJRCxNQUFNLENBQUNFLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxNQUFJQyxVQUFVLEdBQUcsQ0FBakIsQ0FQMEIsQ0FPTjs7QUFDcEIsTUFBSUMsYUFBYSxHQUFHLEVBQXBCO0FBQ0EsTUFBSUMscUJBQXFCLEdBQUcsS0FBNUI7QUFDQSxNQUFJQyxHQUFHLEdBQUdOLE1BQU0sQ0FBQ08sUUFBakI7QUFDQSxNQUFJQyxpQkFBSjs7QUFFQSxXQUFTTixZQUFULENBQXNCTyxRQUF0QixFQUFnQztBQUM5QjtBQUNBLFFBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0EsY0FBUSxHQUFHLElBQUlDLFFBQUosQ0FBYSxLQUFLRCxRQUFsQixDQUFYO0FBQ0QsS0FKNkIsQ0FLOUI7OztBQUNBLFFBQUlFLElBQUksR0FBRyxJQUFJQyxLQUFKLENBQVVDLFNBQVMsQ0FBQ0MsTUFBVixHQUFtQixDQUE3QixDQUFYOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osSUFBSSxDQUFDRyxNQUF6QixFQUFpQ0MsQ0FBQyxFQUFsQyxFQUFzQztBQUNsQ0osVUFBSSxDQUFDSSxDQUFELENBQUosR0FBVUYsU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBTCxDQUFuQjtBQUNILEtBVDZCLENBVTlCOzs7QUFDQSxRQUFJQyxJQUFJLEdBQUc7QUFBRVAsY0FBUSxFQUFFQSxRQUFaO0FBQXNCRSxVQUFJLEVBQUVBO0FBQTVCLEtBQVg7QUFDQVAsaUJBQWEsQ0FBQ0QsVUFBRCxDQUFiLEdBQTRCYSxJQUE1QjtBQUNBUixxQkFBaUIsQ0FBQ0wsVUFBRCxDQUFqQjtBQUNBLFdBQU9BLFVBQVUsRUFBakI7QUFDRDs7QUFFRCxXQUFTYyxjQUFULENBQXdCQyxNQUF4QixFQUFnQztBQUM1QixXQUFPZCxhQUFhLENBQUNjLE1BQUQsQ0FBcEI7QUFDSDs7QUFFRCxXQUFTQyxHQUFULENBQWFILElBQWIsRUFBbUI7QUFDZixRQUFJUCxRQUFRLEdBQUdPLElBQUksQ0FBQ1AsUUFBcEI7QUFDQSxRQUFJRSxJQUFJLEdBQUdLLElBQUksQ0FBQ0wsSUFBaEI7O0FBQ0EsWUFBUUEsSUFBSSxDQUFDRyxNQUFiO0FBQ0EsV0FBSyxDQUFMO0FBQ0lMLGdCQUFRO0FBQ1I7O0FBQ0osV0FBSyxDQUFMO0FBQ0lBLGdCQUFRLENBQUNFLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBUjtBQUNBOztBQUNKLFdBQUssQ0FBTDtBQUNJRixnQkFBUSxDQUFDRSxJQUFJLENBQUMsQ0FBRCxDQUFMLEVBQVVBLElBQUksQ0FBQyxDQUFELENBQWQsQ0FBUjtBQUNBOztBQUNKLFdBQUssQ0FBTDtBQUNJRixnQkFBUSxDQUFDRSxJQUFJLENBQUMsQ0FBRCxDQUFMLEVBQVVBLElBQUksQ0FBQyxDQUFELENBQWQsRUFBbUJBLElBQUksQ0FBQyxDQUFELENBQXZCLENBQVI7QUFDQTs7QUFDSjtBQUNJRixnQkFBUSxDQUFDVyxLQUFULENBQWVuQixTQUFmLEVBQTBCVSxJQUExQjtBQUNBO0FBZko7QUFpQkg7O0FBRUQsV0FBU1UsWUFBVCxDQUFzQkgsTUFBdEIsRUFBOEI7QUFDMUI7QUFDQTtBQUNBLFFBQUliLHFCQUFKLEVBQTJCO0FBQ3ZCO0FBQ0E7QUFDQWlCLGdCQUFVLENBQUNELFlBQUQsRUFBZSxDQUFmLEVBQWtCSCxNQUFsQixDQUFWO0FBQ0gsS0FKRCxNQUlPO0FBQ0gsVUFBSUYsSUFBSSxHQUFHWixhQUFhLENBQUNjLE1BQUQsQ0FBeEI7O0FBQ0EsVUFBSUYsSUFBSixFQUFVO0FBQ05YLDZCQUFxQixHQUFHLElBQXhCOztBQUNBLFlBQUk7QUFDQWMsYUFBRyxDQUFDSCxJQUFELENBQUg7QUFDSCxTQUZELFNBRVU7QUFDTkMsd0JBQWMsQ0FBQ0MsTUFBRCxDQUFkO0FBQ0FiLCtCQUFxQixHQUFHLEtBQXhCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsV0FBU2tCLDZCQUFULEdBQXlDO0FBQ3JDZixxQkFBaUIsR0FBRyxVQUFTVSxNQUFULEVBQWlCO0FBQ2pDTSxhQUFPLENBQUNDLFFBQVIsQ0FBaUIsWUFBWTtBQUFFSixvQkFBWSxDQUFDSCxNQUFELENBQVo7QUFBdUIsT0FBdEQ7QUFDSCxLQUZEO0FBR0g7O0FBRUQsV0FBU1EsaUJBQVQsR0FBNkI7QUFDekI7QUFDQTtBQUNBLFFBQUkxQixNQUFNLENBQUMyQixXQUFQLElBQXNCLENBQUMzQixNQUFNLENBQUM0QixhQUFsQyxFQUFpRDtBQUM3QyxVQUFJQyx5QkFBeUIsR0FBRyxJQUFoQztBQUNBLFVBQUlDLFlBQVksR0FBRzlCLE1BQU0sQ0FBQytCLFNBQTFCOztBQUNBL0IsWUFBTSxDQUFDK0IsU0FBUCxHQUFtQixZQUFXO0FBQzFCRixpQ0FBeUIsR0FBRyxLQUE1QjtBQUNILE9BRkQ7O0FBR0E3QixZQUFNLENBQUMyQixXQUFQLENBQW1CLEVBQW5CLEVBQXVCLEdBQXZCO0FBQ0EzQixZQUFNLENBQUMrQixTQUFQLEdBQW1CRCxZQUFuQjtBQUNBLGFBQU9ELHlCQUFQO0FBQ0g7QUFDSjs7QUFFRCxXQUFTRyxnQ0FBVCxHQUE0QztBQUN4QztBQUNBO0FBQ0E7QUFFQSxRQUFJQyxhQUFhLEdBQUcsa0JBQWtCQyxJQUFJLENBQUNDLE1BQUwsRUFBbEIsR0FBa0MsR0FBdEQ7O0FBQ0EsUUFBSUMsZUFBZSxHQUFHLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbEMsVUFBSUEsS0FBSyxDQUFDQyxNQUFOLEtBQWlCdEMsTUFBakIsSUFDQSxPQUFPcUMsS0FBSyxDQUFDRSxJQUFiLEtBQXNCLFFBRHRCLElBRUFGLEtBQUssQ0FBQ0UsSUFBTixDQUFXQyxPQUFYLENBQW1CUCxhQUFuQixNQUFzQyxDQUYxQyxFQUU2QztBQUN6Q1osb0JBQVksQ0FBQyxDQUFDZ0IsS0FBSyxDQUFDRSxJQUFOLENBQVdFLEtBQVgsQ0FBaUJSLGFBQWEsQ0FBQ25CLE1BQS9CLENBQUYsQ0FBWjtBQUNIO0FBQ0osS0FORDs7QUFRQSxRQUFJZCxNQUFNLENBQUMwQyxnQkFBWCxFQUE2QjtBQUN6QjFDLFlBQU0sQ0FBQzBDLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DTixlQUFuQyxFQUFvRCxLQUFwRDtBQUNILEtBRkQsTUFFTztBQUNIcEMsWUFBTSxDQUFDMkMsV0FBUCxDQUFtQixXQUFuQixFQUFnQ1AsZUFBaEM7QUFDSDs7QUFFRDVCLHFCQUFpQixHQUFHLFVBQVNVLE1BQVQsRUFBaUI7QUFDakNsQixZQUFNLENBQUMyQixXQUFQLENBQW1CTSxhQUFhLEdBQUdmLE1BQW5DLEVBQTJDLEdBQTNDO0FBQ0gsS0FGRDtBQUdIOztBQUVELFdBQVMwQixtQ0FBVCxHQUErQztBQUMzQyxRQUFJQyxPQUFPLEdBQUcsSUFBSUMsY0FBSixFQUFkOztBQUNBRCxXQUFPLENBQUNFLEtBQVIsQ0FBY2hCLFNBQWQsR0FBMEIsVUFBU00sS0FBVCxFQUFnQjtBQUN0QyxVQUFJbkIsTUFBTSxHQUFHbUIsS0FBSyxDQUFDRSxJQUFuQjtBQUNBbEIsa0JBQVksQ0FBQ0gsTUFBRCxDQUFaO0FBQ0gsS0FIRDs7QUFLQVYscUJBQWlCLEdBQUcsVUFBU1UsTUFBVCxFQUFpQjtBQUNqQzJCLGFBQU8sQ0FBQ0csS0FBUixDQUFjckIsV0FBZCxDQUEwQlQsTUFBMUI7QUFDSCxLQUZEO0FBR0g7O0FBRUQsV0FBUytCLHFDQUFULEdBQWlEO0FBQzdDLFFBQUlDLElBQUksR0FBRzVDLEdBQUcsQ0FBQzZDLGVBQWY7O0FBQ0EzQyxxQkFBaUIsR0FBRyxVQUFTVSxNQUFULEVBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxVQUFJa0MsTUFBTSxHQUFHOUMsR0FBRyxDQUFDK0MsYUFBSixDQUFrQixRQUFsQixDQUFiOztBQUNBRCxZQUFNLENBQUNFLGtCQUFQLEdBQTRCLFlBQVk7QUFDcENqQyxvQkFBWSxDQUFDSCxNQUFELENBQVo7QUFDQWtDLGNBQU0sQ0FBQ0Usa0JBQVAsR0FBNEIsSUFBNUI7QUFDQUosWUFBSSxDQUFDSyxXQUFMLENBQWlCSCxNQUFqQjtBQUNBQSxjQUFNLEdBQUcsSUFBVDtBQUNILE9BTEQ7O0FBTUFGLFVBQUksQ0FBQ00sV0FBTCxDQUFpQkosTUFBakI7QUFDSCxLQVhEO0FBWUg7O0FBRUQsV0FBU0ssK0JBQVQsR0FBMkM7QUFDdkNqRCxxQkFBaUIsR0FBRyxVQUFTVSxNQUFULEVBQWlCO0FBQ2pDSSxnQkFBVSxDQUFDRCxZQUFELEVBQWUsQ0FBZixFQUFrQkgsTUFBbEIsQ0FBVjtBQUNILEtBRkQ7QUFHSCxHQTNKeUIsQ0E2SjFCOzs7QUFDQSxNQUFJd0MsUUFBUSxHQUFHQyxNQUFNLENBQUNDLGNBQVAsSUFBeUJELE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQjVELE1BQXRCLENBQXhDO0FBQ0EwRCxVQUFRLEdBQUdBLFFBQVEsSUFBSUEsUUFBUSxDQUFDcEMsVUFBckIsR0FBa0NvQyxRQUFsQyxHQUE2QzFELE1BQXhELENBL0owQixDQWlLMUI7O0FBQ0EsTUFBSSxHQUFHNkQsUUFBSCxDQUFZQyxJQUFaLENBQWlCOUQsTUFBTSxDQUFDd0IsT0FBeEIsTUFBcUMsa0JBQXpDLEVBQTZEO0FBQ3pEO0FBQ0FELGlDQUE2QjtBQUVoQyxHQUpELE1BSU8sSUFBSUcsaUJBQWlCLEVBQXJCLEVBQXlCO0FBQzVCO0FBQ0FNLG9DQUFnQztBQUVuQyxHQUpNLE1BSUEsSUFBSWhDLE1BQU0sQ0FBQzhDLGNBQVgsRUFBMkI7QUFDOUI7QUFDQUYsdUNBQW1DO0FBRXRDLEdBSk0sTUFJQSxJQUFJdEMsR0FBRyxJQUFJLHdCQUF3QkEsR0FBRyxDQUFDK0MsYUFBSixDQUFrQixRQUFsQixDQUFuQyxFQUFnRTtBQUNuRTtBQUNBSix5Q0FBcUM7QUFFeEMsR0FKTSxNQUlBO0FBQ0g7QUFDQVEsbUNBQStCO0FBQ2xDOztBQUVEQyxVQUFRLENBQUN4RCxZQUFULEdBQXdCQSxZQUF4QjtBQUNBd0QsVUFBUSxDQUFDekMsY0FBVCxHQUEwQkEsY0FBMUI7QUFDSCxDQXpMQSxFQXlMQyxPQUFPOEMsSUFBUCxLQUFnQixXQUFoQixHQUE4QixPQUFPL0QsTUFBUCxLQUFrQixXQUFsQixHQUFnQyxJQUFoQyxHQUF1Q0EsTUFBckUsR0FBOEUrRCxJQXpML0UsQ0FBRCxDIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "../node_modules/timers-browserify/main.js":
/*!*************************************************!*\
  !*** ../node_modules/timers-browserify/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"../node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YTBmNSJdLCJuYW1lcyI6WyJzY29wZSIsImdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJhcHBseSIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiZXhwb3J0cyIsInNldFRpbWVvdXQiLCJUaW1lb3V0IiwiY2FsbCIsImFyZ3VtZW50cyIsImNsZWFyVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVvdXQiLCJjbG9zZSIsImlkIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJpdGVtIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSJdLCJtYXBwaW5ncyI6IkFBQUEsa0RBQUlBLEtBQUssR0FBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFsQyxJQUNDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBRGhDLElBRUFDLE1BRlo7QUFHQSxJQUFJQyxLQUFLLEdBQUdDLFFBQVEsQ0FBQ0MsU0FBVCxDQUFtQkYsS0FBL0IsQyxDQUVBOztBQUVBRyxPQUFPLENBQUNDLFVBQVIsR0FBcUIsWUFBVztBQUM5QixTQUFPLElBQUlDLE9BQUosQ0FBWUwsS0FBSyxDQUFDTSxJQUFOLENBQVdGLFVBQVgsRUFBdUJSLEtBQXZCLEVBQThCVyxTQUE5QixDQUFaLEVBQXNEQyxZQUF0RCxDQUFQO0FBQ0QsQ0FGRDs7QUFHQUwsT0FBTyxDQUFDTSxXQUFSLEdBQXNCLFlBQVc7QUFDL0IsU0FBTyxJQUFJSixPQUFKLENBQVlMLEtBQUssQ0FBQ00sSUFBTixDQUFXRyxXQUFYLEVBQXdCYixLQUF4QixFQUErQlcsU0FBL0IsQ0FBWixFQUF1REcsYUFBdkQsQ0FBUDtBQUNELENBRkQ7O0FBR0FQLE9BQU8sQ0FBQ0ssWUFBUixHQUNBTCxPQUFPLENBQUNPLGFBQVIsR0FBd0IsVUFBU0MsT0FBVCxFQUFrQjtBQUN4QyxNQUFJQSxPQUFKLEVBQWE7QUFDWEEsV0FBTyxDQUFDQyxLQUFSO0FBQ0Q7QUFDRixDQUxEOztBQU9BLFNBQVNQLE9BQVQsQ0FBaUJRLEVBQWpCLEVBQXFCQyxPQUFyQixFQUE4QjtBQUM1QixPQUFLQyxHQUFMLEdBQVdGLEVBQVg7QUFDQSxPQUFLRyxRQUFMLEdBQWdCRixPQUFoQjtBQUNEOztBQUNEVCxPQUFPLENBQUNILFNBQVIsQ0FBa0JlLEtBQWxCLEdBQTBCWixPQUFPLENBQUNILFNBQVIsQ0FBa0JnQixHQUFsQixHQUF3QixZQUFXLENBQUUsQ0FBL0Q7O0FBQ0FiLE9BQU8sQ0FBQ0gsU0FBUixDQUFrQlUsS0FBbEIsR0FBMEIsWUFBVztBQUNuQyxPQUFLSSxRQUFMLENBQWNWLElBQWQsQ0FBbUJWLEtBQW5CLEVBQTBCLEtBQUttQixHQUEvQjtBQUNELENBRkQsQyxDQUlBOzs7QUFDQVosT0FBTyxDQUFDZ0IsTUFBUixHQUFpQixVQUFTQyxJQUFULEVBQWVDLEtBQWYsRUFBc0I7QUFDckNiLGNBQVksQ0FBQ1ksSUFBSSxDQUFDRSxjQUFOLENBQVo7QUFDQUYsTUFBSSxDQUFDRyxZQUFMLEdBQW9CRixLQUFwQjtBQUNELENBSEQ7O0FBS0FsQixPQUFPLENBQUNxQixRQUFSLEdBQW1CLFVBQVNKLElBQVQsRUFBZTtBQUNoQ1osY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUNBRixNQUFJLENBQUNHLFlBQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNELENBSEQ7O0FBS0FwQixPQUFPLENBQUNzQixZQUFSLEdBQXVCdEIsT0FBTyxDQUFDdUIsTUFBUixHQUFpQixVQUFTTixJQUFULEVBQWU7QUFDckRaLGNBQVksQ0FBQ1ksSUFBSSxDQUFDRSxjQUFOLENBQVo7QUFFQSxNQUFJRCxLQUFLLEdBQUdELElBQUksQ0FBQ0csWUFBakI7O0FBQ0EsTUFBSUYsS0FBSyxJQUFJLENBQWIsRUFBZ0I7QUFDZEQsUUFBSSxDQUFDRSxjQUFMLEdBQXNCbEIsVUFBVSxDQUFDLFNBQVN1QixTQUFULEdBQXFCO0FBQ3BELFVBQUlQLElBQUksQ0FBQ1EsVUFBVCxFQUNFUixJQUFJLENBQUNRLFVBQUw7QUFDSCxLQUgrQixFQUc3QlAsS0FINkIsQ0FBaEM7QUFJRDtBQUNGLENBVkQsQyxDQVlBOzs7QUFDQVEsbUJBQU8sQ0FBQyxrRUFBRCxDQUFQLEMsQ0FDQTtBQUNBO0FBQ0E7OztBQUNBMUIsT0FBTyxDQUFDMkIsWUFBUixHQUF3QixPQUFPaEMsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFBSSxDQUFDZ0MsWUFBckMsSUFDQyxPQUFPakMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDaUMsWUFEekMsSUFFQyxRQUFRLEtBQUtBLFlBRnJDO0FBR0EzQixPQUFPLENBQUM0QixjQUFSLEdBQTBCLE9BQU9qQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxJQUFJLENBQUNpQyxjQUFyQyxJQUNDLE9BQU9sQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNrQyxjQUR6QyxJQUVDLFFBQVEsS0FBS0EsY0FGdkMsQyIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "../node_modules/vue-2-breadcrumbs/lib/vue-2-breadcrumbs.js":
/*!******************************************************************!*\
  !*** ../node_modules/vue-2-breadcrumbs/lib/vue-2-breadcrumbs.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  install(Vue, options) {\n    Object.defineProperties(Vue.prototype, {\n      $breadcrumbs: {\n        get() {\n          const breadcrumbs = this.$route.matched.map(routeRecord => {\n            let path = routeRecord.path.length ? routeRecord.path : '/';\n            let route = routeRecord;\n            Object.keys(this.$route.params).forEach(param => {\n              path = path.replace(':' + param, this.$route.params[param]);\n            }, this);\n            route.path = path;\n            return route;\n          }, this);\n          return breadcrumbs;\n        }\n\n      }\n    });\n    const defaults = {\n      methods: {\n        getBreadcrumb: function (bc) {\n          return typeof bc === 'function' ? bc.call(this, this.$route.params) : bc;\n        }\n      },\n      template: `\n\t\t  <ol class=\"breadcrumb\" v-if=\"$breadcrumbs.length\">\n\t\t\t<li class=\"breadcrumb-item\" v-if=\"crumb.meta.breadcrumb\" v-for=\"(crumb, i) in $breadcrumbs\">\n\t\t\t  <router-link active-class=\"active\" :to=\"{ path: crumb.path }\" :tag=\"i != $breadcrumbs.length - 1 ? 'a' : 'span'\">{{ getBreadcrumb(crumb.meta.breadcrumb) }}</router-link>\n\t\t\t</li>\n\t\t  </ol>\n\t\t`\n    };\n    Vue.component('breadcrumbs', Object.assign(defaults, options));\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS0yLWJyZWFkY3J1bWJzL2xpYi92dWUtMi1icmVhZGNydW1icy5qcz85YzllIl0sIm5hbWVzIjpbImluc3RhbGwiLCJWdWUiLCJvcHRpb25zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIiRicmVhZGNydW1icyIsImdldCIsImJyZWFkY3J1bWJzIiwiJHJvdXRlIiwibWF0Y2hlZCIsIm1hcCIsInJvdXRlUmVjb3JkIiwicGF0aCIsImxlbmd0aCIsInJvdXRlIiwia2V5cyIsInBhcmFtcyIsImZvckVhY2giLCJwYXJhbSIsInJlcGxhY2UiLCJkZWZhdWx0cyIsIm1ldGhvZHMiLCJnZXRCcmVhZGNydW1iIiwiYmMiLCJjYWxsIiwidGVtcGxhdGUiLCJjb21wb25lbnQiLCJhc3NpZ24iXSwibWFwcGluZ3MiOiJBQUFBO0FBQWU7QUFDZEEsU0FBTyxDQUFDQyxHQUFELEVBQU1DLE9BQU4sRUFBZTtBQUNwQkMsVUFBTSxDQUFDQyxnQkFBUCxDQUF3QkgsR0FBRyxDQUFDSSxTQUE1QixFQUF1QztBQUN4Q0Msa0JBQVksRUFBRTtBQUNaQyxXQUFHLEdBQUc7QUFDUCxnQkFBTUMsV0FBVyxHQUFHLEtBQUtDLE1BQUwsQ0FBWUMsT0FBWixDQUFvQkMsR0FBcEIsQ0FBd0JDLFdBQVcsSUFBSTtBQUN6RCxnQkFBSUMsSUFBSSxHQUFHRCxXQUFXLENBQUNDLElBQVosQ0FBaUJDLE1BQWpCLEdBQTBCRixXQUFXLENBQUNDLElBQXRDLEdBQTZDLEdBQXhEO0FBQ0EsZ0JBQUlFLEtBQUssR0FBR0gsV0FBWjtBQUVBVCxrQkFBTSxDQUFDYSxJQUFQLENBQVksS0FBS1AsTUFBTCxDQUFZUSxNQUF4QixFQUFnQ0MsT0FBaEMsQ0FBd0NDLEtBQUssSUFBSTtBQUNsRE4sa0JBQUksR0FBR0EsSUFBSSxDQUFDTyxPQUFMLENBQWEsTUFBTUQsS0FBbkIsRUFBMEIsS0FBS1YsTUFBTCxDQUFZUSxNQUFaLENBQW1CRSxLQUFuQixDQUExQixDQUFQO0FBQ0UsYUFGRCxFQUVHLElBRkg7QUFJQUosaUJBQUssQ0FBQ0YsSUFBTixHQUFhQSxJQUFiO0FBRUEsbUJBQU9FLEtBQVA7QUFDRCxXQVhtQixFQVdqQixJQVhpQixDQUFwQjtBQWFBLGlCQUFPUCxXQUFQO0FBQ0U7O0FBaEJXO0FBRDBCLEtBQXZDO0FBcUJBLFVBQU1hLFFBQVEsR0FBRztBQUNsQkMsYUFBTyxFQUFFO0FBQ1BDLHFCQUFhLEVBQUUsVUFBVUMsRUFBVixFQUFjO0FBQzlCLGlCQUFPLE9BQU9BLEVBQVAsS0FBYyxVQUFkLEdBQTJCQSxFQUFFLENBQUNDLElBQUgsQ0FBUSxJQUFSLEVBQWMsS0FBS2hCLE1BQUwsQ0FBWVEsTUFBMUIsQ0FBM0IsR0FBK0RPLEVBQXRFO0FBQ0U7QUFITSxPQURTO0FBTWxCRSxjQUFRLEVBQUc7Ozs7Ozs7QUFOTyxLQUFqQjtBQWVBekIsT0FBRyxDQUFDMEIsU0FBSixDQUFjLGFBQWQsRUFBNkJ4QixNQUFNLENBQUN5QixNQUFQLENBQWNQLFFBQWQsRUFBd0JuQixPQUF4QixDQUE3QjtBQUNEOztBQXZDYSxDQUFmIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy92dWUtMi1icmVhZGNydW1icy9saWIvdnVlLTItYnJlYWRjcnVtYnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG5cdGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVnVlLnByb3RvdHlwZSwge1xuXHRcdCRicmVhZGNydW1iczoge1xuXHRcdCAgZ2V0KCkge1xuXHRcdFx0Y29uc3QgYnJlYWRjcnVtYnMgPSB0aGlzLiRyb3V0ZS5tYXRjaGVkLm1hcChyb3V0ZVJlY29yZCA9PiB7XG5cdFx0XHQgIGxldCBwYXRoID0gcm91dGVSZWNvcmQucGF0aC5sZW5ndGggPyByb3V0ZVJlY29yZC5wYXRoIDogJy8nO1xuXHRcdFx0ICBsZXQgcm91dGUgPSByb3V0ZVJlY29yZDtcblxuXHRcdFx0ICBPYmplY3Qua2V5cyh0aGlzLiRyb3V0ZS5wYXJhbXMpLmZvckVhY2gocGFyYW0gPT4ge1xuXHRcdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCc6JyArIHBhcmFtLCB0aGlzLiRyb3V0ZS5wYXJhbXNbcGFyYW1dKTtcblx0XHRcdCAgfSwgdGhpcyk7XG5cblx0XHRcdCAgcm91dGUucGF0aCA9IHBhdGg7XG5cblx0XHRcdCAgcmV0dXJuIHJvdXRlO1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHJldHVybiBicmVhZGNydW1icztcblx0XHQgIH1cblx0XHR9XG5cdCAgfSk7XG5cblx0ICBjb25zdCBkZWZhdWx0cyA9IHtcblx0XHRtZXRob2RzOiB7XG5cdFx0ICBnZXRCcmVhZGNydW1iOiBmdW5jdGlvbiAoYmMpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgYmMgPT09ICdmdW5jdGlvbicgPyBiYy5jYWxsKHRoaXMsIHRoaXMuJHJvdXRlLnBhcmFtcykgOiBiYztcblx0XHQgIH1cblx0XHR9LFxuXHRcdHRlbXBsYXRlOiBgXG5cdFx0ICA8b2wgY2xhc3M9XCJicmVhZGNydW1iXCIgdi1pZj1cIiRicmVhZGNydW1icy5sZW5ndGhcIj5cblx0XHRcdDxsaSBjbGFzcz1cImJyZWFkY3J1bWItaXRlbVwiIHYtaWY9XCJjcnVtYi5tZXRhLmJyZWFkY3J1bWJcIiB2LWZvcj1cIihjcnVtYiwgaSkgaW4gJGJyZWFkY3J1bWJzXCI+XG5cdFx0XHQgIDxyb3V0ZXItbGluayBhY3RpdmUtY2xhc3M9XCJhY3RpdmVcIiA6dG89XCJ7IHBhdGg6IGNydW1iLnBhdGggfVwiIDp0YWc9XCJpICE9ICRicmVhZGNydW1icy5sZW5ndGggLSAxID8gJ2EnIDogJ3NwYW4nXCI+e3sgZ2V0QnJlYWRjcnVtYihjcnVtYi5tZXRhLmJyZWFkY3J1bWIpIH19PC9yb3V0ZXItbGluaz5cblx0XHRcdDwvbGk+XG5cdFx0ICA8L29sPlxuXHRcdGBcblx0ICB9O1xuXG5cdCAgVnVlLmNvbXBvbmVudCgnYnJlYWRjcnVtYnMnLCBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRpb25zKSk7XG5cdH1cbiAgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/vue-2-breadcrumbs/lib/vue-2-breadcrumbs.js\n");

/***/ }),

/***/ "../node_modules/vue-router/dist/vue-router.esm.js":
/*!*********************************************************!*\
  !*** ../node_modules/vue-router/dist/vue-router.esm.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*!\n  * vue-router v3.0.2\n  * (c) 2018 Evan You\n  * @license MIT\n  */\n\n/*  */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[vue-router] \" + message);\n  }\n}\n\nfunction warn(condition, message) {\n  if ( true && !condition) {\n    typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n  }\n}\n\nfunction isError(err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\nfunction extend(a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n\n  return a;\n}\n\nvar View = {\n  name: 'RouterView',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render(_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data; // used by devtools to display a router-view badge\n\n    data.routerView = true; // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n\n    var depth = 0;\n    var inactive = false;\n\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n\n      if (parent._inactive) {\n        inactive = true;\n      }\n\n      parent = parent.$parent;\n    }\n\n    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive\n\n    if (inactive) {\n      return h(cache[name], data, children);\n    }\n\n    var matched = route.matched[depth]; // render empty node if no matched route\n\n    if (!matched) {\n      cache[name] = null;\n      return h();\n    }\n\n    var component = cache[name] = matched.components[name]; // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n\n      if (val && current !== vm || !val && current === vm) {\n        matched.instances[name] = val;\n      }\n    } // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;\n\n    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    }; // resolve props\n\n\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    if (propsToPass) {\n      // clone to prevent mutation\n      propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs\n\n      var attrs = data.attrs = data.attrs || {};\n\n      for (var key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key];\n          delete propsToPass[key];\n        }\n      }\n    }\n\n    return h(component, data, children);\n  }\n};\n\nfunction resolveProps(route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return;\n\n    case 'object':\n      return config;\n\n    case 'function':\n      return config(route);\n\n    case 'boolean':\n      return config ? route.params : undefined;\n\n    default:\n      if (true) {\n        warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + typeof config + \", \" + \"expecting an object, function or boolean.\");\n      }\n\n  }\n}\n/*  */\n\n\nvar encodeReserveRE = /[!'()*]/g;\n\nvar encodeReserveReplacer = function (c) {\n  return '%' + c.charCodeAt(0).toString(16);\n};\n\nvar commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\nvar encode = function (str) {\n  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n};\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery(query, extraQuery, _parseQuery) {\n  if (extraQuery === void 0) extraQuery = {};\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n     true && warn(false, e.message);\n    parsedQuery = {};\n  }\n\n  for (var key in extraQuery) {\n    parsedQuery[key] = extraQuery[key];\n  }\n\n  return parsedQuery;\n}\n\nfunction parseQuery(query) {\n  var res = {};\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n  return res;\n}\n\nfunction stringifyQuery(obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return '';\n    }\n\n    if (val === null) {\n      return encode(key);\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return;\n        }\n\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&');\n    }\n\n    return encode(key) + '=' + encode(val);\n  }).filter(function (x) {\n    return x.length > 0;\n  }).join('&') : null;\n  return res ? \"?\" + res : '';\n}\n/*  */\n\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute(record, location, redirectedFrom, router) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var query = location.query || {};\n\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || record && record.name,\n    meta: record && record.meta || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n\n  return Object.freeze(route);\n}\n\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  } else if (value && typeof value === 'object') {\n    var res = {};\n\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n\n    return res;\n  } else {\n    return value;\n  }\n} // the starting route that represents the initial state\n\n\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch(record) {\n  var res = [];\n\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n\n  return res;\n}\n\nfunction getFullPath(ref, _stringifyQuery) {\n  var path = ref.path;\n  var query = ref.query;\n  if (query === void 0) query = {};\n  var hash = ref.hash;\n  if (hash === void 0) hash = '';\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash;\n}\n\nfunction isSameRoute(a, b) {\n  if (b === START) {\n    return a === b;\n  } else if (!b) {\n    return false;\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n  } else if (a.name && b.name) {\n    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n  } else {\n    return false;\n  }\n}\n\nfunction isObjectEqual(a, b) {\n  if (a === void 0) a = {};\n  if (b === void 0) b = {}; // handle null value #1566\n\n  if (!a || !b) {\n    return a === b;\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key]; // check nested equality\n\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal);\n    }\n\n    return String(aVal) === String(bVal);\n  });\n}\n\nfunction isIncludedRoute(current, target) {\n  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n}\n\nfunction queryIncludes(current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*  */\n// work around weird flow bug\n\n\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\nvar Link = {\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class\n\n    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n    var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = {\n      click: guardEvent\n    };\n\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = {\n        href: href\n      };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default);\n  }\n};\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n    return;\n  } // don't redirect when preventDefault called\n\n\n  if (e.defaultPrevented) {\n    return;\n  } // don't redirect on right click\n\n\n  if (e.button !== undefined && e.button !== 0) {\n    return;\n  } // don't redirect if `target=\"_blank\"`\n\n\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n\n    if (/\\b_blank\\b/i.test(target)) {\n      return;\n    }\n  } // this may be a Weex event which doesn't have this method\n\n\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return true;\n}\n\nfunction findAnchor(children) {\n  if (children) {\n    var child;\n\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (child.tag === 'a') {\n        return child;\n      }\n\n      if (child.children && (child = findAnchor(child.children))) {\n        return child;\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install(Vue) {\n  if (install.installed && _Vue === Vue) {\n    return;\n  }\n\n  install.installed = true;\n  _Vue = Vue;\n\n  var isDef = function (v) {\n    return v !== undefined;\n  };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n\n        this._router.init(this);\n\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n      }\n\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed() {\n      registerInstance(this);\n    }\n  });\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get() {\n      return this._routerRoot._router;\n    }\n  });\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get() {\n      return this._routerRoot._route;\n    }\n  });\n  Vue.component('RouterView', View);\n  Vue.component('RouterLink', Link);\n  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks\n\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n/*  */\n\n\nvar inBrowser = typeof window !== 'undefined';\n/*  */\n\nfunction resolvePath(relative, base, append) {\n  var firstChar = relative.charAt(0);\n\n  if (firstChar === '/') {\n    return relative;\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative;\n  }\n\n  var stack = base.split('/'); // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  } // resolve relative path\n\n\n  var segments = relative.replace(/^\\//, '').split('/');\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  } // ensure leading slash\n\n\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/');\n}\n\nfunction parsePath(path) {\n  var hash = '';\n  var query = '';\n  var hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction cleanPath(path) {\n  return path.replace(/\\/\\//g, '/');\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n/**\n * Expose `pathToRegexp`.\n */\n\n\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\n\nvar PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\n\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length; // Ignore already escaped sequences.\n\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7]; // Push the current path onto the tokens.\n\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  } // Match any characters still remaining.\n\n\n  if (index < str.length) {\n    path += str.substr(index);\n  } // If the path exists, push it onto the end.\n\n\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\n\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\n\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\n\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\n\n\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\n\n\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\n\n\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\n\n\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = ''; // Iterate over the tokens and create our regexp string.\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\n\n\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path,\n    /** @type {!Array} */\n    keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(\n    /** @type {!Array} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  return stringToRegexp(\n  /** @type {string} */\n  path,\n  /** @type {!Array} */\n  keys, options);\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n/*  */\n// $flow-disable-line\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams(path, params, routeMsg) {\n  try {\n    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n    return filler(params || {}, {\n      pretty: true\n    });\n  } catch (e) {\n    if (true) {\n      warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n    }\n\n    return '';\n  }\n}\n/*  */\n\n\nfunction createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || []; // $flow-disable-line\n\n  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line\n\n  var nameMap = oldNameMap || Object.create(null);\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  }); // ensure wildcard routes are always at the end\n\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  };\n}\n\nfunction addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n  var path = route.path;\n  var name = route.name;\n\n  if (true) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n  }\n\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || {\n      default: route.component\n    },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null ? {} : route.components ? route.props : {\n      default: route.props\n    }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (true) {\n      if (route.name && !route.redirect && route.children.some(function (child) {\n        return /^\\/?$/.test(child.path);\n      })) {\n        warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n      }\n    }\n\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if ( true && !matchAs) {\n      warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n    }\n  }\n}\n\nfunction compileRouteRegex(path, pathToRegexpOptions) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n\n  if (true) {\n    var keys = Object.create(null);\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n      keys[key.name] = true;\n    });\n  }\n\n  return regex;\n}\n\nfunction normalizePath(path, parent, strict) {\n  if (!strict) {\n    path = path.replace(/\\/$/, '');\n  }\n\n  if (path[0] === '/') {\n    return path;\n  }\n\n  if (parent == null) {\n    return path;\n  }\n\n  return cleanPath(parent.path + \"/\" + path);\n}\n/*  */\n\n\nfunction normalizeLocation(raw, current, append, router) {\n  var next = typeof raw === 'string' ? {\n    path: raw\n  } : raw; // named target\n\n  if (next.name || next._normalized) {\n    return next;\n  } // relative params\n\n\n  if (!next.path && next.params && current) {\n    next = extend({}, next);\n    next._normalized = true;\n    var params = extend(extend({}, current.params), next.params);\n\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, \"path \" + current.path);\n    } else if (true) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n\n    return next;\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = current && current.path || '/';\n  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n  var hash = next.hash || parsedPath.hash;\n\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n/*  */\n\n\nfunction createMatcher(routes, router) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes(routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match(raw, currentRoute, redirectedFrom) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n\n      if (true) {\n        warn(record, \"Route with name '\" + name + \"' does not exist\");\n      }\n\n      if (!record) {\n        return _createRoute(null, location);\n      }\n\n      var paramNames = record.regex.keys.filter(function (key) {\n        return !key.optional;\n      }).map(function (key) {\n        return key.name;\n      });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n        return _createRoute(record, location, redirectedFrom);\n      }\n    } else if (location.path) {\n      location.params = {};\n\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom);\n        }\n      }\n    } // no match\n\n\n    return _createRoute(null, location);\n  }\n\n  function redirect(record, location) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = {\n        path: redirect\n      };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (true) {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n\n      return _createRoute(null, location);\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n\n      if (true) {\n        assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n      }\n\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location);\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record); // 2. resolve params\n\n      var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\"); // 3. rematch with existing query and hash\n\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location);\n    } else {\n      if (true) {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n\n      return _createRoute(null, location);\n    }\n  }\n\n  function alias(record, location, matchAs) {\n    var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location);\n    }\n\n    return _createRoute(null, location);\n  }\n\n  function _createRoute(record, location, redirectedFrom) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location);\n    }\n\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs);\n    }\n\n    return createRoute(record, location, redirectedFrom, router);\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  };\n}\n\nfunction matchRoute(regex, path, params) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false;\n  } else if (!params) {\n    return true;\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n\n    if (key) {\n      // Fix #1994: using * with props: true generates a param named 0\n      params[key.name || 'pathMatch'] = val;\n    }\n  }\n\n  return true;\n}\n\nfunction resolveRecordPath(path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true);\n}\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll() {\n  // Fix for #1585 for Firefox\n  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n  window.history.replaceState({\n    key: getStateKey()\n  }, '', window.location.href.replace(window.location.origin, ''));\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll(router, to, from, isPop) {\n  if (!router.app) {\n    return;\n  }\n\n  var behavior = router.options.scrollBehavior;\n\n  if (!behavior) {\n    return;\n  }\n\n  if (true) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  } // wait until re-render finishes before scrolling\n\n\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);\n\n    if (!shouldScroll) {\n      return;\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll.then(function (shouldScroll) {\n        scrollToPosition(shouldScroll, position);\n      }).catch(function (err) {\n        if (true) {\n          assert(false, err.toString());\n        }\n      });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition() {\n  var key = getStateKey();\n\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition() {\n  var key = getStateKey();\n\n  if (key) {\n    return positionStore[key];\n  }\n}\n\nfunction getElementPosition(el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  };\n}\n\nfunction isValidPosition(obj) {\n  return isNumber(obj.x) || isNumber(obj.y);\n}\n\nfunction normalizePosition(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  };\n}\n\nfunction normalizeOffset(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  };\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number';\n}\n\nfunction scrollToPosition(shouldScroll, position) {\n  var isObject = typeof shouldScroll === 'object';\n\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    var el = document.querySelector(shouldScroll.selector);\n\n    if (el) {\n      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    window.scrollTo(position.x, position.y);\n  }\n}\n/*  */\n\n\nvar supportsPushState = inBrowser && function () {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n\n  return window.history && 'pushState' in window.history;\n}(); // use User Timing api (if present) for more accurate key precision\n\n\nvar Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\nvar _key = genKey();\n\nfunction genKey() {\n  return Time.now().toFixed(3);\n}\n\nfunction getStateKey() {\n  return _key;\n}\n\nfunction setStateKey(key) {\n  _key = key;\n}\n\nfunction pushState(url, replace) {\n  saveScrollPosition(); // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n\n  var history = window.history;\n\n  try {\n    if (replace) {\n      history.replaceState({\n        key: _key\n      }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({\n        key: _key\n      }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState(url) {\n  pushState(url, true);\n}\n/*  */\n\n\nfunction runQueue(queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n\n  step(0);\n}\n/*  */\n\n\nfunction resolveAsyncComponents(matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          } // save resolved on async factory in case it's used elsewhere\n\n\n          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n\n          if (pending <= 0) {\n            next();\n          }\n        });\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n           true && warn(false, msg);\n\n          if (!error) {\n            error = isError(reason) ? reason : new Error(msg);\n            next(error);\n          }\n        });\n        var res;\n\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) {\n      next();\n    }\n  };\n}\n\nfunction flatMapComponents(matched, fn) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return fn(m.components[key], m.instances[key], m, key);\n    });\n  }));\n}\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nvar hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n} // in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    if (called) {\n      return;\n    }\n\n    called = true;\n    return fn.apply(this, args);\n  };\n}\n/*  */\n\n\nvar History = function History(router, base) {\n  this.router = router;\n  this.base = normalizeBase(base); // start with a route object that stands for \"nowhere\"\n\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady(cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError(errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL(); // fire ready cbs once\n\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) {\n        cb(err);\n      });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n  var this$1 = this;\n  var current = this.current;\n\n  var abort = function (err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n\n    onAbort && onAbort(err);\n  };\n\n  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to\n  route.matched.length === current.matched.length) {\n    this.ensureURL();\n    return abort();\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n  var updated = ref.updated;\n  var deactivated = ref.deactivated;\n  var activated = ref.activated;\n  var queue = [].concat( // in-component leave guards\n  extractLeaveGuards(deactivated), // global before hooks\n  this.router.beforeHooks, // in-component update hooks\n  extractUpdateHooks(updated), // in-config enter guards\n  activated.map(function (m) {\n    return m.beforeEnter;\n  }), // async components\n  resolveAsyncComponents(activated));\n  this.pending = route;\n\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort();\n    }\n\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n\n    var isValid = function () {\n      return this$1.current === route;\n    }; // wait until async components are resolved before\n    // extracting in-component enter guards\n\n\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n\n      this$1.pending = null;\n      onComplete(route);\n\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin\n\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  } // make sure there's the starting slash\n\n\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  } // remove trailing slash\n\n\n  return base.replace(/\\/$/, '');\n}\n\nfunction resolveQueue(current, next) {\n  var i;\n  var max = Math.max(current.length, next.length);\n\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break;\n    }\n  }\n\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  };\n}\n\nfunction extractGuards(records, name, bind, reverse) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n\n    if (guard) {\n      return Array.isArray(guard) ? guard.map(function (guard) {\n        return bind(guard, instance, match, key);\n      }) : bind(guard, instance, match, key);\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards);\n}\n\nfunction extractGuard(def, key) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n\n  return def.options[key];\n}\n\nfunction extractLeaveGuards(deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n}\n\nfunction extractUpdateHooks(updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n}\n\nfunction bindGuard(guard, instance) {\n  if (instance) {\n    return function boundRouteGuard() {\n      return guard.apply(instance, arguments);\n    };\n  }\n}\n\nfunction extractEnterGuards(activated, cbs, isValid) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid);\n  });\n}\n\nfunction bindEnterGuard(guard, match, key, cbs, isValid) {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    });\n  };\n}\n\nfunction poll(cb, // somehow flow cannot infer this is a function\ninstances, key, isValid) {\n  if (instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\n  ) {\n      cb(instances[key]);\n    } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n/*  */\n\n\nvar HTML5History = function (History$$1) {\n  function HTML5History(router, base) {\n    var this$1 = this;\n    History$$1.call(this, router, base);\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    var initLocation = getLocation(this.base);\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n\n      var location = getLocation(this$1.base);\n\n      if (this$1.current === START && location === initLocation) {\n        return;\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if (History$$1) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL(push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getLocation(this.base);\n  };\n\n  return HTML5History;\n}(History);\n\nfunction getLocation(base) {\n  var path = decodeURI(window.location.pathname);\n\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n\n  return (path || '/') + window.location.search + window.location.hash;\n}\n/*  */\n\n\nvar HashHistory = function (History$$1) {\n  function HashHistory(router, base, fallback) {\n    History$$1.call(this, router, base); // check history fallback deeplinking\n\n    if (fallback && checkFallback(this.base)) {\n      return;\n    }\n\n    ensureSlash();\n  }\n\n  if (History$$1) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n\n  HashHistory.prototype.setupListeners = function setupListeners() {\n    var this$1 = this;\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n      var current = this$1.current;\n\n      if (!ensureSlash()) {\n        return;\n      }\n\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL(push) {\n    var current = this.current.fullPath;\n\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getHash();\n  };\n\n  return HashHistory;\n}(History);\n\nfunction checkFallback(base) {\n  var location = getLocation(base);\n\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true;\n  }\n}\n\nfunction ensureSlash() {\n  var path = getHash();\n\n  if (path.charAt(0) === '/') {\n    return true;\n  }\n\n  replaceHash('/' + path);\n  return false;\n}\n\nfunction getHash() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : decodeURI(href.slice(index + 1));\n}\n\nfunction getUrl(path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return base + \"#\" + path;\n}\n\nfunction pushHash(path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash(path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n/*  */\n\n\nvar AbstractHistory = function (History$$1) {\n  function AbstractHistory(router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if (History$$1) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go(n) {\n    var this$1 = this;\n    var targetIndex = this.index + n;\n\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return;\n    }\n\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/';\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop\n  };\n\n  return AbstractHistory;\n}(History);\n/*  */\n\n\nvar VueRouter = function VueRouter(options) {\n  if (options === void 0) options = {};\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n\n  if (this.fallback) {\n    mode = 'hash';\n  }\n\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break;\n\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break;\n\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break;\n\n    default:\n      if (true) {\n        assert(false, \"invalid mode: \" + mode);\n      }\n\n  }\n};\n\nvar prototypeAccessors = {\n  currentRoute: {\n    configurable: true\n  }\n};\n\nVueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom);\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current;\n};\n\nVueRouter.prototype.init = function init(app\n/* Vue component instance */\n) {\n  var this$1 = this;\n   true && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n  this.apps.push(app); // main app already initialized.\n\n  if (this.app) {\n    return;\n  }\n\n  this.app = app;\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n\n    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach(fn) {\n  return registerHook(this.beforeHooks, fn);\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n  return registerHook(this.resolveHooks, fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach(fn) {\n  return registerHook(this.afterHooks, fn);\n};\n\nVueRouter.prototype.onReady = function onReady(cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError(errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push(location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go(n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back() {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward() {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n\n  if (!route) {\n    return [];\n  }\n\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key];\n    });\n  }));\n};\n\nVueRouter.prototype.resolve = function resolve(to, current, append) {\n  var location = normalizeLocation(to, current || this.history.current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  };\n};\n\nVueRouter.prototype.addRoutes = function addRoutes(routes) {\n  this.matcher.addRoutes(routes);\n\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties(VueRouter.prototype, prototypeAccessors);\n\nfunction registerHook(list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n\n    if (i > -1) {\n      list.splice(i, 1);\n    }\n  };\n}\n\nfunction createHref(base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path;\n}\n\nVueRouter.install = install;\nVueRouter.version = '3.0.2';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcz80YWY5Il0sIm5hbWVzIjpbImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm4iLCJwcm9jZXNzIiwiY29uc29sZSIsImlzRXJyb3IiLCJlcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpbmRleE9mIiwiZXh0ZW5kIiwiYSIsImIiLCJrZXkiLCJWaWV3IiwibmFtZSIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwidmFsIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwcm9wc1RvUGFzcyIsInJlc29sdmVQcm9wcyIsImF0dHJzIiwiY29uZmlnIiwicGFyYW1zIiwidW5kZWZpbmVkIiwicGF0aCIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJfcGFyc2VRdWVyeSIsInBhcnNlIiwicGFyc2VRdWVyeSIsInBhcnNlZFF1ZXJ5IiwiZSIsInJlcyIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJsZW5ndGgiLCJqb2luIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwia2V5cyIsIm1hcCIsInJlc3VsdCIsInZhbDIiLCJmaWx0ZXIiLCJ4IiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWNvcmQiLCJsb2NhdGlvbiIsInJlZGlyZWN0ZWRGcm9tIiwicm91dGVyIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJvcHRpb25zIiwiY2xvbmUiLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsInZhbHVlIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiX3N0cmluZ2lmeVF1ZXJ5Iiwic3RyaW5naWZ5IiwiaXNTYW1lUm91dGUiLCJpc09iamVjdEVxdWFsIiwiYUtleXMiLCJiS2V5cyIsImV2ZXJ5IiwiYVZhbCIsImJWYWwiLCJpc0luY2x1ZGVkUm91dGUiLCJ0YXJnZXQiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwidG8iLCJyZXF1aXJlZCIsInRhZyIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImV2ZW50IiwidGhpcyQxIiwiJHJvdXRlciIsInJlc29sdmUiLCJocmVmIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsIm9uIiwiY2xpY2siLCJjbGFzcyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiY2hpbGQiLCJpIiwiX1Z1ZSIsImluc3RhbGwiLCJWdWUiLCJpbnN0YWxsZWQiLCJpc0RlZiIsInYiLCJyZWdpc3Rlckluc3RhbmNlIiwiY2FsbFZhbCIsIiRvcHRpb25zIiwiX3BhcmVudFZub2RlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJfcm91dGVyIiwiaW5pdCIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJkZXN0cm95ZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIl9yb3V0ZSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiYmVmb3JlUm91dGVVcGRhdGUiLCJjcmVhdGVkIiwiaW5Ccm93c2VyIiwid2luZG93IiwicmVzb2x2ZVBhdGgiLCJyZWxhdGl2ZSIsImJhc2UiLCJmaXJzdENoYXIiLCJjaGFyQXQiLCJzdGFjayIsInBvcCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcnNlUGF0aCIsImhhc2hJbmRleCIsInNsaWNlIiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImlzYXJyYXkiLCJhcnIiLCJwYXRoVG9SZWdleHBfMSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiaW5kZXgiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsIlR5cGVFcnJvciIsIkpTT04iLCJqIiwiYXR0YWNoS2V5cyIsInJlIiwiZmxhZ3MiLCJzZW5zaXRpdmUiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsInNvdXJjZSIsIm1hdGNoIiwiYXJyYXlUb1JlZ2V4cCIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwic3RyaWN0IiwiZW5kIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJyZWdleHBDb21waWxlQ2FjaGUiLCJjcmVhdGUiLCJmaWxsUGFyYW1zIiwicm91dGVNc2ciLCJmaWxsZXIiLCJjcmVhdGVSb3V0ZU1hcCIsInJvdXRlcyIsIm9sZFBhdGhMaXN0Iiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTGlzdCIsInBhdGhNYXAiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJsIiwic3BsaWNlIiwibWF0Y2hBcyIsInBhdGhUb1JlZ2V4cE9wdGlvbnMiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJjYXNlU2Vuc2l0aXZlIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc2VzIiwiYWxpYXNSb3V0ZSIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsIl9jcmVhdGVSb3V0ZSIsInBhcmFtTmFtZXMiLCJyZWNvcmQkMSIsIm1hdGNoUm91dGUiLCJvcmlnaW5hbFJlZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJ0YXJnZXRSZWNvcmQiLCJyZXNvbHZlUmVjb3JkUGF0aCIsInJlc29sdmVkUGF0aCIsImFsaWFzZWRQYXRoIiwiYWxpYXNlZE1hdGNoIiwiYWxpYXNlZFJlY29yZCIsImxlbiIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsInJlcGxhY2VTdGF0ZSIsImdldFN0YXRlS2V5Iiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInN0YXRlIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJmcm9tIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsInRoZW4iLCJzY3JvbGxUb1Bvc2l0aW9uIiwiY2F0Y2giLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImVsIiwiZG9jRWwiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImRvY1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJlbFJlY3QiLCJsZWZ0IiwidG9wIiwiaXNWYWxpZFBvc2l0aW9uIiwiaXNOdW1iZXIiLCJub3JtYWxpemVQb3NpdGlvbiIsIm5vcm1hbGl6ZU9mZnNldCIsImlzT2JqZWN0Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwic2Nyb2xsVG8iLCJzdXBwb3J0c1B1c2hTdGF0ZSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIl9rZXkiLCJnZW5LZXkiLCJ0b0ZpeGVkIiwicHVzaFN0YXRlIiwidXJsIiwicnVuUXVldWUiLCJxdWV1ZSIsImZuIiwiY2IiLCJzdGVwIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50cyIsImhhc0FzeW5jIiwicGVuZGluZyIsImVycm9yIiwiZmxhdE1hcENvbXBvbmVudHMiLCJkZWYiLCJjaWQiLCJvbmNlIiwicmVzb2x2ZWREZWYiLCJpc0VTTW9kdWxlIiwicmVzb2x2ZWQiLCJyZWplY3QiLCJyZWFzb24iLCJtc2ciLCJjb21wIiwiZmxhdHRlbiIsImNvbmNhdCIsImFwcGx5IiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJfX2VzTW9kdWxlIiwiY2FsbGVkIiwiYXJncyIsImFyZ3VtZW50cyIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicmVhZHkiLCJyZWFkeUNicyIsInJlYWR5RXJyb3JDYnMiLCJlcnJvckNicyIsImxpc3RlbiIsIm9uUmVhZHkiLCJlcnJvckNiIiwib25FcnJvciIsInRyYW5zaXRpb25UbyIsIm9uQ29tcGxldGUiLCJvbkFib3J0IiwiY29uZmlybVRyYW5zaXRpb24iLCJ1cGRhdGVSb3V0ZSIsImVuc3VyZVVSTCIsImFib3J0IiwicmVzb2x2ZVF1ZXVlIiwidXBkYXRlZCIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXh0cmFjdExlYXZlR3VhcmRzIiwiYmVmb3JlSG9va3MiLCJleHRyYWN0VXBkYXRlSG9va3MiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInJlc29sdmVIb29rcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwibWF4IiwiTWF0aCIsImV4dHJhY3RHdWFyZHMiLCJyZWNvcmRzIiwiYmluZCIsInJldmVyc2UiLCJndWFyZHMiLCJpbnN0YW5jZSIsImd1YXJkIiwiZXh0cmFjdEd1YXJkIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiYmluZEVudGVyR3VhcmQiLCJyb3V0ZUVudGVyR3VhcmQiLCJwb2xsIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJzZXRUaW1lb3V0IiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsInN1cHBvcnRzU2Nyb2xsIiwiaW5pdExvY2F0aW9uIiwiZ2V0TG9jYXRpb24iLCJfX3Byb3RvX18iLCJjb25zdHJ1Y3RvciIsImdvIiwibiIsImZyb21Sb3V0ZSIsImdldEN1cnJlbnRMb2NhdGlvbiIsImRlY29kZVVSSSIsInBhdGhuYW1lIiwic2VhcmNoIiwiSGFzaEhpc3RvcnkiLCJmYWxsYmFjayIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJnZXRVcmwiLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNvbmZpZ3VyYWJsZSIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsInJlZ2lzdGVySG9vayIsImJlZm9yZVJlc29sdmUiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImRlZmluZVByb3BlcnRpZXMiLCJsaXN0IiwidmVyc2lvbiIsInVzZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7Ozs7O0FBS0E7QUFFQSxTQUFTQSxNQUFULENBQWlCQyxTQUFqQixFQUE0QkMsT0FBNUIsRUFBcUM7QUFDbkMsTUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2QsVUFBTSxJQUFJRSxLQUFKLENBQVcsa0JBQWtCRCxPQUE3QixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRSxJQUFULENBQWVILFNBQWYsRUFBMEJDLE9BQTFCLEVBQW1DO0FBQ2pDLE1BQUlH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ZS1yb3V0ZXIuZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogdnVlLXJvdXRlciB2My4wLjJcbiAgKiAoYykgMjAxOCBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxuZnVuY3Rpb24gZXh0ZW5kIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbnZhciBWaWV3ID0ge1xuICBuYW1lOiAnUm91dGVyVmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgLy8gdXNlZCBieSBkZXZ0b29scyB0byBkaXNwbGF5IGEgcm91dGVyLXZpZXcgYmFkZ2VcbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBjb21wb25lbnRzIHJlbmRlcmVkIGJ5IHJvdXRlci12aWV3IGNhbiByZXNvbHZlIG5hbWVkIHNsb3RzXG4gICAgdmFyIGggPSBwYXJlbnQuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX3JvdXRlclJvb3QgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzdGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcbiAgICAvLyBpbiBjYXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgYWNyb3NzIGRpZmZlcmVudCByb3V0ZXNcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xuICAgIHZhciBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSByZXNvbHZlUHJvcHMocm91dGUsIG1hdGNoZWQucHJvcHMgJiYgbWF0Y2hlZC5wcm9wc1tuYW1lXSk7XG4gICAgaWYgKHByb3BzVG9QYXNzKSB7XG4gICAgICAvLyBjbG9uZSB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgICBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSBleHRlbmQoe30sIHByb3BzVG9QYXNzKTtcbiAgICAgIC8vIHBhc3Mgbm9uLWRlY2xhcmVkIHByb3BzIGFzIGF0dHJzXG4gICAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvUGFzcykge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5wcm9wcyB8fCAhKGtleSBpbiBjb21wb25lbnQucHJvcHMpKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgICAgZGVsZXRlIHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb20sXG4gIHJvdXRlclxuKSB7XG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcblxuICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSB8fCB7fTtcbiAgdHJ5IHtcbiAgICBxdWVyeSA9IGNsb25lKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG5mdW5jdGlvbiBjbG9uZSAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChjbG9uZSlcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgcmVzW2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXG4gIHJlZixcbiAgX3N0cmluZ2lmeVF1ZXJ5XG4pIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICB2YXIgc3RyaW5naWZ5ID0gX3N0cmluZ2lmeVF1ZXJ5IHx8IHN0cmluZ2lmeVF1ZXJ5O1xuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICAvLyBoYW5kbGUgbnVsbCB2YWx1ZSAjMTU2NlxuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPT09IGIgfVxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdSb3V0ZXJMaW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcbiAgICAgIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgOiBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufVxuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCAmJiBfVnVlID09PSBWdWUpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfTtcblxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xuICAgIHZhciBpID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XG4gICAgICBpKHZtLCBjYWxsVmFsKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgnUm91dGVyVmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdSb3V0ZXJMaW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmJlZm9yZVJvdXRlVXBkYXRlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxudmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIHBhdGhUb1JlZ2V4cF8xID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxucGF0aFRvUmVnZXhwXzEucGFyc2UgPSBwYXJzZV8xO1xucGF0aFRvUmVnZXhwXzEuY29tcGlsZSA9IGNvbXBpbGVfMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG4vLyAkZmxvdy1kaXNhYmxlLWxpbmVcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBwYXRoVG9SZWdleHBfMS5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTGlzdCxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHBhdGhMaXN0W2ldID09PSAnKicpIHtcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgIGwtLTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhMaXN0OiBwYXRoTGlzdCxcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhMaXN0LFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgcGF0aFRvUmVnZXhwT3B0aW9ucyA9IHJvdXRlLnBhdGhUb1JlZ2V4cE9wdGlvbnMgfHwge307XG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoXG4gICAgcGF0aCxcbiAgICBwYXJlbnQsXG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zdHJpY3RcbiAgKTtcblxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQsIGRvZXMgbm90IHJlZGlyZWN0IGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xuICB2YXIgcmVnZXggPSBwYXRoVG9SZWdleHBfMShwYXRoLCBbXSwgcGF0aFRvUmVnZXhwT3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIGtleXNba2V5Lm5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVnZXhcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50LCBzdHJpY3QpIHtcbiAgaWYgKCFzdHJpY3QpIHsgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTsgfVxuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kLFxuICByb3V0ZXJcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBleHRlbmQoe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgXCJyZWxhdGl2ZSBwYXJhbXMgbmF2aWdhdGlvbiByZXF1aXJlcyBhIGN1cnJlbnQgcm91dGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcbiAgdmFyIGJhc2VQYXRoID0gKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXG4gICAgOiBiYXNlUGF0aDtcblxuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkoXG4gICAgcGFyc2VkUGF0aC5xdWVyeSxcbiAgICBuZXh0LnF1ZXJ5LFxuICAgIHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5wYXJzZVF1ZXJ5XG4gICk7XG5cbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY29yZCkgeyByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHJlY29yZC5yZWdleC5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xuICAgICAgICB2YXIgcmVjb3JkJDEgPSBwYXRoTWFwW3BhdGhdO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcbiAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG5cbiAgICB2YXIgcmUgPSByZWRpcmVjdDtcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xuICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuICAgIHF1ZXJ5ID0gcmUuaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykgPyByZS5xdWVyeSA6IHF1ZXJ5O1xuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuICAgICAgdmFyIHRhcmdldFJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgIC8vIDEuIHJlc29sdmUgcmVsYXRpdmUgcmVkaXJlY3RcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG4gICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICByZWdleCxcbiAgcGF0aCxcbiAgcGFyYW1zXG4pIHtcbiAgdmFyIG0gPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IHJlZ2V4LmtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIC8vIEZpeCAjMTk5NDogdXNpbmcgKiB3aXRoIHByb3BzOiB0cnVlIGdlbmVyYXRlcyBhIHBhcmFtIG5hbWVkIDBcbiAgICAgIHBhcmFtc1trZXkubmFtZSB8fCAncGF0aE1hdGNoJ10gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICAvLyBGaXggZm9yICMxNTg1IGZvciBGaXJlZm94XG4gIC8vIEZpeCBmb3IgIzIxOTUgQWRkIG9wdGlvbmFsIHRoaXJkIGF0dHJpYnV0ZSB0byB3b3JrYXJvdW5kIGEgYnVnIGluIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgyNjc4XG4gIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogZ2V0U3RhdGVLZXkoKSB9LCAnJywgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ub3JpZ2luLCAnJykpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IuY2FsbChyb3V0ZXIsIHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG5cbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaG91bGRTY3JvbGwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2hvdWxkU2Nyb2xsLnRoZW4oZnVuY3Rpb24gKHNob3VsZFNjcm9sbCkge1xuICAgICAgICBzY3JvbGxUb1Bvc2l0aW9uKChzaG91bGRTY3JvbGwpLCBwb3NpdGlvbik7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwsIG9mZnNldCkge1xuICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcCAtIG9mZnNldC55XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0IChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uIChzaG91bGRTY3JvbGwsIHBvc2l0aW9uKSB7XG4gIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2hvdWxkU2Nyb2xsLm9mZnNldCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLm9mZnNldCA9PT0gJ29iamVjdCcgPyBzaG91bGRTY3JvbGwub2Zmc2V0IDoge307XG4gICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcbiAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gIH1cblxuICBpZiAocG9zaXRpb24pIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKGlzRVNNb2R1bGUocmVzb2x2ZWREZWYpKSB7XG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUgKG9iaikge1xuICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihyb3V0ZSk7IH0pO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChvbkFib3J0KSB7XG4gICAgICBvbkFib3J0KGVycik7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgaWYgKHRoaXMkMS5lcnJvckNicy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xuICB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXG4gICAgICAgICAgICB0eXBlb2YgdG8ucGF0aCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKFxuICAgIGluc3RhbmNlc1trZXldICYmXG4gICAgIWluc3RhbmNlc1trZXldLl9pc0JlaW5nRGVzdHJveWVkIC8vIGRvIG5vdCByZXVzZSBiZWluZyBkZXN0cm95ZWQgaW5zdGFuY2VcbiAgKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gICAgdmFyIHN1cHBvcnRzU2Nyb2xsID0gc3VwcG9ydHNQdXNoU3RhdGUgJiYgZXhwZWN0U2Nyb2xsO1xuXG4gICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHZhciBpbml0TG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzLmJhc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuXG4gICAgICAvLyBBdm9pZGluZyBmaXJzdCBgcG9wc3RhdGVgIGV2ZW50IGRpc3BhdGNoZWQgaW4gc29tZSBicm93c2VycyBidXQgZmlyc3RcbiAgICAgIC8vIGhpc3Rvcnkgcm91dGUgbm90IHVwZGF0ZWQgc2luY2UgYXN5bmMgZ3VhcmQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKTtcbiAgICAgIGlmICh0aGlzJDEuY3VycmVudCA9PT0gU1RBUlQgJiYgbG9jYXRpb24gPT09IGluaXRMb2NhdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSBkZWNvZGVVUkkod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XG5cbiAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoc3VwcG9ydHNQdXNoU3RhdGUgPyAncG9wc3RhdGUnIDogJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcbiAgICApO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpO1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGRlY29kZVVSSShocmVmLnNsaWNlKGluZGV4ICsgMSkpXG59XG5cbmZ1bmN0aW9uIGdldFVybCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHB1c2hTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICByZXBsYWNlU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cblxuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYmVmb3JlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVSZXNvbHZlID0gZnVuY3Rpb24gYmVmb3JlUmVzb2x2ZSAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLnJlc29sdmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmFmdGVySG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IsIGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25FcnJvcihlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRvLm1hdGNoZWRcbiAgICAgID8gdG9cbiAgICAgIDogdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxuICAgIDogdGhpcy5jdXJyZW50Um91dGU7XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbS5jb21wb25lbnRzW2tleV1cbiAgICB9KVxuICB9KSlcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxuICB0byxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXG4gICAgdG8sXG4gICAgY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudCxcbiAgICBhcHBlbmQsXG4gICAgdGhpc1xuICApO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZWdpc3Rlckhvb2sgKGxpc3QsIGZuKSB7XG4gIGxpc3QucHVzaChmbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMy4wLjInO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/vue-router/dist/vue-router.esm.js\n");

/***/ }),

/***/ "../node_modules/vue/dist/vue.esm.js":
/*!*******************************************!*\
  !*** ../node_modules/vue/dist/vue.esm.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.2\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n\n/*  */\nvar emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive.\n */\n\n\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n  typeof value === 'symbol' || typeof value === 'boolean';\n}\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\n\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\n\n\nvar _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\n\n\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\n\n\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\nfunction isPromise(val) {\n  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\n\n\nfunction toString(val) {\n  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\n\n\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\n\n\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n/**\n * Check if a tag is a built-in tag.\n */\n\n\nvar isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\n\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\n\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n/**\n * Check whether an object has the property.\n */\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\n\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\n\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n/**\n * Capitalize a string.\n */\n\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\n\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\n\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\n\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n\n  return ret;\n}\n/**\n * Mix properties into target object.\n */\n\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\n\n\nfunction toObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\n\n\nfunction noop(a, b, c) {}\n/**\n * Always return false.\n */\n\n\nvar no = function (a, b, c) {\n  return false;\n};\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\n\n\nvar identity = function (_) {\n  return _;\n};\n/**\n * Generate a string containing static keys from compiler modules.\n */\n\n\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\n\n\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\n\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Ensure a function is called only once.\n */\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\n\nvar unicodeLetters = 'a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';\n/**\n * Check if a string starts with $ or _\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n/**\n * Define a property.\n */\n\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n/**\n * Parse simple path.\n */\n\n\nvar bailRE = new RegExp(\"[^\" + unicodeLetters + \".$_\\\\d]\");\n\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  };\n}\n/*  */\n// can we use __proto__?\n\n\nvar hasProto = '__proto__' in {}; // Browser environment sniffing\n\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA); // Firefox has a \"watch\" function on Object.prototype...\n\nvar nativeWatch = {}.watch;\nvar supportsPassive = false;\n\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n} // this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\n\n\nvar _isServer;\n\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n\n  return _isServer;\n}; // detect devtools\n\n\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\n\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */\n// $flow-disable-line\n\n\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set =\n  /*@__PURE__*/\n  function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n/*  */\n\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = noop; // work around flow check\n\nvar formatComponentName = noop;\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n\n  var classify = function (str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + trace);\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n\n    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n\n      if (n > 1) {\n        str += str;\n      }\n\n      n >>= 1;\n    }\n\n    return res;\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n/*  */\n\n\nvar uid = 0;\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) {\n      return a.id - b.id;\n    });\n  }\n\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n}; // The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\n\n\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget() {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n/*  */\n\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = {\n  child: {\n    configurable: true\n  }\n}; // DEPRECATED: alias for componentInstance for backwards compat.\n\n/* istanbul ignore next */\n\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function (text) {\n  if (text === void 0) text = '';\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n} // optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\n\n\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, // #7975\n  // clone children array to avoid mutating original in case of cloning\n  // a child.\n  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned;\n}\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n/**\n * Intercept mutating methods and emit events\n */\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) {\n      ob.observeArray(inserted);\n    } // notify change\n\n\n    ob.dep.notify();\n    return result;\n  });\n});\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\n\nvar shouldObserve = true;\n\nfunction toggleObserving(value) {\n  shouldObserve = value;\n}\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n\n\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\n\n\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n/**\n * Observe a list of Array items.\n */\n\n\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n}; // helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\n\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n\n/* istanbul ignore next */\n\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n\nfunction observe(value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return;\n  }\n\n  var ob;\n\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n\n  return ob;\n}\n/**\n * Define a reactive property on an Object.\n */\n\n\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (property && property.configurable === false) {\n    return;\n  } // cater for pre-defined getter/setters\n\n\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n\n      if (Dep.target) {\n        dep.depend();\n\n        if (childOb) {\n          childOb.dep.depend();\n\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n\n\n      if ( true && customSetter) {\n        customSetter();\n      } // #7981: for accessor properties without setter\n\n\n      if (getter && !setter) {\n        return;\n      }\n\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\n\n\nfunction set(target, key, val) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n/**\n * Delete a property and trigger change if necessary.\n */\n\n\nfunction del(target, key) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  delete target[key];\n\n  if (!ob) {\n    return;\n  }\n\n  ob.dep.notify();\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\n\n\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\n\n\nvar strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\n\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n\n    return defaultStrat(parent, child);\n  };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\n\n\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n\n  var key, toVal, fromVal;\n  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]; // in case the object is already observed...\n\n    if (key === '__ob__') {\n      continue;\n    }\n\n    toVal = to[key];\n    fromVal = from[key];\n\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n\n  return to;\n}\n/**\n * Data\n */\n\n\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n\n    if (!parentVal) {\n      return childVal;\n    } // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n\n\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\n\n\nfunction mergeHook(parentVal, childVal) {\n  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  return res ? dedupeHooks(res) : res;\n}\n\nfunction dedupeHooks(hooks) {\n  var res = [];\n\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n\n  return res;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  var res = Object.create(parentVal || null);\n\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n\n\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = {};\n  extend(ret, parentVal);\n\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n\n    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n\n  return ret;\n};\n/**\n * Other object hashes.\n */\n\n\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n\n  if (childVal) {\n    extend(ret, childVal);\n  }\n\n  return ret;\n};\n\nstrats.provide = mergeDataOrFn;\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\n\n\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeLetters + \"]*$\").test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n  }\n\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\n\n\nfunction normalizeProps(options, vm) {\n  var props = options.props;\n\n  if (!props) {\n    return;\n  }\n\n  var res = {};\n  var i, val, name;\n\n  if (Array.isArray(props)) {\n    i = props.length;\n\n    while (i--) {\n      val = props[i];\n\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = {\n          type: null\n        };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : {\n        type: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n  }\n\n  options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\n\n\nfunction normalizeInject(options, vm) {\n  var inject = options.inject;\n\n  if (!inject) {\n    return;\n  }\n\n  var normalized = options.inject = {};\n\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = {\n        from: inject[i]\n      };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({\n        from: key\n      }, val) : {\n        from: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n  }\n}\n/**\n * Normalize raw function directives into object format.\n */\n\n\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n\n      if (typeof def$$1 === 'function') {\n        dirs[key] = {\n          bind: def$$1,\n          update: def$$1\n        };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n  }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\n\n\nfunction mergeOptions(parent, child, vm) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child); // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n\n  for (key in parent) {\n    mergeField(key);\n  }\n\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n\n  return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\n\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n\n  var assets = options[type]; // check local registration variations first\n\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n\n  var camelizedId = camelize(id);\n\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n\n  var PascalCaseId = capitalize(camelizedId);\n\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  } // fallback to prototype chain\n\n\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n  if ( true && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key]; // boolean casting\n\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  } // check default value\n\n\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n    // make sure to observe it.\n\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n\n  if (true) {\n    assertProp(prop, key, value, vm, absent);\n  }\n\n  return value;\n}\n/**\n * Get the default value of a prop.\n */\n\n\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n\n  var def = prop.default; // warn against non-factory defaults for Object & Array\n\n  if ( true && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  } // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n\n\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  } // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n\n\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n/**\n * Assert whether a prop is valid.\n */\n\n\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n\n  if (value == null && !prop.required) {\n    return;\n  }\n\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n    return;\n  }\n\n  var validator = prop.validator;\n\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\n\n\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n\n  message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n\n  return message;\n}\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return \"\\\"\" + value + \"\\\"\";\n  } else if (type === 'Number') {\n    return \"\" + Number(value);\n  } else {\n    return \"\" + value;\n  }\n}\n\nfunction isExplicable(value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) {\n    return value.toLowerCase() === elem;\n  });\n}\n\nfunction isBoolean() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  return args.some(function (elem) {\n    return elem.toLowerCase() === 'boolean';\n  });\n}\n/*  */\n\n\nfunction handleError(err, vm, info) {\n  if (vm) {\n    var cur = vm;\n\n    while (cur = cur.$parent) {\n      var hooks = cur.$options.errorCaptured;\n\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n\n            if (capture) {\n              return;\n            }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n\n  globalHandleError(err, vm, info);\n}\n\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n  var res;\n\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n\n    if (res && !res._isVue && isPromise(res)) {\n      res.catch(function (e) {\n        return handleError(e, vm, info + \" (Promise/async)\");\n      });\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n\n  return res;\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  if (true) {\n    warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n  }\n  /* istanbul ignore else */\n\n\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n/*  */\n\n\nvar isUsingMicroTask = false;\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n} // Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n\nvar timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n\n/* istanbul ignore next, $flow-disable-line */\n\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n\n  timerFunc = function () {\n    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n    if (isIOS) {\n      setTimeout(noop);\n    }\n  };\n\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\nMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  } // $flow-disable-line\n\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n/*  */\n\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function (tag) {\n      return perf.mark(tag);\n    };\n\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag); // perf.clearMeasures(name)\n    };\n  }\n}\n/* not type checking this file because flow doesn't play well with Proxy */\n\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n      if (!has && !isAllowed) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return has || !isAllowed;\n    }\n  };\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n/*  */\n\n\nvar seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\n\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n\n  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n    return;\n  }\n\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n\n    if (seen.has(depId)) {\n      return;\n    }\n\n    seen.add(depId);\n  }\n\n  if (isA) {\n    i = val.length;\n\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n/*  */\n\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns, vm) {\n  function invoker() {\n    var arguments$1 = arguments;\n    var fns = invoker.fns;\n\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n    }\n  }\n\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n  var name, def$$1, cur, old, event;\n\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n\n    if (isUndef(cur)) {\n       true && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n/*  */\n\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n/*  */\n\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n\n  if (isUndef(propOptions)) {\n    return;\n  }\n\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n\n      if (!preserve) {\n        delete hash[key];\n      }\n\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n\n      if (!preserve) {\n        delete hash[altKey];\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\n\n\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n\n  return children;\n} // 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\n\n\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n\n    lastIndex = res.length - 1;\n    last = res[lastIndex]; //  nested\n\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n\n        res.push(c);\n      }\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = {\n    data: data,\n    context: context,\n    children: children,\n    tag: tag\n  };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, context) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        contexts.length = 0;\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n\n      if (!sync) {\n        forceRender(true);\n      } else {\n        contexts.length = 0;\n      }\n    });\n    var reject = once(function (reason) {\n       true && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject( true ? \"timeout (\" + res.timeout + \"ms)\" : undefined);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false; // return in case resolved synchronously\n\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n/*  */\n\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n/*  */\n\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n/*  */\n\n/*  */\n\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false; // init parent attached events\n\n  var listeners = vm.$options._parentListeners;\n\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler(event, fn) {\n  var _target = target;\n  return function onceHandler() {\n    var res = fn.apply(null, arguments);\n\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  };\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this; // all\n\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    } // array of events\n\n\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n\n      return vm;\n    } // specific event\n\n\n    var cbs = vm._events[event];\n\n    if (!cbs) {\n      return vm;\n    }\n\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    } // specific handler\n\n\n    var cb;\n    var i = cbs.length;\n\n    while (i--) {\n      cb = cbs[i];\n\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n\n    var cbs = vm._events[event];\n\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n\n    return vm;\n  };\n}\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\n\n\nfunction resolveSlots(children, context) {\n  if (!children || !children.length) {\n    return {};\n  }\n\n  var slots = {};\n\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    } // named slots should only be respected if the vnode was rendered in the\n    // same context.\n\n\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      var name = data.slot;\n      var slot = slots[name] || (slots[name] = []);\n\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  } // ignore slots that contains only whitespace\n\n\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nhasDynamicKeys, res) {\n  res = res || {\n    $stable: !hasDynamicKeys\n  };\n\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, hasDynamicKeys, res);\n    } else if (slot) {\n      res[slot.key] = slot.fn;\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  };\n}\n\nfunction initLifecycle(vm) {\n  var options = vm.$options; // locate first non-abstract parent\n\n  var parent = options.parent;\n\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n  vm.$children = [];\n  vm.$refs = {};\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n      /* removeOnly */\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n\n    restoreActiveInstance(); // update __vue__ reference\n\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    } // if parent is an HOC, update its $el as well\n\n\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    } // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true; // remove self from parent\n\n    var parent = vm.$parent;\n\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    } // teardown watchers\n\n\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n\n    var i = vm._watchers.length;\n\n    while (i--) {\n      vm._watchers[i].teardown();\n    } // remove reference from data ob\n    // frozen object may not have observer.\n\n\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    } // call the last hook...\n\n\n    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n    vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n    callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n    vm.$off(); // remove __vue__ reference\n\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    } // release circular reference (#6759)\n\n\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n\n    if (true) {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n\n  callHook(vm, 'beforeMount');\n  var updateComponent;\n  /* istanbul ignore if */\n\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n      mark(startTag);\n\n      var vnode = vm._render();\n\n      mark(endTag);\n      measure(\"vue \" + name + \" render\", startTag, endTag);\n      mark(startTag);\n\n      vm._update(vnode, hydrating);\n\n      mark(endTag);\n      measure(\"vue \" + name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  } // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n\n\n  new Watcher(vm, updateComponent, noop, {\n    before: function before() {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true\n  /* isRenderWatcher */\n  );\n  hydrating = false; // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  } // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n\n\n  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n\n  var needsForceUpdate = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  hasDynamicScopedSlot);\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n\n  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject; // update props\n\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n\n    toggleObserving(true); // keep a copy of raw propsData\n\n    vm.$options.propsData = propsData;\n  } // update listeners\n\n\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n\n  if (!vm._inactive) {\n    vm._inactive = true;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n\n  popTarget();\n}\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n/**\n * Reset the scheduler's state.\n */\n\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n\n  if (true) {\n    circular = {};\n  }\n\n  waiting = flushing = false;\n} // Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\n\n\nvar currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\nvar getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res ( relative to poge load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n\nif (inBrowser && getNow() > document.createEvent('Event').timeStamp) {\n  // if the low-res timestamp which is bigger than the event timestamp\n  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\n  // and we need to use the hi-res version for event listeners as well.\n  getNow = function () {\n    return performance.now();\n  };\n}\n/**\n * Flush both queues and run the watchers.\n */\n\n\nfunction flushSchedulerQueue() {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id; // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  }); // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n\n    if (watcher.before) {\n      watcher.before();\n    }\n\n    id = watcher.id;\n    has[id] = null;\n    watcher.run(); // in dev build, check and stop circular updates.\n\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  } // keep copies of post queues before resetting state\n\n\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n  resetSchedulerState(); // call component updated and activated hooks\n\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue); // devtool hook\n\n  /* istanbul ignore if */\n\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\n\n\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true\n    /* true */\n    );\n  }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\n\n\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n\n  if (has[id] == null) {\n    has[id] = true;\n\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n\n      queue.splice(i + 1, 0, watcher);\n    } // queue the flush\n\n\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return;\n      }\n\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n/*  */\n\n\nvar uid$1 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\n\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n\n  vm._watchers.push(this); // options\n\n\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter\n\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n\n  this.value = this.lazy ? undefined : this.get();\n};\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\n\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n\n    popTarget();\n    this.cleanupDeps();\n  }\n\n  return value;\n};\n/**\n * Add a dependency to this directive.\n */\n\n\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n/**\n * Clean up for dependency collection.\n */\n\n\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var i = this.deps.length;\n\n  while (i--) {\n    var dep = this.deps[i];\n\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\n\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\n\n\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n\n    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\n\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n/**\n * Depend on all deps collected by this watcher.\n */\n\n\nWatcher.prototype.depend = function depend() {\n  var i = this.deps.length;\n\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n/**\n * Remove self from all dependencies' subscriber list.\n */\n\n\nWatcher.prototype.teardown = function teardown() {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n\n    this.active = false;\n  }\n};\n/*  */\n\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true\n    /* asRootData */\n    );\n  }\n\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent; // root instance props should be converted\n\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n\n  var loop = function (key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n\n      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n        warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {} // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n\n\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop(key);\n\n  toggleObserving(true);\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  } // proxy data on instance\n\n\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n\n  while (i--) {\n    var key = keys[i];\n\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n      }\n    }\n\n    if (props && hasOwn(props, key)) {\n       true && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  } // observe data\n\n\n  observe(data, true\n  /* asRootData */\n  );\n}\n\nfunction getData(data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = {\n  lazy: true\n};\n\nfunction initComputed(vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n    if ( true && getter == null) {\n      warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    } // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  var shouldCache = !isServerRendering();\n\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n\n  if ( true && sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n    };\n  }\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n\n      if (Dep.target) {\n        watcher.depend();\n      }\n\n      return watcher.value;\n    }\n  };\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter() {\n    return fn.call(this, this);\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + typeof methods[key] + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n\n      if (key in vm && isReserved(key)) {\n        warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n      }\n    }\n\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n\n  return vm.$watch(expOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n\n  dataDef.get = function () {\n    return this._data;\n  };\n\n  var propsDef = {};\n\n  propsDef.get = function () {\n    return this._props;\n  };\n\n  if (true) {\n    dataDef.set = function () {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n      }\n    }\n\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n/*  */\n\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // #6574 in case the inject object is observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      var provideKey = inject[key].from;\n      var source = vm;\n\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n\n        source = source.$parent;\n      }\n\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n        } else if (true) {\n          warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/*  */\n\n\nfunction normalizeScopedSlots(slots, normalSlots) {\n  var res;\n\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    return slots;\n  } else {\n    res = {};\n\n    for (var key in slots) {\n      if (slots[key] && key[0] !== '$') {\n        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);\n      }\n    }\n  } // expose normal slots on scopedSlots\n\n\n  for (var key$1 in normalSlots) {\n    if (!(key$1 in res)) {\n      res[key$1] = proxyNormalSlot(normalSlots, key$1);\n    }\n  }\n\n  res._normalized = true;\n  res.$stable = slots ? slots.$stable : true;\n  return res;\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function (scope) {\n    if (scope === void 0) scope = {};\n    var res = fn(scope);\n    return res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n    : normalizeChildren(res);\n  }; // proxy scoped slots on normal $slots\n\n\n  if (!hasOwn(normalSlots, key)) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized\n    });\n  }\n\n  return normalized;\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () {\n    return slots[key];\n  };\n}\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\n\n\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n\n  if (!isDef(ret)) {\n    ret = [];\n  }\n\n  ret._isVList = true;\n  return ret;\n}\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\n\n\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn('slot v-bind without argument expects an Object', this);\n      }\n\n      props = extend(extend({}, bindObject), props);\n    }\n\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n\n  if (target) {\n    return this.$createElement('template', {\n      slot: target\n    }, nodes);\n  } else {\n    return nodes;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\n\n\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n/*  */\n\n\nfunction isKeyNotMatch(expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1;\n  } else {\n    return expect !== actual;\n  }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\n\n\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName);\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\n\n\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n\n      var hash;\n\n      var loop = function (key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n\n        var camelizedKey = camelize(key);\n\n        if (!(key in hash) && !(camelizedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n\n            on[\"update:\" + camelizedKey] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop(key);\n    }\n  }\n\n  return data;\n}\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\n\n\nfunction renderStatic(index, isInFor) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n\n  if (tree && !isInFor) {\n    return tree;\n  } // otherwise, render a fresh tree.\n\n\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\n\n\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n/*  */\n\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn('v-on without argument expects an Object value', this);\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n\n  return data;\n}\n/*  */\n\n\nfunction bindDynamicKeys(baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n    }\n  }\n\n  return baseObj;\n} // helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\n\n\nfunction prependModifier(value, symbol) {\n  return typeof value === 'string' ? symbol + value : value;\n}\n/*  */\n\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n/*  */\n\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  var options = Ctor.options; // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n\n  var contextVm;\n\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent); // $flow-disable-line\n\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent; // $flow-disable-line\n\n    parent = parent._original;\n  }\n\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n\n  this.slots = function () {\n    return resolveSlots(children, parent);\n  };\n\n  Object.defineProperty(this, 'scopedSlots', {\n    enumerable: true,\n    get: function get() {\n      return normalizeScopedSlots(data.scopedSlots, this.slots());\n    }\n  }); // support for compiled functional template\n\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options; // pre-resolve slots for renderSlot()\n\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n\n      return vnode;\n    };\n  } else {\n    this._c = function (a, b, c, d) {\n      return createElement(contextVm, a, b, c, d, needNormalization);\n    };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n\n  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n\n    return res;\n  }\n}\n\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n\n  return clone;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n// inline hooks to be invoked on component VNodes during patch\n\n\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating) {\n    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  },\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  }\n};\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  } // if at this stage it's not a constructor or an async component factory,\n  // reject.\n\n\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n\n    return;\n  } // async component\n\n\n  var asyncFactory;\n\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {}; // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n\n  resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  } // extract props\n\n\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  } // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n\n\n  var listeners = data.on; // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n    // work around flow\n    var slot = data.slot;\n    data = {};\n\n    if (slot) {\n      data.slot = slot;\n    }\n  } // install component management hooks onto the placeholder node\n\n\n  installComponentHooks(data); // return a placeholder vnode\n\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n    Ctor: Ctor,\n    propsData: propsData,\n    listeners: listeners,\n    tag: tag,\n    children: children\n  }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  }; // check inline-template render functions\n\n  var inlineTemplate = vnode.data.inlineTemplate;\n\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction installComponentHooks(data) {\n  var hooks = data.hook || (data.hook = {});\n\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1(f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n\n  merged._merged = true;\n  return merged;\n} // transform component v-model info (value and callback) into\n// prop and event handler respectively.\n\n\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';\n  (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n\n  if (isDef(existing)) {\n    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n/*  */\n\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n// without getting yelled at by flow\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n     true && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  } // object syntax in v-bind\n\n\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  } // warn against non-primitive key\n\n\n  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    {\n      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n    }\n  } // support single function children as default scoped slot\n\n\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = {\n      default: children[0]\n    };\n    children.length = 0;\n  }\n\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n\n  var vnode, ns;\n\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n\n  if (Array.isArray(vnode)) {\n    return vnode;\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) {\n      applyNS(vnode, ns);\n    }\n\n    if (isDef(data)) {\n      registerDeepBindings(data);\n    }\n\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n} // ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\n\n\nfunction registerDeepBindings(data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n/*  */\n\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n\n  vm._staticTrees = null; // v-once cached trees\n\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  }; // normalization is always applied for the public version, used in\n  // user-written render functions.\n\n\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  }; // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n\n\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots);\n    } // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n\n\n    vm.$vnode = _parentVnode; // render self\n\n    var vnode;\n\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\"); // return error render result,\n      // or previous vnode to prevent render error causing blank component\n\n      /* istanbul ignore else */\n\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } // if the returned array contains only a single node, allow it\n\n\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    } // return empty vnode in case the render function errored out\n\n\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n\n      vnode = createEmptyVNode();\n    } // set parent\n\n\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n/*  */\n\n\nvar uid$3 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this; // a uid\n\n    vm._uid = uid$3++;\n    var startTag, endTag;\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    } // a flag to avoid this being observed\n\n\n    vm._isVue = true; // merge options\n\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n\n\n    if (true) {\n      initProxy(vm);\n    } else {} // expose real self\n\n\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n\n    callHook(vm, 'created');\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n\n      modified[key] = latest[key];\n    }\n  }\n\n  return modified;\n}\n\nfunction Vue(options) {\n  if ( true && !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    } // additional parameters\n\n\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n  /**\n   * Class inheritance\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    } // allow further extension/mixin/plugin usage\n\n\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use; // create asset registers, so extended classes\n    // can have their private assets too.\n\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    }); // enable recursive self-lookup\n\n    if (name) {\n      Sub.options.components[name] = Sub;\n    } // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n\n\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n/*  */\n\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = {\n            bind: definition,\n            update: definition\n          };\n        }\n\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n/*  */\n\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n\n  for (var key in cache) {\n    var cachedNode = cache[key];\n\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  var cached$$1 = cache[key];\n\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n  created: function created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n  destroyed: function destroyed() {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) {\n        return matches(val, name);\n      });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) {\n        return !matches(val, name);\n      });\n    });\n  },\n  render: function render() {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n\n      if ( // not included\n      include && (!name || !matches(include, name)) || // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key); // prune oldest entry\n\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n\n    return vnode || slot && slot[0];\n  }\n};\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n\n  configDef.get = function () {\n    return config;\n  };\n\n  if (true) {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n\n  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj;\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  }); // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n\n  Vue.options._base = Vue;\n  extend(Vue.options.components, builtInComponents);\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n}); // expose FunctionalRenderContext for ssr runtime helper installation\n\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\nVue.version = '2.6.2';\n/*  */\n// these are reserved for web because they are directly compiled away\n// during template compilation\n\nvar isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\nvar acceptValue = makeMap('input,textarea,option,select,progress');\n\nvar mustUseProp = function (tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n};\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false;\n};\n/*  */\n\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n\n      res += stringified;\n    }\n  }\n\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n\n      res += key;\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\n\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function (tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  } // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n\n\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\n\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n\n  if (isReservedTag(tag)) {\n    return false;\n  }\n\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n\n  var el = document.createElement(tag);\n\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n\n    if (!selected) {\n       true && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n\n    return selected;\n  } else {\n    return el;\n  }\n}\n/*  */\n\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n\n  if (tagName !== 'select') {\n    return elm;\n  } // false or null will remove the attribute but undefined will not\n\n\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope(node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps =\n/*#__PURE__*/\nObject.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n\n  if (!isDef(key)) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\n\nvar emptyNode = new VNode('', {}, []);\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      /* istanbul ignore if */\n\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false\n        /* hydrating */\n        );\n      } // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n\n\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n\n    vnode.elm = vnode.componentInstance.$el;\n\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode); // make sure to invoke the insert hook\n\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i; // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n\n    var innerNode = vnode;\n\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    } // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n\n\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n\n    i = vnode.data.hook; // Reuse variable\n\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  } // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n\n\n  function setScope(vnode) {\n    var i;\n\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n\n        ancestor = ancestor.parent;\n      }\n    } // for slot content they should also get the scopeId from the host instance.\n\n\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } // recursively invoke hooks on child component root node\n\n\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    var seenKeys = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n\n      if (isDef(c) && sameVnode(node, c)) {\n        return i;\n      }\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n\n      return;\n    } // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    } // assert node match\n\n\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false;\n      }\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true\n        /* hydrating */\n        );\n      }\n\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n\n              childNode = childNode.nextSibling;\n            } // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n\n\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n\n              return false;\n            }\n          }\n        }\n      }\n\n      if (isDef(data)) {\n        var fullInvoke = false;\n\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (true) {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          } // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n\n\n          oldVnode = emptyNodeAt(oldVnode);\n        } // replacing existing element\n\n\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n\n            ancestor.elm = vnode.elm;\n\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              } // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n\n\n              var insert = ancestor.data.hook.insert;\n\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n\n            ancestor = ancestor.parent;\n          }\n        } // destroy old node\n\n\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n/*  */\n\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n  var key, oldDir, dir;\n\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n\n  var i, dir;\n\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  } // $flow-disable-line\n\n\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  } // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n  /* istanbul ignore if */\n\n\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr(el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n\n    /* istanbul ignore if */\n    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n\n      el.addEventListener('input', blocker); // $flow-disable-line\n\n      el.__ieph = true;\n      /* IE placeholder patched */\n    }\n\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode); // handle transition classes\n\n  var transitionClass = el._transitionClasses;\n\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  } // set the class\n\n\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;\n          break;\n        // \"\n\n        case 0x27:\n          inSingle = true;\n          break;\n        // '\n\n        case 0x60:\n          inTemplateString = true;\n          break;\n        // `\n\n        case 0x28:\n          paren++;\n          break;\n        // (\n\n        case 0x29:\n          paren--;\n          break;\n        // )\n\n        case 0x5B:\n          square++;\n          break;\n        // [\n\n        case 0x5D:\n          square--;\n          break;\n        // ]\n\n        case 0x7B:\n          curly++;\n          break;\n        // {\n\n        case 0x7D:\n          curly--;\n          break;\n        // }\n      }\n\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0; // find first non-whitespace prev char\n\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n\n          if (p !== ' ') {\n            break;\n          }\n        }\n\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n  }\n}\n/*  */\n\n/* eslint-disable no-unused-vars */\n\n\nfunction baseWarn(msg, range) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n/* eslint-enable no-unused-vars */\n\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n}\n\nfunction addAttr(el, name, value, range, dynamic) {\n  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n  attrs.push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n} // add a raw attr (use this in preTransforms)\n\n\nfunction addRawAttr(el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({\n    name: name,\n    value: value\n  }, range));\n}\n\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker(symbol, name, dynamic) {\n  return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n  modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n  /* istanbul ignore if */\n\n  if ( true && warn && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n  } // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n\n\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  } // check capture modifier\n\n\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n\n\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({\n    value: value.trim(),\n    dynamic: dynamic\n  }, range);\n\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr(el, name) {\n  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n} // note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\n\n\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n  var val;\n\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n\n  return val;\n}\n\nfunction getAndRemoveAttrByRegex(el, name) {\n  var list = el.attrsList;\n\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr;\n    }\n  }\n}\n\nfunction rangeSetItem(item, range) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n\n  return item;\n}\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var assignment = genAssignmentCode(value, valueExpression);\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: JSON.stringify(value),\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\nfunction genAssignmentCode(value, assignment) {\n  var res = parseModel(value);\n\n  if (res.key === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n  }\n}\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\nfunction parseModel(val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      };\n    } else {\n      return {\n        exp: val,\n        key: null\n      };\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n\n  while (!eof()) {\n    chr = next();\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n\n  while (!eof()) {\n    chr = next();\n\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n/*  */\n\n\nvar warn$1; // in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\n\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (true) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (true) {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n  } // ensure runtime directive metadata\n\n\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n\n  if (true) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n  var valueExpression = '$event.target.value';\n\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n/*  */\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\n\n\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  } // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n  /* istanbul ignore if */\n\n\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1(event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n\n  return function onceHandler() {\n    var res = handler.apply(null, arguments);\n\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  };\n}\n\nfunction add$1(name, handler, capture, passive) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (isUsingMicroTask) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n\n    handler = original._wrapper = function (e) {\n      if (e.timeStamp >= attachedTimestamp) {\n        return original.apply(this, arguments);\n      }\n    };\n  }\n\n  target$1.addEventListener(name, handler, supportsPassive ? {\n    capture: capture,\n    passive: passive\n  } : capture);\n}\n\nfunction remove$2(name, handler, capture, _target) {\n  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key]; // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n\n      if (cur === oldProps[key]) {\n        continue;\n      } // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n\n\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    } // skip the update if old and new VDOM state is the same.\n    // the only exception is `value` where the DOM value may be temporarily\n    // out of sync with VDOM state due to focus, composition and modifiers.\n    // This also covers #4521 by skipping the unnecesarry `checked` update.\n\n\n    if (key !== 'value' && cur === oldProps[key]) {\n      continue;\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur; // avoid resetting cursor position when value is the same\n\n      var strCur = isUndef(cur) ? '' : String(cur);\n\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n} // check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true; // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n}); // merge static and dynamic style data on the same vnode\n\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n} // normalize possible array / string values into Object\n\n\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n\n  return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\n\n\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\n\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n\n  for (name in newStyle) {\n    cur = newStyle[name];\n\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n/*  */\n\nvar whitespaceRE = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\n\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n\n    cur = cur.trim();\n\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n/*  */\n\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (typeof def$$1 === 'object') {\n    var res = {};\n\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation'; // Transition property/event sniffing\n\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\n\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n} // binding to window is necessary to make hot reload work in IE in strict mode\n\n\nvar raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n/* istanbul ignore next */\nfunction (fn) {\n  return fn();\n};\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n\n  if (!type) {\n    return cb();\n  }\n\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\n\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n/*  */\n\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm; // call leave callback now\n\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data)) {\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration; // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n\n      enterHook && enterHook(el, cb);\n    });\n  } // start enter transition\n\n\n  beforeEnterHook && beforeEnterHook(el);\n\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm; // call enter callback now\n\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    } // record leaving element\n\n\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n\n    beforeLeave && beforeLeave(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    leave && leave(el, cb);\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n} // only used in dev mode\n\n\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\n\n\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n\n  var invokerFns = fn.fns;\n\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n/*  */\n// the directive module should be applied last, after all\n// built-in modules have been applied.\n\nvar modules = platformModules.concat(baseModules);\nvar patch = createPatchFunction({\n  nodeOps: nodeOps,\n  modules: modules\n});\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\n\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, curOptions);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n\n  var selected, option;\n\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n\n        return;\n      }\n    }\n  }\n\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(function (o) {\n    return !looseEqual(o, value);\n  });\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n/*  */\n// recursively search for possible transition defined inside the component root\n\n\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n    /* istanbul ignore if */\n\n    if (!value === !oldValue) {\n      return;\n    }\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n\n    if (transition$$1) {\n      vnode.data.show = true;\n\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n}; // in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\n\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options; // props\n\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  } // events.\n  // extract listeners and pass them directly to the transition methods\n\n\n  var listeners = options._parentListeners;\n\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar isNotTextNode = function (c) {\n  return c.tag || isAsyncPlaceholder(c);\n};\n\nvar isVShowDirective = function (d) {\n  return d.name === 'show';\n};\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render(h) {\n    var this$1 = this;\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    } // filter out text nodes (possible whitespaces)\n\n\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n\n    if (!children.length) {\n      return;\n    } // warn multiple elements\n\n\n    if ( true && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode; // warn invalid mode\n\n    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0]; // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    } // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    } // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n\n\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild); // mark v-show\n    // so that the transition module can hand over the control to the directive\n\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n\n        var delayedLeave;\n\n        var performLeave = function () {\n          delayedLeave();\n        };\n\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n  props: props,\n  beforeMount: function beforeMount() {\n    var this$1 = this;\n    var update = this._update;\n\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;\n          (c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    } // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n\n\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation); // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n\n    this._reflow = document.body.offsetHeight;\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (e && e.target !== el) {\n            return;\n          }\n\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (this._hasMove) {\n        return this._hasMove;\n      } // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n\n\n      var clone = el.cloneNode();\n\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n\n\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n/*  */\n// install platform specific utils\n\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents); // install platform patch function\n\nVue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n}; // devtools global hook\n\n/* istanbul ignore next */\n\n\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (true) {\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n\n    if ( true && config.productionTip !== false && typeof console !== 'undefined') {\n      console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n    }\n  }, 0);\n}\n/*  */\n\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n  if (!tagRE.test(text)) {\n    return;\n  }\n\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n\n  while (match = tagRE.exec(text)) {\n    index = match.index; // push text token\n\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    } // tag token\n\n\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    rawTokens.push({\n      '@binding': exp\n    });\n    lastIndex = index + match[0].length;\n  }\n\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  };\n}\n/*  */\n\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n\n  if ( true && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n\n    if (res) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n    }\n  }\n\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n\n  var classBinding = getBindingAttr(el, 'class', false\n  /* getStatic */\n  );\n\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData(el) {\n  var data = '';\n\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (true) {\n      var res = parseText(staticStyle, options.delimiters);\n\n      if (res) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n      }\n    }\n\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false\n  /* getStatic */\n  );\n\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n/*  */\n\nvar decoder;\nvar he = {\n  decode: function decode(html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n};\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n// (and which close themselves)\n\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n// Regular Expressions for parsing tags and attributes\n\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeLetters + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page\n\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\nvar shouldIgnoreFirstNewline = function (tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n};\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n\n  while (html) {\n    last = html; // Make sure we're not in a plaintext content element like script/style\n\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n\n            advance(commentEnd + 3);\n            continue;\n          }\n        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        } // Doctype:\n\n\n        var doctypeMatch = html.match(doctype);\n\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        } // End tag:\n\n\n        var endTagMatch = html.match(endTag);\n\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        } // Start tag:\n\n\n        var startTagMatch = parseStartTag();\n\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest = void 0,\n          next = void 0;\n\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n\n          if (next < 0) {\n            break;\n          }\n\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n          .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n\n        if (options.chars) {\n          options.chars(text);\n        }\n\n        return '';\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n\n      if ( true && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n          start: index + html.length\n        });\n      }\n\n      break;\n    }\n  } // Clean up any remaining tags\n\n\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n\n      if ( true && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs: attrs,\n        start: match.start,\n        end: match.end\n      });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n\n    if (start == null) {\n      start = index;\n    }\n\n    if (end == null) {\n      end = index;\n    } // Find the closest opened tag of the same type\n\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ( true && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n            start: stack[i].start\n          });\n        }\n\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      } // Remove the open elements from the stack\n\n\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n/*  */\n\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\nvar slotRE = /^v-slot(:|$)|^#/;\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\nvar decodeHTMLCached = cached(he.decode); // configurable state\n\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  };\n}\n/**\n * Convert HTML string to AST.\n */\n\n\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n\n  maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement(element) {\n    trimEndingWhitespace(element);\n\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    } // tree management\n\n\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (true) {\n          checkRootConstraints(element);\n        }\n\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (true) {\n        warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n          start: element.start\n        });\n      }\n    }\n\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"';\n          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    } // final children cleanup\n    // filter out scoped slots\n\n\n    element.children = element.children.filter(function (c) {\n      return !c.slotScope;\n    }); // remove trailing whitespace node again\n\n    trimEndingWhitespace(element); // check pre state\n\n    if (element.pre) {\n      inVPre = false;\n    }\n\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    } // apply post-transforms\n\n\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace(el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n\n      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints(el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n        start: el.start\n      });\n    }\n\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start(tag, attrs, unary, start$1) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n      /* istanbul ignore if */\n\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (true) {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated;\n          }, {});\n        }\n\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n              start: attr.start + attr.name.indexOf(\"[\"),\n              end: attr.start + attr.name.length\n            });\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         true && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n          start: element.start\n        });\n      } // apply pre-transforms\n\n\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n\n        if (true) {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n    end: function end(tag, start, end$1) {\n      var element = stack[stack.length - 1]; // pop stack\n\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n\n      if ( true && options.outputSourceRange) {\n        element.end = end$1;\n      }\n\n      closeElement(element);\n    },\n    chars: function chars(text, start, end) {\n      if (!currentParent) {\n        if (true) {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.', {\n              start: start\n            });\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n              start: start\n            });\n          }\n        }\n\n        return;\n      } // IE textarea placeholder bug\n\n      /* istanbul ignore if */\n\n\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n\n      var children = currentParent.children;\n\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n\n      if (text) {\n        if (whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n\n        var res;\n        var child;\n\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n\n        if (child) {\n          if ( true && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment(text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n\n        if ( true && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var list = el.attrsList;\n  var len = list.length;\n\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement(element, options) {\n  processKey(element); // determine whether this is a plain element after\n  // removing structural attributes\n\n  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n\n  processAttrs(element);\n  return element;\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n\n  if (exp) {\n    if (true) {\n      if (el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n      }\n\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n          /* tip */\n          );\n        }\n      }\n    }\n\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var res = parseFor(exp);\n\n    if (res) {\n      extend(el, res);\n    } else if (true) {\n      warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n    }\n  }\n}\n\nfunction parseFor(exp) {\n  var inMatch = exp.match(forAliasRE);\n\n  if (!inMatch) {\n    return;\n  }\n\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n\n  return res;\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (true) {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if ( true && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n      }\n\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n  if (once$$1 != null) {\n    el.once = true;\n  }\n} // handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\nfunction processSlotContent(el) {\n  var slotScope;\n\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n\n    if ( true && slotScope) {\n      warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n    }\n\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n    /* istanbul ignore if */\n    if ( true && el.attrsMap['v-for']) {\n      warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n    }\n\n    el.slotScope = slotScope;\n  } // slot=\"xxx\"\n\n\n  var slotTarget = getBindingAttr(el, 'slot');\n\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  } // 2.6 v-slot syntax\n\n\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding) {\n        if (true) {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n          }\n\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving the component\", el);\n          }\n        }\n\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || \"_\"; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding$1) {\n        if (true) {\n          if (!maybeComponent(el)) {\n            warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n          }\n\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n          }\n\n          if (el.scopedSlots) {\n            warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n          }\n        } // add the component's children to its default slot\n\n\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          return !c.slotScope;\n        });\n        slotContainer.slotScope = slotBinding$1.value || \"_\"; // remove children as they are returned from scopedSlots now\n\n        el.children = []; // mark el non-plain so data gets generated\n\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName(binding) {\n  var name = binding.name.replace(slotRE, '');\n\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (true) {\n      warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n    }\n  }\n\n  return dynamicArgRE.test(name) // dynamic [name]\n  ? {\n    name: name.slice(1, -1),\n    dynamic: true // static name\n\n  } : {\n    name: \"\\\"\" + name + \"\\\"\",\n    dynamic: false\n  };\n} // handle <slot/> outlets\n\n\nfunction processSlotOutlet(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n\n    if ( true && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true; // modifiers\n\n      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        if ( true && value.trim().length === 0) {\n          warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n        }\n\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n\n            if (!isDynamic) {\n              addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n              );\n            }\n          }\n        }\n\n        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, ''); // parse arg\n\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n        if ( true && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (true) {\n        var res = parseText(value, delimiters);\n\n        if (res) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n        }\n      }\n\n      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n\n      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if ( true && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n\n    map[attrs[i].name] = attrs[i].value;\n  }\n\n  return map;\n} // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n/* istanbul ignore next */\n\nfunction guardIESVGBug(attrs) {\n  var res = [];\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n    }\n\n    _el = _el.parent;\n  }\n}\n/*  */\n\n\nfunction preTransformNode(el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n\n    if (!map['v-model']) {\n      return;\n    }\n\n    var typeBinding;\n\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + map['v-bind'] + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n      var branch0 = cloneASTElement(el); // process for on the main node\n\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      }); // 2. add radio else-if condition\n\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      }); // 3. other\n\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0;\n    }\n  }\n}\n\nfunction cloneASTElement(el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\nvar modules$1 = [klass$1, style$1, model$1];\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n/*  */\n\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\nvar genStaticKeysCached = cached(genStaticKeys$1);\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\n\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n  markStatic$1(root); // second pass: mark static roots.\n\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    } // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n\n\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n\n    if (node.tag !== 'template') {\n      return false;\n    }\n\n    if (node.for) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n}; // KeyboardEvent.key aliases\n\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n}; // #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\n\nvar genGuard = function (condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n\n  staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n  } else {\n    return prefix + staticHandlers;\n  }\n}\n\nfunction genHandler(handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value;\n    }\n\n    return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key]; // left/right\n\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = handler.modifiers;\n        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n          return !modifiers[keyModifier];\n        }).map(function (keyModifier) {\n          return \"$event.\" + keyModifier + \"Key\";\n        }).join('||'));\n      } else {\n        keys.push(key);\n      }\n    }\n\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n\n    var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return \"if(('keyCode' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n}\n/*  */\n\n\nfunction on(el, dir) {\n  if ( true && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n\n  el.wrapListeners = function (code) {\n    return \"_g(\" + code + \",\" + dir.value + \")\";\n  };\n}\n/*  */\n\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n  };\n}\n/*  */\n\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n/*  */\n\nvar CodegenState = function CodegenState(options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n\n  this.maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\nfunction generate(ast, options) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: state.staticRenderFns\n  };\n}\n\nfunction genElement(el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state);\n  } else {\n    // component or element\n    var code;\n\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n\n      if (!el.plain || el.pre && state.maybeComponent(el)) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    } // module transforms\n\n\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n\n    return code;\n  }\n} // hoist static sub-trees out\n\n\nfunction genStatic(el, state) {\n  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n\n  var originalPreState = state.pre;\n\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n\n  state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n  state.pre = originalPreState;\n  return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n} // v-once\n\n\nfunction genOnce(el, state) {\n  el.onceProcessed = true;\n\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n\n      parent = parent.parent;\n    }\n\n    if (!key) {\n       true && state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n      return genElement(el, state);\n    }\n\n    return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n  } else {\n    return genStatic(el, state);\n  }\n}\n\nfunction genIf(el, state, altGen, altEmpty) {\n  el.ifProcessed = true; // avoid recursion\n\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\n\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n  if (!conditions.length) {\n    return altEmpty || '_e()';\n  }\n\n  var condition = conditions.shift();\n\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n  function genTernaryExp(el) {\n    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n  }\n}\n\nfunction genFor(el, state, altGen, altHelper) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if ( true && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n    /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n\n  return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n}\n\nfunction genData$2(el, state) {\n  var data = '{'; // directives first.\n  // directives may mutate the el's other properties before they are generated.\n\n  var dirs = genDirectives(el, state);\n\n  if (dirs) {\n    data += dirs + ',';\n  } // key\n\n\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  } // ref\n\n\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  } // pre\n\n\n  if (el.pre) {\n    data += \"pre:true,\";\n  } // record original tag name for components using \"is\" attribute\n\n\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  } // module data generation functions\n\n\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  } // attributes\n\n\n  if (el.attrs) {\n    data += \"attrs:\" + genProps(el.attrs) + \",\";\n  } // DOM props\n\n\n  if (el.props) {\n    data += \"domProps:\" + genProps(el.props) + \",\";\n  } // event handlers\n\n\n  if (el.events) {\n    data += genHandlers(el.events, false) + \",\";\n  }\n\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true) + \",\";\n  } // slot target\n  // only for non-scoped slots\n\n\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  } // scoped slots\n\n\n  if (el.scopedSlots) {\n    data += genScopedSlots(el.scopedSlots, state) + \",\";\n  } // component v-model\n\n\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  } // inline-template\n\n\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n\n  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n  } // v-bind data wrap\n\n\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  } // v-on data wrap\n\n\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n\n  return data;\n}\n\nfunction genDirectives(el, state) {\n  var dirs = el.directives;\n\n  if (!dirs) {\n    return;\n  }\n\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el, state) {\n  var ast = el.children[0];\n\n  if ( true && (el.children.length !== 1 || ast.type !== 1)) {\n    state.warn('Inline-template components must have exactly one child element.', {\n      start: el.start\n    });\n  }\n\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(slots, state) {\n  var hasDynamicKeys = Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return slot.slotTargetDynamic || slot.if || slot.for;\n  });\n  return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n    return genScopedSlot(slots[key], state);\n  }).join(',') + \"]\" + (hasDynamicKeys ? \",true\" : \"\") + \")\";\n}\n\nfunction genScopedSlot(el, state) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\");\n  }\n\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot);\n  }\n\n  var fn = \"function(\" + String(el.slotScope) + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n  return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + \"}\";\n}\n\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n  var children = el.children;\n\n  if (children.length) {\n    var el$1 = children[0]; // optimize single v-for\n\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n      return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n    }\n\n    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n    var gen = altGenNode || genNode;\n    return \"[\" + children.map(function (c) {\n      return gen(c, state);\n    }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n  }\n} // determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\n\n\nfunction getNormalizationType(children, maybeComponent) {\n  var res = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n\n    if (el.type !== 1) {\n      continue;\n    }\n\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction genNode(node, state) {\n  if (node.type === 1) {\n    return genElement(node, state);\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genComment(comment) {\n  return \"_e(\" + JSON.stringify(comment.text) + \")\";\n}\n\nfunction genSlot(el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n    return camelize(a.name) + \":\" + a.value;\n  }).join(',') + \"}\";\n  var bind$$1 = el.attrsMap['v-bind'];\n\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n\n  return res + ')';\n} // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\nfunction genComponent(componentName, el, state) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n\n    if (prop.dynamic) {\n      dynamicProps += prop.name + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n    }\n  }\n\n  staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n  if (dynamicProps) {\n    return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n  } else {\n    return staticProps;\n  }\n} // #3895, #4268\n\n\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n/*  */\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\n\n\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\nfunction detectErrors(ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode(node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n\n        if (value) {\n          var range = node.rawAttrsMap[name];\n\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          }\n        }\n      }\n    }\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent(exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n  }\n\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor(node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier(ident, type, text, warn, range) {\n  if (typeof ident === 'string') {\n    try {\n      new Function(\"var \" + ident + \"=_\");\n    } catch (e) {\n      warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n    }\n  }\n}\n\nfunction checkExpression(exp, text, warn, range) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n    if (keywordMatch) {\n      warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n    } else {\n      warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n}\n/*  */\n\n\nvar range = 2;\n\nfunction generateCodeFrame(source, start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = source.length;\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) {\n          continue;\n        }\n\n        res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n        var lineLength = lines[j].length;\n\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n\n          count += lineLength + 1;\n        }\n      }\n\n      break;\n    }\n  }\n\n  return res.join('\\n');\n}\n\nfunction repeat$1(str, n) {\n  var result = '';\n\n  while (true) {\n    // eslint-disable-line\n    if (n & 1) {\n      result += str;\n    }\n\n    n >>>= 1;\n\n    if (n <= 0) {\n      break;\n    }\n\n    str += str;\n  }\n\n  return result;\n}\n/*  */\n\n\nfunction createFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({\n      err: err,\n      code: code\n    });\n    return noop;\n  }\n}\n\nfunction createCompileToFunctionFn(compile) {\n  var cache = Object.create(null);\n  return function compileToFunctions(template, options, vm) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n    /* istanbul ignore if */\n\n    if (true) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    } // check cache\n\n\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n\n    if (cache[key]) {\n      return cache[key];\n    } // compile\n\n\n    var compiled = compile(template, options); // check compilation errors/tips\n\n    if (true) {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n          });\n        } else {\n          warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n      }\n\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) {\n            return tip(e.msg, vm);\n          });\n        } else {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      }\n    } // turn code into functions\n\n\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors);\n    }); // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n\n    /* istanbul ignore if */\n\n    if (true) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return cache[key] = res;\n  };\n}\n/*  */\n\n\nfunction createCompilerCreator(baseCompile) {\n  return function createCompiler(baseOptions) {\n    function compile(template, options) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if ( true && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = {\n              msg: msg\n            };\n\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n\n            (tip ? tips : errors).push(data);\n          };\n        } // merge custom modules\n\n\n        if (options.modules) {\n          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n        } // merge custom directives\n\n\n        if (options.directives) {\n          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n        } // copy other options\n\n\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n      var compiled = baseCompile(template.trim(), finalOptions);\n\n      if (true) {\n        detectErrors(compiled.ast, warn);\n      }\n\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled;\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    };\n  };\n}\n/*  */\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\n\n\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n});\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n/*  */\n// check whether current browser encodes a char inside attribute values\n\nvar div;\n\nfunction getShouldDecode(href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0;\n} // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\nvar mount = Vue.prototype.$mount;\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n  /* istanbul ignore if */\n\n  if (el === document.body || el === document.documentElement) {\n     true && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options; // resolve template/el and convert to render function\n\n  if (!options.render) {\n    var template = options.template;\n\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n\n          if ( true && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (true) {\n          warn('invalid template option:' + template, this);\n        }\n\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n\n    if (template) {\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"development\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n      /* istanbul ignore if */\n\n      if ( true && config.performance && mark) {\n        mark('compile end');\n        measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n\n  return mount.call(this, el, hydrating);\n};\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\n\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue.compile = compileToFunctions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"../node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20uanM/YTRiNSJdLCJuYW1lcyI6WyJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJiIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwiRGF0ZSIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwicHJvY2VzcyIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJhc3luYyIsIl9saWZlY3ljbGVIb29rcyIsInVuaWNvZGVMZXR0ZXJzIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsIlJlZ0V4cCIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsIndpbmRvdyIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJzb3J0IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImRlZHVwZUhvb2tzIiwiaG9va3MiLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwidHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsImRlZiQkMSIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJtZXNzYWdlIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiTnVtYmVyIiwiZXhwbGljaXRUeXBlcyIsInNvbWUiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsImxvZ0Vycm9yIiwiaXNVc2luZ01pY3JvVGFzayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsInRpbWVyRnVuYyIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJldmVudCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsImZhY3RvcnkiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiVnVlIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCIkc3RhYmxlIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJyZXN0b3JlQWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJjYWxsSG9vayIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJiZWZvcmUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwibmVlZHNGb3JjZVVwZGF0ZSIsIl9yZW5kZXJDaGlsZHJlbiIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93Iiwibm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDEiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInNvdXJjZSIsInByb3ZpZGVEZWZhdWx0Iiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsIl9ub3JtYWxpemVkIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsInByb3h5Tm9ybWFsU2xvdCIsInNjb3BlIiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInZhbHVlcyIsInByZXBlbmRNb2RpZmllciIsInN5bWJvbCIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwiaW5qZWN0aW9ucyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImNsYXNzIiwiaW5pdFJlbmRlciIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlZiIsInJlbmRlckVycm9yIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImZpbHRlciIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInRoaXMkMSIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsInBhcmVudEVsbSIsInJlZkVsbSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZnVsbEludm9rZSIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiYXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicmFuZ2UiLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImR5bmFtaWMiLCJyYW5nZVNldEl0ZW0iLCJwbGFpbiIsImFkZEF0dHIiLCJkeW5hbWljQXR0cnMiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJpc0R5bmFtaWNBcmciLCJwcmVwZW5kTW9kaWZpZXJNYXJrZXIiLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldFJhd0JpbmRpbmdBdHRyIiwicmF3QXR0cnNNYXAiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ2YWx1ZSQxIiwidHlwZUJpbmRpbmciLCJiaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJleGVjIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJkeW5hbWljQXJnQXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsImVsZW1lbnQiLCJ0cmltRW5kaW5nV2hpdGVzcGFjZSIsInByb2Nlc3NlZCIsInByb2Nlc3NFbGVtZW50IiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwiZm9yYmlkZGVuIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImNvbW1lbnRzIiwic3RhcnQkMSIsImd1YXJkSUVTVkdCdWciLCJjdW11bGF0ZWQiLCJpc0ZvcmJpZGRlblRhZyIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJlbmQkMSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3RDb250ZW50IiwicHJvY2Vzc1Nsb3RPdXRsZXQiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiZm9yIiwiaXRlcmF0b3IyIiwiaXRlcmF0b3IxIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RCaW5kaW5nJDEiLCJkeW5hbWljJDEiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInNlbGYiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwicHJlZml4Iiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiZ2VuU2NvcGVkU2xvdCIsImlzTGVnYWN5U3ludGF4IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwibm9ybWFsaXphdGlvblR5cGUkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJjb3VudCIsInJlcGVhdCQxIiwibGluZUxlbmd0aCIsInBhZCIsImxlbmd0aCQxIiwibWluIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJsZWFkaW5nU3BhY2VMZW5ndGgiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQUtBO0FBRUEsSUFBSUEsV0FBVyxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLENBQWxCLEMsQ0FFQTtBQUNBOztBQUNBLFNBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLENBQUMsS0FBS0MsU0FBTixJQUFtQkQsQ0FBQyxLQUFLLElBQWhDO0FBQ0Q7O0FBRUQsU0FBU0UsS0FBVCxDQUFnQkYsQ0FBaEIsRUFBbUI7QUFDakIsU0FBT0EsQ0FBQyxLQUFLQyxTQUFOLElBQW1CRCxDQUFDLEtBQUssSUFBaEM7QUFDRDs7QUFFRCxTQUFTRyxNQUFULENBQWlCSCxDQUFqQixFQUFvQjtBQUNsQixTQUFPQSxDQUFDLEtBQUssSUFBYjtBQUNEOztBQUVELFNBQVNJLE9BQVQsQ0FBa0JKLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLENBQUMsS0FBSyxLQUFiO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxTQUFTSyxXQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUMzQixTQUNFLE9BQU9BLEtBQVAsS0FB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QixFQUEyQjtBQUN6QixNQUFJQSxFQUFFLENBQUNnMkMsU0FBUCxFQUFrQjtBQUNoQixXQUFPaDJDLEVBQUUsQ0FBQ2cyQyxTQUFWO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSUMsU0FBUyxHQUFHcnZDLFFBQVEsQ0FBQ2dWLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQXE2QixhQUFTLENBQUNsd0IsV0FBVixDQUFzQi9sQixFQUFFLENBQUNpaEMsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxXQUFPZ1YsU0FBUyxDQUFDOXFCLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRDNkLEdBQUcsQ0FBQ3NuQyxPQUFKLEdBQWNDLGtCQUFkO0FBRWV2bkMsa0VBQWYsRSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjYuMlxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlTGV0dGVycyA9ICdhLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyB1bmljb2RlTGV0dGVycyArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIFwiIChQcm9taXNlL2FzeW5jKVwiKTsgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxudmFyIHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICB2YXIgY291bnRlciA9IDE7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscycgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICBoYXNEeW5hbWljS2V5cyxcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNsb3QgPSBmbnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCBoYXNEeW5hbWljS2V5cywgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAocGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyAmJiAhcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICh2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICF2bS4kc2NvcGVkU2xvdHMuJHN0YWJsZSlcbiAgKTtcbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAoIHJlbGF0aXZlIHRvIHBvZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG5pZiAoaW5Ccm93c2VyICYmIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XG4gIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXG4gIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVycyBhcyB3ZWxsLlxuICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzXG4pIHtcbiAgdmFyIHJlcztcbiAgaWYgKCFzbG90cykge1xuICAgIHJlcyA9IHt9O1xuICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDEgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMSBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDFdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSk7XG4gICAgfVxuICB9XG4gIHJlcy5fbm9ybWFsaXplZCA9IHRydWU7XG4gIHJlcy4kc3RhYmxlID0gc2xvdHMgPyBzbG90cy4kc3RhYmxlIDogdHJ1ZTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSB7fTtcblxuICAgIHZhciByZXMgPSBmbihzY29wZSk7XG4gICAgcmV0dXJuIHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXMpXG4gICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpXG4gIH07XG4gIC8vIHByb3h5IHNjb3BlZCBzbG90cyBvbiBub3JtYWwgJHNsb3RzXG4gIGlmICghaGFzT3duKG5vcm1hbFNsb3RzLCBrZXkpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkXG59XG5cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gW107XG4gICAgICB2YXIgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBjYW1lbGl6ZWRLZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICB9XG4gIH0pKTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjInO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICBvbGRWbm9kZSxcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleCxcbiAgICByZW1vdmVPbmx5XG4gICkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmIChpc1VzaW5nTWljcm9UYXNrKSB7XG4gICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgIHZhciBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG52YXIgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIGlzIGB2YWx1ZWAgd2hlcmUgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgIC8vIFRoaXMgYWxzbyBjb3ZlcnMgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyAmJiBjdXIgPT09IG9sZFByb3BzW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbnZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3Rpbmdcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbnZhciBpc1ZTaG93RGlyZWN0aXZlID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9O1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzJDEpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKlwiO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIiksIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICBcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQkMTtcbiAgICAgIH1cbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXG4gICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBcIl9cIjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgXCJfXCI7XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoKCdrZXlDb2RlJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG5cblxuXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdGhpcy5wcmUgPSBmYWxzZTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICB9XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlwiICsgKGRpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogKFwiXFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpKSkgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgKTtcbiAgfVxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBoYXNEeW5hbWljS2V5cyA9IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgcmV0dXJuIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHwgc2xvdC5pZiB8fCBzbG90LmZvclxuICB9KTtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChoYXNEeW5hbWljS2V5cyA/IFwiLHRydWVcIiA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIFwibnVsbFwiKVxuICB9XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgPyAoXCIoXCIgKyAoZWwuaWYpICsgXCIpP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICA6IFwiXCI7XG4gICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUkMSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICB2YXIgZHluYW1pY1Byb3BzID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNQcm9wcyArPSAocHJvcC5uYW1lKSArIFwiLFwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgcmV0dXJuIChcIl9kKFwiICsgc3RhdGljUHJvcHMgKyBcIixbXCIgKyAoZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgd2FybihcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAobiAmIDEpIHsgcmVzdWx0ICs9IHN0cjsgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgIHN0ciArPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/vue/dist/vue.esm.js\n");

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanM/YTQyYiJdLCJuYW1lcyI6WyJnIiwiRnVuY3Rpb24iLCJlIiwid2luZG93IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsQ0FBSixDLENBRUE7O0FBQ0FBLENBQUMsR0FBSSxZQUFXO0FBQ2YsU0FBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxHQUFDLEdBQUdBLENBQUMsSUFBSSxJQUFJQyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNYO0FBQ0EsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDSCxDQUFDLEdBQUdHLE1BQUo7QUFDaEMsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsQ0FBakIiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"../node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-router */ \"../node_modules/vue-router/dist/vue-router.esm.js\");\n/* harmony import */ var vue_2_breadcrumbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-2-breadcrumbs */ \"../node_modules/vue-2-breadcrumbs/lib/vue-2-breadcrumbs.js\");\nvue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(vue_router__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(vue_2_breadcrumbs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);const Feeds={template:\"<div><router-view/></div>\"},Feed={template:\"<div><h2>Feed</h2></div>\"},Biz={template:\"<div><h2>Feeds</h2></div>\"},Foo={template:\"<div><h2>Foo</h2></div>\"},Bar={template:\"<div><h2>Bar</h2></div>\"},Baz={template:\"<div><h2>Baz</h2></div>\"},router=new vue_router__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({routes:[{path:\"/\",redirect:\"/feeds\"},{path:\"/feeds\",component:Feeds,meta:{breadcrumb:\"Feeds\"},children:[{path:\"\",component:Biz},{path:\"foo\",component:Foo,meta:{breadcrumb:()=>`foo ${2}`}},{path:\"bar\",component:Bar,meta:{breadcrumb:\"bar\"}},{name:\"baz\",path:\"baz\",component:Baz,meta:{breadcrumb:function(){const{name}=this.$route;return`name \"${name}\" of context $route`}}},{path:\":id\",component:Feed,meta:{breadcrumb:params=>`Other Feed ${params.id}`}}]}]});new vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({router,template:`\n        <div id=\"app\" class=\"container\">\n            <ul class=\"nav\">\n                <li class=\"nav-item  dropdown\">\n                    <router-link to=\"/feeds\" class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">Feeds</router-link>\n                    <div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n                        <router-link to=\"/feeds/foo\" class=\"dropdown-item\">Foo</router-link>\n                        <router-link to=\"/feeds/bar\" class=\"dropdown-item\">Bar</router-link>\n                        <router-link to=\"/feeds/baz\" class=\"dropdown-item\">Baz</router-link>\n                        <router-link to=\"/feeds/1\" class=\"dropdown-item\">Other Feed 1</router-link>\n                        <router-link to=\"/feeds/2\" class=\"dropdown-item\">Other Feed 2</router-link>\n                        <router-link to=\"/feeds/3\" class=\"dropdown-item\">Other Feed 3</router-link>\n                    </div>\n                </li>\n            </ul>\n            <breadcrumbs/>\n            <router-view/>\n        </div>\n    `}).$mount(\"#app\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAuanM/OWE3OCJdLCJuYW1lcyI6WyJWdWUiLCJ1c2UiLCJWdWVSb3V0ZXIiLCJWdWVCcmVhZGNydW1icyIsIkZlZWRzIiwidGVtcGxhdGUiLCJGZWVkIiwiQml6IiwiRm9vIiwiQmFyIiwiQmF6Iiwicm91dGVyIiwicm91dGVzIiwicGF0aCIsInJlZGlyZWN0IiwiY29tcG9uZW50IiwibWV0YSIsImJyZWFkY3J1bWIiLCJjaGlsZHJlbiIsIm5hbWUiLCIkcm91dGUiLCJwYXJhbXMiLCJpZCIsIiRtb3VudCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQUEsMkNBQUcsQ0FBQ0MsR0FBSixDQUFRQyxrREFBUixDLENBQ0FGLDJDQUFHLENBQUNDLEdBQUosQ0FBUUUseURBQVIsQyxNQUVNQyxNQUFLLENBQUcsQ0FBRUMsUUFBUSxDQUFFLDJCQUFaLEMsQ0FDUkMsSUFBSSxDQUFHLENBQUVELFFBQVEsQ0FBRSwwQkFBWixDLENBQ1BFLEdBQUcsQ0FBRyxDQUFFRixRQUFRLENBQUUsMkJBQVosQyxDQUNORyxHQUFHLENBQUcsQ0FBRUgsUUFBUSxDQUFFLHlCQUFaLEMsQ0FDTkksR0FBRyxDQUFHLENBQUVKLFFBQVEsQ0FBRSx5QkFBWixDLENBQ05LLEdBQUcsQ0FBRyxDQUFFTCxRQUFRLENBQUUseUJBQVosQyxDQUVOTSxNQUFNLENBQUcsR0FBSVQsbURBQUosQ0FBYyxDQUN6QlUsTUFBTSxDQUFFLENBQ0osQ0FBRUMsSUFBSSxDQUFFLEdBQVIsQ0FBYUMsUUFBUSxDQUFFLFFBQXZCLENBREksQ0FFSixDQUNJRCxJQUFJLENBQUUsUUFEVixDQUVJRSxTQUFTLENBQUVYLEtBRmYsQ0FHSVksSUFBSSxDQUFFLENBQ0ZDLFVBQVUsQ0FBRSxPQURWLENBSFYsQ0FNSUMsUUFBUSxDQUFFLENBQ04sQ0FDSUwsSUFBSSxDQUFFLEVBRFYsQ0FFSUUsU0FBUyxDQUFFUixHQUZmLENBRE0sQ0FLTixDQUNJTSxJQUFJLENBQUUsS0FEVixDQUVJRSxTQUFTLENBQUVQLEdBRmYsQ0FHSVEsSUFBSSxDQUFFLENBQ0ZDLFVBQVUsQ0FBRSxJQUFPLE9BQUQsQ0FBYSxFQUQ3QixDQUhWLENBTE0sQ0FZTixDQUNJSixJQUFJLENBQUUsS0FEVixDQUVJRSxTQUFTLENBQUVOLEdBRmYsQ0FHSU8sSUFBSSxDQUFFLENBQ0ZDLFVBQVUsQ0FBRSxLQURWLENBSFYsQ0FaTSxDQW1CTixDQUNJRSxJQUFJLENBQUUsS0FEVixDQUVJTixJQUFJLENBQUUsS0FGVixDQUdJRSxTQUFTLENBQUVMLEdBSGYsQ0FJSU0sSUFBSSxDQUFFLENBQ0ZDLFVBQVUsQ0FBRSxVQUFZLENBQ3BCLEtBQU0sQ0FBRUUsSUFBRixFQUFXLEtBQUtDLE1BQXRCLENBQ0EsTUFBUSxTQUFRRCxJQUFLLHFCQUN4QixDQUpDLENBSlYsQ0FuQk0sQ0E4Qk4sQ0FDSU4sSUFBSSxDQUFFLEtBRFYsQ0FFSUUsU0FBUyxDQUFFVCxJQUZmLENBR0lVLElBQUksQ0FBRSxDQUNGQyxVQUFVLENBQUVJLE1BQU0sRUFBSyxjQUFhQSxNQUFNLENBQUNDLEVBQUcsRUFENUMsQ0FIVixDQTlCTSxDQU5kLENBRkksQ0FEaUIsQ0FBZCxDLENBbURmLEdBQUl0Qiw0Q0FBSixDQUFRLENBQ0pXLE1BREksQ0FFSk4sUUFBUSxDQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FGUCxDQUFSLEVBcUJHa0IsTUFyQkgsQ0FxQlUsTUFyQlYsQyIsImZpbGUiOiIuL2FwcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcic7XG5pbXBvcnQgVnVlQnJlYWRjcnVtYnMgZnJvbSAndnVlLTItYnJlYWRjcnVtYnMnO1xuXG5WdWUudXNlKFZ1ZVJvdXRlcik7XG5WdWUudXNlKFZ1ZUJyZWFkY3J1bWJzKTtcblxuY29uc3QgRmVlZHMgPSB7IHRlbXBsYXRlOiAnPGRpdj48cm91dGVyLXZpZXcvPjwvZGl2PicgfTtcbmNvbnN0IEZlZWQgPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+RmVlZDwvaDI+PC9kaXY+JyB9O1xuY29uc3QgQml6ID0geyB0ZW1wbGF0ZTogJzxkaXY+PGgyPkZlZWRzPC9oMj48L2Rpdj4nIH07XG5jb25zdCBGb28gPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+Rm9vPC9oMj48L2Rpdj4nIH07XG5jb25zdCBCYXIgPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+QmFyPC9oMj48L2Rpdj4nIH07XG5jb25zdCBCYXogPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+QmF6PC9oMj48L2Rpdj4nIH07XG5cbmNvbnN0IHJvdXRlciA9IG5ldyBWdWVSb3V0ZXIoe1xuICAgIHJvdXRlczogW1xuICAgICAgICB7IHBhdGg6ICcvJywgcmVkaXJlY3Q6ICcvZmVlZHMnIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhdGg6ICcvZmVlZHMnLFxuICAgICAgICAgICAgY29tcG9uZW50OiBGZWVkcyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBicmVhZGNydW1iOiAnRmVlZHMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IEJpelxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnZm9vJyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBGb28sXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWI6ICgpID0+IGBmb28gJHsxICsgMX1gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2JhcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogQmFyLFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhZGNydW1iOiAnYmFyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXonLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnYmF6JyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBCYXosXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHRoaXMuJHJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgbmFtZSBcIiR7bmFtZX1cIiBvZiBjb250ZXh0ICRyb3V0ZWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJzppZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogRmVlZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWRjcnVtYjogcGFyYW1zID0+IGBPdGhlciBGZWVkICR7cGFyYW1zLmlkfWBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF1cbn0pO1xuXG5uZXcgVnVlKHtcbiAgICByb3V0ZXIsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBpZD1cImFwcFwiIGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJuYXZcIj5cbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSAgZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL2ZlZWRzXCIgY2xhc3M9XCJuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiBocmVmPVwiI1wiIGlkPVwibmF2YmFyRHJvcGRvd25cIiByb2xlPVwiYnV0dG9uXCIgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+RmVlZHM8L3JvdXRlci1saW5rPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIGFyaWEtbGFiZWxsZWRieT1cIm5hdmJhckRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvZmVlZHMvZm9vXCIgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCI+Rm9vPC9yb3V0ZXItbGluaz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9mZWVkcy9iYXJcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIj5CYXI8L3JvdXRlci1saW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL2ZlZWRzL2JhelwiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPkJhejwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvZmVlZHMvMVwiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPk90aGVyIEZlZWQgMTwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvZmVlZHMvMlwiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPk90aGVyIEZlZWQgMjwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvZmVlZHMvM1wiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPk90aGVyIEZlZWQgMzwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPGJyZWFkY3J1bWJzLz5cbiAgICAgICAgICAgIDxyb3V0ZXItdmlldy8+XG4gICAgICAgIDwvZGl2PlxuICAgIGBcbn0pLiRtb3VudCgnI2FwcCcpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app.js\n");

/***/ })

/******/ });