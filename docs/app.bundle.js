/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports !== "undefined") {
		factory(exports);
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports);
		global.index = mod.exports;
	}
})(this, function (exports) {
	"use strict";

	(function (global, factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports !== "undefined") {
			factory(exports);
		} else {
			var mod = {
				exports: {}
			};
			factory(mod.exports);
			global.index = mod.exports;
		}
	})(undefined, function (exports) {
		'use strict';

		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = {
			install(Vue) {
				Object.defineProperties(Vue.prototype, {
					$breadcrumbs: {
						get() {
							return this.$route.matched;
						}
					}
				});

				Vue.component('breadcrumbs', {
					template: `
					<ol class="breadcrumb" v-if="$breadcrumbs.length">
						<li class="breadcrumb-item" v-if="crumb.meta.breadcrumb" v-for="(crumb, index) in $breadcrumbs">
							<router-link v-bind:to="{ path: crumb.path }" :tag="index != $breadcrumbs.length - 1 ? 'a' : 'span'">{{ crumb.meta.breadcrumb }}</router-link>
						</li>
					</ol>
				`
				});
			}
		};
	});
});

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", expecting an object, function or boolean.");
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery) {
  if (extraQuery === void 0) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery;
  } else {
    return extraQuery;
  }
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom) {
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  return (path || '/') + stringifyQuery(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact ? isSameRoute(current, compareTarget) : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  if (relative.charAt(0) === '/') {
    return relative;
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue;
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

/*  */

function createRouteMap(routes, oldPathMap, oldNameMap) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex(path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp };
}

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function normalizeLocation(raw, current, append) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : current && current.path || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = getRouteRegex(record.path).keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(path, params, pathname) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function () {
    onAbort && onAbort();
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || typeof to === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        typeof to === 'object' && to.replace ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () {
      return this$1.current === route;
    };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            return cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  return function boundRouteGuard() {
    return guard.apply(instance, arguments);
  };
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, "Failed to resolve async component " + key + ": " + reason);
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      };
    }
  });
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady(cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
 * Vue.js v2.2.5
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function () {
  return false;
};

/**
 * Return same value
 */
var identity = function (_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  };
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: ['component', 'directive', 'filter'],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return (/native code/.test(Ctor.toString())
  );
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) {
      console.error(err);
    };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        cb.call(ctx);
      }
      if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var formatLocation = function (str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return "\n(found in " + str + ")";
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$3) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = typeof value === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = typeof value === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = typeof value === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = typeof value === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1];
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn("Error in " + info + ":", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function () {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.componentOptions;
  })[0];
}

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // reset scheduler before updated hook called
  var oldQueue = queue.slice();
  resetSchedulerState();

  // call updated hooks
  index = oldQueue.length;
  while (index--) {
    watcher = oldQueue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);
  observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy(vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (!Ctor) {
    return;
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return;
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor, tag);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function () {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function resolveAsyncComponent(factory, baseCtor, cb) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function (res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function (reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved;
  }
}

function extractProps(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the delared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    var loop = function (i) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            defineReactive$$1(vm, key, source._provided[provideKey], function () {
              warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
            });
          } else {
            defineReactive$$1(vm, key, source._provided[provideKey]);
          }
          break;
        }
        source = source.$parent;
      }
    };

    for (var i = 0; i < keys.length; i++) loop(i);
  }
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern instanceof RegExp) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Vue$3.version = '2.2.5';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (parentNode = parentNode.parent) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  var res = '';
  if (!value) {
    return res;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if (stringified = stringifyClass(value[i])) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function sameVnode(a, b) {
  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important) {
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "var $$exp = " + modelRs.exp + ", $$idx = " + modelRs.idx + ";" + "if (!Array.isArray($$exp)){" + value + "=" + assignment + "}" + "else{$$exp.splice($$idx, 1, " + assignment + ")}";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + value + "=$$c}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number || type === 'number') {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, handler, once, capture) {
  if (once) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, handler, capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (modifiers && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return;
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm();
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (!fn) {
    return false;
  }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  return (/\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null
  );
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function () {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\">";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var decoder;

function decode(html) {
  decoder = decoder || document.createElement('div');
  decoder.innerHTML = html;
  return decoder.textContent;
}

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
// attr value double quotes
/"([^"]*)"+/.source,
// attr value, single quotes
/'([^']*)'+/.source,
// attr value, no quotes
/([^\s"'=<>`]+)/.source];
var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          continue;
        }
      }

      var text = void 0,
          rest$1 = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest$1 = html.slice(textEnd);
        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {
          // < in plain text, be forgiving and treat it as text
          next = rest$1.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest$1 = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var endTagLength = 0;
      var rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest.length;
      html = rest;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformGetTagNamespace = options.getTagNamespace || no;
  platformMustUseProp = options.mustUseProp || no;
  platformIsPreTag = options.isPreTag || no;
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
        }
        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      walkThroughConditionsBlocks(node.ifConditions, isInFor);
    }
  }
}

function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
    markStaticRoots(conditionBlocks[i].block, isInFor);
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, native) {
  var res = native ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  bind: bind$1,
  cloak: noop
};

/*  */

// configurable state
var warn$3;
var transforms$1;
var dataGenFns;
var platformDirectives$1;
var isPlatformReservedTag$1;
var staticRenderFns;
var onceCount;
var currentOptions;

function generate(ast, options) {
  // save previous staticRenderFns so generate calls can be nested
  var prevStaticRenderFns = staticRenderFns;
  var currentStaticRenderFns = staticRenderFns = [];
  var prevOnceCount = onceCount;
  onceCount = 0;
  currentOptions = options;
  warn$3 = options.warn || baseWarn;
  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
  dataGenFns = pluckModuleFunction(options.modules, 'genData');
  platformDirectives$1 = options.directives || {};
  isPlatformReservedTag$1 = options.isReservedTag || no;
  var code = ast ? genElement(ast) : '_c("div")';
  staticRenderFns = prevStaticRenderFns;
  onceCount = prevOnceCount;
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: currentStaticRenderFns
  };
}

function genElement(el) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el);
  } else if (el.for && !el.forProcessed) {
    return genFor(el);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el);
    } else {
      var data = el.plain ? undefined : genData(el);

      var children = el.inlineTemplate ? null : genChildren(el, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < transforms$1.length; i++) {
      code = transforms$1[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el) {
  el.staticProcessed = true;
  staticRenderFns.push("with(this){return " + genElement(el) + "}");
  return "_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && warn$3("v-once can only be used inside v-for that is keyed. ");
      return genElement(el);
    }
    return "_o(" + genElement(el) + "," + onceCount++ + (key ? "," + key : "") + ")";
  } else {
    return genStatic(el);
  }
}

function genIf(el) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice());
}

function genIfConditions(conditions) {
  if (!conditions.length) {
    return '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return el.once ? genOnce(el) : genElement(el);
  }
}

function genFor(el) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    warn$3("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genElement(el) + '})';
}

function genData(el) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < dataGenFns.length; i++) {
    data += dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  return data;
}

function genDirectives(el) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, warn$3);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
    warn$3('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, currentOptions);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key]);
  }).join(',') + "])";
}

function genScopedSlot(key, el) {
  return "[" + key + ",function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + "}]";
}

function genChildren(el, checkSkip) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return genElement(el$1);
    }
    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
    return "[" + children.map(genNode).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function maybeComponent(el) {
  return !isPlatformReservedTag$1(el.tag);
}

function genNode(node) {
  if (node.type === 1) {
    return genElement(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genSlot(el) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el) {
  var children = el.inlineTemplate ? null : genChildren(el, true);
  return "_c(" + componentName + "," + genData(el) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
  if (keywordMatch) {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

function makeFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompiler(baseOptions) {
  var functionCompileCache = Object.create(null);

  function compile(template, options) {
    var finalOptions = Object.create(baseOptions);
    var errors = [];
    var tips = [];
    finalOptions.warn = function (msg, tip$$1) {
      (tip$$1 ? tips : errors).push(msg);
    };

    if (options) {
      // merge custom modules
      if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
      }
      // copy other options
      for (var key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key];
        }
      }
    }

    var compiled = baseCompile(template, finalOptions);
    if (process.env.NODE_ENV !== 'production') {
      errors.push.apply(errors, detectErrors(compiled.ast));
    }
    compiled.errors = errors;
    compiled.tips = tips;
    return compiled;
  }

  function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (functionCompileCache[key]) {
      return functionCompileCache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = makeFunction(compiled.render, fnGenErrors);
    var l = compiled.staticRenderFns.length;
    res.staticRenderFns = new Array(l);
    for (var i = 0; i < l; i++) {
      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
    }

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return functionCompileCache[key] = res;
  }

  return {
    compile: compile,
    compileToFunctions: compileToFunctions
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData$1
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$2(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$2
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

/* harmony default export */ __webpack_exports__["default"] = (Vue$3);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(5)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(7)(
  /* script */
  null,
  /* template */
  __webpack_require__(8),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "D:\\sand-box\\git\\vue-r\\src\\home.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] home.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1fa66eb8", Component.options)
  } else {
    hotAPI.reload("data-v-1fa66eb8", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(3);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(2);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _home = __webpack_require__(4);

var _home2 = _interopRequireDefault(_home);

var _vue2Breadcrumbs = __webpack_require__(1);

var _vue2Breadcrumbs2 = _interopRequireDefault(_vue2Breadcrumbs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);
_vue2.default.use(_vue2Breadcrumbs2.default);

const Feeds = { template: '<div><router-view/></div>' };
const Biz = { template: '<div><h2>Biz</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };
const Foo = { template: '<div><h2>Foo</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };
const Bar = { template: '<div><h2>Bar</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };

const router = new _vueRouter2.default({
	routes: [{ path: '/', redirect: '/feeds' }, {
		path: '/feeds',
		component: Feeds,
		meta: {
			breadcrumb: 'Feeds'
		},
		children: [{
			path: '',
			component: Biz
		}, {
			path: 'foo',
			component: Foo,
			meta: {
				breadcrumb: 'foo'
			}
		}, {
			path: 'bar',
			component: Bar,
			meta: {
				breadcrumb: 'bar'
			}
		}]
	}]
});

new _vue2.default({
	router,
	components: {
		Home: _home2.default
	},
	template: `
		<div id="app" class="container">
			<ul class="nav">
				<li class="nav-item  dropdown">
					<router-link to="/feeds" class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Feeds</router-link>
					<div class="dropdown-menu">
				<router-link to="/feeds/foo" class="dropdown-item">Foo</router-link>
				<router-link to="/feeds/bar" class="dropdown-item">Bar</router-link>
					</div>
				</li>
			</ul>
			<breadcrumbs/>
			<router-view/>
			<hr>
			<Home/>
		</div>
	`
}).$mount('#app');

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('h3', [_vm._v("Home component")]), _vm._v(" "), _c('p', [_vm._v("Lorem ipsum dolor sit amet, consectetur adipisicing elit. Veniam molestias aperiam odit sit harum quam, laborum magnam. Veritatis itaque temporibus vitae beatae quam eaque voluptatem alias enim? Maxime, itaque. Eveniet.")])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-1fa66eb8", module.exports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTg5ZTAwYjllOTFkNWQ5MDQyOTEiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3Z1ZS0yLWJyZWFkY3J1bWJzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ob21lLnZ1ZSIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9ob21lLnZ1ZT9jZTZmIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJiaW5kaW5nIiwibmFtZSIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJnbG9iYWwiLCJmYWN0b3J5IiwiZGVmaW5lIiwibW9kIiwiaW5kZXgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVmYXVsdCIsImluc3RhbGwiLCJWdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiJGJyZWFkY3J1bWJzIiwiZ2V0IiwiJHJvdXRlIiwibWF0Y2hlZCIsImNvbXBvbmVudCIsInRlbXBsYXRlIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIndhcm4iLCJjb25zb2xlIiwiVmlldyIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJyZW5kZXIiLCJoIiwicmVmIiwiY2hpbGRyZW4iLCJwYXJlbnQiLCJkYXRhIiwicm91dGVyVmlldyIsInJvdXRlIiwiY2FjaGUiLCJfcm91dGVyVmlld0NhY2hlIiwiZGVwdGgiLCJpbmFjdGl2ZSIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJjb21wb25lbnRzIiwiaG9va3MiLCJob29rIiwiaW5pdCIsInZub2RlIiwiaW5zdGFuY2VzIiwiY2hpbGQiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiZGVzdHJveSIsInVuZGVmaW5lZCIsInJlc29sdmVQcm9wcyIsImNvbmZpZyIsInBhcmFtcyIsInBhdGgiLCJlbmNvZGVSZXNlcnZlUkUiLCJlbmNvZGVSZXNlcnZlUmVwbGFjZXIiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJwYXJzZWRRdWVyeSIsInBhcnNlUXVlcnkiLCJOT0RFX0VOViIsImtleSIsInJlcyIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJ2YWwiLCJqb2luIiwiaXNBcnJheSIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwia2V5cyIsIm1hcCIsInJlc3VsdCIsInNsaWNlIiwidmFsMiIsImZpbHRlciIsIngiLCJ0cmFpbGluZ1NsYXNoUkUiLCJjcmVhdGVSb3V0ZSIsInJlY29yZCIsImxvY2F0aW9uIiwicmVkaXJlY3RlZEZyb20iLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsIlNUQVJUIiwidW5zaGlmdCIsImlzU2FtZVJvdXRlIiwiYSIsImIiLCJpc09iamVjdEVxdWFsIiwiYUtleXMiLCJiS2V5cyIsImV2ZXJ5IiwiaXNJbmNsdWRlZFJvdXRlIiwiY3VycmVudCIsInRhcmdldCIsImluZGV4T2YiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwidG8iLCJyZXF1aXJlZCIsInRhZyIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsImFjdGl2ZUNsYXNzIiwiZXZlbnQiLCJ0aGlzJDEiLCJyb3V0ZXIiLCIkcm91dGVyIiwicmVzb2x2ZSIsImhyZWYiLCJjbGFzc2VzIiwib3B0aW9ucyIsImxpbmtBY3RpdmVDbGFzcyIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsImNsaWNrIiwiY2xhc3MiLCJhdHRycyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsImV4dGVuZCIsIl9WdWUiLCJ1dGlsIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImdldEF0dHJpYnV0ZSIsInRlc3QiLCJwcmV2ZW50RGVmYXVsdCIsImluc3RhbGxlZCIsIiRyb290IiwiX3JvdXRlciIsIl9yb3V0ZSIsIm1peGluIiwiYmVmb3JlQ3JlYXRlIiwiJG9wdGlvbnMiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImNyZWF0ZWQiLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJyZXNvbHZlUGF0aCIsInJlbGF0aXZlIiwiYmFzZSIsImNoYXJBdCIsInN0YWNrIiwicG9wIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyc2VQYXRoIiwiaGFzaEluZGV4IiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImNyZWF0ZVJvdXRlTWFwIiwicm91dGVzIiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTWFwIiwiY3JlYXRlIiwibmFtZU1hcCIsImFkZFJvdXRlUmVjb3JkIiwibWF0Y2hBcyIsIm5vcm1hbGl6ZVBhdGgiLCJyZWRpcmVjdCIsImJlZm9yZUVudGVyIiwic29tZSIsImNoaWxkTWF0Y2hBcyIsImFsaWFzIiwiYWxpYXNSb3V0ZSIsImluZGV4JDEiLCJhcnIiLCJpc2FycmF5IiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsInBhcnNlIiwiY29tcGlsZV8xIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb25fMSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cF8xIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsIlJlZ0V4cCIsInRva2VucyIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJleGVjIiwibSIsImVzY2FwZWQiLCJvZmZzZXQiLCJuZXh0IiwicHJlZml4IiwiY2FwdHVyZSIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsInN1YnN0ciIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInRvVXBwZXJDYXNlIiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsInByZXR0eSIsInRva2VuIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENhY2hlIiwiZ2V0Um91dGVSZWdleCIsImhpdCIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsInBhcmFtTmFtZXMiLCJfY3JlYXRlUm91dGUiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsImhhc093blByb3BlcnR5IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwYXRobmFtZSIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiZnJvbSIsImlzUG9wIiwiYXBwIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsIiRuZXh0VGljayIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJpc09iamVjdCIsInNlbGVjdG9yIiwiZWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJpc1ZhbGlkUG9zaXRpb24iLCJub3JtYWxpemVQb3NpdGlvbiIsInNjcm9sbFRvIiwieSIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc051bWJlciIsInYiLCJzdXBwb3J0c1B1c2hTdGF0ZSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIl9rZXkiLCJnZW5LZXkiLCJ0b0ZpeGVkIiwicHVzaFN0YXRlIiwidXJsIiwicmVwbGFjZVN0YXRlIiwicnVuUXVldWUiLCJmbiIsImNiIiwic3RlcCIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicGVuZGluZyIsInJlYWR5IiwicmVhZHlDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwibWF4IiwiTWF0aCIsImV4dHJhY3RHdWFyZHMiLCJyZWNvcmRzIiwiYmluZCIsInJldmVyc2UiLCJndWFyZHMiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJmbGF0dGVuIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiXyIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsInJlc29sdmVkRGVmIiwicmVqZWN0IiwicmVhc29uIiwidGhlbiIsImNhbGxlZCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJnZXRMb2NhdGlvbiIsIl9fcHJvdG9fXyIsImNvbnN0cnVjdG9yIiwiZ28iLCJuIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwic2VhcmNoIiwiSGFzaEhpc3RvcnkiLCJmYWxsYmFjayIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwicmVzb2x2ZWQiLCJ1c2UiLCJfdG9TdHJpbmciLCJ0b051bWJlciIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwicmVtb3ZlIiwiaXRlbSIsInNwbGljZSIsImhhc093biIsImlzUHJpbWl0aXZlIiwiY2FjaGVkIiwiY2FjaGVkRm4iLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjYXBpdGFsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJjdHgiLCJib3VuZEZuIiwibCIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJfZnJvbSIsIk9CSkVDVF9TVFJJTkciLCJpc1BsYWluT2JqZWN0IiwidG9PYmplY3QiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJzdGF0aWNLZXlzIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImxvb3NlSW5kZXhPZiIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2Fzc2V0VHlwZXMiLCJfbGlmZWN5Y2xlSG9va3MiLCJfbWF4VXBkYXRlQ291bnQiLCJlbXB0eU9iamVjdCIsImlzUmVzZXJ2ZWQiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJoYXNQcm90byIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsImNhbGxiYWNrcyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsIlByb21pc2UiLCJwIiwibG9nRXJyb3IiLCJlcnIiLCJlcnJvciIsImNhdGNoIiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInF1ZXVlTmV4dFRpY2siLCJfcmVzb2x2ZSIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJmb3JtYXRMb2NhdGlvbiIsImluY2x1ZGVGaWxlIiwiX2lzVnVlIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJ1aWQkMSIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJ0b1ZhbCIsImZyb21WYWwiLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJtZXJnZUFzc2V0cyIsIndhdGNoIiwibWV0aG9kcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIlZ1ZSQzIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsImhhbmRsZUVycm9yIiwiaW5mbyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJjb21wb25lbnRJbnN0YW5jZSIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsIm5lc3RlZEluZGV4IiwibGFzdCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwidXNlciIsImV4cHJlc3Npb24iLCJvbGRRdWV1ZSIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5Iiwic3luYyIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJpbnNlcnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJleHRyYWN0UHJvcHMiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwiX2NvbnRleHQiLCJkIiwiY3JlYXRlRWxlbWVudCIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwicmVxdWVzdGVkIiwicGVuZGluZ0NhbGxiYWNrcyIsImRvbVByb3BzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsImZyb21QYXJlbnQiLCJvdXJzIiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJ0cmVlIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZW5kZXJNaXhpbiIsInJlbmRlckVycm9yIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwiaW5qZWN0IiwicHJvdmlkZUtleSIsInVpZCIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiaW5pdFVzZSIsInBsdWdpbiIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJwYXR0ZXJuVHlwZXMiLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsImRlbGV0ZSIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsImdlbkNsYXNzRnJvbURhdGEiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsInNlbGVjdGVkIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaW5QcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJzdWJzdHJpbmciLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImR5bmFtaWNUeXBlIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplIiwicHJlZml4ZXMiLCJ0ZXN0RWwiLCJ1cHBlciIsInByZWZpeGVkIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiTnVtYmVyIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJtb2RlbCQxIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJnZXRWYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwiY29tcCIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJiZWZvcmVVcGRhdGUiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImR5IiwicGxhdGZvcm1Db21wb25lbnRzIiwic2hvdWxkRGVjb2RlIiwiY29udGVudCIsImVuY29kZWQiLCJkaXYiLCJpbm5lckhUTUwiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImRlY29kZXIiLCJodG1sIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImRlY29kZUF0dHIiLCJwYXJzZUhUTUwiLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCQxIiwiY2hhcnMiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiZW5kVGFnTGVuZ3RoIiwicmVzdCIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwibGFzdEluZGV4Iiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluVlByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZWxlbWVudCIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290Iiwid2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIiwiY29uZGl0aW9uQmxvY2tzIiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsInJpZ2h0IiwiZG93biIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInByZXZlbnQiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJ3YXJuJDMiLCJ0cmFuc2Zvcm1zJDEiLCJkYXRhR2VuRm5zIiwicGxhdGZvcm1EaXJlY3RpdmVzJDEiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSIsIm9uY2VDb3VudCIsImN1cnJlbnRPcHRpb25zIiwiZ2VuZXJhdGUiLCJhc3QiLCJwcmV2U3RhdGljUmVuZGVyRm5zIiwiY3VycmVudFN0YXRpY1JlbmRlckZucyIsInByZXZPbmNlQ291bnQiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwibWF5YmVDb21wb25lbnQiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiZ2VuU2NvcGVkU2xvdCIsInNjb3BlIiwiY2hlY2tTa2lwIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwiaWRlbnRSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIkZ1bmN0aW9uIiwiYmFzZUNvbXBpbGUiLCJtYWtlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlciIsImJhc2VPcHRpb25zIiwiZnVuY3Rpb25Db21waWxlQ2FjaGUiLCJmaW5hbE9wdGlvbnMiLCJ0aXBzIiwidGlwJCQxIiwiY29tcGlsZWQiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJmbkdlbkVycm9ycyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhJDEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQyIiwic3R5bGUkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsInJlZiQxIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJldmFsIiwiRmVlZHMiLCJCaXoiLCJGb28iLCJCYXIiLCJicmVhZGNydW1iIiwiSG9tZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQSxJQUFJQSxVQUFVQyxPQUFPQyxPQUFQLEdBQWlCLEVBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsVUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsU0FBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsVUFBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIO0FBQ0EsYUFBWTtBQUNULFFBQUk7QUFDQSxZQUFJLE9BQU9FLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDbENMLCtCQUFtQkssVUFBbkI7QUFDSCxTQUZELE1BRU87QUFDSEwsK0JBQW1CRSxnQkFBbkI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPSSxDQUFQLEVBQVU7QUFDUk4sMkJBQW1CRSxnQkFBbkI7QUFDSDtBQUNELFFBQUk7QUFDQSxZQUFJLE9BQU9LLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDcENOLGlDQUFxQk0sWUFBckI7QUFDSCxTQUZELE1BRU87QUFDSE4saUNBQXFCRyxtQkFBckI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPRSxDQUFQLEVBQVU7QUFDUkwsNkJBQXFCRyxtQkFBckI7QUFDSDtBQUNKLENBbkJBLEdBQUQ7QUFvQkEsU0FBU0ksVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDckIsUUFBSVQscUJBQXFCSyxVQUF6QixFQUFxQztBQUNqQztBQUNBLGVBQU9BLFdBQVdJLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNULHFCQUFxQkUsZ0JBQXJCLElBQXlDLENBQUNGLGdCQUEzQyxLQUFnRUssVUFBcEUsRUFBZ0Y7QUFDNUVMLDJCQUFtQkssVUFBbkI7QUFDQSxlQUFPQSxXQUFXSSxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9ULGlCQUFpQlMsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFNSCxDQUFOLEVBQVE7QUFDTixZQUFJO0FBQ0E7QUFDQSxtQkFBT04saUJBQWlCVSxJQUFqQixDQUFzQixJQUF0QixFQUE0QkQsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNILFNBSEQsQ0FHRSxPQUFNSCxDQUFOLEVBQVE7QUFDTjtBQUNBLG1CQUFPTixpQkFBaUJVLElBQWpCLENBQXNCLElBQXRCLEVBQTRCRCxHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0g7QUFDSjtBQUdKO0FBQ0QsU0FBU0UsZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDN0IsUUFBSVgsdUJBQXVCTSxZQUEzQixFQUF5QztBQUNyQztBQUNBLGVBQU9BLGFBQWFLLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNYLHVCQUF1QkcsbUJBQXZCLElBQThDLENBQUNILGtCQUFoRCxLQUF1RU0sWUFBM0UsRUFBeUY7QUFDckZOLDZCQUFxQk0sWUFBckI7QUFDQSxlQUFPQSxhQUFhSyxNQUFiLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9YLG1CQUFtQlcsTUFBbkIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFPTixDQUFQLEVBQVM7QUFDUCxZQUFJO0FBQ0E7QUFDQSxtQkFBT0wsbUJBQW1CUyxJQUFuQixDQUF3QixJQUF4QixFQUE4QkUsTUFBOUIsQ0FBUDtBQUNILFNBSEQsQ0FHRSxPQUFPTixDQUFQLEVBQVM7QUFDUDtBQUNBO0FBQ0EsbUJBQU9MLG1CQUFtQlMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSDtBQUNKO0FBSUo7QUFDRCxJQUFJQyxRQUFRLEVBQVo7QUFDQSxJQUFJQyxXQUFXLEtBQWY7QUFDQSxJQUFJQyxZQUFKO0FBQ0EsSUFBSUMsYUFBYSxDQUFDLENBQWxCOztBQUVBLFNBQVNDLGVBQVQsR0FBMkI7QUFDdkIsUUFBSSxDQUFDSCxRQUFELElBQWEsQ0FBQ0MsWUFBbEIsRUFBZ0M7QUFDNUI7QUFDSDtBQUNERCxlQUFXLEtBQVg7QUFDQSxRQUFJQyxhQUFhRyxNQUFqQixFQUF5QjtBQUNyQkwsZ0JBQVFFLGFBQWFJLE1BQWIsQ0FBb0JOLEtBQXBCLENBQVI7QUFDSCxLQUZELE1BRU87QUFDSEcscUJBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDRCxRQUFJSCxNQUFNSyxNQUFWLEVBQWtCO0FBQ2RFO0FBQ0g7QUFDSjs7QUFFRCxTQUFTQSxVQUFULEdBQXNCO0FBQ2xCLFFBQUlOLFFBQUosRUFBYztBQUNWO0FBQ0g7QUFDRCxRQUFJTyxVQUFVYixXQUFXUyxlQUFYLENBQWQ7QUFDQUgsZUFBVyxJQUFYOztBQUVBLFFBQUlRLE1BQU1ULE1BQU1LLE1BQWhCO0FBQ0EsV0FBTUksR0FBTixFQUFXO0FBQ1BQLHVCQUFlRixLQUFmO0FBQ0FBLGdCQUFRLEVBQVI7QUFDQSxlQUFPLEVBQUVHLFVBQUYsR0FBZU0sR0FBdEIsRUFBMkI7QUFDdkIsZ0JBQUlQLFlBQUosRUFBa0I7QUFDZEEsNkJBQWFDLFVBQWIsRUFBeUJPLEdBQXpCO0FBQ0g7QUFDSjtBQUNEUCxxQkFBYSxDQUFDLENBQWQ7QUFDQU0sY0FBTVQsTUFBTUssTUFBWjtBQUNIO0FBQ0RILG1CQUFlLElBQWY7QUFDQUQsZUFBVyxLQUFYO0FBQ0FILG9CQUFnQlUsT0FBaEI7QUFDSDs7QUFFRHhCLFFBQVEyQixRQUFSLEdBQW1CLFVBQVVmLEdBQVYsRUFBZTtBQUM5QixRQUFJZ0IsT0FBTyxJQUFJQyxLQUFKLENBQVVDLFVBQVVULE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLFFBQUlTLFVBQVVULE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsYUFBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUN2Q0gsaUJBQUtHLElBQUksQ0FBVCxJQUFjRCxVQUFVQyxDQUFWLENBQWQ7QUFDSDtBQUNKO0FBQ0RmLFVBQU1nQixJQUFOLENBQVcsSUFBSUMsSUFBSixDQUFTckIsR0FBVCxFQUFjZ0IsSUFBZCxDQUFYO0FBQ0EsUUFBSVosTUFBTUssTUFBTixLQUFpQixDQUFqQixJQUFzQixDQUFDSixRQUEzQixFQUFxQztBQUNqQ04sbUJBQVdZLFVBQVg7QUFDSDtBQUNKLENBWEQ7O0FBYUE7QUFDQSxTQUFTVSxJQUFULENBQWNyQixHQUFkLEVBQW1Cc0IsS0FBbkIsRUFBMEI7QUFDdEIsU0FBS3RCLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtzQixLQUFMLEdBQWFBLEtBQWI7QUFDSDtBQUNERCxLQUFLRSxTQUFMLENBQWVULEdBQWYsR0FBcUIsWUFBWTtBQUM3QixTQUFLZCxHQUFMLENBQVN3QixLQUFULENBQWUsSUFBZixFQUFxQixLQUFLRixLQUExQjtBQUNILENBRkQ7QUFHQWxDLFFBQVFxQyxLQUFSLEdBQWdCLFNBQWhCO0FBQ0FyQyxRQUFRc0MsT0FBUixHQUFrQixJQUFsQjtBQUNBdEMsUUFBUXVDLEdBQVIsR0FBYyxFQUFkO0FBQ0F2QyxRQUFRd0MsSUFBUixHQUFlLEVBQWY7QUFDQXhDLFFBQVF5QyxPQUFSLEdBQWtCLEVBQWxCLEMsQ0FBc0I7QUFDdEJ6QyxRQUFRMEMsUUFBUixHQUFtQixFQUFuQjs7QUFFQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCM0MsUUFBUTRDLEVBQVIsR0FBYUQsSUFBYjtBQUNBM0MsUUFBUTZDLFdBQVIsR0FBc0JGLElBQXRCO0FBQ0EzQyxRQUFROEMsSUFBUixHQUFlSCxJQUFmO0FBQ0EzQyxRQUFRK0MsR0FBUixHQUFjSixJQUFkO0FBQ0EzQyxRQUFRZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLFFBQVFpRCxrQkFBUixHQUE2Qk4sSUFBN0I7QUFDQTNDLFFBQVFrRCxJQUFSLEdBQWVQLElBQWY7O0FBRUEzQyxRQUFRbUQsT0FBUixHQUFrQixVQUFVQyxJQUFWLEVBQWdCO0FBQzlCLFVBQU0sSUFBSTlDLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sUUFBUXFELEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQXJELFFBQVFzRCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlqRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQU4sUUFBUXdELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25MQSxFQUFDLFVBQVVDLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLE1BQUksSUFBSixFQUFnRDtBQUMvQ0MsR0FBQSxpQ0FBTyxDQUFDLE9BQUQsQ0FBUCxvQ0FBb0JELE9BQXBCO0FBQUE7QUFBQTtBQUFBO0FBQ0EsR0FGRCxNQUVPLElBQUksT0FBT3hELE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDMUN3RCxXQUFReEQsT0FBUjtBQUNBLEdBRk0sTUFFQTtBQUNOLE9BQUkwRCxNQUFNO0FBQ1QxRCxhQUFTO0FBREEsSUFBVjtBQUdBd0QsV0FBUUUsSUFBSTFELE9BQVo7QUFDQXVELFVBQU9JLEtBQVAsR0FBZUQsSUFBSTFELE9BQW5CO0FBQ0E7QUFDRCxFQVpELGFBWVMsVUFBVUEsT0FBVixFQUFtQjtBQUMzQjs7QUFFQTRELFNBQU9DLGNBQVAsQ0FBc0I3RCxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUM1QzhELFVBQU87QUFEcUMsR0FBN0M7QUFHQTlELFVBQVErRCxPQUFSLEdBQWtCO0FBQ2pCQyxXQUFRQyxHQUFSLEVBQWE7QUFDWkwsV0FBT00sZ0JBQVAsQ0FBd0JELElBQUloQyxTQUE1QixFQUF1QztBQUN0Q2tDLG1CQUFjO0FBQ2JDLFlBQU07QUFDTCxjQUFPLEtBQUtDLE1BQUwsQ0FBWUMsT0FBbkI7QUFDQTtBQUhZO0FBRHdCLEtBQXZDOztBQVFBTCxRQUFJTSxTQUFKLENBQWMsYUFBZCxFQUE2QjtBQUM1QkMsZUFBVzs7Ozs7OztBQURpQixLQUE3QjtBQVNBO0FBbkJnQixHQUFsQjtBQXFCQSxFQXZDRDs7Ozs7Ozs7K0NDQUE7QUFBQTs7Ozs7QUFLQTs7QUFFQSxTQUFTQyxNQUFULENBQWlCQyxTQUFqQixFQUE0QkMsT0FBNUIsRUFBcUM7QUFDbkMsTUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2QsVUFBTSxJQUFJdEUsS0FBSixDQUFXLGtCQUFrQnVFLE9BQTdCLENBQU47QUFDRDtBQUNGOztBQUVELFNBQVNDLElBQVQsQ0FBZUYsU0FBZixFQUEwQkMsT0FBMUIsRUFBbUM7QUFDakMsTUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2QsV0FBT0csT0FBUCxLQUFtQixXQUFuQixJQUFrQ0EsUUFBUUQsSUFBUixDQUFjLGtCQUFrQkQsT0FBaEMsQ0FBbEM7QUFDRDtBQUNGOztBQUVELElBQUlHLE9BQU87QUFDVDVCLFFBQU0sYUFERztBQUVUNkIsY0FBWSxJQUZIO0FBR1RDLFNBQU87QUFDTDlCLFVBQU07QUFDSitCLFlBQU1DLE1BREY7QUFFSm5CLGVBQVM7QUFGTDtBQURELEdBSEU7QUFTVG9CLFVBQVEsU0FBU0EsTUFBVCxDQUFpQkMsQ0FBakIsRUFBb0JDLEdBQXBCLEVBQXlCO0FBQy9CLFFBQUlMLFFBQVFLLElBQUlMLEtBQWhCO0FBQ0EsUUFBSU0sV0FBV0QsSUFBSUMsUUFBbkI7QUFDQSxRQUFJQyxTQUFTRixJQUFJRSxNQUFqQjtBQUNBLFFBQUlDLE9BQU9ILElBQUlHLElBQWY7O0FBRUFBLFNBQUtDLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsUUFBSXZDLE9BQU84QixNQUFNOUIsSUFBakI7QUFDQSxRQUFJd0MsUUFBUUgsT0FBT2xCLE1BQW5CO0FBQ0EsUUFBSXNCLFFBQVFKLE9BQU9LLGdCQUFQLEtBQTRCTCxPQUFPSyxnQkFBUCxHQUEwQixFQUF0RCxDQUFaOztBQUVBO0FBQ0E7QUFDQSxRQUFJQyxRQUFRLENBQVo7QUFDQSxRQUFJQyxXQUFXLEtBQWY7QUFDQSxXQUFPUCxNQUFQLEVBQWU7QUFDYixVQUFJQSxPQUFPUSxNQUFQLElBQWlCUixPQUFPUSxNQUFQLENBQWNQLElBQWQsQ0FBbUJDLFVBQXhDLEVBQW9EO0FBQ2xESTtBQUNEO0FBQ0QsVUFBSU4sT0FBT1MsU0FBWCxFQUFzQjtBQUNwQkYsbUJBQVcsSUFBWDtBQUNEO0FBQ0RQLGVBQVNBLE9BQU9VLE9BQWhCO0FBQ0Q7QUFDRFQsU0FBS1UsZUFBTCxHQUF1QkwsS0FBdkI7O0FBRUE7QUFDQSxRQUFJQyxRQUFKLEVBQWM7QUFDWixhQUFPVixFQUFFTyxNQUFNekMsSUFBTixDQUFGLEVBQWVzQyxJQUFmLEVBQXFCRixRQUFyQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSWhCLFVBQVVvQixNQUFNcEIsT0FBTixDQUFjdUIsS0FBZCxDQUFkO0FBQ0E7QUFDQSxRQUFJLENBQUN2QixPQUFMLEVBQWM7QUFDWnFCLFlBQU16QyxJQUFOLElBQWMsSUFBZDtBQUNBLGFBQU9rQyxHQUFQO0FBQ0Q7O0FBRUQsUUFBSWIsWUFBWW9CLE1BQU16QyxJQUFOLElBQWNvQixRQUFRNkIsVUFBUixDQUFtQmpELElBQW5CLENBQTlCOztBQUVBO0FBQ0EsUUFBSWtELFFBQVFaLEtBQUthLElBQUwsS0FBY2IsS0FBS2EsSUFBTCxHQUFZLEVBQTFCLENBQVo7QUFDQUQsVUFBTUUsSUFBTixHQUFhLFVBQVVDLEtBQVYsRUFBaUI7QUFDNUJqQyxjQUFRa0MsU0FBUixDQUFrQnRELElBQWxCLElBQTBCcUQsTUFBTUUsS0FBaEM7QUFDRCxLQUZEO0FBR0FMLFVBQU1NLFFBQU4sR0FBaUIsVUFBVUMsUUFBVixFQUFvQkosS0FBcEIsRUFBMkI7QUFDMUNqQyxjQUFRa0MsU0FBUixDQUFrQnRELElBQWxCLElBQTBCcUQsTUFBTUUsS0FBaEM7QUFDRCxLQUZEO0FBR0FMLFVBQU1RLE9BQU4sR0FBZ0IsVUFBVUwsS0FBVixFQUFpQjtBQUMvQixVQUFJakMsUUFBUWtDLFNBQVIsQ0FBa0J0RCxJQUFsQixNQUE0QnFELE1BQU1FLEtBQXRDLEVBQTZDO0FBQzNDbkMsZ0JBQVFrQyxTQUFSLENBQWtCdEQsSUFBbEIsSUFBMEIyRCxTQUExQjtBQUNEO0FBQ0YsS0FKRDs7QUFNQTtBQUNBckIsU0FBS1IsS0FBTCxHQUFhOEIsYUFBYXBCLEtBQWIsRUFBb0JwQixRQUFRVSxLQUFSLElBQWlCVixRQUFRVSxLQUFSLENBQWM5QixJQUFkLENBQXJDLENBQWI7O0FBRUEsV0FBT2tDLEVBQUViLFNBQUYsRUFBYWlCLElBQWIsRUFBbUJGLFFBQW5CLENBQVA7QUFDRDtBQXBFUSxDQUFYOztBQXVFQSxTQUFTd0IsWUFBVCxDQUF1QnBCLEtBQXZCLEVBQThCcUIsTUFBOUIsRUFBc0M7QUFDcEMsVUFBUSxPQUFPQSxNQUFmO0FBQ0UsU0FBSyxXQUFMO0FBQ0U7QUFDRixTQUFLLFFBQUw7QUFDRSxhQUFPQSxNQUFQO0FBQ0YsU0FBSyxVQUFMO0FBQ0UsYUFBT0EsT0FBT3JCLEtBQVAsQ0FBUDtBQUNGLFNBQUssU0FBTDtBQUNFLGFBQU9xQixTQUFTckIsTUFBTXNCLE1BQWYsR0FBd0JILFNBQS9CO0FBQ0Y7QUFDRWpDLFdBQUssS0FBTCxFQUFhLGdCQUFpQmMsTUFBTXVCLElBQXZCLEdBQStCLFVBQS9CLEdBQTZDLE9BQU9GLE1BQXBELEdBQThELDZDQUEzRTtBQVZKO0FBWUQ7O0FBRUQ7O0FBRUEsSUFBSUcsa0JBQWtCLFVBQXRCO0FBQ0EsSUFBSUMsd0JBQXdCLFVBQVVDLENBQVYsRUFBYTtBQUFFLFNBQU8sTUFBTUEsRUFBRUMsVUFBRixDQUFhLENBQWIsRUFBZ0JDLFFBQWhCLENBQXlCLEVBQXpCLENBQWI7QUFBNEMsQ0FBdkY7QUFDQSxJQUFJQyxVQUFVLE1BQWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsU0FBUyxVQUFVQyxHQUFWLEVBQWU7QUFBRSxTQUFPQyxtQkFBbUJELEdBQW5CLEVBQ2xDRSxPQURrQyxDQUMxQlQsZUFEMEIsRUFDVEMscUJBRFMsRUFFbENRLE9BRmtDLENBRTFCSixPQUYwQixFQUVqQixHQUZpQixDQUFQO0FBRUgsQ0FGM0I7O0FBSUEsSUFBSUssU0FBU0Msa0JBQWI7O0FBRUEsU0FBU0MsWUFBVCxDQUNFQyxLQURGLEVBRUVDLFVBRkYsRUFHRTtBQUNBLE1BQUtBLGVBQWUsS0FBSyxDQUF6QixFQUE2QkEsYUFBYSxFQUFiOztBQUU3QixNQUFJRCxLQUFKLEVBQVc7QUFDVCxRQUFJRSxXQUFKO0FBQ0EsUUFBSTtBQUNGQSxvQkFBY0MsV0FBV0gsS0FBWCxDQUFkO0FBQ0QsS0FGRCxDQUVFLE9BQU94SCxDQUFQLEVBQVU7QUFDVlQsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUFLLEtBQUwsRUFBWXJFLEVBQUVvRSxPQUFkLENBQXpDO0FBQ0FzRCxvQkFBYyxFQUFkO0FBQ0Q7QUFDRCxTQUFLLElBQUlHLEdBQVQsSUFBZ0JKLFVBQWhCLEVBQTRCO0FBQzFCQyxrQkFBWUcsR0FBWixJQUFtQkosV0FBV0ksR0FBWCxDQUFuQjtBQUNEO0FBQ0QsV0FBT0gsV0FBUDtBQUNELEdBWkQsTUFZTztBQUNMLFdBQU9ELFVBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNFLFVBQVQsQ0FBcUJILEtBQXJCLEVBQTRCO0FBQzFCLE1BQUlNLE1BQU0sRUFBVjs7QUFFQU4sVUFBUUEsTUFBTU8sSUFBTixHQUFhWCxPQUFiLENBQXFCLFdBQXJCLEVBQWtDLEVBQWxDLENBQVI7O0FBRUEsTUFBSSxDQUFDSSxLQUFMLEVBQVk7QUFDVixXQUFPTSxHQUFQO0FBQ0Q7O0FBRUROLFFBQU1RLEtBQU4sQ0FBWSxHQUFaLEVBQWlCQyxPQUFqQixDQUF5QixVQUFVQyxLQUFWLEVBQWlCO0FBQ3hDLFFBQUlDLFFBQVFELE1BQU1kLE9BQU4sQ0FBYyxLQUFkLEVBQXFCLEdBQXJCLEVBQTBCWSxLQUExQixDQUFnQyxHQUFoQyxDQUFaO0FBQ0EsUUFBSUgsTUFBTVIsT0FBT2MsTUFBTUMsS0FBTixFQUFQLENBQVY7QUFDQSxRQUFJQyxNQUFNRixNQUFNdkgsTUFBTixHQUFlLENBQWYsR0FDTnlHLE9BQU9jLE1BQU1HLElBQU4sQ0FBVyxHQUFYLENBQVAsQ0FETSxHQUVOLElBRko7O0FBSUEsUUFBSVIsSUFBSUQsR0FBSixNQUFhdkIsU0FBakIsRUFBNEI7QUFDMUJ3QixVQUFJRCxHQUFKLElBQVdRLEdBQVg7QUFDRCxLQUZELE1BRU8sSUFBSWpILE1BQU1tSCxPQUFOLENBQWNULElBQUlELEdBQUosQ0FBZCxDQUFKLEVBQTZCO0FBQ2xDQyxVQUFJRCxHQUFKLEVBQVN0RyxJQUFULENBQWM4RyxHQUFkO0FBQ0QsS0FGTSxNQUVBO0FBQ0xQLFVBQUlELEdBQUosSUFBVyxDQUFDQyxJQUFJRCxHQUFKLENBQUQsRUFBV1EsR0FBWCxDQUFYO0FBQ0Q7QUFDRixHQWREOztBQWdCQSxTQUFPUCxHQUFQO0FBQ0Q7O0FBRUQsU0FBU1UsY0FBVCxDQUF5QkMsR0FBekIsRUFBOEI7QUFDNUIsTUFBSVgsTUFBTVcsTUFBTXBGLE9BQU9xRixJQUFQLENBQVlELEdBQVosRUFBaUJFLEdBQWpCLENBQXFCLFVBQVVkLEdBQVYsRUFBZTtBQUNsRCxRQUFJUSxNQUFNSSxJQUFJWixHQUFKLENBQVY7O0FBRUEsUUFBSVEsUUFBUS9CLFNBQVosRUFBdUI7QUFDckIsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQsUUFBSStCLFFBQVEsSUFBWixFQUFrQjtBQUNoQixhQUFPcEIsT0FBT1ksR0FBUCxDQUFQO0FBQ0Q7O0FBRUQsUUFBSXpHLE1BQU1tSCxPQUFOLENBQWNGLEdBQWQsQ0FBSixFQUF3QjtBQUN0QixVQUFJTyxTQUFTLEVBQWI7QUFDQVAsVUFBSVEsS0FBSixHQUFZWixPQUFaLENBQW9CLFVBQVVhLElBQVYsRUFBZ0I7QUFDbEMsWUFBSUEsU0FBU3hDLFNBQWIsRUFBd0I7QUFDdEI7QUFDRDtBQUNELFlBQUl3QyxTQUFTLElBQWIsRUFBbUI7QUFDakJGLGlCQUFPckgsSUFBUCxDQUFZMEYsT0FBT1ksR0FBUCxDQUFaO0FBQ0QsU0FGRCxNQUVPO0FBQ0xlLGlCQUFPckgsSUFBUCxDQUFZMEYsT0FBT1ksR0FBUCxJQUFjLEdBQWQsR0FBb0JaLE9BQU82QixJQUFQLENBQWhDO0FBQ0Q7QUFDRixPQVREO0FBVUEsYUFBT0YsT0FBT04sSUFBUCxDQUFZLEdBQVosQ0FBUDtBQUNEOztBQUVELFdBQU9yQixPQUFPWSxHQUFQLElBQWMsR0FBZCxHQUFvQlosT0FBT29CLEdBQVAsQ0FBM0I7QUFDRCxHQTNCZSxFQTJCYlUsTUEzQmEsQ0EyQk4sVUFBVUMsQ0FBVixFQUFhO0FBQUUsV0FBT0EsRUFBRXBJLE1BQUYsR0FBVyxDQUFsQjtBQUFzQixHQTNCL0IsRUEyQmlDMEgsSUEzQmpDLENBMkJzQyxHQTNCdEMsQ0FBTixHQTJCbUQsSUEzQjdEO0FBNEJBLFNBQU9SLE1BQU8sTUFBTUEsR0FBYixHQUFvQixFQUEzQjtBQUNEOztBQUVEOztBQUVBLElBQUltQixrQkFBa0IsTUFBdEI7O0FBRUEsU0FBU0MsV0FBVCxDQUNFQyxNQURGLEVBRUVDLFFBRkYsRUFHRUMsY0FIRixFQUlFO0FBQ0EsTUFBSWxFLFFBQVE7QUFDVnhDLFVBQU15RyxTQUFTekcsSUFBVCxJQUFrQndHLFVBQVVBLE9BQU94RyxJQUQvQjtBQUVWMkcsVUFBT0gsVUFBVUEsT0FBT0csSUFBbEIsSUFBMkIsRUFGdkI7QUFHVjVDLFVBQU0wQyxTQUFTMUMsSUFBVCxJQUFpQixHQUhiO0FBSVY2QyxVQUFNSCxTQUFTRyxJQUFULElBQWlCLEVBSmI7QUFLVi9CLFdBQU80QixTQUFTNUIsS0FBVCxJQUFrQixFQUxmO0FBTVZmLFlBQVEyQyxTQUFTM0MsTUFBVCxJQUFtQixFQU5qQjtBQU9WK0MsY0FBVUMsWUFBWUwsUUFBWixDQVBBO0FBUVZyRixhQUFTb0YsU0FBU08sWUFBWVAsTUFBWixDQUFULEdBQStCO0FBUjlCLEdBQVo7QUFVQSxNQUFJRSxjQUFKLEVBQW9CO0FBQ2xCbEUsVUFBTWtFLGNBQU4sR0FBdUJJLFlBQVlKLGNBQVosQ0FBdkI7QUFDRDtBQUNELFNBQU9oRyxPQUFPc0csTUFBUCxDQUFjeEUsS0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxJQUFJeUUsUUFBUVYsWUFBWSxJQUFaLEVBQWtCO0FBQzVCeEMsUUFBTTtBQURzQixDQUFsQixDQUFaOztBQUlBLFNBQVNnRCxXQUFULENBQXNCUCxNQUF0QixFQUE4QjtBQUM1QixNQUFJckIsTUFBTSxFQUFWO0FBQ0EsU0FBT3FCLE1BQVAsRUFBZTtBQUNickIsUUFBSStCLE9BQUosQ0FBWVYsTUFBWjtBQUNBQSxhQUFTQSxPQUFPbkUsTUFBaEI7QUFDRDtBQUNELFNBQU84QyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzJCLFdBQVQsQ0FBc0IzRSxHQUF0QixFQUEyQjtBQUN6QixNQUFJNEIsT0FBTzVCLElBQUk0QixJQUFmO0FBQ0EsTUFBSWMsUUFBUTFDLElBQUkwQyxLQUFoQixDQUF1QixJQUFLQSxVQUFVLEtBQUssQ0FBcEIsRUFBd0JBLFFBQVEsRUFBUjtBQUMvQyxNQUFJK0IsT0FBT3pFLElBQUl5RSxJQUFmLENBQXFCLElBQUtBLFNBQVMsS0FBSyxDQUFuQixFQUF1QkEsT0FBTyxFQUFQOztBQUU1QyxTQUFPLENBQUM3QyxRQUFRLEdBQVQsSUFBZ0I4QixlQUFlaEIsS0FBZixDQUFoQixHQUF3QytCLElBQS9DO0FBQ0Q7O0FBRUQsU0FBU08sV0FBVCxDQUFzQkMsQ0FBdEIsRUFBeUJDLENBQXpCLEVBQTRCO0FBQzFCLE1BQUlBLE1BQU1KLEtBQVYsRUFBaUI7QUFDZixXQUFPRyxNQUFNQyxDQUFiO0FBQ0QsR0FGRCxNQUVPLElBQUksQ0FBQ0EsQ0FBTCxFQUFRO0FBQ2IsV0FBTyxLQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlELEVBQUVyRCxJQUFGLElBQVVzRCxFQUFFdEQsSUFBaEIsRUFBc0I7QUFDM0IsV0FDRXFELEVBQUVyRCxJQUFGLENBQU9VLE9BQVAsQ0FBZTZCLGVBQWYsRUFBZ0MsRUFBaEMsTUFBd0NlLEVBQUV0RCxJQUFGLENBQU9VLE9BQVAsQ0FBZTZCLGVBQWYsRUFBZ0MsRUFBaEMsQ0FBeEMsSUFDQWMsRUFBRVIsSUFBRixLQUFXUyxFQUFFVCxJQURiLElBRUFVLGNBQWNGLEVBQUV2QyxLQUFoQixFQUF1QndDLEVBQUV4QyxLQUF6QixDQUhGO0FBS0QsR0FOTSxNQU1BLElBQUl1QyxFQUFFcEgsSUFBRixJQUFVcUgsRUFBRXJILElBQWhCLEVBQXNCO0FBQzNCLFdBQ0VvSCxFQUFFcEgsSUFBRixLQUFXcUgsRUFBRXJILElBQWIsSUFDQW9ILEVBQUVSLElBQUYsS0FBV1MsRUFBRVQsSUFEYixJQUVBVSxjQUFjRixFQUFFdkMsS0FBaEIsRUFBdUJ3QyxFQUFFeEMsS0FBekIsQ0FGQSxJQUdBeUMsY0FBY0YsRUFBRXRELE1BQWhCLEVBQXdCdUQsRUFBRXZELE1BQTFCLENBSkY7QUFNRCxHQVBNLE1BT0E7QUFDTCxXQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN3RCxhQUFULENBQXdCRixDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEI7QUFDNUIsTUFBS0QsTUFBTSxLQUFLLENBQWhCLEVBQW9CQSxJQUFJLEVBQUo7QUFDcEIsTUFBS0MsTUFBTSxLQUFLLENBQWhCLEVBQW9CQSxJQUFJLEVBQUo7O0FBRXBCLE1BQUlFLFFBQVE3RyxPQUFPcUYsSUFBUCxDQUFZcUIsQ0FBWixDQUFaO0FBQ0EsTUFBSUksUUFBUTlHLE9BQU9xRixJQUFQLENBQVlzQixDQUFaLENBQVo7QUFDQSxNQUFJRSxNQUFNdEosTUFBTixLQUFpQnVKLE1BQU12SixNQUEzQixFQUFtQztBQUNqQyxXQUFPLEtBQVA7QUFDRDtBQUNELFNBQU9zSixNQUFNRSxLQUFOLENBQVksVUFBVXZDLEdBQVYsRUFBZTtBQUFFLFdBQU9sRCxPQUFPb0YsRUFBRWxDLEdBQUYsQ0FBUCxNQUFtQmxELE9BQU9xRixFQUFFbkMsR0FBRixDQUFQLENBQTFCO0FBQTJDLEdBQXhFLENBQVA7QUFDRDs7QUFFRCxTQUFTd0MsZUFBVCxDQUEwQkMsT0FBMUIsRUFBbUNDLE1BQW5DLEVBQTJDO0FBQ3pDLFNBQ0VELFFBQVE1RCxJQUFSLENBQWFVLE9BQWIsQ0FBcUI2QixlQUFyQixFQUFzQyxHQUF0QyxFQUEyQ3VCLE9BQTNDLENBQ0VELE9BQU83RCxJQUFQLENBQVlVLE9BQVosQ0FBb0I2QixlQUFwQixFQUFxQyxHQUFyQyxDQURGLE1BRU0sQ0FGTixLQUdDLENBQUNzQixPQUFPaEIsSUFBUixJQUFnQmUsUUFBUWYsSUFBUixLQUFpQmdCLE9BQU9oQixJQUh6QyxLQUlBa0IsY0FBY0gsUUFBUTlDLEtBQXRCLEVBQTZCK0MsT0FBTy9DLEtBQXBDLENBTEY7QUFPRDs7QUFFRCxTQUFTaUQsYUFBVCxDQUF3QkgsT0FBeEIsRUFBaUNDLE1BQWpDLEVBQXlDO0FBQ3ZDLE9BQUssSUFBSTFDLEdBQVQsSUFBZ0IwQyxNQUFoQixFQUF3QjtBQUN0QixRQUFJLEVBQUUxQyxPQUFPeUMsT0FBVCxDQUFKLEVBQXVCO0FBQ3JCLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRDs7QUFFQTtBQUNBLElBQUlJLFVBQVUsQ0FBQy9GLE1BQUQsRUFBU3RCLE1BQVQsQ0FBZDtBQUNBLElBQUlzSCxhQUFhLENBQUNoRyxNQUFELEVBQVN2RCxLQUFULENBQWpCOztBQUVBLElBQUl3SixPQUFPO0FBQ1RqSSxRQUFNLGFBREc7QUFFVDhCLFNBQU87QUFDTG9HLFFBQUk7QUFDRm5HLFlBQU1nRyxPQURKO0FBRUZJLGdCQUFVO0FBRlIsS0FEQztBQUtMQyxTQUFLO0FBQ0hyRyxZQUFNQyxNQURIO0FBRUhuQixlQUFTO0FBRk4sS0FMQTtBQVNMd0gsV0FBT0MsT0FURjtBQVVMQyxZQUFRRCxPQVZIO0FBV0w3RCxhQUFTNkQsT0FYSjtBQVlMRSxpQkFBYXhHLE1BWlI7QUFhTHlHLFdBQU87QUFDTDFHLFlBQU1pRyxVQUREO0FBRUxuSCxlQUFTO0FBRko7QUFiRixHQUZFO0FBb0JUb0IsVUFBUSxTQUFTQSxNQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUMxQixRQUFJd0csU0FBUyxJQUFiOztBQUVBLFFBQUlDLFNBQVMsS0FBS0MsT0FBbEI7QUFDQSxRQUFJakIsVUFBVSxLQUFLeEcsTUFBbkI7QUFDQSxRQUFJZ0IsTUFBTXdHLE9BQU9FLE9BQVAsQ0FBZSxLQUFLWCxFQUFwQixFQUF3QlAsT0FBeEIsRUFBaUMsS0FBS1ksTUFBdEMsQ0FBVjtBQUNBLFFBQUk5QixXQUFXdEUsSUFBSXNFLFFBQW5CO0FBQ0EsUUFBSWpFLFFBQVFMLElBQUlLLEtBQWhCO0FBQ0EsUUFBSXNHLE9BQU8zRyxJQUFJMkcsSUFBZjtBQUNBLFFBQUlDLFVBQVUsRUFBZDtBQUNBLFFBQUlQLGNBQWMsS0FBS0EsV0FBTCxJQUFvQkcsT0FBT0ssT0FBUCxDQUFlQyxlQUFuQyxJQUFzRCxvQkFBeEU7QUFDQSxRQUFJQyxnQkFBZ0J6QyxTQUFTMUMsSUFBVCxHQUFnQndDLFlBQVksSUFBWixFQUFrQkUsUUFBbEIsQ0FBaEIsR0FBOENqRSxLQUFsRTtBQUNBdUcsWUFBUVAsV0FBUixJQUF1QixLQUFLSCxLQUFMLEdBQ25CbEIsWUFBWVEsT0FBWixFQUFxQnVCLGFBQXJCLENBRG1CLEdBRW5CeEIsZ0JBQWdCQyxPQUFoQixFQUF5QnVCLGFBQXpCLENBRko7O0FBSUEsUUFBSUMsVUFBVSxVQUFVOUwsQ0FBVixFQUFhO0FBQ3pCLFVBQUkrTCxXQUFXL0wsQ0FBWCxDQUFKLEVBQW1CO0FBQ2pCLFlBQUlxTCxPQUFPakUsT0FBWCxFQUFvQjtBQUNsQmtFLGlCQUFPbEUsT0FBUCxDQUFlZ0MsUUFBZjtBQUNELFNBRkQsTUFFTztBQUNMa0MsaUJBQU8vSixJQUFQLENBQVk2SCxRQUFaO0FBQ0Q7QUFDRjtBQUNGLEtBUkQ7O0FBVUEsUUFBSWpILEtBQUssRUFBRTZKLE9BQU9ELFVBQVQsRUFBVDtBQUNBLFFBQUkzSyxNQUFNbUgsT0FBTixDQUFjLEtBQUs2QyxLQUFuQixDQUFKLEVBQStCO0FBQzdCLFdBQUtBLEtBQUwsQ0FBV25ELE9BQVgsQ0FBbUIsVUFBVWpJLENBQVYsRUFBYTtBQUFFbUMsV0FBR25DLENBQUgsSUFBUThMLE9BQVI7QUFBa0IsT0FBcEQ7QUFDRCxLQUZELE1BRU87QUFDTDNKLFNBQUcsS0FBS2lKLEtBQVIsSUFBaUJVLE9BQWpCO0FBQ0Q7O0FBRUQsUUFBSTdHLE9BQU87QUFDVGdILGFBQU9QO0FBREUsS0FBWDs7QUFJQSxRQUFJLEtBQUtYLEdBQUwsS0FBYSxHQUFqQixFQUFzQjtBQUNwQjlGLFdBQUs5QyxFQUFMLEdBQVVBLEVBQVY7QUFDQThDLFdBQUtpSCxLQUFMLEdBQWEsRUFBRVQsTUFBTUEsSUFBUixFQUFiO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxVQUFJMUIsSUFBSW9DLFdBQVcsS0FBS0MsTUFBTCxDQUFZNUksT0FBdkIsQ0FBUjtBQUNBLFVBQUl1RyxDQUFKLEVBQU87QUFDTDtBQUNBQSxVQUFFc0MsUUFBRixHQUFhLEtBQWI7QUFDQSxZQUFJQyxTQUFTQyxLQUFLQyxJQUFMLENBQVVGLE1BQXZCO0FBQ0EsWUFBSUcsUUFBUTFDLEVBQUU5RSxJQUFGLEdBQVNxSCxPQUFPLEVBQVAsRUFBV3ZDLEVBQUU5RSxJQUFiLENBQXJCO0FBQ0F3SCxjQUFNdEssRUFBTixHQUFXQSxFQUFYO0FBQ0EsWUFBSXVLLFNBQVMzQyxFQUFFOUUsSUFBRixDQUFPaUgsS0FBUCxHQUFlSSxPQUFPLEVBQVAsRUFBV3ZDLEVBQUU5RSxJQUFGLENBQU9pSCxLQUFsQixDQUE1QjtBQUNBUSxlQUFPakIsSUFBUCxHQUFjQSxJQUFkO0FBQ0QsT0FSRCxNQVFPO0FBQ0w7QUFDQXhHLGFBQUs5QyxFQUFMLEdBQVVBLEVBQVY7QUFDRDtBQUNGOztBQUVELFdBQU8wQyxFQUFFLEtBQUtrRyxHQUFQLEVBQVk5RixJQUFaLEVBQWtCLEtBQUttSCxNQUFMLENBQVk1SSxPQUE5QixDQUFQO0FBQ0Q7QUE5RVEsQ0FBWDs7QUFpRkEsU0FBU3VJLFVBQVQsQ0FBcUIvTCxDQUFyQixFQUF3QjtBQUN0QjtBQUNBLE1BQUlBLEVBQUUyTSxPQUFGLElBQWEzTSxFQUFFNE0sT0FBZixJQUEwQjVNLEVBQUU2TSxRQUFoQyxFQUEwQztBQUFFO0FBQVE7QUFDcEQ7QUFDQSxNQUFJN00sRUFBRThNLGdCQUFOLEVBQXdCO0FBQUU7QUFBUTtBQUNsQztBQUNBLE1BQUk5TSxFQUFFK00sTUFBRixLQUFhekcsU0FBYixJQUEwQnRHLEVBQUUrTSxNQUFGLEtBQWEsQ0FBM0MsRUFBOEM7QUFBRTtBQUFRO0FBQ3hEO0FBQ0EsTUFBSS9NLEVBQUV1SyxNQUFGLElBQVl2SyxFQUFFdUssTUFBRixDQUFTeUMsWUFBekIsRUFBdUM7QUFDckMsUUFBSXpDLFNBQVN2SyxFQUFFdUssTUFBRixDQUFTeUMsWUFBVCxDQUFzQixRQUF0QixDQUFiO0FBQ0EsUUFBSSxjQUFjQyxJQUFkLENBQW1CMUMsTUFBbkIsQ0FBSixFQUFnQztBQUFFO0FBQVE7QUFDM0M7QUFDRDtBQUNBLE1BQUl2SyxFQUFFa04sY0FBTixFQUFzQjtBQUNwQmxOLE1BQUVrTixjQUFGO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTZixVQUFULENBQXFCcEgsUUFBckIsRUFBK0I7QUFDN0IsTUFBSUEsUUFBSixFQUFjO0FBQ1osUUFBSW1CLEtBQUo7QUFDQSxTQUFLLElBQUk1RSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5RCxTQUFTbkUsTUFBN0IsRUFBcUNVLEdBQXJDLEVBQTBDO0FBQ3hDNEUsY0FBUW5CLFNBQVN6RCxDQUFULENBQVI7QUFDQSxVQUFJNEUsTUFBTTZFLEdBQU4sS0FBYyxHQUFsQixFQUF1QjtBQUNyQixlQUFPN0UsS0FBUDtBQUNEO0FBQ0QsVUFBSUEsTUFBTW5CLFFBQU4sS0FBbUJtQixRQUFRaUcsV0FBV2pHLE1BQU1uQixRQUFqQixDQUEzQixDQUFKLEVBQTREO0FBQzFELGVBQU9tQixLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsSUFBSXFHLElBQUo7O0FBRUEsU0FBUzlJLE9BQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3JCLE1BQUlELFFBQVEwSixTQUFaLEVBQXVCO0FBQUU7QUFBUTtBQUNqQzFKLFVBQVEwSixTQUFSLEdBQW9CLElBQXBCOztBQUVBWixTQUFPN0ksR0FBUDs7QUFFQUwsU0FBT0MsY0FBUCxDQUFzQkksSUFBSWhDLFNBQTFCLEVBQXFDLFNBQXJDLEVBQWdEO0FBQzlDbUMsU0FBSyxTQUFTQSxHQUFULEdBQWdCO0FBQUUsYUFBTyxLQUFLdUosS0FBTCxDQUFXQyxPQUFsQjtBQUEyQjtBQURKLEdBQWhEOztBQUlBaEssU0FBT0MsY0FBUCxDQUFzQkksSUFBSWhDLFNBQTFCLEVBQXFDLFFBQXJDLEVBQStDO0FBQzdDbUMsU0FBSyxTQUFTQSxHQUFULEdBQWdCO0FBQUUsYUFBTyxLQUFLdUosS0FBTCxDQUFXRSxNQUFsQjtBQUEwQjtBQURKLEdBQS9DOztBQUlBNUosTUFBSTZKLEtBQUosQ0FBVTtBQUNSQyxrQkFBYyxTQUFTQSxZQUFULEdBQXlCO0FBQ3JDLFVBQUksS0FBS0MsUUFBTCxDQUFjbkMsTUFBbEIsRUFBMEI7QUFDeEIsYUFBSytCLE9BQUwsR0FBZSxLQUFLSSxRQUFMLENBQWNuQyxNQUE3QjtBQUNBLGFBQUsrQixPQUFMLENBQWF0SCxJQUFiLENBQWtCLElBQWxCO0FBQ0FyQyxZQUFJOEksSUFBSixDQUFTa0IsY0FBVCxDQUF3QixJQUF4QixFQUE4QixRQUE5QixFQUF3QyxLQUFLTCxPQUFMLENBQWFNLE9BQWIsQ0FBcUJyRCxPQUE3RDtBQUNEO0FBQ0Y7QUFQTyxHQUFWOztBQVVBNUcsTUFBSU0sU0FBSixDQUFjLGFBQWQsRUFBNkJPLElBQTdCO0FBQ0FiLE1BQUlNLFNBQUosQ0FBYyxhQUFkLEVBQTZCNEcsSUFBN0I7O0FBRUEsTUFBSWdELFNBQVNsSyxJQUFJOEMsTUFBSixDQUFXcUgscUJBQXhCO0FBQ0E7QUFDQUQsU0FBT0UsZ0JBQVAsR0FBMEJGLE9BQU9HLGdCQUFQLEdBQTBCSCxPQUFPSSxPQUEzRDtBQUNEOztBQUVEOztBQUVBLElBQUlDLFlBQVksT0FBT0MsTUFBUCxLQUFrQixXQUFsQzs7QUFFQTs7QUFFQSxTQUFTQyxXQUFULENBQ0VDLFFBREYsRUFFRUMsSUFGRixFQUdFbkQsTUFIRixFQUlFO0FBQ0EsTUFBSWtELFNBQVNFLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBM0IsRUFBZ0M7QUFDOUIsV0FBT0YsUUFBUDtBQUNEOztBQUVELE1BQUlBLFNBQVNFLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBdkIsSUFBOEJGLFNBQVNFLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBekQsRUFBOEQ7QUFDNUQsV0FBT0QsT0FBT0QsUUFBZDtBQUNEOztBQUVELE1BQUlHLFFBQVFGLEtBQUtyRyxLQUFMLENBQVcsR0FBWCxDQUFaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUksQ0FBQ2tELE1BQUQsSUFBVyxDQUFDcUQsTUFBTUEsTUFBTTNOLE1BQU4sR0FBZSxDQUFyQixDQUFoQixFQUF5QztBQUN2QzJOLFVBQU1DLEdBQU47QUFDRDs7QUFFRDtBQUNBLE1BQUlDLFdBQVdMLFNBQVNoSCxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEVBQXhCLEVBQTRCWSxLQUE1QixDQUFrQyxHQUFsQyxDQUFmO0FBQ0EsT0FBSyxJQUFJMUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbU4sU0FBUzdOLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QyxRQUFJb04sVUFBVUQsU0FBU25OLENBQVQsQ0FBZDtBQUNBLFFBQUlvTixZQUFZLEdBQWhCLEVBQXFCO0FBQ25CO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFlBQVksSUFBaEIsRUFBc0I7QUFDM0JILFlBQU1DLEdBQU47QUFDRCxLQUZNLE1BRUE7QUFDTEQsWUFBTWhOLElBQU4sQ0FBV21OLE9BQVg7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSUgsTUFBTSxDQUFOLE1BQWEsRUFBakIsRUFBcUI7QUFDbkJBLFVBQU0xRSxPQUFOLENBQWMsRUFBZDtBQUNEOztBQUVELFNBQU8wRSxNQUFNakcsSUFBTixDQUFXLEdBQVgsQ0FBUDtBQUNEOztBQUVELFNBQVNxRyxTQUFULENBQW9CakksSUFBcEIsRUFBMEI7QUFDeEIsTUFBSTZDLE9BQU8sRUFBWDtBQUNBLE1BQUkvQixRQUFRLEVBQVo7O0FBRUEsTUFBSW9ILFlBQVlsSSxLQUFLOEQsT0FBTCxDQUFhLEdBQWIsQ0FBaEI7QUFDQSxNQUFJb0UsYUFBYSxDQUFqQixFQUFvQjtBQUNsQnJGLFdBQU83QyxLQUFLbUMsS0FBTCxDQUFXK0YsU0FBWCxDQUFQO0FBQ0FsSSxXQUFPQSxLQUFLbUMsS0FBTCxDQUFXLENBQVgsRUFBYytGLFNBQWQsQ0FBUDtBQUNEOztBQUVELE1BQUlDLGFBQWFuSSxLQUFLOEQsT0FBTCxDQUFhLEdBQWIsQ0FBakI7QUFDQSxNQUFJcUUsY0FBYyxDQUFsQixFQUFxQjtBQUNuQnJILFlBQVFkLEtBQUttQyxLQUFMLENBQVdnRyxhQUFhLENBQXhCLENBQVI7QUFDQW5JLFdBQU9BLEtBQUttQyxLQUFMLENBQVcsQ0FBWCxFQUFjZ0csVUFBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUNMbkksVUFBTUEsSUFERDtBQUVMYyxXQUFPQSxLQUZGO0FBR0wrQixVQUFNQTtBQUhELEdBQVA7QUFLRDs7QUFFRCxTQUFTdUYsU0FBVCxDQUFvQnBJLElBQXBCLEVBQTBCO0FBQ3hCLFNBQU9BLEtBQUtVLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLEdBQXRCLENBQVA7QUFDRDs7QUFFRDs7QUFFQSxTQUFTMkgsY0FBVCxDQUNFQyxNQURGLEVBRUVDLFVBRkYsRUFHRUMsVUFIRixFQUlFO0FBQ0EsTUFBSUMsVUFBVUYsY0FBYzVMLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUE1QjtBQUNBLE1BQUlDLFVBQVVILGNBQWM3TCxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBNUI7O0FBRUFKLFNBQU8vRyxPQUFQLENBQWUsVUFBVTlDLEtBQVYsRUFBaUI7QUFDOUJtSyxtQkFBZUgsT0FBZixFQUF3QkUsT0FBeEIsRUFBaUNsSyxLQUFqQztBQUNELEdBRkQ7O0FBSUEsU0FBTztBQUNMZ0ssYUFBU0EsT0FESjtBQUVMRSxhQUFTQTtBQUZKLEdBQVA7QUFJRDs7QUFFRCxTQUFTQyxjQUFULENBQ0VILE9BREYsRUFFRUUsT0FGRixFQUdFbEssS0FIRixFQUlFSCxNQUpGLEVBS0V1SyxPQUxGLEVBTUU7QUFDQSxNQUFJN0ksT0FBT3ZCLE1BQU11QixJQUFqQjtBQUNBLE1BQUkvRCxPQUFPd0MsTUFBTXhDLElBQWpCO0FBQ0EsTUFBSXBELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMUQsV0FBT3dDLFFBQVEsSUFBZixFQUFxQixnREFBckI7QUFDQXhDLFdBQ0UsT0FBT2lCLE1BQU1uQixTQUFiLEtBQTJCLFFBRDdCLEVBRUUsMENBQTJDVyxPQUFPK0IsUUFBUS9ELElBQWYsQ0FBM0MsR0FBbUUsZUFBbkUsR0FDQSw2Q0FIRjtBQUtEOztBQUVELE1BQUl3RyxTQUFTO0FBQ1h6QyxVQUFNOEksY0FBYzlJLElBQWQsRUFBb0IxQixNQUFwQixDQURLO0FBRVhZLGdCQUFZVCxNQUFNUyxVQUFOLElBQW9CLEVBQUVwQyxTQUFTMkIsTUFBTW5CLFNBQWpCLEVBRnJCO0FBR1hpQyxlQUFXLEVBSEE7QUFJWHRELFVBQU1BLElBSks7QUFLWHFDLFlBQVFBLE1BTEc7QUFNWHVLLGFBQVNBLE9BTkU7QUFPWEUsY0FBVXRLLE1BQU1zSyxRQVBMO0FBUVhDLGlCQUFhdkssTUFBTXVLLFdBUlI7QUFTWHBHLFVBQU1uRSxNQUFNbUUsSUFBTixJQUFjLEVBVFQ7QUFVWDdFLFdBQU9VLE1BQU1WLEtBQU4sSUFBZSxJQUFmLEdBQ0gsRUFERyxHQUVIVSxNQUFNUyxVQUFOLEdBQ0VULE1BQU1WLEtBRFIsR0FFRSxFQUFFakIsU0FBUzJCLE1BQU1WLEtBQWpCO0FBZEssR0FBYjs7QUFpQkEsTUFBSVUsTUFBTUosUUFBVixFQUFvQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFJeEYsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSXpDLE1BQU14QyxJQUFOLElBQWN3QyxNQUFNSixRQUFOLENBQWU0SyxJQUFmLENBQW9CLFVBQVV6SixLQUFWLEVBQWlCO0FBQUUsZUFBTyxTQUFRK0csSUFBUixDQUFhL0csTUFBTVEsSUFBbkI7QUFBUDtBQUFrQyxPQUF6RSxDQUFsQixFQUE4RjtBQUM1RnJDLGFBQ0UsS0FERixFQUVFLGtCQUFtQmMsTUFBTXhDLElBQXpCLEdBQWlDLCtCQUFqQyxHQUNBLHFEQURBLEdBQ3lEd0MsTUFBTXhDLElBRC9ELEdBQ3VFLFFBRHZFLEdBRUEscUVBRkEsR0FHQSxtRUFIQSxHQUlBLGdCQU5GO0FBUUQ7QUFDRjtBQUNEd0MsVUFBTUosUUFBTixDQUFla0QsT0FBZixDQUF1QixVQUFVL0IsS0FBVixFQUFpQjtBQUN0QyxVQUFJMEosZUFBZUwsVUFDZlQsVUFBV1MsVUFBVSxHQUFWLEdBQWlCckosTUFBTVEsSUFBbEMsQ0FEZSxHQUVmSixTQUZKO0FBR0FnSixxQkFBZUgsT0FBZixFQUF3QkUsT0FBeEIsRUFBaUNuSixLQUFqQyxFQUF3Q2lELE1BQXhDLEVBQWdEeUcsWUFBaEQ7QUFDRCxLQUxEO0FBTUQ7O0FBRUQsTUFBSXpLLE1BQU0wSyxLQUFOLEtBQWdCdkosU0FBcEIsRUFBK0I7QUFDN0IsUUFBSWxGLE1BQU1tSCxPQUFOLENBQWNwRCxNQUFNMEssS0FBcEIsQ0FBSixFQUFnQztBQUM5QjFLLFlBQU0wSyxLQUFOLENBQVk1SCxPQUFaLENBQW9CLFVBQVU0SCxLQUFWLEVBQWlCO0FBQ25DLFlBQUlDLGFBQWE7QUFDZnBKLGdCQUFNbUosS0FEUztBQUVmOUssb0JBQVVJLE1BQU1KO0FBRkQsU0FBakI7QUFJQXVLLHVCQUFlSCxPQUFmLEVBQXdCRSxPQUF4QixFQUFpQ1MsVUFBakMsRUFBNkM5SyxNQUE3QyxFQUFxRG1FLE9BQU96QyxJQUE1RDtBQUNELE9BTkQ7QUFPRCxLQVJELE1BUU87QUFDTCxVQUFJb0osYUFBYTtBQUNmcEosY0FBTXZCLE1BQU0wSyxLQURHO0FBRWY5SyxrQkFBVUksTUFBTUo7QUFGRCxPQUFqQjtBQUlBdUsscUJBQWVILE9BQWYsRUFBd0JFLE9BQXhCLEVBQWlDUyxVQUFqQyxFQUE2QzlLLE1BQTdDLEVBQXFEbUUsT0FBT3pDLElBQTVEO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLENBQUN5SSxRQUFRaEcsT0FBT3pDLElBQWYsQ0FBTCxFQUEyQjtBQUN6QnlJLFlBQVFoRyxPQUFPekMsSUFBZixJQUF1QnlDLE1BQXZCO0FBQ0Q7O0FBRUQsTUFBSXhHLElBQUosRUFBVTtBQUNSLFFBQUksQ0FBQzBNLFFBQVExTSxJQUFSLENBQUwsRUFBb0I7QUFDbEIwTSxjQUFRMU0sSUFBUixJQUFnQndHLE1BQWhCO0FBQ0QsS0FGRCxNQUVPLElBQUk1SixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDMkgsT0FBOUMsRUFBdUQ7QUFDNURsTCxXQUNFLEtBREYsRUFFRSx3Q0FDQSxZQURBLEdBQ2UxQixJQURmLEdBQ3NCLGNBRHRCLEdBQ3dDd0csT0FBT3pDLElBRC9DLEdBQ3VELE1BSHpEO0FBS0Q7QUFDRjtBQUNGOztBQUVELFNBQVM4SSxhQUFULENBQXdCOUksSUFBeEIsRUFBOEIxQixNQUE5QixFQUFzQztBQUNwQzBCLFNBQU9BLEtBQUtVLE9BQUwsQ0FBYSxLQUFiLEVBQW9CLEVBQXBCLENBQVA7QUFDQSxNQUFJVixLQUFLLENBQUwsTUFBWSxHQUFoQixFQUFxQjtBQUFFLFdBQU9BLElBQVA7QUFBYTtBQUNwQyxNQUFJMUIsVUFBVSxJQUFkLEVBQW9CO0FBQUUsV0FBTzBCLElBQVA7QUFBYTtBQUNuQyxTQUFPb0ksVUFBWTlKLE9BQU8wQixJQUFSLEdBQWdCLEdBQWhCLEdBQXNCQSxJQUFqQyxDQUFQO0FBQ0Q7O0FBRUQsSUFBSXFKLFVBQVUzTyxNQUFNbUgsT0FBTixJQUFpQixVQUFVeUgsR0FBVixFQUFlO0FBQzVDLFNBQU8zTSxPQUFPM0IsU0FBUCxDQUFpQnFGLFFBQWpCLENBQTBCM0csSUFBMUIsQ0FBK0I0UCxHQUEvQixLQUF1QyxnQkFBOUM7QUFDRCxDQUZEOztBQUlBLElBQUlDLFVBQVVGLE9BQWQ7O0FBRUE7OztBQUdBLElBQUkzTSxRQUFROE0sWUFBWjtBQUNBLElBQUlDLFVBQVVDLEtBQWQ7QUFDQSxJQUFJQyxZQUFZQyxPQUFoQjtBQUNBLElBQUlDLHFCQUFxQkMsZ0JBQXpCO0FBQ0EsSUFBSUMsbUJBQW1CQyxjQUF2Qjs7QUFFQTs7Ozs7QUFLQSxJQUFJQyxjQUFjLElBQUlDLE1BQUosQ0FBVztBQUMzQjtBQUNBO0FBQ0EsU0FIMkI7QUFJM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBVjJCLEVBVzNCdEksSUFYMkIsQ0FXdEIsR0FYc0IsQ0FBWCxFQVdMLEdBWEssQ0FBbEI7O0FBYUE7Ozs7Ozs7QUFPQSxTQUFTOEgsS0FBVCxDQUFnQmxKLEdBQWhCLEVBQXFCeUUsT0FBckIsRUFBOEI7QUFDNUIsTUFBSWtGLFNBQVMsRUFBYjtBQUNBLE1BQUloSixNQUFNLENBQVY7QUFDQSxNQUFJekUsUUFBUSxDQUFaO0FBQ0EsTUFBSXNELE9BQU8sRUFBWDtBQUNBLE1BQUlvSyxtQkFBbUJuRixXQUFXQSxRQUFRb0YsU0FBbkIsSUFBZ0MsR0FBdkQ7QUFDQSxNQUFJakosR0FBSjs7QUFFQSxTQUFPLENBQUNBLE1BQU02SSxZQUFZSyxJQUFaLENBQWlCOUosR0FBakIsQ0FBUCxLQUFpQyxJQUF4QyxFQUE4QztBQUM1QyxRQUFJK0osSUFBSW5KLElBQUksQ0FBSixDQUFSO0FBQ0EsUUFBSW9KLFVBQVVwSixJQUFJLENBQUosQ0FBZDtBQUNBLFFBQUlxSixTQUFTckosSUFBSTFFLEtBQWpCO0FBQ0FzRCxZQUFRUSxJQUFJMkIsS0FBSixDQUFVekYsS0FBVixFQUFpQitOLE1BQWpCLENBQVI7QUFDQS9OLFlBQVErTixTQUFTRixFQUFFclEsTUFBbkI7O0FBRUE7QUFDQSxRQUFJc1EsT0FBSixFQUFhO0FBQ1h4SyxjQUFRd0ssUUFBUSxDQUFSLENBQVI7QUFDQTtBQUNEOztBQUVELFFBQUlFLE9BQU9sSyxJQUFJOUQsS0FBSixDQUFYO0FBQ0EsUUFBSWlPLFNBQVN2SixJQUFJLENBQUosQ0FBYjtBQUNBLFFBQUluRixPQUFPbUYsSUFBSSxDQUFKLENBQVg7QUFDQSxRQUFJd0osVUFBVXhKLElBQUksQ0FBSixDQUFkO0FBQ0EsUUFBSXlKLFFBQVF6SixJQUFJLENBQUosQ0FBWjtBQUNBLFFBQUkwSixXQUFXMUosSUFBSSxDQUFKLENBQWY7QUFDQSxRQUFJMkosV0FBVzNKLElBQUksQ0FBSixDQUFmOztBQUVBO0FBQ0EsUUFBSXBCLElBQUosRUFBVTtBQUNSbUssYUFBT3RQLElBQVAsQ0FBWW1GLElBQVo7QUFDQUEsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQsUUFBSWdMLFVBQVVMLFVBQVUsSUFBVixJQUFrQkQsUUFBUSxJQUExQixJQUFrQ0EsU0FBU0MsTUFBekQ7QUFDQSxRQUFJTSxTQUFTSCxhQUFhLEdBQWIsSUFBb0JBLGFBQWEsR0FBOUM7QUFDQSxRQUFJSSxXQUFXSixhQUFhLEdBQWIsSUFBb0JBLGFBQWEsR0FBaEQ7QUFDQSxRQUFJVCxZQUFZakosSUFBSSxDQUFKLEtBQVVnSixnQkFBMUI7QUFDQSxRQUFJZSxVQUFVUCxXQUFXQyxLQUF6Qjs7QUFFQVYsV0FBT3RQLElBQVAsQ0FBWTtBQUNWb0IsWUFBTUEsUUFBUWtGLEtBREo7QUFFVndKLGNBQVFBLFVBQVUsRUFGUjtBQUdWTixpQkFBV0EsU0FIRDtBQUlWYSxnQkFBVUEsUUFKQTtBQUtWRCxjQUFRQSxNQUxFO0FBTVZELGVBQVNBLE9BTkM7QUFPVkQsZ0JBQVUsQ0FBQyxDQUFDQSxRQVBGO0FBUVZJLGVBQVNBLFVBQVVDLFlBQVlELE9BQVosQ0FBVixHQUFrQ0osV0FBVyxJQUFYLEdBQWtCLE9BQU9NLGFBQWFoQixTQUFiLENBQVAsR0FBaUM7QUFScEYsS0FBWjtBQVVEOztBQUVEO0FBQ0EsTUFBSTNOLFFBQVE4RCxJQUFJdEcsTUFBaEIsRUFBd0I7QUFDdEI4RixZQUFRUSxJQUFJOEssTUFBSixDQUFXNU8sS0FBWCxDQUFSO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJc0QsSUFBSixFQUFVO0FBQ1JtSyxXQUFPdFAsSUFBUCxDQUFZbUYsSUFBWjtBQUNEOztBQUVELFNBQU9tSyxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTUCxPQUFULENBQWtCcEosR0FBbEIsRUFBdUJ5RSxPQUF2QixFQUFnQztBQUM5QixTQUFPNkUsaUJBQWlCSixNQUFNbEosR0FBTixFQUFXeUUsT0FBWCxDQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNzRyx3QkFBVCxDQUFtQy9LLEdBQW5DLEVBQXdDO0FBQ3RDLFNBQU9nTCxVQUFVaEwsR0FBVixFQUFlRSxPQUFmLENBQXVCLFNBQXZCLEVBQWtDLFVBQVVQLENBQVYsRUFBYTtBQUNwRCxXQUFPLE1BQU1BLEVBQUVDLFVBQUYsQ0FBYSxDQUFiLEVBQWdCQyxRQUFoQixDQUF5QixFQUF6QixFQUE2Qm9MLFdBQTdCLEVBQWI7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0MsY0FBVCxDQUF5QmxMLEdBQXpCLEVBQThCO0FBQzVCLFNBQU9nTCxVQUFVaEwsR0FBVixFQUFlRSxPQUFmLENBQXVCLE9BQXZCLEVBQWdDLFVBQVVQLENBQVYsRUFBYTtBQUNsRCxXQUFPLE1BQU1BLEVBQUVDLFVBQUYsQ0FBYSxDQUFiLEVBQWdCQyxRQUFoQixDQUF5QixFQUF6QixFQUE2Qm9MLFdBQTdCLEVBQWI7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRDs7O0FBR0EsU0FBUzNCLGdCQUFULENBQTJCSyxNQUEzQixFQUFtQztBQUNqQztBQUNBLE1BQUl3QixVQUFVLElBQUlqUixLQUFKLENBQVV5UCxPQUFPalEsTUFBakIsQ0FBZDs7QUFFQTtBQUNBLE9BQUssSUFBSVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdVAsT0FBT2pRLE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0QyxRQUFJLE9BQU91UCxPQUFPdlAsQ0FBUCxDQUFQLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDK1EsY0FBUS9RLENBQVIsSUFBYSxJQUFJc1AsTUFBSixDQUFXLFNBQVNDLE9BQU92UCxDQUFQLEVBQVV1USxPQUFuQixHQUE2QixJQUF4QyxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLFVBQVVwSixHQUFWLEVBQWU2SixJQUFmLEVBQXFCO0FBQzFCLFFBQUk1TCxPQUFPLEVBQVg7QUFDQSxRQUFJekIsT0FBT3dELE9BQU8sRUFBbEI7QUFDQSxRQUFJa0QsVUFBVTJHLFFBQVEsRUFBdEI7QUFDQSxRQUFJckwsU0FBUzBFLFFBQVE0RyxNQUFSLEdBQWlCTix3QkFBakIsR0FBNEM5SyxrQkFBekQ7O0FBRUEsU0FBSyxJQUFJN0YsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdVAsT0FBT2pRLE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0QyxVQUFJa1IsUUFBUTNCLE9BQU92UCxDQUFQLENBQVo7O0FBRUEsVUFBSSxPQUFPa1IsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QjlMLGdCQUFROEwsS0FBUjs7QUFFQTtBQUNEOztBQUVELFVBQUlqUCxRQUFRMEIsS0FBS3VOLE1BQU03UCxJQUFYLENBQVo7QUFDQSxVQUFJK0wsT0FBSjs7QUFFQSxVQUFJbkwsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLFlBQUlpUCxNQUFNWixRQUFWLEVBQW9CO0FBQ2xCO0FBQ0EsY0FBSVksTUFBTWQsT0FBVixFQUFtQjtBQUNqQmhMLG9CQUFROEwsTUFBTW5CLE1BQWQ7QUFDRDs7QUFFRDtBQUNELFNBUEQsTUFPTztBQUNMLGdCQUFNLElBQUlvQixTQUFKLENBQWMsZUFBZUQsTUFBTTdQLElBQXJCLEdBQTRCLGlCQUExQyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJc04sUUFBUTFNLEtBQVIsQ0FBSixFQUFvQjtBQUNsQixZQUFJLENBQUNpUCxNQUFNYixNQUFYLEVBQW1CO0FBQ2pCLGdCQUFNLElBQUljLFNBQUosQ0FBYyxlQUFlRCxNQUFNN1AsSUFBckIsR0FBNEIsaUNBQTVCLEdBQWdFK1AsS0FBS0MsU0FBTCxDQUFlcFAsS0FBZixDQUFoRSxHQUF3RixHQUF0RyxDQUFOO0FBQ0Q7O0FBRUQsWUFBSUEsTUFBTTNDLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIsY0FBSTRSLE1BQU1aLFFBQVYsRUFBb0I7QUFDbEI7QUFDRCxXQUZELE1BRU87QUFDTCxrQkFBTSxJQUFJYSxTQUFKLENBQWMsZUFBZUQsTUFBTTdQLElBQXJCLEdBQTRCLG1CQUExQyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxhQUFLLElBQUlpUSxJQUFJLENBQWIsRUFBZ0JBLElBQUlyUCxNQUFNM0MsTUFBMUIsRUFBa0NnUyxHQUFsQyxFQUF1QztBQUNyQ2xFLG9CQUFVekgsT0FBTzFELE1BQU1xUCxDQUFOLENBQVAsQ0FBVjs7QUFFQSxjQUFJLENBQUNQLFFBQVEvUSxDQUFSLEVBQVcyTCxJQUFYLENBQWdCeUIsT0FBaEIsQ0FBTCxFQUErQjtBQUM3QixrQkFBTSxJQUFJK0QsU0FBSixDQUFjLG1CQUFtQkQsTUFBTTdQLElBQXpCLEdBQWdDLGNBQWhDLEdBQWlENlAsTUFBTVgsT0FBdkQsR0FBaUUsbUJBQWpFLEdBQXVGYSxLQUFLQyxTQUFMLENBQWVqRSxPQUFmLENBQXZGLEdBQWlILEdBQS9ILENBQU47QUFDRDs7QUFFRGhJLGtCQUFRLENBQUNrTSxNQUFNLENBQU4sR0FBVUosTUFBTW5CLE1BQWhCLEdBQXlCbUIsTUFBTXpCLFNBQWhDLElBQTZDckMsT0FBckQ7QUFDRDs7QUFFRDtBQUNEOztBQUVEQSxnQkFBVThELE1BQU1mLFFBQU4sR0FBaUJXLGVBQWU3TyxLQUFmLENBQWpCLEdBQXlDMEQsT0FBTzFELEtBQVAsQ0FBbkQ7O0FBRUEsVUFBSSxDQUFDOE8sUUFBUS9RLENBQVIsRUFBVzJMLElBQVgsQ0FBZ0J5QixPQUFoQixDQUFMLEVBQStCO0FBQzdCLGNBQU0sSUFBSStELFNBQUosQ0FBYyxlQUFlRCxNQUFNN1AsSUFBckIsR0FBNEIsY0FBNUIsR0FBNkM2UCxNQUFNWCxPQUFuRCxHQUE2RCxtQkFBN0QsR0FBbUZuRCxPQUFuRixHQUE2RixHQUEzRyxDQUFOO0FBQ0Q7O0FBRURoSSxjQUFROEwsTUFBTW5CLE1BQU4sR0FBZTNDLE9BQXZCO0FBQ0Q7O0FBRUQsV0FBT2hJLElBQVA7QUFDRCxHQW5FRDtBQW9FRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3FMLFlBQVQsQ0FBdUI3SyxHQUF2QixFQUE0QjtBQUMxQixTQUFPQSxJQUFJRSxPQUFKLENBQVksNEJBQVosRUFBMEMsTUFBMUMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTMEssV0FBVCxDQUFzQlAsS0FBdEIsRUFBNkI7QUFDM0IsU0FBT0EsTUFBTW5LLE9BQU4sQ0FBYyxlQUFkLEVBQStCLE1BQS9CLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVN5TCxVQUFULENBQXFCQyxFQUFyQixFQUF5QnBLLElBQXpCLEVBQStCO0FBQzdCb0ssS0FBR3BLLElBQUgsR0FBVUEsSUFBVjtBQUNBLFNBQU9vSyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNDLEtBQVQsQ0FBZ0JwSCxPQUFoQixFQUF5QjtBQUN2QixTQUFPQSxRQUFRcUgsU0FBUixHQUFvQixFQUFwQixHQUF5QixHQUFoQztBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU0MsY0FBVCxDQUF5QnZNLElBQXpCLEVBQStCZ0MsSUFBL0IsRUFBcUM7QUFDbkM7QUFDQSxNQUFJd0ssU0FBU3hNLEtBQUt5TSxNQUFMLENBQVlDLEtBQVosQ0FBa0IsV0FBbEIsQ0FBYjs7QUFFQSxNQUFJRixNQUFKLEVBQVk7QUFDVixTQUFLLElBQUk1UixJQUFJLENBQWIsRUFBZ0JBLElBQUk0UixPQUFPdFMsTUFBM0IsRUFBbUNVLEdBQW5DLEVBQXdDO0FBQ3RDb0gsV0FBS25ILElBQUwsQ0FBVTtBQUNSb0IsY0FBTXJCLENBREU7QUFFUitQLGdCQUFRLElBRkE7QUFHUk4sbUJBQVcsSUFISDtBQUlSYSxrQkFBVSxLQUpGO0FBS1JELGdCQUFRLEtBTEE7QUFNUkQsaUJBQVMsS0FORDtBQU9SRCxrQkFBVSxLQVBGO0FBUVJJLGlCQUFTO0FBUkQsT0FBVjtBQVVEO0FBQ0Y7O0FBRUQsU0FBT2dCLFdBQVduTSxJQUFYLEVBQWlCZ0MsSUFBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVMySyxhQUFULENBQXdCM00sSUFBeEIsRUFBOEJnQyxJQUE5QixFQUFvQ2lELE9BQXBDLEVBQTZDO0FBQzNDLE1BQUl4RCxRQUFRLEVBQVo7O0FBRUEsT0FBSyxJQUFJN0csSUFBSSxDQUFiLEVBQWdCQSxJQUFJb0YsS0FBSzlGLE1BQXpCLEVBQWlDVSxHQUFqQyxFQUFzQztBQUNwQzZHLFVBQU01RyxJQUFOLENBQVcyTyxhQUFheEosS0FBS3BGLENBQUwsQ0FBYixFQUFzQm9ILElBQXRCLEVBQTRCaUQsT0FBNUIsRUFBcUN3SCxNQUFoRDtBQUNEOztBQUVELE1BQUlHLFNBQVMsSUFBSTFDLE1BQUosQ0FBVyxRQUFRekksTUFBTUcsSUFBTixDQUFXLEdBQVgsQ0FBUixHQUEwQixHQUFyQyxFQUEwQ3lLLE1BQU1wSCxPQUFOLENBQTFDLENBQWI7O0FBRUEsU0FBT2tILFdBQVdTLE1BQVgsRUFBbUI1SyxJQUFuQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBUzZLLGNBQVQsQ0FBeUI3TSxJQUF6QixFQUErQmdDLElBQS9CLEVBQXFDaUQsT0FBckMsRUFBOEM7QUFDNUMsU0FBTytFLGVBQWVOLE1BQU0xSixJQUFOLEVBQVlpRixPQUFaLENBQWYsRUFBcUNqRCxJQUFyQyxFQUEyQ2lELE9BQTNDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTK0UsY0FBVCxDQUF5QkcsTUFBekIsRUFBaUNuSSxJQUFqQyxFQUF1Q2lELE9BQXZDLEVBQWdEO0FBQzlDLE1BQUksQ0FBQ3NFLFFBQVF2SCxJQUFSLENBQUwsRUFBb0I7QUFDbEJpRCxjQUFVLHNCQUF3QmpELFFBQVFpRCxPQUExQztBQUNBakQsV0FBTyxFQUFQO0FBQ0Q7O0FBRURpRCxZQUFVQSxXQUFXLEVBQXJCOztBQUVBLE1BQUk2SCxTQUFTN0gsUUFBUTZILE1BQXJCO0FBQ0EsTUFBSUMsTUFBTTlILFFBQVE4SCxHQUFSLEtBQWdCLEtBQTFCO0FBQ0EsTUFBSXRPLFFBQVEsRUFBWjs7QUFFQTtBQUNBLE9BQUssSUFBSTdELElBQUksQ0FBYixFQUFnQkEsSUFBSXVQLE9BQU9qUSxNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsUUFBSWtSLFFBQVEzQixPQUFPdlAsQ0FBUCxDQUFaOztBQUVBLFFBQUksT0FBT2tSLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0JyTixlQUFTNE0sYUFBYVMsS0FBYixDQUFUO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSW5CLFNBQVNVLGFBQWFTLE1BQU1uQixNQUFuQixDQUFiO0FBQ0EsVUFBSUMsVUFBVSxRQUFRa0IsTUFBTVgsT0FBZCxHQUF3QixHQUF0Qzs7QUFFQW5KLFdBQUtuSCxJQUFMLENBQVVpUixLQUFWOztBQUVBLFVBQUlBLE1BQU1iLE1BQVYsRUFBa0I7QUFDaEJMLG1CQUFXLFFBQVFELE1BQVIsR0FBaUJDLE9BQWpCLEdBQTJCLElBQXRDO0FBQ0Q7O0FBRUQsVUFBSWtCLE1BQU1aLFFBQVYsRUFBb0I7QUFDbEIsWUFBSSxDQUFDWSxNQUFNZCxPQUFYLEVBQW9CO0FBQ2xCSixvQkFBVSxRQUFRRCxNQUFSLEdBQWlCLEdBQWpCLEdBQXVCQyxPQUF2QixHQUFpQyxLQUEzQztBQUNELFNBRkQsTUFFTztBQUNMQSxvQkFBVUQsU0FBUyxHQUFULEdBQWVDLE9BQWYsR0FBeUIsSUFBbkM7QUFDRDtBQUNGLE9BTkQsTUFNTztBQUNMQSxrQkFBVUQsU0FBUyxHQUFULEdBQWVDLE9BQWYsR0FBeUIsR0FBbkM7QUFDRDs7QUFFRG5NLGVBQVNtTSxPQUFUO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJUCxZQUFZZ0IsYUFBYXBHLFFBQVFvRixTQUFSLElBQXFCLEdBQWxDLENBQWhCO0FBQ0EsTUFBSTJDLG9CQUFvQnZPLE1BQU0wRCxLQUFOLENBQVksQ0FBQ2tJLFVBQVVuUSxNQUF2QixNQUFtQ21RLFNBQTNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxDQUFDeUMsTUFBTCxFQUFhO0FBQ1hyTyxZQUFRLENBQUN1TyxvQkFBb0J2TyxNQUFNMEQsS0FBTixDQUFZLENBQVosRUFBZSxDQUFDa0ksVUFBVW5RLE1BQTFCLENBQXBCLEdBQXdEdUUsS0FBekQsSUFBa0UsS0FBbEUsR0FBMEU0TCxTQUExRSxHQUFzRixTQUE5RjtBQUNEOztBQUVELE1BQUkwQyxHQUFKLEVBQVM7QUFDUHRPLGFBQVMsR0FBVDtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQUEsYUFBU3FPLFVBQVVFLGlCQUFWLEdBQThCLEVBQTlCLEdBQW1DLFFBQVEzQyxTQUFSLEdBQW9CLEtBQWhFO0FBQ0Q7O0FBRUQsU0FBTzhCLFdBQVcsSUFBSWpDLE1BQUosQ0FBVyxNQUFNekwsS0FBakIsRUFBd0I0TixNQUFNcEgsT0FBTixDQUF4QixDQUFYLEVBQW9EakQsSUFBcEQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFTd0gsWUFBVCxDQUF1QnhKLElBQXZCLEVBQTZCZ0MsSUFBN0IsRUFBbUNpRCxPQUFuQyxFQUE0QztBQUMxQyxNQUFJLENBQUNzRSxRQUFRdkgsSUFBUixDQUFMLEVBQW9CO0FBQ2xCaUQsY0FBVSxzQkFBd0JqRCxRQUFRaUQsT0FBMUM7QUFDQWpELFdBQU8sRUFBUDtBQUNEOztBQUVEaUQsWUFBVUEsV0FBVyxFQUFyQjs7QUFFQSxNQUFJakYsZ0JBQWdCa0ssTUFBcEIsRUFBNEI7QUFDMUIsV0FBT3FDLGVBQWV2TSxJQUFmLEVBQXFCLHFCQUF1QmdDLElBQTVDLENBQVA7QUFDRDs7QUFFRCxNQUFJdUgsUUFBUXZKLElBQVIsQ0FBSixFQUFtQjtBQUNqQixXQUFPMk0sZUFBYyxxQkFBdUIzTSxJQUFyQyxFQUE0QyxxQkFBdUJnQyxJQUFuRSxFQUEwRWlELE9BQTFFLENBQVA7QUFDRDs7QUFFRCxTQUFPNEgsZ0JBQWUscUJBQXVCN00sSUFBdEMsRUFBNkMscUJBQXVCZ0MsSUFBcEUsRUFBMkVpRCxPQUEzRSxDQUFQO0FBQ0Q7O0FBRUR2SSxNQUFNZ04sS0FBTixHQUFjRCxPQUFkO0FBQ0EvTSxNQUFNa04sT0FBTixHQUFnQkQsU0FBaEI7QUFDQWpOLE1BQU1vTixnQkFBTixHQUF5QkQsa0JBQXpCO0FBQ0FuTixNQUFNc04sY0FBTixHQUF1QkQsZ0JBQXZCOztBQUVBOztBQUVBLElBQUlrRCxjQUFjdFEsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQWxCOztBQUVBLFNBQVN3RSxhQUFULENBQXdCbE4sSUFBeEIsRUFBOEI7QUFDNUIsTUFBSW1OLE1BQU1GLFlBQVlqTixJQUFaLENBQVY7QUFDQSxNQUFJZ0MsSUFBSixFQUFVNEssTUFBVjs7QUFFQSxNQUFJTyxHQUFKLEVBQVM7QUFDUG5MLFdBQU9tTCxJQUFJbkwsSUFBWDtBQUNBNEssYUFBU08sSUFBSVAsTUFBYjtBQUNELEdBSEQsTUFHTztBQUNMNUssV0FBTyxFQUFQO0FBQ0E0SyxhQUFTbFEsTUFBTXNELElBQU4sRUFBWWdDLElBQVosQ0FBVDtBQUNBaUwsZ0JBQVlqTixJQUFaLElBQW9CLEVBQUVnQyxNQUFNQSxJQUFSLEVBQWM0SyxRQUFRQSxNQUF0QixFQUFwQjtBQUNEOztBQUVELFNBQU8sRUFBRTVLLE1BQU1BLElBQVIsRUFBYzRLLFFBQVFBLE1BQXRCLEVBQVA7QUFDRDs7QUFFRCxJQUFJUSxxQkFBcUJ6USxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBekI7O0FBRUEsU0FBUzJFLFVBQVQsQ0FDRXJOLElBREYsRUFFRUQsTUFGRixFQUdFdU4sUUFIRixFQUlFO0FBQ0EsTUFBSTtBQUNGLFFBQUlDLFNBQ0ZILG1CQUFtQnBOLElBQW5CLE1BQ0NvTixtQkFBbUJwTixJQUFuQixJQUEyQnRELE1BQU1rTixPQUFOLENBQWM1SixJQUFkLENBRDVCLENBREY7QUFHQSxXQUFPdU4sT0FBT3hOLFVBQVUsRUFBakIsRUFBcUIsRUFBRThMLFFBQVEsSUFBVixFQUFyQixDQUFQO0FBQ0QsR0FMRCxDQUtFLE9BQU92UyxDQUFQLEVBQVU7QUFDVixRQUFJVCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3ZELFdBQUssS0FBTCxFQUFhLHVCQUF1QjJQLFFBQXZCLEdBQWtDLElBQWxDLEdBQTBDaFUsRUFBRW9FLE9BQXpEO0FBQ0Q7QUFDRCxXQUFPLEVBQVA7QUFDRDtBQUNGOztBQUVEOztBQUVBLFNBQVM4UCxpQkFBVCxDQUNFQyxHQURGLEVBRUU3SixPQUZGLEVBR0VZLE1BSEYsRUFJRTtBQUNBLE1BQUlrRyxPQUFPLE9BQU8rQyxHQUFQLEtBQWUsUUFBZixHQUEwQixFQUFFek4sTUFBTXlOLEdBQVIsRUFBMUIsR0FBMENBLEdBQXJEO0FBQ0E7QUFDQSxNQUFJL0MsS0FBS3pPLElBQUwsSUFBYXlPLEtBQUtnRCxXQUF0QixFQUFtQztBQUNqQyxXQUFPaEQsSUFBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSSxDQUFDQSxLQUFLMUssSUFBTixJQUFjMEssS0FBSzNLLE1BQW5CLElBQTZCNkQsT0FBakMsRUFBMEM7QUFDeEM4RyxXQUFPaUQsT0FBTyxFQUFQLEVBQVdqRCxJQUFYLENBQVA7QUFDQUEsU0FBS2dELFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxRQUFJM04sU0FBUzROLE9BQU9BLE9BQU8sRUFBUCxFQUFXL0osUUFBUTdELE1BQW5CLENBQVAsRUFBbUMySyxLQUFLM0ssTUFBeEMsQ0FBYjtBQUNBLFFBQUk2RCxRQUFRM0gsSUFBWixFQUFrQjtBQUNoQnlPLFdBQUt6TyxJQUFMLEdBQVkySCxRQUFRM0gsSUFBcEI7QUFDQXlPLFdBQUszSyxNQUFMLEdBQWNBLE1BQWQ7QUFDRCxLQUhELE1BR08sSUFBSTZELFFBQVF2RyxPQUFaLEVBQXFCO0FBQzFCLFVBQUl1USxVQUFVaEssUUFBUXZHLE9BQVIsQ0FBZ0J1RyxRQUFRdkcsT0FBUixDQUFnQm5ELE1BQWhCLEdBQXlCLENBQXpDLEVBQTRDOEYsSUFBMUQ7QUFDQTBLLFdBQUsxSyxJQUFMLEdBQVlxTixXQUFXTyxPQUFYLEVBQW9CN04sTUFBcEIsRUFBNkIsVUFBVzZELFFBQVE1RCxJQUFoRCxDQUFaO0FBQ0QsS0FITSxNQUdBLElBQUluSCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRHZELFdBQUssS0FBTCxFQUFZLHNEQUFaO0FBQ0Q7QUFDRCxXQUFPK00sSUFBUDtBQUNEOztBQUVELE1BQUltRCxhQUFhNUYsVUFBVXlDLEtBQUsxSyxJQUFMLElBQWEsRUFBdkIsQ0FBakI7QUFDQSxNQUFJOE4sV0FBWWxLLFdBQVdBLFFBQVE1RCxJQUFwQixJQUE2QixHQUE1QztBQUNBLE1BQUlBLE9BQU82TixXQUFXN04sSUFBWCxHQUNQeUgsWUFBWW9HLFdBQVc3TixJQUF2QixFQUE2QjhOLFFBQTdCLEVBQXVDdEosVUFBVWtHLEtBQUtsRyxNQUF0RCxDQURPLEdBRU5aLFdBQVdBLFFBQVE1RCxJQUFwQixJQUE2QixHQUZqQztBQUdBLE1BQUljLFFBQVFELGFBQWFnTixXQUFXL00sS0FBeEIsRUFBK0I0SixLQUFLNUosS0FBcEMsQ0FBWjtBQUNBLE1BQUkrQixPQUFPNkgsS0FBSzdILElBQUwsSUFBYWdMLFdBQVdoTCxJQUFuQztBQUNBLE1BQUlBLFFBQVFBLEtBQUsrRSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUEvQixFQUFvQztBQUNsQy9FLFdBQU8sTUFBTUEsSUFBYjtBQUNEOztBQUVELFNBQU87QUFDTDZLLGlCQUFhLElBRFI7QUFFTDFOLFVBQU1BLElBRkQ7QUFHTGMsV0FBT0EsS0FIRjtBQUlMK0IsVUFBTUE7QUFKRCxHQUFQO0FBTUQ7O0FBRUQsU0FBUzhLLE1BQVQsQ0FBaUJ0SyxDQUFqQixFQUFvQkMsQ0FBcEIsRUFBdUI7QUFDckIsT0FBSyxJQUFJbkMsR0FBVCxJQUFnQm1DLENBQWhCLEVBQW1CO0FBQ2pCRCxNQUFFbEMsR0FBRixJQUFTbUMsRUFBRW5DLEdBQUYsQ0FBVDtBQUNEO0FBQ0QsU0FBT2tDLENBQVA7QUFDRDs7QUFFRDs7QUFFQSxTQUFTMEssYUFBVCxDQUF3QnpGLE1BQXhCLEVBQWdDO0FBQzlCLE1BQUlsSyxNQUFNaUssZUFBZUMsTUFBZixDQUFWO0FBQ0EsTUFBSUcsVUFBVXJLLElBQUlxSyxPQUFsQjtBQUNBLE1BQUlFLFVBQVV2SyxJQUFJdUssT0FBbEI7O0FBRUEsV0FBU3FGLFNBQVQsQ0FBb0IxRixNQUFwQixFQUE0QjtBQUMxQkQsbUJBQWVDLE1BQWYsRUFBdUJHLE9BQXZCLEVBQWdDRSxPQUFoQztBQUNEOztBQUVELFdBQVMrRCxLQUFULENBQ0VlLEdBREYsRUFFRVEsWUFGRixFQUdFdEwsY0FIRixFQUlFO0FBQ0EsUUFBSUQsV0FBVzhLLGtCQUFrQkMsR0FBbEIsRUFBdUJRLFlBQXZCLENBQWY7QUFDQSxRQUFJaFMsT0FBT3lHLFNBQVN6RyxJQUFwQjs7QUFFQSxRQUFJQSxJQUFKLEVBQVU7QUFDUixVQUFJd0csU0FBU2tHLFFBQVExTSxJQUFSLENBQWI7QUFDQSxVQUFJcEQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN2RCxhQUFLOEUsTUFBTCxFQUFjLHNCQUFzQnhHLElBQXRCLEdBQTZCLGtCQUEzQztBQUNEO0FBQ0QsVUFBSWlTLGFBQWFoQixjQUFjekssT0FBT3pDLElBQXJCLEVBQTJCZ0MsSUFBM0IsQ0FDZEssTUFEYyxDQUNQLFVBQVVsQixHQUFWLEVBQWU7QUFBRSxlQUFPLENBQUNBLElBQUkrSixRQUFaO0FBQXVCLE9BRGpDLEVBRWRqSixHQUZjLENBRVYsVUFBVWQsR0FBVixFQUFlO0FBQUUsZUFBT0EsSUFBSWxGLElBQVg7QUFBa0IsT0FGekIsQ0FBakI7O0FBSUEsVUFBSSxPQUFPeUcsU0FBUzNDLE1BQWhCLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDMkMsaUJBQVMzQyxNQUFULEdBQWtCLEVBQWxCO0FBQ0Q7O0FBRUQsVUFBSWtPLGdCQUFnQixPQUFPQSxhQUFhbE8sTUFBcEIsS0FBK0IsUUFBbkQsRUFBNkQ7QUFDM0QsYUFBSyxJQUFJb0IsR0FBVCxJQUFnQjhNLGFBQWFsTyxNQUE3QixFQUFxQztBQUNuQyxjQUFJLEVBQUVvQixPQUFPdUIsU0FBUzNDLE1BQWxCLEtBQTZCbU8sV0FBV3BLLE9BQVgsQ0FBbUIzQyxHQUFuQixJQUEwQixDQUFDLENBQTVELEVBQStEO0FBQzdEdUIscUJBQVMzQyxNQUFULENBQWdCb0IsR0FBaEIsSUFBdUI4TSxhQUFhbE8sTUFBYixDQUFvQm9CLEdBQXBCLENBQXZCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQUlzQixNQUFKLEVBQVk7QUFDVkMsaUJBQVMxQyxJQUFULEdBQWdCcU4sV0FBVzVLLE9BQU96QyxJQUFsQixFQUF3QjBDLFNBQVMzQyxNQUFqQyxFQUEwQyxtQkFBbUI5RCxJQUFuQixHQUEwQixJQUFwRSxDQUFoQjtBQUNBLGVBQU9rUyxhQUFhMUwsTUFBYixFQUFxQkMsUUFBckIsRUFBK0JDLGNBQS9CLENBQVA7QUFDRDtBQUNGLEtBekJELE1BeUJPLElBQUlELFNBQVMxQyxJQUFiLEVBQW1CO0FBQ3hCMEMsZUFBUzNDLE1BQVQsR0FBa0IsRUFBbEI7QUFDQSxXQUFLLElBQUlDLElBQVQsSUFBaUJ5SSxPQUFqQixFQUEwQjtBQUN4QixZQUFJMkYsV0FBV3BPLElBQVgsRUFBaUIwQyxTQUFTM0MsTUFBMUIsRUFBa0MyQyxTQUFTMUMsSUFBM0MsQ0FBSixFQUFzRDtBQUNwRCxpQkFBT21PLGFBQWExRixRQUFRekksSUFBUixDQUFiLEVBQTRCMEMsUUFBNUIsRUFBc0NDLGNBQXRDLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBLFdBQU93TCxhQUFhLElBQWIsRUFBbUJ6TCxRQUFuQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU3FHLFFBQVQsQ0FDRXRHLE1BREYsRUFFRUMsUUFGRixFQUdFO0FBQ0EsUUFBSTJMLG1CQUFtQjVMLE9BQU9zRyxRQUE5QjtBQUNBLFFBQUlBLFdBQVcsT0FBT3NGLGdCQUFQLEtBQTRCLFVBQTVCLEdBQ1RBLGlCQUFpQjdMLFlBQVlDLE1BQVosRUFBb0JDLFFBQXBCLENBQWpCLENBRFMsR0FFVDJMLGdCQUZOOztBQUlBLFFBQUksT0FBT3RGLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaENBLGlCQUFXLEVBQUUvSSxNQUFNK0ksUUFBUixFQUFYO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDQSxRQUFELElBQWEsT0FBT0EsUUFBUCxLQUFvQixRQUFyQyxFQUErQztBQUM3Q2xRLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsS0FEdUMsRUFDL0IsOEJBQStCcU8sS0FBS0MsU0FBTCxDQUFlbEQsUUFBZixDQURBLENBQXpDO0FBR0EsYUFBT29GLGFBQWEsSUFBYixFQUFtQnpMLFFBQW5CLENBQVA7QUFDRDs7QUFFRCxRQUFJMEosS0FBS3JELFFBQVQ7QUFDQSxRQUFJOU0sT0FBT21RLEdBQUduUSxJQUFkO0FBQ0EsUUFBSStELE9BQU9vTSxHQUFHcE0sSUFBZDtBQUNBLFFBQUljLFFBQVE0QixTQUFTNUIsS0FBckI7QUFDQSxRQUFJK0IsT0FBT0gsU0FBU0csSUFBcEI7QUFDQSxRQUFJOUMsU0FBUzJDLFNBQVMzQyxNQUF0QjtBQUNBZSxZQUFRc0wsR0FBR2tDLGNBQUgsQ0FBa0IsT0FBbEIsSUFBNkJsQyxHQUFHdEwsS0FBaEMsR0FBd0NBLEtBQWhEO0FBQ0ErQixXQUFPdUosR0FBR2tDLGNBQUgsQ0FBa0IsTUFBbEIsSUFBNEJsQyxHQUFHdkosSUFBL0IsR0FBc0NBLElBQTdDO0FBQ0E5QyxhQUFTcU0sR0FBR2tDLGNBQUgsQ0FBa0IsUUFBbEIsSUFBOEJsQyxHQUFHck0sTUFBakMsR0FBMENBLE1BQW5EOztBQUVBLFFBQUk5RCxJQUFKLEVBQVU7QUFDUjtBQUNBLFVBQUlzUyxlQUFlNUYsUUFBUTFNLElBQVIsQ0FBbkI7QUFDQSxVQUFJcEQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMxRCxlQUFPK1EsWUFBUCxFQUFzQixvQ0FBb0N0UyxJQUFwQyxHQUEyQyxlQUFqRTtBQUNEO0FBQ0QsYUFBT3lRLE1BQU07QUFDWGdCLHFCQUFhLElBREY7QUFFWHpSLGNBQU1BLElBRks7QUFHWDZFLGVBQU9BLEtBSEk7QUFJWCtCLGNBQU1BLElBSks7QUFLWDlDLGdCQUFRQTtBQUxHLE9BQU4sRUFNSkgsU0FOSSxFQU1POEMsUUFOUCxDQUFQO0FBT0QsS0FiRCxNQWFPLElBQUkxQyxJQUFKLEVBQVU7QUFDZjtBQUNBLFVBQUk0TixVQUFVWSxrQkFBa0J4TyxJQUFsQixFQUF3QnlDLE1BQXhCLENBQWQ7QUFDQTtBQUNBLFVBQUlnTSxlQUFlcEIsV0FBV08sT0FBWCxFQUFvQjdOLE1BQXBCLEVBQTZCLGdDQUFnQzZOLE9BQWhDLEdBQTBDLElBQXZFLENBQW5CO0FBQ0E7QUFDQSxhQUFPbEIsTUFBTTtBQUNYZ0IscUJBQWEsSUFERjtBQUVYMU4sY0FBTXlPLFlBRks7QUFHWDNOLGVBQU9BLEtBSEk7QUFJWCtCLGNBQU1BO0FBSkssT0FBTixFQUtKakQsU0FMSSxFQUtPOEMsUUFMUCxDQUFQO0FBTUQsS0FaTSxNQVlBO0FBQ0wvRSxXQUFLLEtBQUwsRUFBYSw4QkFBK0JxTyxLQUFLQyxTQUFMLENBQWVsRCxRQUFmLENBQTVDO0FBQ0EsYUFBT29GLGFBQWEsSUFBYixFQUFtQnpMLFFBQW5CLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQVN5RyxLQUFULENBQ0UxRyxNQURGLEVBRUVDLFFBRkYsRUFHRW1HLE9BSEYsRUFJRTtBQUNBLFFBQUk2RixjQUFjckIsV0FBV3hFLE9BQVgsRUFBb0JuRyxTQUFTM0MsTUFBN0IsRUFBc0MsK0JBQStCOEksT0FBL0IsR0FBeUMsSUFBL0UsQ0FBbEI7QUFDQSxRQUFJOEYsZUFBZWpDLE1BQU07QUFDdkJnQixtQkFBYSxJQURVO0FBRXZCMU4sWUFBTTBPO0FBRmlCLEtBQU4sQ0FBbkI7QUFJQSxRQUFJQyxZQUFKLEVBQWtCO0FBQ2hCLFVBQUl0UixVQUFVc1IsYUFBYXRSLE9BQTNCO0FBQ0EsVUFBSXVSLGdCQUFnQnZSLFFBQVFBLFFBQVFuRCxNQUFSLEdBQWlCLENBQXpCLENBQXBCO0FBQ0F3SSxlQUFTM0MsTUFBVCxHQUFrQjRPLGFBQWE1TyxNQUEvQjtBQUNBLGFBQU9vTyxhQUFhUyxhQUFiLEVBQTRCbE0sUUFBNUIsQ0FBUDtBQUNEO0FBQ0QsV0FBT3lMLGFBQWEsSUFBYixFQUFtQnpMLFFBQW5CLENBQVA7QUFDRDs7QUFFRCxXQUFTeUwsWUFBVCxDQUNFMUwsTUFERixFQUVFQyxRQUZGLEVBR0VDLGNBSEYsRUFJRTtBQUNBLFFBQUlGLFVBQVVBLE9BQU9zRyxRQUFyQixFQUErQjtBQUM3QixhQUFPQSxTQUFTdEcsTUFBVCxFQUFpQkUsa0JBQWtCRCxRQUFuQyxDQUFQO0FBQ0Q7QUFDRCxRQUFJRCxVQUFVQSxPQUFPb0csT0FBckIsRUFBOEI7QUFDNUIsYUFBT00sTUFBTTFHLE1BQU4sRUFBY0MsUUFBZCxFQUF3QkQsT0FBT29HLE9BQS9CLENBQVA7QUFDRDtBQUNELFdBQU9yRyxZQUFZQyxNQUFaLEVBQW9CQyxRQUFwQixFQUE4QkMsY0FBOUIsQ0FBUDtBQUNEOztBQUVELFNBQU87QUFDTCtKLFdBQU9BLEtBREY7QUFFTHNCLGVBQVdBO0FBRk4sR0FBUDtBQUlEOztBQUVELFNBQVNJLFVBQVQsQ0FDRXBPLElBREYsRUFFRUQsTUFGRixFQUdFOE8sUUFIRixFQUlFO0FBQ0EsTUFBSXpRLE1BQU04TyxjQUFjbE4sSUFBZCxDQUFWO0FBQ0EsTUFBSTRNLFNBQVN4TyxJQUFJd08sTUFBakI7QUFDQSxNQUFJNUssT0FBTzVELElBQUk0RCxJQUFmO0FBQ0EsTUFBSXVJLElBQUlzRSxTQUFTbkMsS0FBVCxDQUFlRSxNQUFmLENBQVI7O0FBRUEsTUFBSSxDQUFDckMsQ0FBTCxFQUFRO0FBQ04sV0FBTyxLQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUksQ0FBQ3hLLE1BQUwsRUFBYTtBQUNsQixXQUFPLElBQVA7QUFDRDs7QUFFRCxPQUFLLElBQUluRixJQUFJLENBQVIsRUFBV04sTUFBTWlRLEVBQUVyUSxNQUF4QixFQUFnQ1UsSUFBSU4sR0FBcEMsRUFBeUMsRUFBRU0sQ0FBM0MsRUFBOEM7QUFDNUMsUUFBSXVHLE1BQU1hLEtBQUtwSCxJQUFJLENBQVQsQ0FBVjtBQUNBLFFBQUkrRyxNQUFNLE9BQU80SSxFQUFFM1AsQ0FBRixDQUFQLEtBQWdCLFFBQWhCLEdBQTJCZ0csbUJBQW1CMkosRUFBRTNQLENBQUYsQ0FBbkIsQ0FBM0IsR0FBc0QyUCxFQUFFM1AsQ0FBRixDQUFoRTtBQUNBLFFBQUl1RyxHQUFKLEVBQVM7QUFBRXBCLGFBQU9vQixJQUFJbEYsSUFBWCxJQUFtQjBGLEdBQW5CO0FBQXlCO0FBQ3JDOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVM2TSxpQkFBVCxDQUE0QnhPLElBQTVCLEVBQWtDeUMsTUFBbEMsRUFBMEM7QUFDeEMsU0FBT2dGLFlBQVl6SCxJQUFaLEVBQWtCeUMsT0FBT25FLE1BQVAsR0FBZ0JtRSxPQUFPbkUsTUFBUCxDQUFjMEIsSUFBOUIsR0FBcUMsR0FBdkQsRUFBNEQsSUFBNUQsQ0FBUDtBQUNEOztBQUVEOztBQUdBLElBQUk4TyxnQkFBZ0JuUyxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBcEI7O0FBRUEsU0FBU3FHLFdBQVQsR0FBd0I7QUFDdEJ2SCxTQUFPd0gsZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0MsVUFBVTFWLENBQVYsRUFBYTtBQUMvQzJWO0FBQ0EsUUFBSTNWLEVBQUU0VixLQUFGLElBQVc1VixFQUFFNFYsS0FBRixDQUFRL04sR0FBdkIsRUFBNEI7QUFDMUJnTyxrQkFBWTdWLEVBQUU0VixLQUFGLENBQVEvTixHQUFwQjtBQUNEO0FBQ0YsR0FMRDtBQU1EOztBQUVELFNBQVNpTyxZQUFULENBQ0V4SyxNQURGLEVBRUVULEVBRkYsRUFHRWtMLElBSEYsRUFJRUMsS0FKRixFQUtFO0FBQ0EsTUFBSSxDQUFDMUssT0FBTzJLLEdBQVosRUFBaUI7QUFDZjtBQUNEOztBQUVELE1BQUlDLFdBQVc1SyxPQUFPSyxPQUFQLENBQWV3SyxjQUE5QjtBQUNBLE1BQUksQ0FBQ0QsUUFBTCxFQUFlO0FBQ2I7QUFDRDs7QUFFRCxNQUFJM1csUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMxRCxXQUFPLE9BQU9nUyxRQUFQLEtBQW9CLFVBQTNCLEVBQXVDLG1DQUF2QztBQUNEOztBQUVEO0FBQ0E1SyxTQUFPMkssR0FBUCxDQUFXRyxTQUFYLENBQXFCLFlBQVk7QUFDL0IsUUFBSUMsV0FBV0MsbUJBQWY7QUFDQSxRQUFJQyxlQUFlTCxTQUFTckwsRUFBVCxFQUFha0wsSUFBYixFQUFtQkMsUUFBUUssUUFBUixHQUFtQixJQUF0QyxDQUFuQjtBQUNBLFFBQUksQ0FBQ0UsWUFBTCxFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsUUFBSUMsV0FBVyxPQUFPRCxZQUFQLEtBQXdCLFFBQXZDO0FBQ0EsUUFBSUMsWUFBWSxPQUFPRCxhQUFhRSxRQUFwQixLQUFpQyxRQUFqRCxFQUEyRDtBQUN6RCxVQUFJQyxLQUFLQyxTQUFTQyxhQUFULENBQXVCTCxhQUFhRSxRQUFwQyxDQUFUO0FBQ0EsVUFBSUMsRUFBSixFQUFRO0FBQ05MLG1CQUFXUSxtQkFBbUJILEVBQW5CLENBQVg7QUFDRCxPQUZELE1BRU8sSUFBSUksZ0JBQWdCUCxZQUFoQixDQUFKLEVBQW1DO0FBQ3hDRixtQkFBV1Usa0JBQWtCUixZQUFsQixDQUFYO0FBQ0Q7QUFDRixLQVBELE1BT08sSUFBSUMsWUFBWU0sZ0JBQWdCUCxZQUFoQixDQUFoQixFQUErQztBQUNwREYsaUJBQVdVLGtCQUFrQlIsWUFBbEIsQ0FBWDtBQUNEOztBQUVELFFBQUlGLFFBQUosRUFBYztBQUNabkksYUFBTzhJLFFBQVAsQ0FBZ0JYLFNBQVNyTixDQUF6QixFQUE0QnFOLFNBQVNZLENBQXJDO0FBQ0Q7QUFDRixHQXJCRDtBQXNCRDs7QUFFRCxTQUFTdEIsa0JBQVQsR0FBK0I7QUFDN0IsTUFBSTlOLE1BQU1xUCxhQUFWO0FBQ0EsTUFBSXJQLEdBQUosRUFBUztBQUNQMk4sa0JBQWMzTixHQUFkLElBQXFCO0FBQ25CbUIsU0FBR2tGLE9BQU9pSixXQURTO0FBRW5CRixTQUFHL0ksT0FBT2tKO0FBRlMsS0FBckI7QUFJRDtBQUNGOztBQUVELFNBQVNkLGlCQUFULEdBQThCO0FBQzVCLE1BQUl6TyxNQUFNcVAsYUFBVjtBQUNBLE1BQUlyUCxHQUFKLEVBQVM7QUFDUCxXQUFPMk4sY0FBYzNOLEdBQWQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2dQLGtCQUFULENBQTZCSCxFQUE3QixFQUFpQztBQUMvQixNQUFJVyxRQUFRVixTQUFTVyxlQUFyQjtBQUNBLE1BQUlDLFVBQVVGLE1BQU1HLHFCQUFOLEVBQWQ7QUFDQSxNQUFJQyxTQUFTZixHQUFHYyxxQkFBSCxFQUFiO0FBQ0EsU0FBTztBQUNMeE8sT0FBR3lPLE9BQU9DLElBQVAsR0FBY0gsUUFBUUcsSUFEcEI7QUFFTFQsT0FBR1EsT0FBT0UsR0FBUCxHQUFhSixRQUFRSTtBQUZuQixHQUFQO0FBSUQ7O0FBRUQsU0FBU2IsZUFBVCxDQUEwQnJPLEdBQTFCLEVBQStCO0FBQzdCLFNBQU9tUCxTQUFTblAsSUFBSU8sQ0FBYixLQUFtQjRPLFNBQVNuUCxJQUFJd08sQ0FBYixDQUExQjtBQUNEOztBQUVELFNBQVNGLGlCQUFULENBQTRCdE8sR0FBNUIsRUFBaUM7QUFDL0IsU0FBTztBQUNMTyxPQUFHNE8sU0FBU25QLElBQUlPLENBQWIsSUFBa0JQLElBQUlPLENBQXRCLEdBQTBCa0YsT0FBT2lKLFdBRC9CO0FBRUxGLE9BQUdXLFNBQVNuUCxJQUFJd08sQ0FBYixJQUFrQnhPLElBQUl3TyxDQUF0QixHQUEwQi9JLE9BQU9rSjtBQUYvQixHQUFQO0FBSUQ7O0FBRUQsU0FBU1EsUUFBVCxDQUFtQkMsQ0FBbkIsRUFBc0I7QUFDcEIsU0FBTyxPQUFPQSxDQUFQLEtBQWEsUUFBcEI7QUFDRDs7QUFFRDs7QUFFQSxJQUFJQyxvQkFBb0I3SixhQUFjLFlBQVk7QUFDaEQsTUFBSThKLEtBQUs3SixPQUFPOEosU0FBUCxDQUFpQkMsU0FBMUI7O0FBRUEsTUFDRSxDQUFDRixHQUFHdk4sT0FBSCxDQUFXLFlBQVgsTUFBNkIsQ0FBQyxDQUE5QixJQUFtQ3VOLEdBQUd2TixPQUFILENBQVcsYUFBWCxNQUE4QixDQUFDLENBQW5FLEtBQ0F1TixHQUFHdk4sT0FBSCxDQUFXLGVBQVgsTUFBZ0MsQ0FBQyxDQURqQyxJQUVBdU4sR0FBR3ZOLE9BQUgsQ0FBVyxRQUFYLE1BQXlCLENBQUMsQ0FGMUIsSUFHQXVOLEdBQUd2TixPQUFILENBQVcsZUFBWCxNQUFnQyxDQUFDLENBSm5DLEVBS0U7QUFDQSxXQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFPMEQsT0FBT1AsT0FBUCxJQUFrQixlQUFlTyxPQUFPUCxPQUEvQztBQUNELENBYm9DLEVBQXJDOztBQWVBO0FBQ0EsSUFBSXVLLE9BQU9qSyxhQUFhQyxPQUFPaUssV0FBcEIsSUFBbUNqSyxPQUFPaUssV0FBUCxDQUFtQkMsR0FBdEQsR0FDUGxLLE9BQU9pSyxXQURBLEdBRVBFLElBRko7O0FBSUEsSUFBSUMsT0FBT0MsUUFBWDs7QUFFQSxTQUFTQSxNQUFULEdBQW1CO0FBQ2pCLFNBQU9MLEtBQUtFLEdBQUwsR0FBV0ksT0FBWCxDQUFtQixDQUFuQixDQUFQO0FBQ0Q7O0FBRUQsU0FBU3RCLFdBQVQsR0FBd0I7QUFDdEIsU0FBT29CLElBQVA7QUFDRDs7QUFFRCxTQUFTekMsV0FBVCxDQUFzQmhPLEdBQXRCLEVBQTJCO0FBQ3pCeVEsU0FBT3pRLEdBQVA7QUFDRDs7QUFFRCxTQUFTNFEsU0FBVCxDQUFvQkMsR0FBcEIsRUFBeUJ0UixPQUF6QixFQUFrQztBQUNoQ3VPO0FBQ0E7QUFDQTtBQUNBLE1BQUloSSxVQUFVTyxPQUFPUCxPQUFyQjtBQUNBLE1BQUk7QUFDRixRQUFJdkcsT0FBSixFQUFhO0FBQ1h1RyxjQUFRZ0wsWUFBUixDQUFxQixFQUFFOVEsS0FBS3lRLElBQVAsRUFBckIsRUFBb0MsRUFBcEMsRUFBd0NJLEdBQXhDO0FBQ0QsS0FGRCxNQUVPO0FBQ0xKLGFBQU9DLFFBQVA7QUFDQTVLLGNBQVE4SyxTQUFSLENBQWtCLEVBQUU1USxLQUFLeVEsSUFBUCxFQUFsQixFQUFpQyxFQUFqQyxFQUFxQ0ksR0FBckM7QUFDRDtBQUNGLEdBUEQsQ0FPRSxPQUFPMVksQ0FBUCxFQUFVO0FBQ1ZrTyxXQUFPOUUsUUFBUCxDQUFnQmhDLFVBQVUsU0FBVixHQUFzQixRQUF0QyxFQUFnRHNSLEdBQWhEO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxZQUFULENBQXVCRCxHQUF2QixFQUE0QjtBQUMxQkQsWUFBVUMsR0FBVixFQUFlLElBQWY7QUFDRDs7QUFFRDs7QUFFQSxTQUFTRSxRQUFULENBQW1CclksS0FBbkIsRUFBMEJzWSxFQUExQixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDaEMsTUFBSUMsT0FBTyxVQUFVM1YsS0FBVixFQUFpQjtBQUMxQixRQUFJQSxTQUFTN0MsTUFBTUssTUFBbkIsRUFBMkI7QUFDekJrWTtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUl2WSxNQUFNNkMsS0FBTixDQUFKLEVBQWtCO0FBQ2hCeVYsV0FBR3RZLE1BQU02QyxLQUFOLENBQUgsRUFBaUIsWUFBWTtBQUMzQjJWLGVBQUszVixRQUFRLENBQWI7QUFDRCxTQUZEO0FBR0QsT0FKRCxNQUlPO0FBQ0wyVixhQUFLM1YsUUFBUSxDQUFiO0FBQ0Q7QUFDRjtBQUNGLEdBWkQ7QUFhQTJWLE9BQUssQ0FBTDtBQUNEOztBQUVEOztBQUdBLElBQUlDLFVBQVUsU0FBU0EsT0FBVCxDQUFrQjFOLE1BQWxCLEVBQTBCK0MsSUFBMUIsRUFBZ0M7QUFDNUMsT0FBSy9DLE1BQUwsR0FBY0EsTUFBZDtBQUNBLE9BQUsrQyxJQUFMLEdBQVk0SyxjQUFjNUssSUFBZCxDQUFaO0FBQ0E7QUFDQSxPQUFLL0QsT0FBTCxHQUFlVixLQUFmO0FBQ0EsT0FBS3NQLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS0MsS0FBTCxHQUFhLEtBQWI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0QsQ0FSRDs7QUFVQUosUUFBUXRYLFNBQVIsQ0FBa0IyWCxNQUFsQixHQUEyQixTQUFTQSxNQUFULENBQWlCUCxFQUFqQixFQUFxQjtBQUM5QyxPQUFLQSxFQUFMLEdBQVVBLEVBQVY7QUFDRCxDQUZEOztBQUlBRSxRQUFRdFgsU0FBUixDQUFrQjRYLE9BQWxCLEdBQTRCLFNBQVNBLE9BQVQsQ0FBa0JSLEVBQWxCLEVBQXNCO0FBQ2hELE1BQUksS0FBS0ssS0FBVCxFQUFnQjtBQUNkTDtBQUNELEdBRkQsTUFFTztBQUNMLFNBQUtNLFFBQUwsQ0FBYzdYLElBQWQsQ0FBbUJ1WCxFQUFuQjtBQUNEO0FBQ0YsQ0FORDs7QUFRQUUsUUFBUXRYLFNBQVIsQ0FBa0I2WCxZQUFsQixHQUFpQyxTQUFTQSxZQUFULENBQXVCblEsUUFBdkIsRUFBaUNvUSxVQUFqQyxFQUE2Q0MsT0FBN0MsRUFBc0Q7QUFDbkYsTUFBSXBPLFNBQVMsSUFBYjs7QUFFRixNQUFJbEcsUUFBUSxLQUFLbUcsTUFBTCxDQUFZOEgsS0FBWixDQUFrQmhLLFFBQWxCLEVBQTRCLEtBQUtrQixPQUFqQyxDQUFaO0FBQ0EsT0FBS29QLGlCQUFMLENBQXVCdlUsS0FBdkIsRUFBOEIsWUFBWTtBQUN4Q2tHLFdBQU9zTyxXQUFQLENBQW1CeFUsS0FBbkI7QUFDQXFVLGtCQUFjQSxXQUFXclUsS0FBWCxDQUFkO0FBQ0FrRyxXQUFPdU8sU0FBUDs7QUFFQTtBQUNBLFFBQUksQ0FBQ3ZPLE9BQU84TixLQUFaLEVBQW1CO0FBQ2pCOU4sYUFBTzhOLEtBQVAsR0FBZSxJQUFmO0FBQ0E5TixhQUFPK04sUUFBUCxDQUFnQm5SLE9BQWhCLENBQXdCLFVBQVU2USxFQUFWLEVBQWM7QUFDcENBLFdBQUczVCxLQUFIO0FBQ0QsT0FGRDtBQUdEO0FBQ0YsR0FaRCxFQVlHc1UsT0FaSDtBQWFELENBakJEOztBQW1CQVQsUUFBUXRYLFNBQVIsQ0FBa0JnWSxpQkFBbEIsR0FBc0MsU0FBU0EsaUJBQVQsQ0FBNEJ2VSxLQUE1QixFQUFtQ3FVLFVBQW5DLEVBQStDQyxPQUEvQyxFQUF3RDtBQUMxRixNQUFJcE8sU0FBUyxJQUFiOztBQUVGLE1BQUlmLFVBQVUsS0FBS0EsT0FBbkI7QUFDQSxNQUFJdVAsUUFBUSxZQUFZO0FBQUVKLGVBQVdBLFNBQVg7QUFBdUIsR0FBakQ7QUFDQSxNQUNFM1AsWUFBWTNFLEtBQVosRUFBbUJtRixPQUFuQjtBQUNBO0FBQ0FuRixRQUFNcEIsT0FBTixDQUFjbkQsTUFBZCxLQUF5QjBKLFFBQVF2RyxPQUFSLENBQWdCbkQsTUFIM0MsRUFJRTtBQUNBLFNBQUtnWixTQUFMO0FBQ0EsV0FBT0MsT0FBUDtBQUNEOztBQUVELE1BQUkvVSxNQUFNZ1YsYUFBYSxLQUFLeFAsT0FBTCxDQUFhdkcsT0FBMUIsRUFBbUNvQixNQUFNcEIsT0FBekMsQ0FBVjtBQUNFLE1BQUlnVyxVQUFValYsSUFBSWlWLE9BQWxCO0FBQ0EsTUFBSUMsY0FBY2xWLElBQUlrVixXQUF0QjtBQUNBLE1BQUlDLFlBQVluVixJQUFJbVYsU0FBcEI7O0FBRUYsTUFBSTFaLFFBQVEsR0FBR00sTUFBSDtBQUNWO0FBQ0FxWixxQkFBbUJGLFdBQW5CLENBRlU7QUFHVjtBQUNBLE9BQUsxTyxNQUFMLENBQVk2TyxXQUpGO0FBS1Y7QUFDQUMscUJBQW1CTCxPQUFuQixDQU5VO0FBT1Y7QUFDQUUsWUFBVXRSLEdBQVYsQ0FBYyxVQUFVc0ksQ0FBVixFQUFhO0FBQUUsV0FBT0EsRUFBRXZCLFdBQVQ7QUFBdUIsR0FBcEQsQ0FSVTtBQVNWO0FBQ0EySyx5QkFBdUJKLFNBQXZCLENBVlUsQ0FBWjs7QUFhQSxPQUFLZixPQUFMLEdBQWUvVCxLQUFmO0FBQ0EsTUFBSW1WLFdBQVcsVUFBVXhVLElBQVYsRUFBZ0JzTCxJQUFoQixFQUFzQjtBQUNuQyxRQUFJL0YsT0FBTzZOLE9BQVAsS0FBbUIvVCxLQUF2QixFQUE4QjtBQUM1QixhQUFPMFUsT0FBUDtBQUNEO0FBQ0QvVCxTQUFLWCxLQUFMLEVBQVltRixPQUFaLEVBQXFCLFVBQVVPLEVBQVYsRUFBYztBQUNqQyxVQUFJQSxPQUFPLEtBQVgsRUFBa0I7QUFDaEI7QUFDQVEsZUFBT3VPLFNBQVAsQ0FBaUIsSUFBakI7QUFDQUM7QUFDRCxPQUpELE1BSU8sSUFBSSxPQUFPaFAsRUFBUCxLQUFjLFFBQWQsSUFBMEIsT0FBT0EsRUFBUCxLQUFjLFFBQTVDLEVBQXNEO0FBQzNEO0FBQ0MsZUFBT0EsRUFBUCxLQUFjLFFBQWQsSUFBMEJBLEdBQUd6RCxPQUE5QixHQUF5Q2lFLE9BQU9qRSxPQUFQLENBQWV5RCxFQUFmLENBQXpDLEdBQThEUSxPQUFPOUosSUFBUCxDQUFZc0osRUFBWixDQUE5RDtBQUNBZ1A7QUFDRCxPQUpNLE1BSUE7QUFDTDtBQUNBekksYUFBS3ZHLEVBQUw7QUFDRDtBQUNGLEtBYkQ7QUFjRCxHQWxCRDs7QUFvQkErTixXQUFTclksS0FBVCxFQUFnQitaLFFBQWhCLEVBQTBCLFlBQVk7QUFDcEMsUUFBSUMsZUFBZSxFQUFuQjtBQUNBLFFBQUlDLFVBQVUsWUFBWTtBQUFFLGFBQU9uUCxPQUFPZixPQUFQLEtBQW1CbkYsS0FBMUI7QUFBa0MsS0FBOUQ7QUFDQSxRQUFJc1YsY0FBY0MsbUJBQW1CVCxTQUFuQixFQUE4Qk0sWUFBOUIsRUFBNENDLE9BQTVDLENBQWxCO0FBQ0E7QUFDQTtBQUNBNUIsYUFBUzZCLFdBQVQsRUFBc0JILFFBQXRCLEVBQWdDLFlBQVk7QUFDMUMsVUFBSWpQLE9BQU82TixPQUFQLEtBQW1CL1QsS0FBdkIsRUFBOEI7QUFDNUIsZUFBTzBVLE9BQVA7QUFDRDtBQUNEeE8sYUFBTzZOLE9BQVAsR0FBaUIsSUFBakI7QUFDQU0saUJBQVdyVSxLQUFYO0FBQ0EsVUFBSWtHLE9BQU9DLE1BQVAsQ0FBYzJLLEdBQWxCLEVBQXVCO0FBQ3JCNUssZUFBT0MsTUFBUCxDQUFjMkssR0FBZCxDQUFrQkcsU0FBbEIsQ0FBNEIsWUFBWTtBQUN0Q21FLHVCQUFhdFMsT0FBYixDQUFxQixVQUFVNlEsRUFBVixFQUFjO0FBQUUsbUJBQU9BLElBQVA7QUFBYyxXQUFuRDtBQUNELFNBRkQ7QUFHRDtBQUNGLEtBWEQ7QUFZRCxHQWxCRDtBQW1CRCxDQXhFRDs7QUEwRUFFLFFBQVF0WCxTQUFSLENBQWtCaVksV0FBbEIsR0FBZ0MsU0FBU0EsV0FBVCxDQUFzQnhVLEtBQXRCLEVBQTZCO0FBQzNELE1BQUl3VixPQUFPLEtBQUtyUSxPQUFoQjtBQUNBLE9BQUtBLE9BQUwsR0FBZW5GLEtBQWY7QUFDQSxPQUFLMlQsRUFBTCxJQUFXLEtBQUtBLEVBQUwsQ0FBUTNULEtBQVIsQ0FBWDtBQUNBLE9BQUttRyxNQUFMLENBQVlzUCxVQUFaLENBQXVCM1MsT0FBdkIsQ0FBK0IsVUFBVW5DLElBQVYsRUFBZ0I7QUFDN0NBLFlBQVFBLEtBQUtYLEtBQUwsRUFBWXdWLElBQVosQ0FBUjtBQUNELEdBRkQ7QUFHRCxDQVBEOztBQVNBLFNBQVMxQixhQUFULENBQXdCNUssSUFBeEIsRUFBOEI7QUFDNUIsTUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFDVCxRQUFJSixTQUFKLEVBQWU7QUFDYjtBQUNBLFVBQUk0TSxTQUFTbEUsU0FBU0MsYUFBVCxDQUF1QixNQUF2QixDQUFiO0FBQ0F2SSxhQUFRd00sVUFBVUEsT0FBTzdOLFlBQVAsQ0FBb0IsTUFBcEIsQ0FBWCxJQUEyQyxHQUFsRDtBQUNELEtBSkQsTUFJTztBQUNMcUIsYUFBTyxHQUFQO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsTUFBSUEsS0FBS0MsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBdkIsRUFBNEI7QUFDMUJELFdBQU8sTUFBTUEsSUFBYjtBQUNEO0FBQ0Q7QUFDQSxTQUFPQSxLQUFLakgsT0FBTCxDQUFhLEtBQWIsRUFBb0IsRUFBcEIsQ0FBUDtBQUNEOztBQUVELFNBQVMwUyxZQUFULENBQ0V4UCxPQURGLEVBRUU4RyxJQUZGLEVBR0U7QUFDQSxNQUFJOVAsQ0FBSjtBQUNBLE1BQUl3WixNQUFNQyxLQUFLRCxHQUFMLENBQVN4USxRQUFRMUosTUFBakIsRUFBeUJ3USxLQUFLeFEsTUFBOUIsQ0FBVjtBQUNBLE9BQUtVLElBQUksQ0FBVCxFQUFZQSxJQUFJd1osR0FBaEIsRUFBcUJ4WixHQUFyQixFQUEwQjtBQUN4QixRQUFJZ0osUUFBUWhKLENBQVIsTUFBZThQLEtBQUs5UCxDQUFMLENBQW5CLEVBQTRCO0FBQzFCO0FBQ0Q7QUFDRjtBQUNELFNBQU87QUFDTHlZLGFBQVMzSSxLQUFLdkksS0FBTCxDQUFXLENBQVgsRUFBY3ZILENBQWQsQ0FESjtBQUVMMlksZUFBVzdJLEtBQUt2SSxLQUFMLENBQVd2SCxDQUFYLENBRk47QUFHTDBZLGlCQUFhMVAsUUFBUXpCLEtBQVIsQ0FBY3ZILENBQWQ7QUFIUixHQUFQO0FBS0Q7O0FBRUQsU0FBUzBaLGFBQVQsQ0FDRUMsT0FERixFQUVFdFksSUFGRixFQUdFdVksSUFIRixFQUlFQyxPQUpGLEVBS0U7QUFDQSxNQUFJQyxTQUFTQyxrQkFBa0JKLE9BQWxCLEVBQTJCLFVBQVVLLEdBQVYsRUFBZUMsUUFBZixFQUF5Qm5JLEtBQXpCLEVBQWdDdkwsR0FBaEMsRUFBcUM7QUFDM0UsUUFBSTJULFFBQVFDLGFBQWFILEdBQWIsRUFBa0IzWSxJQUFsQixDQUFaO0FBQ0EsUUFBSTZZLEtBQUosRUFBVztBQUNULGFBQU9wYSxNQUFNbUgsT0FBTixDQUFjaVQsS0FBZCxJQUNIQSxNQUFNN1MsR0FBTixDQUFVLFVBQVU2UyxLQUFWLEVBQWlCO0FBQUUsZUFBT04sS0FBS00sS0FBTCxFQUFZRCxRQUFaLEVBQXNCbkksS0FBdEIsRUFBNkJ2TCxHQUE3QixDQUFQO0FBQTJDLE9BQXhFLENBREcsR0FFSHFULEtBQUtNLEtBQUwsRUFBWUQsUUFBWixFQUFzQm5JLEtBQXRCLEVBQTZCdkwsR0FBN0IsQ0FGSjtBQUdEO0FBQ0YsR0FQWSxDQUFiO0FBUUEsU0FBTzZULFFBQVFQLFVBQVVDLE9BQU9ELE9BQVAsRUFBVixHQUE2QkMsTUFBckMsQ0FBUDtBQUNEOztBQUVELFNBQVNLLFlBQVQsQ0FDRUgsR0FERixFQUVFelQsR0FGRixFQUdFO0FBQ0EsTUFBSSxPQUFPeVQsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCO0FBQ0FBLFVBQU0vTyxLQUFLRCxNQUFMLENBQVlnUCxHQUFaLENBQU47QUFDRDtBQUNELFNBQU9BLElBQUkzUCxPQUFKLENBQVk5RCxHQUFaLENBQVA7QUFDRDs7QUFFRCxTQUFTcVMsa0JBQVQsQ0FBNkJGLFdBQTdCLEVBQTBDO0FBQ3hDLFNBQU9nQixjQUFjaEIsV0FBZCxFQUEyQixrQkFBM0IsRUFBK0MyQixTQUEvQyxFQUEwRCxJQUExRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3ZCLGtCQUFULENBQTZCTCxPQUE3QixFQUFzQztBQUNwQyxTQUFPaUIsY0FBY2pCLE9BQWQsRUFBdUIsbUJBQXZCLEVBQTRDNEIsU0FBNUMsQ0FBUDtBQUNEOztBQUVELFNBQVNBLFNBQVQsQ0FBb0JILEtBQXBCLEVBQTJCRCxRQUEzQixFQUFxQztBQUNuQyxTQUFPLFNBQVNLLGVBQVQsR0FBNEI7QUFDakMsV0FBT0osTUFBTTdaLEtBQU4sQ0FBWTRaLFFBQVosRUFBc0JsYSxTQUF0QixDQUFQO0FBQ0QsR0FGRDtBQUdEOztBQUVELFNBQVNxWixrQkFBVCxDQUNFVCxTQURGLEVBRUU0QixHQUZGLEVBR0VyQixPQUhGLEVBSUU7QUFDQSxTQUFPUSxjQUFjZixTQUFkLEVBQXlCLGtCQUF6QixFQUE2QyxVQUFVdUIsS0FBVixFQUFpQk0sQ0FBakIsRUFBb0IxSSxLQUFwQixFQUEyQnZMLEdBQTNCLEVBQWdDO0FBQ2xGLFdBQU9rVSxlQUFlUCxLQUFmLEVBQXNCcEksS0FBdEIsRUFBNkJ2TCxHQUE3QixFQUFrQ2dVLEdBQWxDLEVBQXVDckIsT0FBdkMsQ0FBUDtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVELFNBQVN1QixjQUFULENBQ0VQLEtBREYsRUFFRXBJLEtBRkYsRUFHRXZMLEdBSEYsRUFJRWdVLEdBSkYsRUFLRXJCLE9BTEYsRUFNRTtBQUNBLFNBQU8sU0FBU3dCLGVBQVQsQ0FBMEJuUixFQUExQixFQUE4QmtMLElBQTlCLEVBQW9DM0UsSUFBcEMsRUFBMEM7QUFDL0MsV0FBT29LLE1BQU0zUSxFQUFOLEVBQVVrTCxJQUFWLEVBQWdCLFVBQVUrQyxFQUFWLEVBQWM7QUFDbkMxSCxXQUFLMEgsRUFBTDtBQUNBLFVBQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzVCK0MsWUFBSXRhLElBQUosQ0FBUyxZQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTBhLGVBQUtuRCxFQUFMLEVBQVMxRixNQUFNbk4sU0FBZixFQUEwQjRCLEdBQTFCLEVBQStCMlMsT0FBL0I7QUFDRCxTQVBEO0FBUUQ7QUFDRixLQVpNLENBQVA7QUFhRCxHQWREO0FBZUQ7O0FBRUQsU0FBU3lCLElBQVQsQ0FDRW5ELEVBREYsRUFDTTtBQUNKN1MsU0FGRixFQUdFNEIsR0FIRixFQUlFMlMsT0FKRixFQUtFO0FBQ0EsTUFBSXZVLFVBQVU0QixHQUFWLENBQUosRUFBb0I7QUFDbEJpUixPQUFHN1MsVUFBVTRCLEdBQVYsQ0FBSDtBQUNELEdBRkQsTUFFTyxJQUFJMlMsU0FBSixFQUFlO0FBQ3BCemEsZUFBVyxZQUFZO0FBQ3JCa2MsV0FBS25ELEVBQUwsRUFBUzdTLFNBQVQsRUFBb0I0QixHQUFwQixFQUF5QjJTLE9BQXpCO0FBQ0QsS0FGRCxFQUVHLEVBRkg7QUFHRDtBQUNGOztBQUVELFNBQVNILHNCQUFULENBQWlDdFcsT0FBakMsRUFBMEM7QUFDeEMsU0FBT3NYLGtCQUFrQnRYLE9BQWxCLEVBQTJCLFVBQVV1WCxHQUFWLEVBQWVRLENBQWYsRUFBa0IxSSxLQUFsQixFQUF5QnZMLEdBQXpCLEVBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLE9BQU95VCxHQUFQLEtBQWUsVUFBZixJQUE2QixDQUFDQSxJQUFJM1AsT0FBdEMsRUFBK0M7QUFDN0MsYUFBTyxVQUFVZCxFQUFWLEVBQWNrTCxJQUFkLEVBQW9CM0UsSUFBcEIsRUFBMEI7QUFDL0IsWUFBSTVGLFVBQVVuSixLQUFLLFVBQVU2WixXQUFWLEVBQXVCO0FBQ3hDOUksZ0JBQU14TixVQUFOLENBQWlCaUMsR0FBakIsSUFBd0JxVSxXQUF4QjtBQUNBOUs7QUFDRCxTQUhhLENBQWQ7O0FBS0EsWUFBSStLLFNBQVM5WixLQUFLLFVBQVUrWixNQUFWLEVBQWtCO0FBQ2xDL1gsZUFBSyxLQUFMLEVBQWEsdUNBQXVDd0QsR0FBdkMsR0FBNkMsSUFBN0MsR0FBb0R1VSxNQUFqRTtBQUNBaEwsZUFBSyxLQUFMO0FBQ0QsU0FIWSxDQUFiOztBQUtBLFlBQUl0SixNQUFNd1QsSUFBSTlQLE9BQUosRUFBYTJRLE1BQWIsQ0FBVjtBQUNBLFlBQUlyVSxPQUFPLE9BQU9BLElBQUl1VSxJQUFYLEtBQW9CLFVBQS9CLEVBQTJDO0FBQ3pDdlUsY0FBSXVVLElBQUosQ0FBUzdRLE9BQVQsRUFBa0IyUSxNQUFsQjtBQUNEO0FBQ0YsT0FmRDtBQWdCRDtBQUNGLEdBeEJNLENBQVA7QUF5QkQ7O0FBRUQsU0FBU2QsaUJBQVQsQ0FDRXRYLE9BREYsRUFFRThVLEVBRkYsRUFHRTtBQUNBLFNBQU82QyxRQUFRM1gsUUFBUTRFLEdBQVIsQ0FBWSxVQUFVc0ksQ0FBVixFQUFhO0FBQ3RDLFdBQU81TixPQUFPcUYsSUFBUCxDQUFZdUksRUFBRXJMLFVBQWQsRUFBMEIrQyxHQUExQixDQUE4QixVQUFVZCxHQUFWLEVBQWU7QUFBRSxhQUFPZ1IsR0FDM0Q1SCxFQUFFckwsVUFBRixDQUFhaUMsR0FBYixDQUQyRCxFQUUzRG9KLEVBQUVoTCxTQUFGLENBQVk0QixHQUFaLENBRjJELEVBRzNEb0osQ0FIMkQsRUFHeERwSixHQUh3RCxDQUFQO0FBSWxELEtBSkcsQ0FBUDtBQUtELEdBTmMsQ0FBUixDQUFQO0FBT0Q7O0FBRUQsU0FBUzZULE9BQVQsQ0FBa0IxTCxHQUFsQixFQUF1QjtBQUNyQixTQUFPNU8sTUFBTU0sU0FBTixDQUFnQmIsTUFBaEIsQ0FBdUJjLEtBQXZCLENBQTZCLEVBQTdCLEVBQWlDcU8sR0FBakMsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzNOLElBQVQsQ0FBZXdXLEVBQWYsRUFBbUI7QUFDakIsTUFBSXlELFNBQVMsS0FBYjtBQUNBLFNBQU8sWUFBWTtBQUNqQixRQUFJQSxNQUFKLEVBQVk7QUFBRTtBQUFRO0FBQ3RCQSxhQUFTLElBQVQ7QUFDQSxXQUFPekQsR0FBR2xYLEtBQUgsQ0FBUyxJQUFULEVBQWVOLFNBQWYsQ0FBUDtBQUNELEdBSkQ7QUFLRDs7QUFFRDs7QUFHQSxJQUFJa2IsZUFBZ0IsVUFBVUMsVUFBVixFQUFzQjtBQUN4QyxXQUFTRCxZQUFULENBQXVCalIsTUFBdkIsRUFBK0IrQyxJQUEvQixFQUFxQztBQUNuQyxRQUFJaEQsU0FBUyxJQUFiOztBQUVBbVIsZUFBV3BjLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0JrTCxNQUF0QixFQUE4QitDLElBQTlCOztBQUVBLFFBQUlvTyxlQUFlblIsT0FBT0ssT0FBUCxDQUFld0ssY0FBbEM7O0FBRUEsUUFBSXNHLFlBQUosRUFBa0I7QUFDaEJoSDtBQUNEOztBQUVEdkgsV0FBT3dILGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLFVBQVUxVixDQUFWLEVBQWE7QUFDL0NxTCxhQUFPa08sWUFBUCxDQUFvQm1ELFlBQVlyUixPQUFPZ0QsSUFBbkIsQ0FBcEIsRUFBOEMsVUFBVWxKLEtBQVYsRUFBaUI7QUFDN0QsWUFBSXNYLFlBQUosRUFBa0I7QUFDaEIzRyx1QkFBYXhLLE1BQWIsRUFBcUJuRyxLQUFyQixFQUE0QmtHLE9BQU9mLE9BQW5DLEVBQTRDLElBQTVDO0FBQ0Q7QUFDRixPQUpEO0FBS0QsS0FORDtBQU9EOztBQUVELE1BQUtrUyxVQUFMLEVBQWtCRCxhQUFhSSxTQUFiLEdBQXlCSCxVQUF6QjtBQUNsQkQsZUFBYTdhLFNBQWIsR0FBeUIyQixPQUFPK0wsTUFBUCxDQUFlb04sY0FBY0EsV0FBVzlhLFNBQXhDLENBQXpCO0FBQ0E2YSxlQUFhN2EsU0FBYixDQUF1QmtiLFdBQXZCLEdBQXFDTCxZQUFyQzs7QUFFQUEsZUFBYTdhLFNBQWIsQ0FBdUJtYixFQUF2QixHQUE0QixTQUFTQSxFQUFULENBQWFDLENBQWIsRUFBZ0I7QUFDMUM1TyxXQUFPUCxPQUFQLENBQWVrUCxFQUFmLENBQWtCQyxDQUFsQjtBQUNELEdBRkQ7O0FBSUFQLGVBQWE3YSxTQUFiLENBQXVCSCxJQUF2QixHQUE4QixTQUFTQSxJQUFULENBQWU2SCxRQUFmLEVBQXlCb1EsVUFBekIsRUFBcUNDLE9BQXJDLEVBQThDO0FBQzFFLFFBQUlwTyxTQUFTLElBQWI7O0FBRUEsU0FBS2tPLFlBQUwsQ0FBa0JuUSxRQUFsQixFQUE0QixVQUFVakUsS0FBVixFQUFpQjtBQUMzQ3NULGdCQUFVM0osVUFBVXpELE9BQU9nRCxJQUFQLEdBQWNsSixNQUFNcUUsUUFBOUIsQ0FBVjtBQUNBc00sbUJBQWF6SyxPQUFPQyxNQUFwQixFQUE0Qm5HLEtBQTVCLEVBQW1Da0csT0FBT2YsT0FBMUMsRUFBbUQsS0FBbkQ7QUFDQWtQLG9CQUFjQSxXQUFXclUsS0FBWCxDQUFkO0FBQ0QsS0FKRCxFQUlHc1UsT0FKSDtBQUtELEdBUkQ7O0FBVUE4QyxlQUFhN2EsU0FBYixDQUF1QjBGLE9BQXZCLEdBQWlDLFNBQVNBLE9BQVQsQ0FBa0JnQyxRQUFsQixFQUE0Qm9RLFVBQTVCLEVBQXdDQyxPQUF4QyxFQUFpRDtBQUNoRixRQUFJcE8sU0FBUyxJQUFiOztBQUVBLFNBQUtrTyxZQUFMLENBQWtCblEsUUFBbEIsRUFBNEIsVUFBVWpFLEtBQVYsRUFBaUI7QUFDM0N3VCxtQkFBYTdKLFVBQVV6RCxPQUFPZ0QsSUFBUCxHQUFjbEosTUFBTXFFLFFBQTlCLENBQWI7QUFDQXNNLG1CQUFhekssT0FBT0MsTUFBcEIsRUFBNEJuRyxLQUE1QixFQUFtQ2tHLE9BQU9mLE9BQTFDLEVBQW1ELEtBQW5EO0FBQ0FrUCxvQkFBY0EsV0FBV3JVLEtBQVgsQ0FBZDtBQUNELEtBSkQsRUFJR3NVLE9BSkg7QUFLRCxHQVJEOztBQVVBOEMsZUFBYTdhLFNBQWIsQ0FBdUJrWSxTQUF2QixHQUFtQyxTQUFTQSxTQUFULENBQW9CclksSUFBcEIsRUFBMEI7QUFDM0QsUUFBSW1iLFlBQVksS0FBS3JPLElBQWpCLE1BQTJCLEtBQUsvRCxPQUFMLENBQWFkLFFBQTVDLEVBQXNEO0FBQ3BELFVBQUljLFVBQVV3RSxVQUFVLEtBQUtULElBQUwsR0FBWSxLQUFLL0QsT0FBTCxDQUFhZCxRQUFuQyxDQUFkO0FBQ0FqSSxhQUFPa1gsVUFBVW5PLE9BQVYsQ0FBUCxHQUE0QnFPLGFBQWFyTyxPQUFiLENBQTVCO0FBQ0Q7QUFDRixHQUxEOztBQU9BaVMsZUFBYTdhLFNBQWIsQ0FBdUJxYixrQkFBdkIsR0FBNEMsU0FBU0Esa0JBQVQsR0FBK0I7QUFDekUsV0FBT0wsWUFBWSxLQUFLck8sSUFBakIsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsU0FBT2tPLFlBQVA7QUFDRCxDQTdEbUIsQ0E2RGxCdkQsT0E3RGtCLENBQXBCOztBQStEQSxTQUFTMEQsV0FBVCxDQUFzQnJPLElBQXRCLEVBQTRCO0FBQzFCLE1BQUkzSCxPQUFPd0gsT0FBTzlFLFFBQVAsQ0FBZ0JtTSxRQUEzQjtBQUNBLE1BQUlsSCxRQUFRM0gsS0FBSzhELE9BQUwsQ0FBYTZELElBQWIsTUFBdUIsQ0FBbkMsRUFBc0M7QUFDcEMzSCxXQUFPQSxLQUFLbUMsS0FBTCxDQUFXd0YsS0FBS3pOLE1BQWhCLENBQVA7QUFDRDtBQUNELFNBQU8sQ0FBQzhGLFFBQVEsR0FBVCxJQUFnQndILE9BQU85RSxRQUFQLENBQWdCNFQsTUFBaEMsR0FBeUM5TyxPQUFPOUUsUUFBUCxDQUFnQkcsSUFBaEU7QUFDRDs7QUFFRDs7QUFHQSxJQUFJMFQsY0FBZSxVQUFVVCxVQUFWLEVBQXNCO0FBQ3ZDLFdBQVNTLFdBQVQsQ0FBc0IzUixNQUF0QixFQUE4QitDLElBQTlCLEVBQW9DNk8sUUFBcEMsRUFBOEM7QUFDNUNWLGVBQVdwYyxJQUFYLENBQWdCLElBQWhCLEVBQXNCa0wsTUFBdEIsRUFBOEIrQyxJQUE5QjtBQUNBO0FBQ0EsUUFBSTZPLFlBQVlDLGNBQWMsS0FBSzlPLElBQW5CLENBQWhCLEVBQTBDO0FBQ3hDO0FBQ0Q7QUFDRCtPO0FBQ0Q7O0FBRUQsTUFBS1osVUFBTCxFQUFrQlMsWUFBWU4sU0FBWixHQUF3QkgsVUFBeEI7QUFDbEJTLGNBQVl2YixTQUFaLEdBQXdCMkIsT0FBTytMLE1BQVAsQ0FBZW9OLGNBQWNBLFdBQVc5YSxTQUF4QyxDQUF4QjtBQUNBdWIsY0FBWXZiLFNBQVosQ0FBc0JrYixXQUF0QixHQUFvQ0ssV0FBcEM7O0FBRUE7QUFDQTtBQUNBQSxjQUFZdmIsU0FBWixDQUFzQjJiLGNBQXRCLEdBQXVDLFNBQVNBLGNBQVQsR0FBMkI7QUFDaEUsUUFBSWhTLFNBQVMsSUFBYjs7QUFFQTZDLFdBQU93SCxnQkFBUCxDQUF3QixZQUF4QixFQUFzQyxZQUFZO0FBQ2hELFVBQUksQ0FBQzBILGFBQUwsRUFBb0I7QUFDbEI7QUFDRDtBQUNEL1IsYUFBT2tPLFlBQVAsQ0FBb0IrRCxTQUFwQixFQUErQixVQUFVblksS0FBVixFQUFpQjtBQUM5Q29ZLG9CQUFZcFksTUFBTXFFLFFBQWxCO0FBQ0QsT0FGRDtBQUdELEtBUEQ7QUFRRCxHQVhEOztBQWFBeVQsY0FBWXZiLFNBQVosQ0FBc0JILElBQXRCLEdBQTZCLFNBQVNBLElBQVQsQ0FBZTZILFFBQWYsRUFBeUJvUSxVQUF6QixFQUFxQ0MsT0FBckMsRUFBOEM7QUFDekUsU0FBS0YsWUFBTCxDQUFrQm5RLFFBQWxCLEVBQTRCLFVBQVVqRSxLQUFWLEVBQWlCO0FBQzNDcVksZUFBU3JZLE1BQU1xRSxRQUFmO0FBQ0FnUSxvQkFBY0EsV0FBV3JVLEtBQVgsQ0FBZDtBQUNELEtBSEQsRUFHR3NVLE9BSEg7QUFJRCxHQUxEOztBQU9Bd0QsY0FBWXZiLFNBQVosQ0FBc0IwRixPQUF0QixHQUFnQyxTQUFTQSxPQUFULENBQWtCZ0MsUUFBbEIsRUFBNEJvUSxVQUE1QixFQUF3Q0MsT0FBeEMsRUFBaUQ7QUFDL0UsU0FBS0YsWUFBTCxDQUFrQm5RLFFBQWxCLEVBQTRCLFVBQVVqRSxLQUFWLEVBQWlCO0FBQzNDb1ksa0JBQVlwWSxNQUFNcUUsUUFBbEI7QUFDQWdRLG9CQUFjQSxXQUFXclUsS0FBWCxDQUFkO0FBQ0QsS0FIRCxFQUdHc1UsT0FISDtBQUlELEdBTEQ7O0FBT0F3RCxjQUFZdmIsU0FBWixDQUFzQm1iLEVBQXRCLEdBQTJCLFNBQVNBLEVBQVQsQ0FBYUMsQ0FBYixFQUFnQjtBQUN6QzVPLFdBQU9QLE9BQVAsQ0FBZWtQLEVBQWYsQ0FBa0JDLENBQWxCO0FBQ0QsR0FGRDs7QUFJQUcsY0FBWXZiLFNBQVosQ0FBc0JrWSxTQUF0QixHQUFrQyxTQUFTQSxTQUFULENBQW9CclksSUFBcEIsRUFBMEI7QUFDMUQsUUFBSStJLFVBQVUsS0FBS0EsT0FBTCxDQUFhZCxRQUEzQjtBQUNBLFFBQUk4VCxjQUFjaFQsT0FBbEIsRUFBMkI7QUFDekIvSSxhQUFPaWMsU0FBU2xULE9BQVQsQ0FBUCxHQUEyQmlULFlBQVlqVCxPQUFaLENBQTNCO0FBQ0Q7QUFDRixHQUxEOztBQU9BMlMsY0FBWXZiLFNBQVosQ0FBc0JxYixrQkFBdEIsR0FBMkMsU0FBU0Esa0JBQVQsR0FBK0I7QUFDeEUsV0FBT08sU0FBUDtBQUNELEdBRkQ7O0FBSUEsU0FBT0wsV0FBUDtBQUNELENBM0RrQixDQTJEakJqRSxPQTNEaUIsQ0FBbkI7O0FBNkRBLFNBQVNtRSxhQUFULENBQXdCOU8sSUFBeEIsRUFBOEI7QUFDNUIsTUFBSWpGLFdBQVdzVCxZQUFZck8sSUFBWixDQUFmO0FBQ0EsTUFBSSxDQUFDLE9BQU9wQixJQUFQLENBQVk3RCxRQUFaLENBQUwsRUFBNEI7QUFDMUI4RSxXQUFPOUUsUUFBUCxDQUFnQmhDLE9BQWhCLENBQ0UwSCxVQUFVVCxPQUFPLElBQVAsR0FBY2pGLFFBQXhCLENBREY7QUFHQSxXQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNnVSxXQUFULEdBQXdCO0FBQ3RCLE1BQUkxVyxPQUFPNFcsU0FBWDtBQUNBLE1BQUk1VyxLQUFLNEgsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBdkIsRUFBNEI7QUFDMUIsV0FBTyxJQUFQO0FBQ0Q7QUFDRGlQLGNBQVksTUFBTTdXLElBQWxCO0FBQ0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBUzRXLE9BQVQsR0FBb0I7QUFDbEI7QUFDQTtBQUNBLE1BQUk3UixPQUFPeUMsT0FBTzlFLFFBQVAsQ0FBZ0JxQyxJQUEzQjtBQUNBLE1BQUlySSxRQUFRcUksS0FBS2pCLE9BQUwsQ0FBYSxHQUFiLENBQVo7QUFDQSxTQUFPcEgsVUFBVSxDQUFDLENBQVgsR0FBZSxFQUFmLEdBQW9CcUksS0FBSzVDLEtBQUwsQ0FBV3pGLFFBQVEsQ0FBbkIsQ0FBM0I7QUFDRDs7QUFFRCxTQUFTb2EsUUFBVCxDQUFtQjlXLElBQW5CLEVBQXlCO0FBQ3ZCd0gsU0FBTzlFLFFBQVAsQ0FBZ0JHLElBQWhCLEdBQXVCN0MsSUFBdkI7QUFDRDs7QUFFRCxTQUFTNlcsV0FBVCxDQUFzQjdXLElBQXRCLEVBQTRCO0FBQzFCLE1BQUlwRixJQUFJNE0sT0FBTzlFLFFBQVAsQ0FBZ0JxQyxJQUFoQixDQUFxQmpCLE9BQXJCLENBQTZCLEdBQTdCLENBQVI7QUFDQTBELFNBQU85RSxRQUFQLENBQWdCaEMsT0FBaEIsQ0FDRThHLE9BQU85RSxRQUFQLENBQWdCcUMsSUFBaEIsQ0FBcUI1QyxLQUFyQixDQUEyQixDQUEzQixFQUE4QnZILEtBQUssQ0FBTCxHQUFTQSxDQUFULEdBQWEsQ0FBM0MsSUFBZ0QsR0FBaEQsR0FBc0RvRixJQUR4RDtBQUdEOztBQUVEOztBQUdBLElBQUkrVyxrQkFBbUIsVUFBVWpCLFVBQVYsRUFBc0I7QUFDM0MsV0FBU2lCLGVBQVQsQ0FBMEJuUyxNQUExQixFQUFrQytDLElBQWxDLEVBQXdDO0FBQ3RDbU8sZUFBV3BjLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0JrTCxNQUF0QixFQUE4QitDLElBQTlCO0FBQ0EsU0FBS0UsS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLbkwsS0FBTCxHQUFhLENBQUMsQ0FBZDtBQUNEOztBQUVELE1BQUtvWixVQUFMLEVBQWtCaUIsZ0JBQWdCZCxTQUFoQixHQUE0QkgsVUFBNUI7QUFDbEJpQixrQkFBZ0IvYixTQUFoQixHQUE0QjJCLE9BQU8rTCxNQUFQLENBQWVvTixjQUFjQSxXQUFXOWEsU0FBeEMsQ0FBNUI7QUFDQStiLGtCQUFnQi9iLFNBQWhCLENBQTBCa2IsV0FBMUIsR0FBd0NhLGVBQXhDOztBQUVBQSxrQkFBZ0IvYixTQUFoQixDQUEwQkgsSUFBMUIsR0FBaUMsU0FBU0EsSUFBVCxDQUFlNkgsUUFBZixFQUF5Qm9RLFVBQXpCLEVBQXFDQyxPQUFyQyxFQUE4QztBQUM3RSxRQUFJcE8sU0FBUyxJQUFiOztBQUVBLFNBQUtrTyxZQUFMLENBQWtCblEsUUFBbEIsRUFBNEIsVUFBVWpFLEtBQVYsRUFBaUI7QUFDM0NrRyxhQUFPa0QsS0FBUCxHQUFlbEQsT0FBT2tELEtBQVAsQ0FBYTFGLEtBQWIsQ0FBbUIsQ0FBbkIsRUFBc0J3QyxPQUFPakksS0FBUCxHQUFlLENBQXJDLEVBQXdDdkMsTUFBeEMsQ0FBK0NzRSxLQUEvQyxDQUFmO0FBQ0FrRyxhQUFPakksS0FBUDtBQUNBb1csb0JBQWNBLFdBQVdyVSxLQUFYLENBQWQ7QUFDRCxLQUpELEVBSUdzVSxPQUpIO0FBS0QsR0FSRDs7QUFVQWdFLGtCQUFnQi9iLFNBQWhCLENBQTBCMEYsT0FBMUIsR0FBb0MsU0FBU0EsT0FBVCxDQUFrQmdDLFFBQWxCLEVBQTRCb1EsVUFBNUIsRUFBd0NDLE9BQXhDLEVBQWlEO0FBQ25GLFFBQUlwTyxTQUFTLElBQWI7O0FBRUEsU0FBS2tPLFlBQUwsQ0FBa0JuUSxRQUFsQixFQUE0QixVQUFVakUsS0FBVixFQUFpQjtBQUMzQ2tHLGFBQU9rRCxLQUFQLEdBQWVsRCxPQUFPa0QsS0FBUCxDQUFhMUYsS0FBYixDQUFtQixDQUFuQixFQUFzQndDLE9BQU9qSSxLQUE3QixFQUFvQ3ZDLE1BQXBDLENBQTJDc0UsS0FBM0MsQ0FBZjtBQUNBcVUsb0JBQWNBLFdBQVdyVSxLQUFYLENBQWQ7QUFDRCxLQUhELEVBR0dzVSxPQUhIO0FBSUQsR0FQRDs7QUFTQWdFLGtCQUFnQi9iLFNBQWhCLENBQTBCbWIsRUFBMUIsR0FBK0IsU0FBU0EsRUFBVCxDQUFhQyxDQUFiLEVBQWdCO0FBQzdDLFFBQUl6UixTQUFTLElBQWI7O0FBRUEsUUFBSXFTLGNBQWMsS0FBS3RhLEtBQUwsR0FBYTBaLENBQS9CO0FBQ0EsUUFBSVksY0FBYyxDQUFkLElBQW1CQSxlQUFlLEtBQUtuUCxLQUFMLENBQVczTixNQUFqRCxFQUF5RDtBQUN2RDtBQUNEO0FBQ0QsUUFBSXVFLFFBQVEsS0FBS29KLEtBQUwsQ0FBV21QLFdBQVgsQ0FBWjtBQUNBLFNBQUtoRSxpQkFBTCxDQUF1QnZVLEtBQXZCLEVBQThCLFlBQVk7QUFDeENrRyxhQUFPakksS0FBUCxHQUFlc2EsV0FBZjtBQUNBclMsYUFBT3NPLFdBQVAsQ0FBbUJ4VSxLQUFuQjtBQUNELEtBSEQ7QUFJRCxHQVpEOztBQWNBc1ksa0JBQWdCL2IsU0FBaEIsQ0FBMEJxYixrQkFBMUIsR0FBK0MsU0FBU0Esa0JBQVQsR0FBK0I7QUFDNUUsUUFBSXpTLFVBQVUsS0FBS2lFLEtBQUwsQ0FBVyxLQUFLQSxLQUFMLENBQVczTixNQUFYLEdBQW9CLENBQS9CLENBQWQ7QUFDQSxXQUFPMEosVUFBVUEsUUFBUWQsUUFBbEIsR0FBNkIsR0FBcEM7QUFDRCxHQUhEOztBQUtBaVUsa0JBQWdCL2IsU0FBaEIsQ0FBMEJrWSxTQUExQixHQUFzQyxTQUFTQSxTQUFULEdBQXNCO0FBQzFEO0FBQ0QsR0FGRDs7QUFJQSxTQUFPNkQsZUFBUDtBQUNELENBdERzQixDQXNEckJ6RSxPQXREcUIsQ0FBdkI7O0FBd0RBOztBQUVBLElBQUkyRSxZQUFZLFNBQVNBLFNBQVQsQ0FBb0JoUyxPQUFwQixFQUE2QjtBQUMzQyxNQUFLQSxZQUFZLEtBQUssQ0FBdEIsRUFBMEJBLFVBQVUsRUFBVjs7QUFFMUIsT0FBS3NLLEdBQUwsR0FBVyxJQUFYO0FBQ0EsT0FBSzJILElBQUwsR0FBWSxFQUFaO0FBQ0EsT0FBS2pTLE9BQUwsR0FBZUEsT0FBZjtBQUNBLE9BQUt3TyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsT0FBS1MsVUFBTCxHQUFrQixFQUFsQjtBQUNBLE9BQUtpRCxPQUFMLEdBQWVwSixjQUFjOUksUUFBUXFELE1BQVIsSUFBa0IsRUFBaEMsQ0FBZjs7QUFFQSxNQUFJOE8sT0FBT25TLFFBQVFtUyxJQUFSLElBQWdCLE1BQTNCO0FBQ0EsT0FBS1osUUFBTCxHQUFnQlksU0FBUyxTQUFULElBQXNCLENBQUNoRyxpQkFBdkM7QUFDQSxNQUFJLEtBQUtvRixRQUFULEVBQW1CO0FBQ2pCWSxXQUFPLE1BQVA7QUFDRDtBQUNELE1BQUksQ0FBQzdQLFNBQUwsRUFBZ0I7QUFDZDZQLFdBQU8sVUFBUDtBQUNEO0FBQ0QsT0FBS0EsSUFBTCxHQUFZQSxJQUFaOztBQUVBLFVBQVFBLElBQVI7QUFDRSxTQUFLLFNBQUw7QUFDRSxXQUFLblEsT0FBTCxHQUFlLElBQUk0TyxZQUFKLENBQWlCLElBQWpCLEVBQXVCNVEsUUFBUTBDLElBQS9CLENBQWY7QUFDQTtBQUNGLFNBQUssTUFBTDtBQUNFLFdBQUtWLE9BQUwsR0FBZSxJQUFJc1AsV0FBSixDQUFnQixJQUFoQixFQUFzQnRSLFFBQVEwQyxJQUE5QixFQUFvQyxLQUFLNk8sUUFBekMsQ0FBZjtBQUNBO0FBQ0YsU0FBSyxVQUFMO0FBQ0UsV0FBS3ZQLE9BQUwsR0FBZSxJQUFJOFAsZUFBSixDQUFvQixJQUFwQixFQUEwQjlSLFFBQVEwQyxJQUFsQyxDQUFmO0FBQ0E7QUFDRjtBQUNFLFVBQUk5TyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzFELGVBQU8sS0FBUCxFQUFlLG1CQUFtQjRaLElBQWxDO0FBQ0Q7QUFiTDtBQWVELENBbkNEOztBQXFDQSxJQUFJQyxxQkFBcUIsRUFBRXBKLGNBQWMsRUFBaEIsRUFBekI7O0FBRUFnSixVQUFVamMsU0FBVixDQUFvQjBSLEtBQXBCLEdBQTRCLFNBQVNBLEtBQVQsQ0FDMUJlLEdBRDBCLEVBRTFCN0osT0FGMEIsRUFHMUJqQixjQUgwQixFQUkxQjtBQUNBLFNBQU8sS0FBS3dVLE9BQUwsQ0FBYXpLLEtBQWIsQ0FBbUJlLEdBQW5CLEVBQXdCN0osT0FBeEIsRUFBaUNqQixjQUFqQyxDQUFQO0FBQ0QsQ0FORDs7QUFRQTBVLG1CQUFtQnBKLFlBQW5CLENBQWdDOVEsR0FBaEMsR0FBc0MsWUFBWTtBQUNoRCxTQUFPLEtBQUs4SixPQUFMLElBQWdCLEtBQUtBLE9BQUwsQ0FBYXJELE9BQXBDO0FBQ0QsQ0FGRDs7QUFJQXFULFVBQVVqYyxTQUFWLENBQW9CcUUsSUFBcEIsR0FBMkIsU0FBU0EsSUFBVCxDQUFla1EsR0FBZixDQUFtQiw0QkFBbkIsRUFBaUQ7QUFDeEUsTUFBSTVLLFNBQVMsSUFBYjs7QUFFRjlMLFVBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDMUQsT0FDdkNULFFBQVEwSixTQUQrQixFQUV2QywyREFDQSxnQ0FIdUMsQ0FBekM7O0FBTUEsT0FBS3lRLElBQUwsQ0FBVXJjLElBQVYsQ0FBZTBVLEdBQWY7O0FBRUE7QUFDQSxNQUFJLEtBQUtBLEdBQVQsRUFBYztBQUNaO0FBQ0Q7O0FBRUQsT0FBS0EsR0FBTCxHQUFXQSxHQUFYOztBQUVBLE1BQUl0SSxVQUFVLEtBQUtBLE9BQW5COztBQUVBLE1BQUlBLG1CQUFtQjRPLFlBQXZCLEVBQXFDO0FBQ25DNU8sWUFBUTRMLFlBQVIsQ0FBcUI1TCxRQUFRb1Asa0JBQVIsRUFBckI7QUFDRCxHQUZELE1BRU8sSUFBSXBQLG1CQUFtQnNQLFdBQXZCLEVBQW9DO0FBQ3pDLFFBQUllLG9CQUFvQixZQUFZO0FBQ2xDclEsY0FBUTBQLGNBQVI7QUFDRCxLQUZEO0FBR0ExUCxZQUFRNEwsWUFBUixDQUNFNUwsUUFBUW9QLGtCQUFSLEVBREYsRUFFRWlCLGlCQUZGLEVBR0VBLGlCQUhGO0FBS0Q7O0FBRURyUSxVQUFRMEwsTUFBUixDQUFlLFVBQVVsVSxLQUFWLEVBQWlCO0FBQzlCa0csV0FBT3VTLElBQVAsQ0FBWTNWLE9BQVosQ0FBb0IsVUFBVWdPLEdBQVYsRUFBZTtBQUNqQ0EsVUFBSTNJLE1BQUosR0FBYW5JLEtBQWI7QUFDRCxLQUZEO0FBR0QsR0FKRDtBQUtELENBdENEOztBQXdDQXdZLFVBQVVqYyxTQUFWLENBQW9CdWMsVUFBcEIsR0FBaUMsU0FBU0EsVUFBVCxDQUFxQnBGLEVBQXJCLEVBQXlCO0FBQ3hELE9BQUtzQixXQUFMLENBQWlCNVksSUFBakIsQ0FBc0JzWCxFQUF0QjtBQUNELENBRkQ7O0FBSUE4RSxVQUFVamMsU0FBVixDQUFvQndjLFNBQXBCLEdBQWdDLFNBQVNBLFNBQVQsQ0FBb0JyRixFQUFwQixFQUF3QjtBQUN0RCxPQUFLK0IsVUFBTCxDQUFnQnJaLElBQWhCLENBQXFCc1gsRUFBckI7QUFDRCxDQUZEOztBQUlBOEUsVUFBVWpjLFNBQVYsQ0FBb0I0WCxPQUFwQixHQUE4QixTQUFTQSxPQUFULENBQWtCUixFQUFsQixFQUFzQjtBQUNsRCxPQUFLbkwsT0FBTCxDQUFhMkwsT0FBYixDQUFxQlIsRUFBckI7QUFDRCxDQUZEOztBQUlBNkUsVUFBVWpjLFNBQVYsQ0FBb0JILElBQXBCLEdBQTJCLFNBQVNBLElBQVQsQ0FBZTZILFFBQWYsRUFBeUJvUSxVQUF6QixFQUFxQ0MsT0FBckMsRUFBOEM7QUFDdkUsT0FBSzlMLE9BQUwsQ0FBYXBNLElBQWIsQ0FBa0I2SCxRQUFsQixFQUE0Qm9RLFVBQTVCLEVBQXdDQyxPQUF4QztBQUNELENBRkQ7O0FBSUFrRSxVQUFVamMsU0FBVixDQUFvQjBGLE9BQXBCLEdBQThCLFNBQVNBLE9BQVQsQ0FBa0JnQyxRQUFsQixFQUE0Qm9RLFVBQTVCLEVBQXdDQyxPQUF4QyxFQUFpRDtBQUM3RSxPQUFLOUwsT0FBTCxDQUFhdkcsT0FBYixDQUFxQmdDLFFBQXJCLEVBQStCb1EsVUFBL0IsRUFBMkNDLE9BQTNDO0FBQ0QsQ0FGRDs7QUFJQWtFLFVBQVVqYyxTQUFWLENBQW9CbWIsRUFBcEIsR0FBeUIsU0FBU0EsRUFBVCxDQUFhQyxDQUFiLEVBQWdCO0FBQ3ZDLE9BQUtuUCxPQUFMLENBQWFrUCxFQUFiLENBQWdCQyxDQUFoQjtBQUNELENBRkQ7O0FBSUFhLFVBQVVqYyxTQUFWLENBQW9CeWMsSUFBcEIsR0FBMkIsU0FBU0EsSUFBVCxHQUFpQjtBQUMxQyxPQUFLdEIsRUFBTCxDQUFRLENBQUMsQ0FBVDtBQUNELENBRkQ7O0FBSUFjLFVBQVVqYyxTQUFWLENBQW9CMGMsT0FBcEIsR0FBOEIsU0FBU0EsT0FBVCxHQUFvQjtBQUNoRCxPQUFLdkIsRUFBTCxDQUFRLENBQVI7QUFDRCxDQUZEOztBQUlBYyxVQUFVamMsU0FBVixDQUFvQjJjLG9CQUFwQixHQUEyQyxTQUFTQSxvQkFBVCxDQUErQnhULEVBQS9CLEVBQW1DO0FBQzVFLE1BQUkxRixRQUFRMEYsS0FDUixLQUFLVyxPQUFMLENBQWFYLEVBQWIsRUFBaUIxRixLQURULEdBRVIsS0FBS3dQLFlBRlQ7QUFHQSxNQUFJLENBQUN4UCxLQUFMLEVBQVk7QUFDVixXQUFPLEVBQVA7QUFDRDtBQUNELFNBQU8sR0FBR3RFLE1BQUgsQ0FBVWMsS0FBVixDQUFnQixFQUFoQixFQUFvQndELE1BQU1wQixPQUFOLENBQWM0RSxHQUFkLENBQWtCLFVBQVVzSSxDQUFWLEVBQWE7QUFDeEQsV0FBTzVOLE9BQU9xRixJQUFQLENBQVl1SSxFQUFFckwsVUFBZCxFQUEwQitDLEdBQTFCLENBQThCLFVBQVVkLEdBQVYsRUFBZTtBQUNsRCxhQUFPb0osRUFBRXJMLFVBQUYsQ0FBYWlDLEdBQWIsQ0FBUDtBQUNELEtBRk0sQ0FBUDtBQUdELEdBSjBCLENBQXBCLENBQVA7QUFLRCxDQVpEOztBQWNBOFYsVUFBVWpjLFNBQVYsQ0FBb0I4SixPQUFwQixHQUE4QixTQUFTQSxPQUFULENBQzVCWCxFQUQ0QixFQUU1QlAsT0FGNEIsRUFHNUJZLE1BSDRCLEVBSTVCO0FBQ0EsTUFBSTlCLFdBQVc4SyxrQkFBa0JySixFQUFsQixFQUFzQlAsV0FBVyxLQUFLcUQsT0FBTCxDQUFhckQsT0FBOUMsRUFBdURZLE1BQXZELENBQWY7QUFDQSxNQUFJL0YsUUFBUSxLQUFLaU8sS0FBTCxDQUFXaEssUUFBWCxFQUFxQmtCLE9BQXJCLENBQVo7QUFDQSxNQUFJZCxXQUFXckUsTUFBTWtFLGNBQU4sSUFBd0JsRSxNQUFNcUUsUUFBN0M7QUFDQSxNQUFJNkUsT0FBTyxLQUFLVixPQUFMLENBQWFVLElBQXhCO0FBQ0EsTUFBSTVDLE9BQU82UyxXQUFXalEsSUFBWCxFQUFpQjdFLFFBQWpCLEVBQTJCLEtBQUtzVSxJQUFoQyxDQUFYO0FBQ0EsU0FBTztBQUNMMVUsY0FBVUEsUUFETDtBQUVMakUsV0FBT0EsS0FGRjtBQUdMc0csVUFBTUEsSUFIRDtBQUlMO0FBQ0E4UyxrQkFBY25WLFFBTFQ7QUFNTG9WLGNBQVVyWjtBQU5MLEdBQVA7QUFRRCxDQWxCRDs7QUFvQkF3WSxVQUFVamMsU0FBVixDQUFvQmdULFNBQXBCLEdBQWdDLFNBQVNBLFNBQVQsQ0FBb0IxRixNQUFwQixFQUE0QjtBQUMxRCxPQUFLNk8sT0FBTCxDQUFhbkosU0FBYixDQUF1QjFGLE1BQXZCO0FBQ0EsTUFBSSxLQUFLckIsT0FBTCxDQUFhckQsT0FBYixLQUF5QlYsS0FBN0IsRUFBb0M7QUFDbEMsU0FBSytELE9BQUwsQ0FBYTRMLFlBQWIsQ0FBMEIsS0FBSzVMLE9BQUwsQ0FBYW9QLGtCQUFiLEVBQTFCO0FBQ0Q7QUFDRixDQUxEOztBQU9BMVosT0FBT00sZ0JBQVAsQ0FBeUJnYSxVQUFVamMsU0FBbkMsRUFBOENxYyxrQkFBOUM7O0FBRUEsU0FBU08sVUFBVCxDQUFxQmpRLElBQXJCLEVBQTJCN0UsUUFBM0IsRUFBcUNzVSxJQUFyQyxFQUEyQztBQUN6QyxNQUFJcFgsT0FBT29YLFNBQVMsTUFBVCxHQUFrQixNQUFNdFUsUUFBeEIsR0FBbUNBLFFBQTlDO0FBQ0EsU0FBTzZFLE9BQU9TLFVBQVVULE9BQU8sR0FBUCxHQUFhM0gsSUFBdkIsQ0FBUCxHQUFzQ0EsSUFBN0M7QUFDRDs7QUFFRGlYLFVBQVVsYSxPQUFWLEdBQW9CQSxPQUFwQjtBQUNBa2EsVUFBVTNiLE9BQVYsR0FBb0IsT0FBcEI7O0FBRUEsSUFBSWlNLGFBQWFDLE9BQU94SyxHQUF4QixFQUE2QjtBQUMzQndLLFNBQU94SyxHQUFQLENBQVcrYSxHQUFYLENBQWVkLFNBQWY7QUFDRDs7QUFFRCwrREFBZUEsU0FBZixFOzs7Ozs7Ozt1RENwdUVBO0FBQUE7Ozs7O0FBS0E7O0FBRUE7OztBQUdBLFNBQVNlLFNBQVQsQ0FBb0JyVyxHQUFwQixFQUF5QjtBQUN2QixTQUFPQSxPQUFPLElBQVAsR0FDSCxFQURHLEdBRUgsT0FBT0EsR0FBUCxLQUFlLFFBQWYsR0FDRXFLLEtBQUtDLFNBQUwsQ0FBZXRLLEdBQWYsRUFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FERixHQUVFMUQsT0FBTzBELEdBQVAsQ0FKTjtBQUtEOztBQUVEOzs7O0FBSUEsU0FBU3NXLFFBQVQsQ0FBbUJ0VyxHQUFuQixFQUF3QjtBQUN0QixNQUFJeVUsSUFBSThCLFdBQVd2VyxHQUFYLENBQVI7QUFDQSxTQUFPd1csTUFBTS9CLENBQU4sSUFBV3pVLEdBQVgsR0FBaUJ5VSxDQUF4QjtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU2dDLE9BQVQsQ0FDRTVYLEdBREYsRUFFRTZYLGdCQUZGLEVBR0U7QUFDQSxNQUFJcFcsTUFBTXRGLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0EsTUFBSTRQLE9BQU85WCxJQUFJYyxLQUFKLENBQVUsR0FBVixDQUFYO0FBQ0EsT0FBSyxJQUFJMUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMGQsS0FBS3BlLE1BQXpCLEVBQWlDVSxHQUFqQyxFQUFzQztBQUNwQ3FILFFBQUlxVyxLQUFLMWQsQ0FBTCxDQUFKLElBQWUsSUFBZjtBQUNEO0FBQ0QsU0FBT3lkLG1CQUNILFVBQVUxVyxHQUFWLEVBQWU7QUFBRSxXQUFPTSxJQUFJTixJQUFJNFcsV0FBSixFQUFKLENBQVA7QUFBZ0MsR0FEOUMsR0FFSCxVQUFVNVcsR0FBVixFQUFlO0FBQUUsV0FBT00sSUFBSU4sR0FBSixDQUFQO0FBQWtCLEdBRnZDO0FBR0Q7O0FBRUQ7OztBQUdBLElBQUk2VyxlQUFlSixRQUFRLGdCQUFSLEVBQTBCLElBQTFCLENBQW5COztBQUVBOzs7QUFHQSxTQUFTSyxNQUFULENBQWlCblAsR0FBakIsRUFBc0JvUCxJQUF0QixFQUE0QjtBQUMxQixNQUFJcFAsSUFBSXBQLE1BQVIsRUFBZ0I7QUFDZCxRQUFJd0MsUUFBUTRNLElBQUl4RixPQUFKLENBQVk0VSxJQUFaLENBQVo7QUFDQSxRQUFJaGMsUUFBUSxDQUFDLENBQWIsRUFBZ0I7QUFDZCxhQUFPNE0sSUFBSXFQLE1BQUosQ0FBV2pjLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O0FBR0EsSUFBSTRSLGlCQUFpQjNSLE9BQU8zQixTQUFQLENBQWlCc1QsY0FBdEM7QUFDQSxTQUFTc0ssTUFBVCxDQUFpQjdXLEdBQWpCLEVBQXNCWixHQUF0QixFQUEyQjtBQUN6QixTQUFPbU4sZUFBZTVVLElBQWYsQ0FBb0JxSSxHQUFwQixFQUF5QlosR0FBekIsQ0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTMFgsV0FBVCxDQUFzQmhjLEtBQXRCLEVBQTZCO0FBQzNCLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFQLEtBQWlCLFFBQXJEO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNpYyxNQUFULENBQWlCM0csRUFBakIsRUFBcUI7QUFDbkIsTUFBSXpULFFBQVEvQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBWjtBQUNBLFNBQVEsU0FBU3FRLFFBQVQsQ0FBbUJ2WSxHQUFuQixFQUF3QjtBQUM5QixRQUFJMk0sTUFBTXpPLE1BQU04QixHQUFOLENBQVY7QUFDQSxXQUFPMk0sUUFBUXpPLE1BQU04QixHQUFOLElBQWEyUixHQUFHM1IsR0FBSCxDQUFyQixDQUFQO0FBQ0QsR0FIRDtBQUlEOztBQUVEOzs7QUFHQSxJQUFJd1ksYUFBYSxRQUFqQjtBQUNBLElBQUlDLFdBQVdILE9BQU8sVUFBVXRZLEdBQVYsRUFBZTtBQUNuQyxTQUFPQSxJQUFJRSxPQUFKLENBQVlzWSxVQUFaLEVBQXdCLFVBQVU1RCxDQUFWLEVBQWFqVixDQUFiLEVBQWdCO0FBQUUsV0FBT0EsSUFBSUEsRUFBRXNMLFdBQUYsRUFBSixHQUFzQixFQUE3QjtBQUFrQyxHQUE1RSxDQUFQO0FBQ0QsQ0FGYyxDQUFmOztBQUlBOzs7QUFHQSxJQUFJeU4sYUFBYUosT0FBTyxVQUFVdFksR0FBVixFQUFlO0FBQ3JDLFNBQU9BLElBQUlvSCxNQUFKLENBQVcsQ0FBWCxFQUFjNkQsV0FBZCxLQUE4QmpMLElBQUkyQixLQUFKLENBQVUsQ0FBVixDQUFyQztBQUNELENBRmdCLENBQWpCOztBQUlBOzs7QUFHQSxJQUFJZ1gsY0FBYyxnQkFBbEI7QUFDQSxJQUFJQyxZQUFZTixPQUFPLFVBQVV0WSxHQUFWLEVBQWU7QUFDcEMsU0FBT0EsSUFDSkUsT0FESSxDQUNJeVksV0FESixFQUNpQixPQURqQixFQUVKelksT0FGSSxDQUVJeVksV0FGSixFQUVpQixPQUZqQixFQUdKWixXQUhJLEVBQVA7QUFJRCxDQUxlLENBQWhCOztBQU9BOzs7QUFHQSxTQUFTL0QsSUFBVCxDQUFlckMsRUFBZixFQUFtQmtILEdBQW5CLEVBQXdCO0FBQ3RCLFdBQVNDLE9BQVQsQ0FBa0JqVyxDQUFsQixFQUFxQjtBQUNuQixRQUFJa1csSUFBSTVlLFVBQVVULE1BQWxCO0FBQ0EsV0FBT3FmLElBQ0hBLElBQUksQ0FBSixHQUNFcEgsR0FBR2xYLEtBQUgsQ0FBU29lLEdBQVQsRUFBYzFlLFNBQWQsQ0FERixHQUVFd1gsR0FBR3pZLElBQUgsQ0FBUTJmLEdBQVIsRUFBYWhXLENBQWIsQ0FIQyxHQUlIOE8sR0FBR3pZLElBQUgsQ0FBUTJmLEdBQVIsQ0FKSjtBQUtEO0FBQ0Q7QUFDQUMsVUFBUUUsT0FBUixHQUFrQnJILEdBQUdqWSxNQUFyQjtBQUNBLFNBQU9vZixPQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNHLE9BQVQsQ0FBa0JuQixJQUFsQixFQUF3Qm9CLEtBQXhCLEVBQStCO0FBQzdCQSxVQUFRQSxTQUFTLENBQWpCO0FBQ0EsTUFBSTllLElBQUkwZCxLQUFLcGUsTUFBTCxHQUFjd2YsS0FBdEI7QUFDQSxNQUFJQyxNQUFNLElBQUlqZixLQUFKLENBQVVFLENBQVYsQ0FBVjtBQUNBLFNBQU9BLEdBQVAsRUFBWTtBQUNWK2UsUUFBSS9lLENBQUosSUFBUzBkLEtBQUsxZCxJQUFJOGUsS0FBVCxDQUFUO0FBQ0Q7QUFDRCxTQUFPQyxHQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVMvVCxNQUFULENBQWlCekIsRUFBakIsRUFBcUJ5VixLQUFyQixFQUE0QjtBQUMxQixPQUFLLElBQUl6WSxHQUFULElBQWdCeVksS0FBaEIsRUFBdUI7QUFDckJ6VixPQUFHaEQsR0FBSCxJQUFVeVksTUFBTXpZLEdBQU4sQ0FBVjtBQUNEO0FBQ0QsU0FBT2dELEVBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTMkwsUUFBVCxDQUFtQi9OLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQU9BLFFBQVEsSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsUUFBdEM7QUFDRDs7QUFFRDs7OztBQUlBLElBQUkxQixXQUFXMUQsT0FBTzNCLFNBQVAsQ0FBaUJxRixRQUFoQztBQUNBLElBQUl3WixnQkFBZ0IsaUJBQXBCO0FBQ0EsU0FBU0MsYUFBVCxDQUF3Qi9YLEdBQXhCLEVBQTZCO0FBQzNCLFNBQU8xQixTQUFTM0csSUFBVCxDQUFjcUksR0FBZCxNQUF1QjhYLGFBQTlCO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNFLFFBQVQsQ0FBbUJ6USxHQUFuQixFQUF3QjtBQUN0QixNQUFJbEksTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJeEcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJME8sSUFBSXBQLE1BQXhCLEVBQWdDVSxHQUFoQyxFQUFxQztBQUNuQyxRQUFJME8sSUFBSTFPLENBQUosQ0FBSixFQUFZO0FBQ1ZnTCxhQUFPeEUsR0FBUCxFQUFZa0ksSUFBSTFPLENBQUosQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPd0csR0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTNUYsSUFBVCxHQUFpQixDQUFFOztBQUVuQjs7O0FBR0EsSUFBSXdlLEtBQUssWUFBWTtBQUFFLFNBQU8sS0FBUDtBQUFlLENBQXRDOztBQUVBOzs7QUFHQSxJQUFJQyxXQUFXLFVBQVU3RSxDQUFWLEVBQWE7QUFBRSxTQUFPQSxDQUFQO0FBQVcsQ0FBekM7O0FBRUE7OztBQUdBLFNBQVM4RSxhQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUMvQixTQUFPQSxRQUFRQyxNQUFSLENBQWUsVUFBVXBZLElBQVYsRUFBZ0J1SSxDQUFoQixFQUFtQjtBQUN2QyxXQUFPdkksS0FBSzdILE1BQUwsQ0FBWW9RLEVBQUU4UCxVQUFGLElBQWdCLEVBQTVCLENBQVA7QUFDRCxHQUZNLEVBRUosRUFGSSxFQUVBelksSUFGQSxDQUVLLEdBRkwsQ0FBUDtBQUdEOztBQUVEOzs7O0FBSUEsU0FBUzBZLFVBQVQsQ0FBcUJqWCxDQUFyQixFQUF3QkMsQ0FBeEIsRUFBMkI7QUFDekIsTUFBSWlYLFlBQVl6SyxTQUFTek0sQ0FBVCxDQUFoQjtBQUNBLE1BQUltWCxZQUFZMUssU0FBU3hNLENBQVQsQ0FBaEI7QUFDQSxNQUFJaVgsYUFBYUMsU0FBakIsRUFBNEI7QUFDMUIsUUFBSTtBQUNGLGFBQU94TyxLQUFLQyxTQUFMLENBQWU1SSxDQUFmLE1BQXNCMkksS0FBS0MsU0FBTCxDQUFlM0ksQ0FBZixDQUE3QjtBQUNELEtBRkQsQ0FFRSxPQUFPaEssQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxhQUFPK0osTUFBTUMsQ0FBYjtBQUNEO0FBQ0YsR0FQRCxNQU9PLElBQUksQ0FBQ2lYLFNBQUQsSUFBYyxDQUFDQyxTQUFuQixFQUE4QjtBQUNuQyxXQUFPdmMsT0FBT29GLENBQVAsTUFBY3BGLE9BQU9xRixDQUFQLENBQXJCO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbVgsWUFBVCxDQUF1Qm5SLEdBQXZCLEVBQTRCM0gsR0FBNUIsRUFBaUM7QUFDL0IsT0FBSyxJQUFJL0csSUFBSSxDQUFiLEVBQWdCQSxJQUFJME8sSUFBSXBQLE1BQXhCLEVBQWdDVSxHQUFoQyxFQUFxQztBQUNuQyxRQUFJMGYsV0FBV2hSLElBQUkxTyxDQUFKLENBQVgsRUFBbUIrRyxHQUFuQixDQUFKLEVBQTZCO0FBQUUsYUFBTy9HLENBQVA7QUFBVTtBQUMxQztBQUNELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNlLElBQVQsQ0FBZXdXLEVBQWYsRUFBbUI7QUFDakIsTUFBSXlELFNBQVMsS0FBYjtBQUNBLFNBQU8sWUFBWTtBQUNqQixRQUFJLENBQUNBLE1BQUwsRUFBYTtBQUNYQSxlQUFTLElBQVQ7QUFDQXpEO0FBQ0Q7QUFDRixHQUxEO0FBTUQ7O0FBRUQ7O0FBRUEsSUFBSXJTLFNBQVM7QUFDWDs7O0FBR0FxSCx5QkFBdUJ4SyxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FKWjs7QUFNWDs7O0FBR0FnUyxVQUFRLEtBVEc7O0FBV1g7OztBQUdBQyxpQkFBZTloQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQWQ3Qjs7QUFnQlg7OztBQUdBMFosWUFBVS9oQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQW5CeEI7O0FBcUJYOzs7QUFHQXVRLGVBQWEsS0F4QkY7O0FBMEJYOzs7QUFHQW9KLGdCQUFjLElBN0JIOztBQStCWDs7O0FBR0FDLG1CQUFpQixFQWxDTjs7QUFvQ1g7OztBQUdBQyxZQUFVcGUsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBdkNDOztBQXlDWDs7OztBQUlBc1MsaUJBQWVoQixFQTdDSjs7QUErQ1g7Ozs7QUFJQWlCLG9CQUFrQmpCLEVBbkRQOztBQXFEWDs7O0FBR0FrQixtQkFBaUIxZixJQXhETjs7QUEwRFg7OztBQUdBMmYsd0JBQXNCbEIsUUE3RFg7O0FBK0RYOzs7O0FBSUFtQixlQUFhcEIsRUFuRUY7O0FBcUVYOzs7QUFHQXFCLGVBQWEsQ0FDWCxXQURXLEVBRVgsV0FGVyxFQUdYLFFBSFcsQ0F4RUY7O0FBOEVYOzs7QUFHQUMsbUJBQWlCLENBQ2YsY0FEZSxFQUVmLFNBRmUsRUFHZixhQUhlLEVBSWYsU0FKZSxFQUtmLGNBTGUsRUFNZixTQU5lLEVBT2YsZUFQZSxFQVFmLFdBUmUsRUFTZixXQVRlLEVBVWYsYUFWZSxDQWpGTjs7QUE4Rlg7OztBQUdBQyxtQkFBaUI7QUFqR04sQ0FBYjs7QUFvR0E7O0FBRUEsSUFBSUMsY0FBYzdlLE9BQU9zRyxNQUFQLENBQWMsRUFBZCxDQUFsQjs7QUFFQTs7O0FBR0EsU0FBU3dZLFVBQVQsQ0FBcUJqYixHQUFyQixFQUEwQjtBQUN4QixNQUFJTCxJQUFJLENBQUNLLE1BQU0sRUFBUCxFQUFXSixVQUFYLENBQXNCLENBQXRCLENBQVI7QUFDQSxTQUFPRCxNQUFNLElBQU4sSUFBY0EsTUFBTSxJQUEzQjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTeVUsR0FBVCxDQUFjN1MsR0FBZCxFQUFtQlosR0FBbkIsRUFBd0JRLEdBQXhCLEVBQTZCK1osVUFBN0IsRUFBeUM7QUFDdkMvZSxTQUFPQyxjQUFQLENBQXNCbUYsR0FBdEIsRUFBMkJaLEdBQTNCLEVBQWdDO0FBQzlCdEUsV0FBTzhFLEdBRHVCO0FBRTlCK1osZ0JBQVksQ0FBQyxDQUFDQSxVQUZnQjtBQUc5QkMsY0FBVSxJQUhvQjtBQUk5QkMsa0JBQWM7QUFKZ0IsR0FBaEM7QUFNRDs7QUFFRDs7O0FBR0EsSUFBSUMsU0FBUyxTQUFiO0FBQ0EsU0FBUzVULFNBQVQsQ0FBb0JqSSxJQUFwQixFQUEwQjtBQUN4QixNQUFJNmIsT0FBT3RWLElBQVAsQ0FBWXZHLElBQVosQ0FBSixFQUF1QjtBQUNyQjtBQUNEO0FBQ0QsTUFBSStILFdBQVcvSCxLQUFLc0IsS0FBTCxDQUFXLEdBQVgsQ0FBZjtBQUNBLFNBQU8sVUFBVVMsR0FBVixFQUFlO0FBQ3BCLFNBQUssSUFBSW5ILElBQUksQ0FBYixFQUFnQkEsSUFBSW1OLFNBQVM3TixNQUE3QixFQUFxQ1UsR0FBckMsRUFBMEM7QUFDeEMsVUFBSSxDQUFDbUgsR0FBTCxFQUFVO0FBQUU7QUFBUTtBQUNwQkEsWUFBTUEsSUFBSWdHLFNBQVNuTixDQUFULENBQUosQ0FBTjtBQUNEO0FBQ0QsV0FBT21ILEdBQVA7QUFDRCxHQU5EO0FBT0Q7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLElBQUkrWixXQUFXLGVBQWUsRUFBOUI7O0FBRUE7QUFDQSxJQUFJdlUsWUFBWSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxDO0FBQ0EsSUFBSXVVLEtBQUt4VSxhQUFhQyxPQUFPOEosU0FBUCxDQUFpQkMsU0FBakIsQ0FBMkJnSCxXQUEzQixFQUF0QjtBQUNBLElBQUl5RCxPQUFPRCxNQUFNLGVBQWV4VixJQUFmLENBQW9Cd1YsRUFBcEIsQ0FBakI7QUFDQSxJQUFJRSxRQUFRRixNQUFNQSxHQUFHalksT0FBSCxDQUFXLFVBQVgsSUFBeUIsQ0FBM0M7QUFDQSxJQUFJb1ksU0FBU0gsTUFBTUEsR0FBR2pZLE9BQUgsQ0FBVyxPQUFYLElBQXNCLENBQXpDO0FBQ0EsSUFBSXFZLFlBQVlKLE1BQU1BLEdBQUdqWSxPQUFILENBQVcsU0FBWCxJQUF3QixDQUE5QztBQUNBLElBQUlzWSxRQUFRTCxNQUFNLHVCQUF1QnhWLElBQXZCLENBQTRCd1YsRUFBNUIsQ0FBbEI7QUFDQSxJQUFJTSxXQUFXTixNQUFNLGNBQWN4VixJQUFkLENBQW1Cd1YsRUFBbkIsQ0FBTixJQUFnQyxDQUFDRyxNQUFoRDs7QUFFQTtBQUNBO0FBQ0EsSUFBSUksU0FBSjtBQUNBLElBQUlDLG9CQUFvQixZQUFZO0FBQ2xDLE1BQUlELGNBQWMxYyxTQUFsQixFQUE2QjtBQUMzQjtBQUNBLFFBQUksQ0FBQzJILFNBQUQsSUFBYyxPQUFPakwsTUFBUCxLQUFrQixXQUFwQyxFQUFpRDtBQUMvQztBQUNBO0FBQ0FnZ0Isa0JBQVloZ0IsT0FBTyxTQUFQLEVBQWtCbEIsR0FBbEIsQ0FBc0JvaEIsT0FBdEIsS0FBa0MsUUFBOUM7QUFDRCxLQUpELE1BSU87QUFDTEYsa0JBQVksS0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxTQUFQO0FBQ0QsQ0FaRDs7QUFjQTtBQUNBLElBQUkxQixXQUFXclQsYUFBYUMsT0FBT2lWLDRCQUFuQzs7QUFFQTtBQUNBLFNBQVNDLFFBQVQsQ0FBbUJDLElBQW5CLEVBQXlCO0FBQ3ZCLFNBQU8sZUFBY3BXLElBQWQsQ0FBbUJvVyxLQUFLdGMsUUFBTCxFQUFuQjtBQUFQO0FBQ0Q7O0FBRUQsSUFBSXVjLFlBQ0YsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0gsU0FBU0csTUFBVCxDQUFqQyxJQUNBLE9BQU9DLE9BQVAsS0FBbUIsV0FEbkIsSUFDa0NKLFNBQVNJLFFBQVFDLE9BQWpCLENBRnBDOztBQUlBOzs7QUFHQSxJQUFJdmlCLFdBQVksWUFBWTtBQUMxQixNQUFJd2lCLFlBQVksRUFBaEI7QUFDQSxNQUFJeEssVUFBVSxLQUFkO0FBQ0EsTUFBSXlLLFNBQUo7O0FBRUEsV0FBU0MsZUFBVCxHQUE0QjtBQUMxQjFLLGNBQVUsS0FBVjtBQUNBLFFBQUkySyxTQUFTSCxVQUFVN2EsS0FBVixDQUFnQixDQUFoQixDQUFiO0FBQ0E2YSxjQUFVOWlCLE1BQVYsR0FBbUIsQ0FBbkI7QUFDQSxTQUFLLElBQUlVLElBQUksQ0FBYixFQUFnQkEsSUFBSXVpQixPQUFPampCLE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0Q3VpQixhQUFPdmlCLENBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxPQUFPd2lCLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NWLFNBQVNVLE9BQVQsQ0FBdEMsRUFBeUQ7QUFDdkQsUUFBSUMsSUFBSUQsUUFBUXRZLE9BQVIsRUFBUjtBQUNBLFFBQUl3WSxXQUFXLFVBQVVDLEdBQVYsRUFBZTtBQUFFM2YsY0FBUTRmLEtBQVIsQ0FBY0QsR0FBZDtBQUFxQixLQUFyRDtBQUNBTixnQkFBWSxZQUFZO0FBQ3RCSSxRQUFFMUgsSUFBRixDQUFPdUgsZUFBUCxFQUF3Qk8sS0FBeEIsQ0FBOEJILFFBQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlsQixLQUFKLEVBQVc7QUFBRS9pQixtQkFBV21DLElBQVg7QUFBbUI7QUFDakMsS0FSRDtBQVNELEdBWkQsTUFZTyxJQUFJLE9BQU9raUIsZ0JBQVAsS0FBNEIsV0FBNUIsS0FDVGhCLFNBQVNnQixnQkFBVDtBQUNBO0FBQ0FBLG1CQUFpQnJkLFFBQWpCLE9BQWdDLHNDQUh2QixDQUFKLEVBSUo7QUFDRDtBQUNBO0FBQ0EsUUFBSXNkLFVBQVUsQ0FBZDtBQUNBLFFBQUlDLFdBQVcsSUFBSUYsZ0JBQUosQ0FBcUJSLGVBQXJCLENBQWY7QUFDQSxRQUFJVyxXQUFXNU4sU0FBUzZOLGNBQVQsQ0FBd0I3ZixPQUFPMGYsT0FBUCxDQUF4QixDQUFmO0FBQ0FDLGFBQVNHLE9BQVQsQ0FBaUJGLFFBQWpCLEVBQTJCO0FBQ3pCRyxxQkFBZTtBQURVLEtBQTNCO0FBR0FmLGdCQUFZLFlBQVk7QUFDdEJVLGdCQUFVLENBQUNBLFVBQVUsQ0FBWCxJQUFnQixDQUExQjtBQUNBRSxlQUFTdGYsSUFBVCxHQUFnQk4sT0FBTzBmLE9BQVAsQ0FBaEI7QUFDRCxLQUhEO0FBSUQsR0FqQk0sTUFpQkE7QUFDTDtBQUNBO0FBQ0FWLGdCQUFZLFlBQVk7QUFDdEI1akIsaUJBQVc2akIsZUFBWCxFQUE0QixDQUE1QjtBQUNELEtBRkQ7QUFHRDs7QUFFRCxTQUFPLFNBQVNlLGFBQVQsQ0FBd0I3TCxFQUF4QixFQUE0QmlILEdBQTVCLEVBQWlDO0FBQ3RDLFFBQUk2RSxRQUFKO0FBQ0FsQixjQUFVbmlCLElBQVYsQ0FBZSxZQUFZO0FBQ3pCLFVBQUl1WCxFQUFKLEVBQVE7QUFBRUEsV0FBRzFZLElBQUgsQ0FBUTJmLEdBQVI7QUFBZTtBQUN6QixVQUFJNkUsUUFBSixFQUFjO0FBQUVBLGlCQUFTN0UsR0FBVDtBQUFnQjtBQUNqQyxLQUhEO0FBSUEsUUFBSSxDQUFDN0csT0FBTCxFQUFjO0FBQ1pBLGdCQUFVLElBQVY7QUFDQXlLO0FBQ0Q7QUFDRCxRQUFJLENBQUM3SyxFQUFELElBQU8sT0FBT2dMLE9BQVAsS0FBbUIsV0FBOUIsRUFBMkM7QUFDekMsYUFBTyxJQUFJQSxPQUFKLENBQVksVUFBVXRZLE9BQVYsRUFBbUI7QUFDcENvWixtQkFBV3BaLE9BQVg7QUFDRCxPQUZNLENBQVA7QUFHRDtBQUNGLEdBZkQ7QUFnQkQsQ0ExRWMsRUFBZjs7QUE0RUEsSUFBSXFaLElBQUo7QUFDQTtBQUNBLElBQUksT0FBT0MsR0FBUCxLQUFlLFdBQWYsSUFBOEIxQixTQUFTMEIsR0FBVCxDQUFsQyxFQUFpRDtBQUMvQztBQUNBRCxTQUFPQyxHQUFQO0FBQ0QsQ0FIRCxNQUdPO0FBQ0w7QUFDQUQsU0FBUSxZQUFZO0FBQ2xCLGFBQVNDLEdBQVQsR0FBZ0I7QUFDZCxXQUFLQyxHQUFMLEdBQVcxaEIsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQVg7QUFDRDtBQUNEMFYsUUFBSXBqQixTQUFKLENBQWNzakIsR0FBZCxHQUFvQixTQUFTQSxHQUFULENBQWNuZCxHQUFkLEVBQW1CO0FBQ3JDLGFBQU8sS0FBS2tkLEdBQUwsQ0FBU2xkLEdBQVQsTUFBa0IsSUFBekI7QUFDRCxLQUZEO0FBR0FpZCxRQUFJcGpCLFNBQUosQ0FBY3VqQixHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY3BkLEdBQWQsRUFBbUI7QUFDckMsV0FBS2tkLEdBQUwsQ0FBU2xkLEdBQVQsSUFBZ0IsSUFBaEI7QUFDRCxLQUZEO0FBR0FpZCxRQUFJcGpCLFNBQUosQ0FBY3dqQixLQUFkLEdBQXNCLFNBQVNBLEtBQVQsR0FBa0I7QUFDdEMsV0FBS0gsR0FBTCxHQUFXMWhCLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0QsS0FGRDs7QUFJQSxXQUFPMFYsR0FBUDtBQUNELEdBZk8sRUFBUjtBQWdCRDs7QUFFRCxJQUFJemdCLE9BQU9uQyxJQUFYO0FBQ0EsSUFBSWlqQixNQUFNampCLElBQVY7QUFDQSxJQUFJa2pCLG1CQUFKOztBQUVBLElBQUk3bEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSXlkLGFBQWEsT0FBTy9nQixPQUFQLEtBQW1CLFdBQXBDO0FBQ0EsTUFBSWdoQixhQUFhLGlCQUFqQjtBQUNBLE1BQUlDLFdBQVcsVUFBVXJlLEdBQVYsRUFBZTtBQUFFLFdBQU9BLElBQ3BDRSxPQURvQyxDQUM1QmtlLFVBRDRCLEVBQ2hCLFVBQVV6ZSxDQUFWLEVBQWE7QUFBRSxhQUFPQSxFQUFFc0wsV0FBRixFQUFQO0FBQXlCLEtBRHhCLEVBRXBDL0ssT0FGb0MsQ0FFNUIsT0FGNEIsRUFFbkIsRUFGbUIsQ0FBUDtBQUVOLEdBRjFCOztBQUlBL0MsU0FBTyxVQUFVbWhCLEdBQVYsRUFBZUMsRUFBZixFQUFtQjtBQUN4QixRQUFJSixjQUFlLENBQUM3ZSxPQUFPNGEsTUFBM0IsRUFBb0M7QUFDbEM5YyxjQUFRNGYsS0FBUixDQUFjLGlCQUFpQnNCLEdBQWpCLEdBQXVCLEdBQXZCLElBQ1pDLEtBQUtDLGVBQWVOLG9CQUFvQkssRUFBcEIsQ0FBZixDQUFMLEdBQStDLEVBRG5DLENBQWQ7QUFHRDtBQUNGLEdBTkQ7O0FBUUFOLFFBQU0sVUFBVUssR0FBVixFQUFlQyxFQUFmLEVBQW1CO0FBQ3ZCLFFBQUlKLGNBQWUsQ0FBQzdlLE9BQU80YSxNQUEzQixFQUFvQztBQUNsQzljLGNBQVFELElBQVIsQ0FBYSxnQkFBZ0JtaEIsR0FBaEIsR0FBc0IsR0FBdEIsSUFDWEMsS0FBS0MsZUFBZU4sb0JBQW9CSyxFQUFwQixDQUFmLENBQUwsR0FBK0MsRUFEcEMsQ0FBYjtBQUdEO0FBQ0YsR0FORDs7QUFRQUwsd0JBQXNCLFVBQVVLLEVBQVYsRUFBY0UsV0FBZCxFQUEyQjtBQUMvQyxRQUFJRixHQUFHclksS0FBSCxLQUFhcVksRUFBakIsRUFBcUI7QUFDbkIsYUFBTyxRQUFQO0FBQ0Q7QUFDRCxRQUFJOWlCLE9BQU8sT0FBTzhpQixFQUFQLEtBQWMsUUFBZCxHQUNQQSxFQURPLEdBRVAsT0FBT0EsRUFBUCxLQUFjLFVBQWQsSUFBNEJBLEdBQUc5WixPQUEvQixHQUNFOFosR0FBRzlaLE9BQUgsQ0FBV2hKLElBRGIsR0FFRThpQixHQUFHRyxNQUFILEdBQ0VILEdBQUdoWSxRQUFILENBQVk5SyxJQUFaLElBQW9COGlCLEdBQUdoWSxRQUFILENBQVlvWSxhQURsQyxHQUVFSixHQUFHOWlCLElBTlg7O0FBUUEsUUFBSW1qQixPQUFPTCxHQUFHRyxNQUFILElBQWFILEdBQUdoWSxRQUFILENBQVlzWSxNQUFwQztBQUNBLFFBQUksQ0FBQ3BqQixJQUFELElBQVNtakIsSUFBYixFQUFtQjtBQUNqQixVQUFJMVMsUUFBUTBTLEtBQUsxUyxLQUFMLENBQVcsaUJBQVgsQ0FBWjtBQUNBelEsYUFBT3lRLFNBQVNBLE1BQU0sQ0FBTixDQUFoQjtBQUNEOztBQUVELFdBQ0UsQ0FBQ3pRLE9BQVEsTUFBTzRpQixTQUFTNWlCLElBQVQsQ0FBUCxHQUF5QixHQUFqQyxHQUF3QyxhQUF6QyxLQUNDbWpCLFFBQVFILGdCQUFnQixLQUF4QixHQUFpQyxTQUFTRyxJQUExQyxHQUFrRCxFQURuRCxDQURGO0FBSUQsR0F0QkQ7O0FBd0JBLE1BQUlKLGlCQUFpQixVQUFVeGUsR0FBVixFQUFlO0FBQ2xDLFFBQUlBLFFBQVEsYUFBWixFQUEyQjtBQUN6QkEsYUFBTywyREFBUDtBQUNEO0FBQ0QsV0FBUSxpQkFBaUJBLEdBQWpCLEdBQXVCLEdBQS9CO0FBQ0QsR0FMRDtBQU1EOztBQUVEOztBQUdBLElBQUk4ZSxRQUFRLENBQVo7O0FBRUE7Ozs7QUFJQSxJQUFJQyxNQUFNLFNBQVNBLEdBQVQsR0FBZ0I7QUFDeEIsT0FBS0MsRUFBTCxHQUFVRixPQUFWO0FBQ0EsT0FBS0csSUFBTCxHQUFZLEVBQVo7QUFDRCxDQUhEOztBQUtBRixJQUFJdmtCLFNBQUosQ0FBYzBrQixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQzNDLE9BQUtGLElBQUwsQ0FBVTVrQixJQUFWLENBQWU4a0IsR0FBZjtBQUNELENBRkQ7O0FBSUFKLElBQUl2a0IsU0FBSixDQUFjNGtCLFNBQWQsR0FBMEIsU0FBU0EsU0FBVCxDQUFvQkQsR0FBcEIsRUFBeUI7QUFDakRsSCxTQUFPLEtBQUtnSCxJQUFaLEVBQWtCRSxHQUFsQjtBQUNELENBRkQ7O0FBSUFKLElBQUl2a0IsU0FBSixDQUFjNmtCLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QyxNQUFJTixJQUFJMWIsTUFBUixFQUFnQjtBQUNkMGIsUUFBSTFiLE1BQUosQ0FBV2ljLE1BQVgsQ0FBa0IsSUFBbEI7QUFDRDtBQUNGLENBSkQ7O0FBTUFQLElBQUl2a0IsU0FBSixDQUFjK2tCLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QztBQUNBLE1BQUlOLE9BQU8sS0FBS0EsSUFBTCxDQUFVdGQsS0FBVixFQUFYO0FBQ0EsT0FBSyxJQUFJdkgsSUFBSSxDQUFSLEVBQVcyZSxJQUFJa0csS0FBS3ZsQixNQUF6QixFQUFpQ1UsSUFBSTJlLENBQXJDLEVBQXdDM2UsR0FBeEMsRUFBNkM7QUFDM0M2a0IsU0FBSzdrQixDQUFMLEVBQVFvbEIsTUFBUjtBQUNEO0FBQ0YsQ0FORDs7QUFRQTtBQUNBO0FBQ0E7QUFDQVQsSUFBSTFiLE1BQUosR0FBYSxJQUFiO0FBQ0EsSUFBSW9jLGNBQWMsRUFBbEI7O0FBRUEsU0FBU0MsVUFBVCxDQUFxQkMsT0FBckIsRUFBOEI7QUFDNUIsTUFBSVosSUFBSTFiLE1BQVIsRUFBZ0I7QUFBRW9jLGdCQUFZcGxCLElBQVosQ0FBaUIwa0IsSUFBSTFiLE1BQXJCO0FBQStCO0FBQ2pEMGIsTUFBSTFiLE1BQUosR0FBYXNjLE9BQWI7QUFDRDs7QUFFRCxTQUFTQyxTQUFULEdBQXNCO0FBQ3BCYixNQUFJMWIsTUFBSixHQUFhb2MsWUFBWW5ZLEdBQVosRUFBYjtBQUNEOztBQUVEOzs7OztBQUtBLElBQUl1WSxhQUFhM2xCLE1BQU1NLFNBQXZCO0FBQ0EsSUFBSXNsQixlQUFlM2pCLE9BQU8rTCxNQUFQLENBQWMyWCxVQUFkLENBQW5CLENBQTZDLENBQzNDLE1BRDJDLEVBRTNDLEtBRjJDLEVBRzNDLE9BSDJDLEVBSTNDLFNBSjJDLEVBSzNDLFFBTDJDLEVBTTNDLE1BTjJDLEVBTzNDLFNBUDJDLEVBUzVDOWUsT0FUNEMsQ0FTcEMsVUFBVWdmLE1BQVYsRUFBa0I7QUFDekI7QUFDQSxNQUFJQyxXQUFXSCxXQUFXRSxNQUFYLENBQWY7QUFDQTNMLE1BQUkwTCxZQUFKLEVBQWtCQyxNQUFsQixFQUEwQixTQUFTRSxPQUFULEdBQW9CO0FBQzVDLFFBQUlDLGNBQWMvbEIsU0FBbEI7O0FBRUE7QUFDQTtBQUNBLFFBQUlDLElBQUlELFVBQVVULE1BQWxCO0FBQ0EsUUFBSU8sT0FBTyxJQUFJQyxLQUFKLENBQVVFLENBQVYsQ0FBWDtBQUNBLFdBQU9BLEdBQVAsRUFBWTtBQUNWSCxXQUFLRyxDQUFMLElBQVU4bEIsWUFBWTlsQixDQUFaLENBQVY7QUFDRDtBQUNELFFBQUlzSCxTQUFTc2UsU0FBU3ZsQixLQUFULENBQWUsSUFBZixFQUFxQlIsSUFBckIsQ0FBYjtBQUNBLFFBQUlrbUIsS0FBSyxLQUFLQyxNQUFkO0FBQ0EsUUFBSUMsUUFBSjtBQUNBLFlBQVFOLE1BQVI7QUFDRSxXQUFLLE1BQUw7QUFDRU0sbUJBQVdwbUIsSUFBWDtBQUNBO0FBQ0YsV0FBSyxTQUFMO0FBQ0VvbUIsbUJBQVdwbUIsSUFBWDtBQUNBO0FBQ0YsV0FBSyxRQUFMO0FBQ0VvbUIsbUJBQVdwbUIsS0FBSzBILEtBQUwsQ0FBVyxDQUFYLENBQVg7QUFDQTtBQVRKO0FBV0EsUUFBSTBlLFFBQUosRUFBYztBQUFFRixTQUFHRyxZQUFILENBQWdCRCxRQUFoQjtBQUE0QjtBQUM1QztBQUNBRixPQUFHSSxHQUFILENBQU9oQixNQUFQO0FBQ0EsV0FBTzdkLE1BQVA7QUFDRCxHQTVCRDtBQTZCRCxDQXpDNEM7O0FBMkM3Qzs7QUFFQSxJQUFJOGUsWUFBWXJrQixPQUFPc2tCLG1CQUFQLENBQTJCWCxZQUEzQixDQUFoQjs7QUFFQTs7Ozs7O0FBTUEsSUFBSVksZ0JBQWdCO0FBQ2xCQyxpQkFBZSxJQURHO0FBRWxCQyxrQkFBZ0I7QUFGRSxDQUFwQjs7QUFLQTs7Ozs7O0FBTUEsSUFBSUMsV0FBVyxTQUFTQSxRQUFULENBQW1CeGtCLEtBQW5CLEVBQTBCO0FBQ3ZDLE9BQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLE9BQUtra0IsR0FBTCxHQUFXLElBQUl4QixHQUFKLEVBQVg7QUFDQSxPQUFLK0IsT0FBTCxHQUFlLENBQWY7QUFDQTFNLE1BQUkvWCxLQUFKLEVBQVcsUUFBWCxFQUFxQixJQUFyQjtBQUNBLE1BQUluQyxNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLFFBQUkwa0IsVUFBVXpGLFdBQ1YwRixZQURVLEdBRVZDLFdBRko7QUFHQUYsWUFBUTFrQixLQUFSLEVBQWV5akIsWUFBZixFQUE2QlUsU0FBN0I7QUFDQSxTQUFLRixZQUFMLENBQWtCamtCLEtBQWxCO0FBQ0QsR0FORCxNQU1PO0FBQ0wsU0FBSzZrQixJQUFMLENBQVU3a0IsS0FBVjtBQUNEO0FBQ0YsQ0FkRDs7QUFnQkE7Ozs7O0FBS0F3a0IsU0FBU3JtQixTQUFULENBQW1CMG1CLElBQW5CLEdBQTBCLFNBQVNBLElBQVQsQ0FBZTNmLEdBQWYsRUFBb0I7QUFDNUMsTUFBSUMsT0FBT3JGLE9BQU9xRixJQUFQLENBQVlELEdBQVosQ0FBWDtBQUNBLE9BQUssSUFBSW5ILElBQUksQ0FBYixFQUFnQkEsSUFBSW9ILEtBQUs5SCxNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcEMrbUIsc0JBQWtCNWYsR0FBbEIsRUFBdUJDLEtBQUtwSCxDQUFMLENBQXZCLEVBQWdDbUgsSUFBSUMsS0FBS3BILENBQUwsQ0FBSixDQUFoQztBQUNEO0FBQ0YsQ0FMRDs7QUFPQTs7O0FBR0F5bUIsU0FBU3JtQixTQUFULENBQW1COGxCLFlBQW5CLEdBQWtDLFNBQVNBLFlBQVQsQ0FBdUJjLEtBQXZCLEVBQThCO0FBQzlELE9BQUssSUFBSWhuQixJQUFJLENBQVIsRUFBVzJlLElBQUlxSSxNQUFNMW5CLE1BQTFCLEVBQWtDVSxJQUFJMmUsQ0FBdEMsRUFBeUMzZSxHQUF6QyxFQUE4QztBQUM1Q21qQixZQUFRNkQsTUFBTWhuQixDQUFOLENBQVI7QUFDRDtBQUNGLENBSkQ7O0FBTUE7O0FBRUE7Ozs7QUFJQSxTQUFTNG1CLFlBQVQsQ0FBdUIzZCxNQUF2QixFQUErQmdlLEdBQS9CLEVBQW9DO0FBQ2xDO0FBQ0FoZSxTQUFPb1MsU0FBUCxHQUFtQjRMLEdBQW5CO0FBQ0E7QUFDRDs7QUFFRDs7OztBQUlBO0FBQ0EsU0FBU0osV0FBVCxDQUFzQjVkLE1BQXRCLEVBQThCZ2UsR0FBOUIsRUFBbUM3ZixJQUFuQyxFQUF5QztBQUN2QyxPQUFLLElBQUlwSCxJQUFJLENBQVIsRUFBVzJlLElBQUl2WCxLQUFLOUgsTUFBekIsRUFBaUNVLElBQUkyZSxDQUFyQyxFQUF3QzNlLEdBQXhDLEVBQTZDO0FBQzNDLFFBQUl1RyxNQUFNYSxLQUFLcEgsQ0FBTCxDQUFWO0FBQ0FnYSxRQUFJL1EsTUFBSixFQUFZMUMsR0FBWixFQUFpQjBnQixJQUFJMWdCLEdBQUosQ0FBakI7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVM0YyxPQUFULENBQWtCbGhCLEtBQWxCLEVBQXlCaWxCLFVBQXpCLEVBQXFDO0FBQ25DLE1BQUksQ0FBQ2hTLFNBQVNqVCxLQUFULENBQUwsRUFBc0I7QUFDcEI7QUFDRDtBQUNELE1BQUk4akIsRUFBSjtBQUNBLE1BQUkvSCxPQUFPL2IsS0FBUCxFQUFjLFFBQWQsS0FBMkJBLE1BQU0rakIsTUFBTixZQUF3QlMsUUFBdkQsRUFBaUU7QUFDL0RWLFNBQUs5akIsTUFBTStqQixNQUFYO0FBQ0QsR0FGRCxNQUVPLElBQ0xNLGNBQWNDLGFBQWQsSUFDQSxDQUFDNUUsbUJBREQsS0FFQzdoQixNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxLQUF3QmlkLGNBQWNqZCxLQUFkLENBRnpCLEtBR0FGLE9BQU9vbEIsWUFBUCxDQUFvQmxsQixLQUFwQixDQUhBLElBSUEsQ0FBQ0EsTUFBTXFpQixNQUxGLEVBTUw7QUFDQXlCLFNBQUssSUFBSVUsUUFBSixDQUFheGtCLEtBQWIsQ0FBTDtBQUNEO0FBQ0QsTUFBSWlsQixjQUFjbkIsRUFBbEIsRUFBc0I7QUFDcEJBLE9BQUdXLE9BQUg7QUFDRDtBQUNELFNBQU9YLEVBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU2dCLGlCQUFULENBQ0U1ZixHQURGLEVBRUVaLEdBRkYsRUFHRVEsR0FIRixFQUlFcWdCLFlBSkYsRUFLRTtBQUNBLE1BQUlqQixNQUFNLElBQUl4QixHQUFKLEVBQVY7O0FBRUEsTUFBSTBDLFdBQVd0bEIsT0FBT3VsQix3QkFBUCxDQUFnQ25nQixHQUFoQyxFQUFxQ1osR0FBckMsQ0FBZjtBQUNBLE1BQUk4Z0IsWUFBWUEsU0FBU3JHLFlBQVQsS0FBMEIsS0FBMUMsRUFBaUQ7QUFDL0M7QUFDRDs7QUFFRDtBQUNBLE1BQUl1RyxTQUFTRixZQUFZQSxTQUFTOWtCLEdBQWxDO0FBQ0EsTUFBSWlsQixTQUFTSCxZQUFZQSxTQUFTNUQsR0FBbEM7O0FBRUEsTUFBSWdFLFVBQVV0RSxRQUFRcGMsR0FBUixDQUFkO0FBQ0FoRixTQUFPQyxjQUFQLENBQXNCbUYsR0FBdEIsRUFBMkJaLEdBQTNCLEVBQWdDO0FBQzlCdWEsZ0JBQVksSUFEa0I7QUFFOUJFLGtCQUFjLElBRmdCO0FBRzlCemUsU0FBSyxTQUFTbWxCLGNBQVQsR0FBMkI7QUFDOUIsVUFBSXpsQixRQUFRc2xCLFNBQVNBLE9BQU96b0IsSUFBUCxDQUFZcUksR0FBWixDQUFULEdBQTRCSixHQUF4QztBQUNBLFVBQUk0ZCxJQUFJMWIsTUFBUixFQUFnQjtBQUNka2QsWUFBSWxCLE1BQUo7QUFDQSxZQUFJd0MsT0FBSixFQUFhO0FBQ1hBLGtCQUFRdEIsR0FBUixDQUFZbEIsTUFBWjtBQUNEO0FBQ0QsWUFBSW5sQixNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCMGxCLHNCQUFZMWxCLEtBQVo7QUFDRDtBQUNGO0FBQ0QsYUFBT0EsS0FBUDtBQUNELEtBZjZCO0FBZ0I5QndoQixTQUFLLFNBQVNtRSxjQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUNwQyxVQUFJNWxCLFFBQVFzbEIsU0FBU0EsT0FBT3pvQixJQUFQLENBQVlxSSxHQUFaLENBQVQsR0FBNEJKLEdBQXhDO0FBQ0E7QUFDQSxVQUFJOGdCLFdBQVc1bEIsS0FBWCxJQUFxQjRsQixXQUFXQSxNQUFYLElBQXFCNWxCLFVBQVVBLEtBQXhELEVBQWdFO0FBQzlEO0FBQ0Q7QUFDRDtBQUNBLFVBQUloRSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzhnQixZQUE3QyxFQUEyRDtBQUN6REE7QUFDRDtBQUNELFVBQUlJLE1BQUosRUFBWTtBQUNWQSxlQUFPMW9CLElBQVAsQ0FBWXFJLEdBQVosRUFBaUIwZ0IsTUFBakI7QUFDRCxPQUZELE1BRU87QUFDTDlnQixjQUFNOGdCLE1BQU47QUFDRDtBQUNESixnQkFBVXRFLFFBQVEwRSxNQUFSLENBQVY7QUFDQTFCLFVBQUloQixNQUFKO0FBQ0Q7QUFqQzZCLEdBQWhDO0FBbUNEOztBQUVEOzs7OztBQUtBLFNBQVMxQixHQUFULENBQWN4YSxNQUFkLEVBQXNCMUMsR0FBdEIsRUFBMkJRLEdBQTNCLEVBQWdDO0FBQzlCLE1BQUlqSCxNQUFNbUgsT0FBTixDQUFjZ0MsTUFBZCxLQUF5QixPQUFPMUMsR0FBUCxLQUFlLFFBQTVDLEVBQXNEO0FBQ3BEMEMsV0FBTzNKLE1BQVAsR0FBZ0JtYSxLQUFLRCxHQUFMLENBQVN2USxPQUFPM0osTUFBaEIsRUFBd0JpSCxHQUF4QixDQUFoQjtBQUNBMEMsV0FBTzhVLE1BQVAsQ0FBY3hYLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0JRLEdBQXRCO0FBQ0EsV0FBT0EsR0FBUDtBQUNEO0FBQ0QsTUFBSWlYLE9BQU8vVSxNQUFQLEVBQWUxQyxHQUFmLENBQUosRUFBeUI7QUFDdkIwQyxXQUFPMUMsR0FBUCxJQUFjUSxHQUFkO0FBQ0EsV0FBT0EsR0FBUDtBQUNEO0FBQ0QsTUFBSWdmLEtBQU05YyxNQUFELENBQVUrYyxNQUFuQjtBQUNBLE1BQUkvYyxPQUFPcWIsTUFBUCxJQUFrQnlCLE1BQU1BLEdBQUdXLE9BQS9CLEVBQXlDO0FBQ3ZDem9CLFlBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsMEVBQ0EscURBRnVDLENBQXpDO0FBSUEsV0FBT2dFLEdBQVA7QUFDRDtBQUNELE1BQUksQ0FBQ2dmLEVBQUwsRUFBUztBQUNQOWMsV0FBTzFDLEdBQVAsSUFBY1EsR0FBZDtBQUNBLFdBQU9BLEdBQVA7QUFDRDtBQUNEZ2dCLG9CQUFrQmhCLEdBQUc5akIsS0FBckIsRUFBNEJzRSxHQUE1QixFQUFpQ1EsR0FBakM7QUFDQWdmLEtBQUdJLEdBQUgsQ0FBT2hCLE1BQVA7QUFDQSxTQUFPcGUsR0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTK2dCLEdBQVQsQ0FBYzdlLE1BQWQsRUFBc0IxQyxHQUF0QixFQUEyQjtBQUN6QixNQUFJekcsTUFBTW1ILE9BQU4sQ0FBY2dDLE1BQWQsS0FBeUIsT0FBTzFDLEdBQVAsS0FBZSxRQUE1QyxFQUFzRDtBQUNwRDBDLFdBQU84VSxNQUFQLENBQWN4WCxHQUFkLEVBQW1CLENBQW5CO0FBQ0E7QUFDRDtBQUNELE1BQUl3ZixLQUFNOWMsTUFBRCxDQUFVK2MsTUFBbkI7QUFDQSxNQUFJL2MsT0FBT3FiLE1BQVAsSUFBa0J5QixNQUFNQSxHQUFHVyxPQUEvQixFQUF5QztBQUN2Q3pvQixZQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLG1FQUNBLHdCQUZ1QyxDQUF6QztBQUlBO0FBQ0Q7QUFDRCxNQUFJLENBQUNpYixPQUFPL1UsTUFBUCxFQUFlMUMsR0FBZixDQUFMLEVBQTBCO0FBQ3hCO0FBQ0Q7QUFDRCxTQUFPMEMsT0FBTzFDLEdBQVAsQ0FBUDtBQUNBLE1BQUksQ0FBQ3dmLEVBQUwsRUFBUztBQUNQO0FBQ0Q7QUFDREEsS0FBR0ksR0FBSCxDQUFPaEIsTUFBUDtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU3dDLFdBQVQsQ0FBc0IxbEIsS0FBdEIsRUFBNkI7QUFDM0IsT0FBSyxJQUFJdkQsSUFBSyxLQUFLLENBQWQsRUFBa0JzQixJQUFJLENBQXRCLEVBQXlCMmUsSUFBSTFjLE1BQU0zQyxNQUF4QyxFQUFnRFUsSUFBSTJlLENBQXBELEVBQXVEM2UsR0FBdkQsRUFBNEQ7QUFDMUR0QixRQUFJdUQsTUFBTWpDLENBQU4sQ0FBSjtBQUNBdEIsU0FBS0EsRUFBRXNuQixNQUFQLElBQWlCdG5CLEVBQUVzbkIsTUFBRixDQUFTRyxHQUFULENBQWFsQixNQUFiLEVBQWpCO0FBQ0EsUUFBSW5sQixNQUFNbUgsT0FBTixDQUFjdkksQ0FBZCxDQUFKLEVBQXNCO0FBQ3BCaXBCLGtCQUFZanBCLENBQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUE7Ozs7O0FBS0EsSUFBSTROLFNBQVNwSCxPQUFPcUgscUJBQXBCOztBQUVBOzs7QUFHQSxJQUFJdE8sUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnRyxTQUFPOEksRUFBUCxHQUFZOUksT0FBT3liLFNBQVAsR0FBbUIsVUFBVXJrQixNQUFWLEVBQWtCa0IsS0FBbEIsRUFBeUJ1ZixFQUF6QixFQUE2QjVkLEdBQTdCLEVBQWtDO0FBQy9ELFFBQUksQ0FBQzRkLEVBQUwsRUFBUztBQUNQcGhCLFdBQ0UsY0FBY3dELEdBQWQsR0FBb0Isc0NBQXBCLEdBQ0Esa0NBRkY7QUFJRDtBQUNELFdBQU95aEIsYUFBYXRrQixNQUFiLEVBQXFCa0IsS0FBckIsQ0FBUDtBQUNELEdBUkQ7QUFTRDs7QUFFRDs7O0FBR0EsU0FBU3FqQixTQUFULENBQW9CMWUsRUFBcEIsRUFBd0JrTCxJQUF4QixFQUE4QjtBQUM1QixNQUFJLENBQUNBLElBQUwsRUFBVztBQUFFLFdBQU9sTCxFQUFQO0FBQVc7QUFDeEIsTUFBSWhELEdBQUosRUFBUzJoQixLQUFULEVBQWdCQyxPQUFoQjtBQUNBLE1BQUkvZ0IsT0FBT3JGLE9BQU9xRixJQUFQLENBQVlxTixJQUFaLENBQVg7QUFDQSxPQUFLLElBQUl6VSxJQUFJLENBQWIsRUFBZ0JBLElBQUlvSCxLQUFLOUgsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDdUcsVUFBTWEsS0FBS3BILENBQUwsQ0FBTjtBQUNBa29CLFlBQVEzZSxHQUFHaEQsR0FBSCxDQUFSO0FBQ0E0aEIsY0FBVTFULEtBQUtsTyxHQUFMLENBQVY7QUFDQSxRQUFJLENBQUN5WCxPQUFPelUsRUFBUCxFQUFXaEQsR0FBWCxDQUFMLEVBQXNCO0FBQ3BCa2QsVUFBSWxhLEVBQUosRUFBUWhELEdBQVIsRUFBYTRoQixPQUFiO0FBQ0QsS0FGRCxNQUVPLElBQUlqSixjQUFjZ0osS0FBZCxLQUF3QmhKLGNBQWNpSixPQUFkLENBQTVCLEVBQW9EO0FBQ3pERixnQkFBVUMsS0FBVixFQUFpQkMsT0FBakI7QUFDRDtBQUNGO0FBQ0QsU0FBTzVlLEVBQVA7QUFDRDs7QUFFRDs7O0FBR0ErQyxPQUFPM0ksSUFBUCxHQUFjLFVBQ1p5a0IsU0FEWSxFQUVaQyxRQUZZLEVBR1psRSxFQUhZLEVBSVo7QUFDQSxNQUFJLENBQUNBLEVBQUwsRUFBUztBQUNQO0FBQ0EsUUFBSSxDQUFDa0UsUUFBTCxFQUFlO0FBQ2IsYUFBT0QsU0FBUDtBQUNEO0FBQ0QsUUFBSSxPQUFPQyxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDcHFCLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsNENBQ0EsaURBREEsR0FFQSxjQUh1QyxFQUl2Q29oQixFQUp1QyxDQUF6QztBQU1BLGFBQU9pRSxTQUFQO0FBQ0Q7QUFDRCxRQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZCxhQUFPQyxRQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxTQUFTQyxZQUFULEdBQXlCO0FBQzlCLGFBQU9MLFVBQ0xJLFNBQVN2cEIsSUFBVCxDQUFjLElBQWQsQ0FESyxFQUVMc3BCLFVBQVV0cEIsSUFBVixDQUFlLElBQWYsQ0FGSyxDQUFQO0FBSUQsS0FMRDtBQU1ELEdBNUJELE1BNEJPLElBQUlzcEIsYUFBYUMsUUFBakIsRUFBMkI7QUFDaEMsV0FBTyxTQUFTRSxvQkFBVCxHQUFpQztBQUN0QztBQUNBLFVBQUlDLGVBQWUsT0FBT0gsUUFBUCxLQUFvQixVQUFwQixHQUNmQSxTQUFTdnBCLElBQVQsQ0FBY3FsQixFQUFkLENBRGUsR0FFZmtFLFFBRko7QUFHQSxVQUFJSSxjQUFjLE9BQU9MLFNBQVAsS0FBcUIsVUFBckIsR0FDZEEsVUFBVXRwQixJQUFWLENBQWVxbEIsRUFBZixDQURjLEdBRWRuZixTQUZKO0FBR0EsVUFBSXdqQixZQUFKLEVBQWtCO0FBQ2hCLGVBQU9QLFVBQVVPLFlBQVYsRUFBd0JDLFdBQXhCLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPQSxXQUFQO0FBQ0Q7QUFDRixLQWJEO0FBY0Q7QUFDRixDQWpERDs7QUFtREE7OztBQUdBLFNBQVNDLFNBQVQsQ0FDRU4sU0FERixFQUVFQyxRQUZGLEVBR0U7QUFDQSxTQUFPQSxXQUNIRCxZQUNFQSxVQUFVN29CLE1BQVYsQ0FBaUI4b0IsUUFBakIsQ0FERixHQUVFdm9CLE1BQU1tSCxPQUFOLENBQWNvaEIsUUFBZCxJQUNFQSxRQURGLEdBRUUsQ0FBQ0EsUUFBRCxDQUxELEdBTUhELFNBTko7QUFPRDs7QUFFRGxqQixPQUFPd2IsZUFBUCxDQUF1Qi9aLE9BQXZCLENBQStCLFVBQVVuQyxJQUFWLEVBQWdCO0FBQzdDOEgsU0FBTzlILElBQVAsSUFBZWtrQixTQUFmO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7OztBQU9BLFNBQVNDLFdBQVQsQ0FBc0JQLFNBQXRCLEVBQWlDQyxRQUFqQyxFQUEyQztBQUN6QyxNQUFJN2hCLE1BQU16RSxPQUFPK0wsTUFBUCxDQUFjc2EsYUFBYSxJQUEzQixDQUFWO0FBQ0EsU0FBT0MsV0FDSHJkLE9BQU94RSxHQUFQLEVBQVk2aEIsUUFBWixDQURHLEdBRUg3aEIsR0FGSjtBQUdEOztBQUVEdEIsT0FBT3ViLFdBQVAsQ0FBbUI5WixPQUFuQixDQUEyQixVQUFVdkQsSUFBVixFQUFnQjtBQUN6Q2tKLFNBQU9sSixPQUFPLEdBQWQsSUFBcUJ1bEIsV0FBckI7QUFDRCxDQUZEOztBQUlBOzs7Ozs7QUFNQXJjLE9BQU9zYyxLQUFQLEdBQWUsVUFBVVIsU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDNUM7QUFDQSxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUFFLFdBQU90bUIsT0FBTytMLE1BQVAsQ0FBY3NhLGFBQWEsSUFBM0IsQ0FBUDtBQUF5QztBQUMxRCxNQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFBRSxXQUFPQyxRQUFQO0FBQWlCO0FBQ25DLE1BQUl0SixNQUFNLEVBQVY7QUFDQS9ULFNBQU8rVCxHQUFQLEVBQVlxSixTQUFaO0FBQ0EsT0FBSyxJQUFJN2hCLEdBQVQsSUFBZ0I4aEIsUUFBaEIsRUFBMEI7QUFDeEIsUUFBSTNrQixTQUFTcWIsSUFBSXhZLEdBQUosQ0FBYjtBQUNBLFFBQUkzQixRQUFReWpCLFNBQVM5aEIsR0FBVCxDQUFaO0FBQ0EsUUFBSTdDLFVBQVUsQ0FBQzVELE1BQU1tSCxPQUFOLENBQWN2RCxNQUFkLENBQWYsRUFBc0M7QUFDcENBLGVBQVMsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0Q7QUFDRHFiLFFBQUl4WSxHQUFKLElBQVc3QyxTQUNQQSxPQUFPbkUsTUFBUCxDQUFjcUYsS0FBZCxDQURPLEdBRVAsQ0FBQ0EsS0FBRCxDQUZKO0FBR0Q7QUFDRCxTQUFPbWEsR0FBUDtBQUNELENBakJEOztBQW1CQTs7O0FBR0F6UyxPQUFPbkosS0FBUCxHQUNBbUosT0FBT3VjLE9BQVAsR0FDQXZjLE9BQU93YyxRQUFQLEdBQWtCLFVBQVVWLFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCO0FBQy9DLE1BQUksQ0FBQ0EsUUFBTCxFQUFlO0FBQUUsV0FBT3RtQixPQUFPK0wsTUFBUCxDQUFjc2EsYUFBYSxJQUEzQixDQUFQO0FBQXlDO0FBQzFELE1BQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUFFLFdBQU9DLFFBQVA7QUFBaUI7QUFDbkMsTUFBSXRKLE1BQU1oZCxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBOUMsU0FBTytULEdBQVAsRUFBWXFKLFNBQVo7QUFDQXBkLFNBQU8rVCxHQUFQLEVBQVlzSixRQUFaO0FBQ0EsU0FBT3RKLEdBQVA7QUFDRCxDQVREOztBQVdBOzs7QUFHQSxJQUFJaUosZUFBZSxVQUFVSSxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUNoRCxTQUFPQSxhQUFhcmpCLFNBQWIsR0FDSG9qQixTQURHLEdBRUhDLFFBRko7QUFHRCxDQUpEOztBQU1BOzs7QUFHQSxTQUFTVSxlQUFULENBQTBCMWUsT0FBMUIsRUFBbUM7QUFDakMsT0FBSyxJQUFJOUQsR0FBVCxJQUFnQjhELFFBQVEvRixVQUF4QixFQUFvQztBQUNsQyxRQUFJMGtCLFFBQVF6aUIsSUFBSW9YLFdBQUosRUFBWjtBQUNBLFFBQUlDLGFBQWFvTCxLQUFiLEtBQXVCOWpCLE9BQU9rYixhQUFQLENBQXFCNEksS0FBckIsQ0FBM0IsRUFBd0Q7QUFDdERqbUIsV0FDRSxnRUFDQSxNQURBLEdBQ1N3RCxHQUZYO0FBSUQ7QUFDRjtBQUNGOztBQUVEOzs7O0FBSUEsU0FBUzBpQixjQUFULENBQXlCNWUsT0FBekIsRUFBa0M7QUFDaEMsTUFBSWxILFFBQVFrSCxRQUFRbEgsS0FBcEI7QUFDQSxNQUFJLENBQUNBLEtBQUwsRUFBWTtBQUFFO0FBQVE7QUFDdEIsTUFBSXFELE1BQU0sRUFBVjtBQUNBLE1BQUl4RyxDQUFKLEVBQU8rRyxHQUFQLEVBQVkxRixJQUFaO0FBQ0EsTUFBSXZCLE1BQU1tSCxPQUFOLENBQWM5RCxLQUFkLENBQUosRUFBMEI7QUFDeEJuRCxRQUFJbUQsTUFBTTdELE1BQVY7QUFDQSxXQUFPVSxHQUFQLEVBQVk7QUFDVitHLFlBQU01RCxNQUFNbkQsQ0FBTixDQUFOO0FBQ0EsVUFBSSxPQUFPK0csR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCMUYsZUFBT2dkLFNBQVN0WCxHQUFULENBQVA7QUFDQVAsWUFBSW5GLElBQUosSUFBWSxFQUFFK0IsTUFBTSxJQUFSLEVBQVo7QUFDRCxPQUhELE1BR08sSUFBSW5GLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEdkQsYUFBSyxnREFBTDtBQUNEO0FBQ0Y7QUFDRixHQVhELE1BV08sSUFBSW1jLGNBQWMvYixLQUFkLENBQUosRUFBMEI7QUFDL0IsU0FBSyxJQUFJb0QsR0FBVCxJQUFnQnBELEtBQWhCLEVBQXVCO0FBQ3JCNEQsWUFBTTVELE1BQU1vRCxHQUFOLENBQU47QUFDQWxGLGFBQU9nZCxTQUFTOVgsR0FBVCxDQUFQO0FBQ0FDLFVBQUluRixJQUFKLElBQVk2ZCxjQUFjblksR0FBZCxJQUNSQSxHQURRLEdBRVIsRUFBRTNELE1BQU0yRCxHQUFSLEVBRko7QUFHRDtBQUNGO0FBQ0RzRCxVQUFRbEgsS0FBUixHQUFnQnFELEdBQWhCO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVMwaUIsbUJBQVQsQ0FBOEI3ZSxPQUE5QixFQUF1QztBQUNyQyxNQUFJOGUsT0FBTzllLFFBQVErZSxVQUFuQjtBQUNBLE1BQUlELElBQUosRUFBVTtBQUNSLFNBQUssSUFBSTVpQixHQUFULElBQWdCNGlCLElBQWhCLEVBQXNCO0FBQ3BCLFVBQUluUCxNQUFNbVAsS0FBSzVpQixHQUFMLENBQVY7QUFDQSxVQUFJLE9BQU95VCxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0JtUCxhQUFLNWlCLEdBQUwsSUFBWSxFQUFFcVQsTUFBTUksR0FBUixFQUFhb0wsUUFBUXBMLEdBQXJCLEVBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFNBQVNxUCxZQUFULENBQ0UzbEIsTUFERixFQUVFa0IsS0FGRixFQUdFdWYsRUFIRixFQUlFO0FBQ0EsTUFBSWxtQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3lpQixvQkFBZ0Jua0IsS0FBaEI7QUFDRDtBQUNEcWtCLGlCQUFlcmtCLEtBQWY7QUFDQXNrQixzQkFBb0J0a0IsS0FBcEI7QUFDQSxNQUFJMGtCLGNBQWMxa0IsTUFBTTJrQixPQUF4QjtBQUNBLE1BQUlELFdBQUosRUFBaUI7QUFDZjVsQixhQUFTLE9BQU80bEIsV0FBUCxLQUF1QixVQUF2QixHQUNMRCxhQUFhM2xCLE1BQWIsRUFBcUI0bEIsWUFBWWpmLE9BQWpDLEVBQTBDOFosRUFBMUMsQ0FESyxHQUVMa0YsYUFBYTNsQixNQUFiLEVBQXFCNGxCLFdBQXJCLEVBQWtDbkYsRUFBbEMsQ0FGSjtBQUdEO0FBQ0QsTUFBSXZmLE1BQU00a0IsTUFBVixFQUFrQjtBQUNoQixTQUFLLElBQUl4cEIsSUFBSSxDQUFSLEVBQVcyZSxJQUFJL1osTUFBTTRrQixNQUFOLENBQWFscUIsTUFBakMsRUFBeUNVLElBQUkyZSxDQUE3QyxFQUFnRDNlLEdBQWhELEVBQXFEO0FBQ25ELFVBQUlpTSxRQUFRckgsTUFBTTRrQixNQUFOLENBQWF4cEIsQ0FBYixDQUFaO0FBQ0EsVUFBSWlNLE1BQU03TCxTQUFOLFlBQTJCcXBCLEtBQS9CLEVBQXNDO0FBQ3BDeGQsZ0JBQVFBLE1BQU01QixPQUFkO0FBQ0Q7QUFDRDNHLGVBQVMybEIsYUFBYTNsQixNQUFiLEVBQXFCdUksS0FBckIsRUFBNEJrWSxFQUE1QixDQUFUO0FBQ0Q7QUFDRjtBQUNELE1BQUk5WixVQUFVLEVBQWQ7QUFDQSxNQUFJOUQsR0FBSjtBQUNBLE9BQUtBLEdBQUwsSUFBWTdDLE1BQVosRUFBb0I7QUFDbEJnbUIsZUFBV25qQixHQUFYO0FBQ0Q7QUFDRCxPQUFLQSxHQUFMLElBQVkzQixLQUFaLEVBQW1CO0FBQ2pCLFFBQUksQ0FBQ29aLE9BQU90YSxNQUFQLEVBQWU2QyxHQUFmLENBQUwsRUFBMEI7QUFDeEJtakIsaUJBQVduakIsR0FBWDtBQUNEO0FBQ0Y7QUFDRCxXQUFTbWpCLFVBQVQsQ0FBcUJuakIsR0FBckIsRUFBMEI7QUFDeEIsUUFBSW9qQixRQUFRcmQsT0FBTy9GLEdBQVAsS0FBZXloQixZQUEzQjtBQUNBM2QsWUFBUTlELEdBQVIsSUFBZW9qQixNQUFNam1CLE9BQU82QyxHQUFQLENBQU4sRUFBbUIzQixNQUFNMkIsR0FBTixDQUFuQixFQUErQjRkLEVBQS9CLEVBQW1DNWQsR0FBbkMsQ0FBZjtBQUNEO0FBQ0QsU0FBTzhELE9BQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTdWYsWUFBVCxDQUNFdmYsT0FERixFQUVFakgsSUFGRixFQUdFd2hCLEVBSEYsRUFJRWlGLFdBSkYsRUFLRTtBQUNBO0FBQ0EsTUFBSSxPQUFPakYsRUFBUCxLQUFjLFFBQWxCLEVBQTRCO0FBQzFCO0FBQ0Q7QUFDRCxNQUFJa0YsU0FBU3pmLFFBQVFqSCxJQUFSLENBQWI7QUFDQTtBQUNBLE1BQUk0YSxPQUFPOEwsTUFBUCxFQUFlbEYsRUFBZixDQUFKLEVBQXdCO0FBQUUsV0FBT2tGLE9BQU9sRixFQUFQLENBQVA7QUFBbUI7QUFDN0MsTUFBSW1GLGNBQWMxTCxTQUFTdUcsRUFBVCxDQUFsQjtBQUNBLE1BQUk1RyxPQUFPOEwsTUFBUCxFQUFlQyxXQUFmLENBQUosRUFBaUM7QUFBRSxXQUFPRCxPQUFPQyxXQUFQLENBQVA7QUFBNEI7QUFDL0QsTUFBSUMsZUFBZTFMLFdBQVd5TCxXQUFYLENBQW5CO0FBQ0EsTUFBSS9MLE9BQU84TCxNQUFQLEVBQWVFLFlBQWYsQ0FBSixFQUFrQztBQUFFLFdBQU9GLE9BQU9FLFlBQVAsQ0FBUDtBQUE2QjtBQUNqRTtBQUNBLE1BQUl4akIsTUFBTXNqQixPQUFPbEYsRUFBUCxLQUFja0YsT0FBT0MsV0FBUCxDQUFkLElBQXFDRCxPQUFPRSxZQUFQLENBQS9DO0FBQ0EsTUFBSS9yQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3VqQixXQUF6QyxJQUF3RCxDQUFDcmpCLEdBQTdELEVBQWtFO0FBQ2hFekQsU0FDRSx1QkFBdUJLLEtBQUttRSxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUF2QixHQUEyQyxJQUEzQyxHQUFrRHFkLEVBRHBELEVBRUV2YSxPQUZGO0FBSUQ7QUFDRCxTQUFPN0QsR0FBUDtBQUNEOztBQUVEOztBQUVBLFNBQVN5akIsWUFBVCxDQUNFMWpCLEdBREYsRUFFRTJqQixXQUZGLEVBR0VuQyxTQUhGLEVBSUU1RCxFQUpGLEVBS0U7QUFDQSxNQUFJZ0csT0FBT0QsWUFBWTNqQixHQUFaLENBQVg7QUFDQSxNQUFJNmpCLFNBQVMsQ0FBQ3BNLE9BQU8rSixTQUFQLEVBQWtCeGhCLEdBQWxCLENBQWQ7QUFDQSxNQUFJdEUsUUFBUThsQixVQUFVeGhCLEdBQVYsQ0FBWjtBQUNBO0FBQ0EsTUFBSThqQixPQUFPMWdCLE9BQVAsRUFBZ0J3Z0IsS0FBSy9tQixJQUFyQixDQUFKLEVBQWdDO0FBQzlCLFFBQUlnbkIsVUFBVSxDQUFDcE0sT0FBT21NLElBQVAsRUFBYSxTQUFiLENBQWYsRUFBd0M7QUFDdENsb0IsY0FBUSxLQUFSO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQ29vQixPQUFPaG5CLE1BQVAsRUFBZThtQixLQUFLL21CLElBQXBCLENBQUQsS0FBK0JuQixVQUFVLEVBQVYsSUFBZ0JBLFVBQVV1YyxVQUFValksR0FBVixDQUF6RCxDQUFKLEVBQThFO0FBQ25GdEUsY0FBUSxJQUFSO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsTUFBSUEsVUFBVStDLFNBQWQsRUFBeUI7QUFDdkIvQyxZQUFRcW9CLG9CQUFvQm5HLEVBQXBCLEVBQXdCZ0csSUFBeEIsRUFBOEI1akIsR0FBOUIsQ0FBUjtBQUNBO0FBQ0E7QUFDQSxRQUFJZ2tCLG9CQUFvQmpFLGNBQWNDLGFBQXRDO0FBQ0FELGtCQUFjQyxhQUFkLEdBQThCLElBQTlCO0FBQ0FwRCxZQUFRbGhCLEtBQVI7QUFDQXFrQixrQkFBY0MsYUFBZCxHQUE4QmdFLGlCQUE5QjtBQUNEO0FBQ0QsTUFBSXRzQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2trQixlQUFXTCxJQUFYLEVBQWlCNWpCLEdBQWpCLEVBQXNCdEUsS0FBdEIsRUFBNkJraUIsRUFBN0IsRUFBaUNpRyxNQUFqQztBQUNEO0FBQ0QsU0FBT25vQixLQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNxb0IsbUJBQVQsQ0FBOEJuRyxFQUE5QixFQUFrQ2dHLElBQWxDLEVBQXdDNWpCLEdBQXhDLEVBQTZDO0FBQzNDO0FBQ0EsTUFBSSxDQUFDeVgsT0FBT21NLElBQVAsRUFBYSxTQUFiLENBQUwsRUFBOEI7QUFDNUIsV0FBT25sQixTQUFQO0FBQ0Q7QUFDRCxNQUFJZ1YsTUFBTW1RLEtBQUtqb0IsT0FBZjtBQUNBO0FBQ0EsTUFBSWpFLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDNE8sU0FBUzhFLEdBQVQsQ0FBN0MsRUFBNEQ7QUFDMURqWCxTQUNFLHFDQUFxQ3dELEdBQXJDLEdBQTJDLEtBQTNDLEdBQ0EsMkRBREEsR0FFQSw4QkFIRixFQUlFNGQsRUFKRjtBQU1EO0FBQ0Q7QUFDQTtBQUNBLE1BQUlBLE1BQU1BLEdBQUdoWSxRQUFILENBQVk0YixTQUFsQixJQUNGNUQsR0FBR2hZLFFBQUgsQ0FBWTRiLFNBQVosQ0FBc0J4aEIsR0FBdEIsTUFBK0J2QixTQUQ3QixJQUVGbWYsR0FBR3NHLE1BQUgsQ0FBVWxrQixHQUFWLE1BQW1CdkIsU0FGckIsRUFFZ0M7QUFDOUIsV0FBT21mLEdBQUdzRyxNQUFILENBQVVsa0IsR0FBVixDQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsU0FBTyxPQUFPeVQsR0FBUCxLQUFlLFVBQWYsSUFBNkIwUSxRQUFRUCxLQUFLL21CLElBQWIsTUFBdUIsVUFBcEQsR0FDSDRXLElBQUlsYixJQUFKLENBQVNxbEIsRUFBVCxDQURHLEdBRUhuSyxHQUZKO0FBR0Q7O0FBRUQ7OztBQUdBLFNBQVN3USxVQUFULENBQ0VMLElBREYsRUFFRTlvQixJQUZGLEVBR0VZLEtBSEYsRUFJRWtpQixFQUpGLEVBS0VpRyxNQUxGLEVBTUU7QUFDQSxNQUFJRCxLQUFLM2dCLFFBQUwsSUFBaUI0Z0IsTUFBckIsRUFBNkI7QUFDM0JybkIsU0FDRSw2QkFBNkIxQixJQUE3QixHQUFvQyxHQUR0QyxFQUVFOGlCLEVBRkY7QUFJQTtBQUNEO0FBQ0QsTUFBSWxpQixTQUFTLElBQVQsSUFBaUIsQ0FBQ2tvQixLQUFLM2dCLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0Q7QUFDRCxNQUFJcEcsT0FBTyttQixLQUFLL21CLElBQWhCO0FBQ0EsTUFBSXVuQixRQUFRLENBQUN2bkIsSUFBRCxJQUFTQSxTQUFTLElBQTlCO0FBQ0EsTUFBSXduQixnQkFBZ0IsRUFBcEI7QUFDQSxNQUFJeG5CLElBQUosRUFBVTtBQUNSLFFBQUksQ0FBQ3RELE1BQU1tSCxPQUFOLENBQWM3RCxJQUFkLENBQUwsRUFBMEI7QUFDeEJBLGFBQU8sQ0FBQ0EsSUFBRCxDQUFQO0FBQ0Q7QUFDRCxTQUFLLElBQUlwRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlvRCxLQUFLOUQsTUFBVCxJQUFtQixDQUFDcXJCLEtBQXBDLEVBQTJDM3FCLEdBQTNDLEVBQWdEO0FBQzlDLFVBQUk2cUIsZUFBZUMsV0FBVzdvQixLQUFYLEVBQWtCbUIsS0FBS3BELENBQUwsQ0FBbEIsQ0FBbkI7QUFDQTRxQixvQkFBYzNxQixJQUFkLENBQW1CNHFCLGFBQWFFLFlBQWIsSUFBNkIsRUFBaEQ7QUFDQUosY0FBUUUsYUFBYUYsS0FBckI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVjVuQixTQUNFLCtDQUErQzFCLElBQS9DLEdBQXNELElBQXRELEdBQ0EsWUFEQSxHQUNldXBCLGNBQWN2akIsR0FBZCxDQUFrQmlYLFVBQWxCLEVBQThCdFgsSUFBOUIsQ0FBbUMsSUFBbkMsQ0FEZixHQUVBLFFBRkEsR0FFV2pGLE9BQU8zQixTQUFQLENBQWlCcUYsUUFBakIsQ0FBMEIzRyxJQUExQixDQUErQm1ELEtBQS9CLEVBQXNDc0YsS0FBdEMsQ0FBNEMsQ0FBNUMsRUFBK0MsQ0FBQyxDQUFoRCxDQUZYLEdBRWdFLEdBSGxFLEVBSUU0YyxFQUpGO0FBTUE7QUFDRDtBQUNELE1BQUk2RyxZQUFZYixLQUFLYSxTQUFyQjtBQUNBLE1BQUlBLFNBQUosRUFBZTtBQUNiLFFBQUksQ0FBQ0EsVUFBVS9vQixLQUFWLENBQUwsRUFBdUI7QUFDckJjLFdBQ0UsMkRBQTJEMUIsSUFBM0QsR0FBa0UsSUFEcEUsRUFFRThpQixFQUZGO0FBSUQ7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxTQUFTMkcsVUFBVCxDQUFxQjdvQixLQUFyQixFQUE0Qm1CLElBQTVCLEVBQWtDO0FBQ2hDLE1BQUl1bkIsS0FBSjtBQUNBLE1BQUlJLGVBQWVMLFFBQVF0bkIsSUFBUixDQUFuQjtBQUNBLE1BQUkybkIsaUJBQWlCLFFBQXJCLEVBQStCO0FBQzdCSixZQUFRLE9BQU8xb0IsS0FBUCxNQUFrQjhvQixlQUFlLFFBQWpDLENBQVI7QUFDRCxHQUZELE1BRU8sSUFBSUEsaUJBQWlCLFFBQXJCLEVBQStCO0FBQ3BDSixZQUFRLE9BQU8xb0IsS0FBUCxNQUFrQjhvQixlQUFlLFFBQWpDLENBQVI7QUFDRCxHQUZNLE1BRUEsSUFBSUEsaUJBQWlCLFNBQXJCLEVBQWdDO0FBQ3JDSixZQUFRLE9BQU8xb0IsS0FBUCxNQUFrQjhvQixlQUFlLFNBQWpDLENBQVI7QUFDRCxHQUZNLE1BRUEsSUFBSUEsaUJBQWlCLFVBQXJCLEVBQWlDO0FBQ3RDSixZQUFRLE9BQU8xb0IsS0FBUCxNQUFrQjhvQixlQUFlLFVBQWpDLENBQVI7QUFDRCxHQUZNLE1BRUEsSUFBSUEsaUJBQWlCLFFBQXJCLEVBQStCO0FBQ3BDSixZQUFRekwsY0FBY2pkLEtBQWQsQ0FBUjtBQUNELEdBRk0sTUFFQSxJQUFJOG9CLGlCQUFpQixPQUFyQixFQUE4QjtBQUNuQ0osWUFBUTdxQixNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxDQUFSO0FBQ0QsR0FGTSxNQUVBO0FBQ0wwb0IsWUFBUTFvQixpQkFBaUJtQixJQUF6QjtBQUNEO0FBQ0QsU0FBTztBQUNMdW5CLFdBQU9BLEtBREY7QUFFTEksa0JBQWNBO0FBRlQsR0FBUDtBQUlEOztBQUVEOzs7OztBQUtBLFNBQVNMLE9BQVQsQ0FBa0JuVCxFQUFsQixFQUFzQjtBQUNwQixNQUFJekYsUUFBUXlGLE1BQU1BLEdBQUc5UixRQUFILEdBQWNxTSxLQUFkLENBQW9CLG9CQUFwQixDQUFsQjtBQUNBLFNBQU9BLFNBQVNBLE1BQU0sQ0FBTixDQUFoQjtBQUNEOztBQUVELFNBQVN1WSxNQUFULENBQWlCam5CLElBQWpCLEVBQXVCbVUsRUFBdkIsRUFBMkI7QUFDekIsTUFBSSxDQUFDelgsTUFBTW1ILE9BQU4sQ0FBY3NRLEVBQWQsQ0FBTCxFQUF3QjtBQUN0QixXQUFPbVQsUUFBUW5ULEVBQVIsTUFBZ0JtVCxRQUFRdG5CLElBQVIsQ0FBdkI7QUFDRDtBQUNELE9BQUssSUFBSXBELElBQUksQ0FBUixFQUFXTixNQUFNNlgsR0FBR2pZLE1BQXpCLEVBQWlDVSxJQUFJTixHQUFyQyxFQUEwQ00sR0FBMUMsRUFBK0M7QUFDN0MsUUFBSTBxQixRQUFRblQsR0FBR3ZYLENBQUgsQ0FBUixNQUFtQjBxQixRQUFRdG5CLElBQVIsQ0FBdkIsRUFBc0M7QUFDcEMsYUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBUzZuQixXQUFULENBQXNCdEksR0FBdEIsRUFBMkJ3QixFQUEzQixFQUErQitHLElBQS9CLEVBQXFDO0FBQ25DLE1BQUlobUIsT0FBTythLFlBQVgsRUFBeUI7QUFDdkIvYSxXQUFPK2EsWUFBUCxDQUFvQm5oQixJQUFwQixDQUF5QixJQUF6QixFQUErQjZqQixHQUEvQixFQUFvQ3dCLEVBQXBDLEVBQXdDK0csSUFBeEM7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJanRCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDdkQsV0FBTSxjQUFjbW9CLElBQWQsR0FBcUIsR0FBM0IsRUFBaUMvRyxFQUFqQztBQUNEO0FBQ0Q7QUFDQSxRQUFJeFgsYUFBYSxPQUFPM0osT0FBUCxLQUFtQixXQUFwQyxFQUFpRDtBQUMvQ0EsY0FBUTRmLEtBQVIsQ0FBY0QsR0FBZDtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU1BLEdBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsSUFBSXdJLFNBQUo7O0FBRUEsSUFBSWx0QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJOGtCLGlCQUFpQjVOLFFBQ25CLDJDQUNBLGdGQURBLEdBRUEsd0VBRkEsR0FHQSxTQUptQixDQUlUO0FBSlMsR0FBckI7O0FBT0EsTUFBSTZOLGlCQUFpQixVQUFVcGlCLE1BQVYsRUFBa0IxQyxHQUFsQixFQUF1QjtBQUMxQ3hELFNBQ0UsMEJBQTBCd0QsR0FBMUIsR0FBZ0Msd0NBQWhDLEdBQ0EsK0RBREEsR0FFQSxnQ0FIRixFQUlFMEMsTUFKRjtBQU1ELEdBUEQ7O0FBU0EsTUFBSXFpQixXQUNGLE9BQU9DLEtBQVAsS0FBaUIsV0FBakIsSUFDQUEsTUFBTTlsQixRQUFOLEdBQWlCcU0sS0FBakIsQ0FBdUIsYUFBdkIsQ0FGRjs7QUFJQSxNQUFJd1osUUFBSixFQUFjO0FBQ1osUUFBSUUsb0JBQW9CaE8sUUFBUSx1Q0FBUixDQUF4QjtBQUNBdFksV0FBT2liLFFBQVAsR0FBa0IsSUFBSW9MLEtBQUosQ0FBVXJtQixPQUFPaWIsUUFBakIsRUFBMkI7QUFDM0NzRCxXQUFLLFNBQVNBLEdBQVQsQ0FBY3hhLE1BQWQsRUFBc0IxQyxHQUF0QixFQUEyQnRFLEtBQTNCLEVBQWtDO0FBQ3JDLFlBQUl1cEIsa0JBQWtCamxCLEdBQWxCLENBQUosRUFBNEI7QUFDMUJ4RCxlQUFNLDhEQUE4RHdELEdBQXBFO0FBQ0EsaUJBQU8sS0FBUDtBQUNELFNBSEQsTUFHTztBQUNMMEMsaUJBQU8xQyxHQUFQLElBQWN0RSxLQUFkO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFUMEMsS0FBM0IsQ0FBbEI7QUFXRDs7QUFFRCxNQUFJd3BCLGFBQWE7QUFDZi9ILFNBQUssU0FBU0EsR0FBVCxDQUFjemEsTUFBZCxFQUFzQjFDLEdBQXRCLEVBQTJCO0FBQzlCLFVBQUltZCxNQUFNbmQsT0FBTzBDLE1BQWpCO0FBQ0EsVUFBSXlpQixZQUFZTixlQUFlN2tCLEdBQWYsS0FBdUJBLElBQUl5RyxNQUFKLENBQVcsQ0FBWCxNQUFrQixHQUF6RDtBQUNBLFVBQUksQ0FBQzBXLEdBQUQsSUFBUSxDQUFDZ0ksU0FBYixFQUF3QjtBQUN0QkwsdUJBQWVwaUIsTUFBZixFQUF1QjFDLEdBQXZCO0FBQ0Q7QUFDRCxhQUFPbWQsT0FBTyxDQUFDZ0ksU0FBZjtBQUNEO0FBUmMsR0FBakI7O0FBV0EsTUFBSUMsYUFBYTtBQUNmcHBCLFNBQUssU0FBU0EsR0FBVCxDQUFjMEcsTUFBZCxFQUFzQjFDLEdBQXRCLEVBQTJCO0FBQzlCLFVBQUksT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkIsRUFBRUEsT0FBTzBDLE1BQVQsQ0FBL0IsRUFBaUQ7QUFDL0NvaUIsdUJBQWVwaUIsTUFBZixFQUF1QjFDLEdBQXZCO0FBQ0Q7QUFDRCxhQUFPMEMsT0FBTzFDLEdBQVAsQ0FBUDtBQUNEO0FBTmMsR0FBakI7O0FBU0E0a0IsY0FBWSxTQUFTQSxTQUFULENBQW9CaEgsRUFBcEIsRUFBd0I7QUFDbEMsUUFBSW1ILFFBQUosRUFBYztBQUNaO0FBQ0EsVUFBSWpoQixVQUFVOFosR0FBR2hZLFFBQWpCO0FBQ0EsVUFBSXlmLFdBQVd2aEIsUUFBUS9HLE1BQVIsSUFBa0IrRyxRQUFRL0csTUFBUixDQUFldW9CLGFBQWpDLEdBQ1hGLFVBRFcsR0FFWEYsVUFGSjtBQUdBdEgsU0FBRzJILFlBQUgsR0FBa0IsSUFBSVAsS0FBSixDQUFVcEgsRUFBVixFQUFjeUgsUUFBZCxDQUFsQjtBQUNELEtBUEQsTUFPTztBQUNMekgsU0FBRzJILFlBQUgsR0FBa0IzSCxFQUFsQjtBQUNEO0FBQ0YsR0FYRDtBQVlEOztBQUVELElBQUk0SCxJQUFKO0FBQ0EsSUFBSUMsT0FBSjs7QUFFQSxJQUFJL3RCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUkybEIsT0FBT3RmLGFBQWFDLE9BQU9pSyxXQUEvQjtBQUNBO0FBQ0EsTUFDRW9WLFFBQ0FBLEtBQUtGLElBREwsSUFFQUUsS0FBS0QsT0FGTCxJQUdBQyxLQUFLQyxVQUhMLElBSUFELEtBQUtFLGFBTFAsRUFNRTtBQUNBSixXQUFPLFVBQVV0aUIsR0FBVixFQUFlO0FBQUUsYUFBT3dpQixLQUFLRixJQUFMLENBQVV0aUIsR0FBVixDQUFQO0FBQXdCLEtBQWhEO0FBQ0F1aUIsY0FBVSxVQUFVM3FCLElBQVYsRUFBZ0IrcUIsUUFBaEIsRUFBMEJDLE1BQTFCLEVBQWtDO0FBQzFDSixXQUFLRCxPQUFMLENBQWEzcUIsSUFBYixFQUFtQitxQixRQUFuQixFQUE2QkMsTUFBN0I7QUFDQUosV0FBS0MsVUFBTCxDQUFnQkUsUUFBaEI7QUFDQUgsV0FBS0MsVUFBTCxDQUFnQkcsTUFBaEI7QUFDQUosV0FBS0UsYUFBTCxDQUFtQjlxQixJQUFuQjtBQUNELEtBTEQ7QUFNRDtBQUNGOztBQUVEOztBQUVBLElBQUlpckIsUUFBUSxTQUFTQSxLQUFULENBQ1Y3aUIsR0FEVSxFQUVWOUYsSUFGVSxFQUdWRixRQUhVLEVBSVY4b0IsSUFKVSxFQUtWQyxHQUxVLEVBTVZDLE9BTlUsRUFPVkMsZ0JBUFUsRUFRVjtBQUNBLE9BQUtqakIsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBSzlGLElBQUwsR0FBWUEsSUFBWjtBQUNBLE9BQUtGLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsT0FBSzhvQixJQUFMLEdBQVlBLElBQVo7QUFDQSxPQUFLQyxHQUFMLEdBQVdBLEdBQVg7QUFDQSxPQUFLRyxFQUFMLEdBQVUzbkIsU0FBVjtBQUNBLE9BQUt5bkIsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsT0FBS0csaUJBQUwsR0FBeUI1bkIsU0FBekI7QUFDQSxPQUFLdUIsR0FBTCxHQUFXNUMsUUFBUUEsS0FBSzRDLEdBQXhCO0FBQ0EsT0FBS21tQixnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsT0FBS0csaUJBQUwsR0FBeUI3bkIsU0FBekI7QUFDQSxPQUFLdEIsTUFBTCxHQUFjc0IsU0FBZDtBQUNBLE9BQUs2TixHQUFMLEdBQVcsS0FBWDtBQUNBLE9BQUs5SCxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsT0FBSytoQixZQUFMLEdBQW9CLElBQXBCO0FBQ0EsT0FBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUNBLE9BQUtDLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxPQUFLQyxNQUFMLEdBQWMsS0FBZDtBQUNELENBM0JEOztBQTZCQSxJQUFJeFEscUJBQXFCLEVBQUU3WCxPQUFPLEVBQVQsRUFBekI7O0FBRUE7QUFDQTtBQUNBNlgsbUJBQW1CN1gsS0FBbkIsQ0FBeUJyQyxHQUF6QixHQUErQixZQUFZO0FBQ3pDLFNBQU8sS0FBS3NxQixpQkFBWjtBQUNELENBRkQ7O0FBSUE5cUIsT0FBT00sZ0JBQVAsQ0FBeUJpcUIsTUFBTWxzQixTQUEvQixFQUEwQ3FjLGtCQUExQzs7QUFFQSxJQUFJeVEsbUJBQW1CLFlBQVk7QUFDakMsTUFBSUMsT0FBTyxJQUFJYixLQUFKLEVBQVg7QUFDQWEsT0FBS1osSUFBTCxHQUFZLEVBQVo7QUFDQVksT0FBS0osU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQU9JLElBQVA7QUFDRCxDQUxEOztBQU9BLFNBQVNDLGVBQVQsQ0FBMEJybUIsR0FBMUIsRUFBK0I7QUFDN0IsU0FBTyxJQUFJdWxCLEtBQUosQ0FBVXRuQixTQUFWLEVBQXFCQSxTQUFyQixFQUFnQ0EsU0FBaEMsRUFBMkMzQixPQUFPMEQsR0FBUCxDQUEzQyxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTc21CLFVBQVQsQ0FBcUIzb0IsS0FBckIsRUFBNEI7QUFDMUIsTUFBSTRvQixTQUFTLElBQUloQixLQUFKLENBQ1g1bkIsTUFBTStFLEdBREssRUFFWC9FLE1BQU1mLElBRkssRUFHWGUsTUFBTWpCLFFBSEssRUFJWGlCLE1BQU02bkIsSUFKSyxFQUtYN25CLE1BQU04bkIsR0FMSyxFQU1YOW5CLE1BQU0rbkIsT0FOSyxFQU9YL25CLE1BQU1nb0IsZ0JBUEssQ0FBYjtBQVNBWSxTQUFPWCxFQUFQLEdBQVlqb0IsTUFBTWlvQixFQUFsQjtBQUNBVyxTQUFPdmlCLFFBQVAsR0FBa0JyRyxNQUFNcUcsUUFBeEI7QUFDQXVpQixTQUFPL21CLEdBQVAsR0FBYTdCLE1BQU02QixHQUFuQjtBQUNBK21CLFNBQU9OLFFBQVAsR0FBa0IsSUFBbEI7QUFDQSxTQUFPTSxNQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsV0FBVCxDQUFzQkMsTUFBdEIsRUFBOEI7QUFDNUIsTUFBSTl0QixNQUFNOHRCLE9BQU9sdUIsTUFBakI7QUFDQSxNQUFJa0gsTUFBTSxJQUFJMUcsS0FBSixDQUFVSixHQUFWLENBQVY7QUFDQSxPQUFLLElBQUlNLElBQUksQ0FBYixFQUFnQkEsSUFBSU4sR0FBcEIsRUFBeUJNLEdBQXpCLEVBQThCO0FBQzVCd0csUUFBSXhHLENBQUosSUFBU3F0QixXQUFXRyxPQUFPeHRCLENBQVAsQ0FBWCxDQUFUO0FBQ0Q7QUFDRCxTQUFPd0csR0FBUDtBQUNEOztBQUVEOztBQUVBLElBQUlpbkIsaUJBQWlCdlAsT0FBTyxVQUFVN2MsSUFBVixFQUFnQjtBQUMxQyxNQUFJcXNCLFVBQVVyc0IsS0FBSzJMLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDLENBRDBDLENBQ0o7QUFDdEMzTCxTQUFPcXNCLFVBQVVyc0IsS0FBS2tHLEtBQUwsQ0FBVyxDQUFYLENBQVYsR0FBMEJsRyxJQUFqQztBQUNBLE1BQUkyTyxVQUFVM08sS0FBSzJMLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDO0FBQ0EzTCxTQUFPMk8sVUFBVTNPLEtBQUtrRyxLQUFMLENBQVcsQ0FBWCxDQUFWLEdBQTBCbEcsSUFBakM7QUFDQSxTQUFPO0FBQ0xBLFVBQU1BLElBREQ7QUFFTE4sVUFBTTJzQixPQUZEO0FBR0wxZCxhQUFTQTtBQUhKLEdBQVA7QUFLRCxDQVZvQixDQUFyQjs7QUFZQSxTQUFTMmQsZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsV0FBU0MsT0FBVCxHQUFvQjtBQUNsQixRQUFJL0gsY0FBYy9sQixTQUFsQjs7QUFFQSxRQUFJNnRCLE1BQU1DLFFBQVFELEdBQWxCO0FBQ0EsUUFBSTl0QixNQUFNbUgsT0FBTixDQUFjMm1CLEdBQWQsQ0FBSixFQUF3QjtBQUN0QixXQUFLLElBQUk1dEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHRCLElBQUl0dUIsTUFBeEIsRUFBZ0NVLEdBQWhDLEVBQXFDO0FBQ25DNHRCLFlBQUk1dEIsQ0FBSixFQUFPSyxLQUFQLENBQWEsSUFBYixFQUFtQnlsQixXQUFuQjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0w7QUFDQSxhQUFPOEgsSUFBSXZ0QixLQUFKLENBQVUsSUFBVixFQUFnQk4sU0FBaEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRDh0QixVQUFRRCxHQUFSLEdBQWNBLEdBQWQ7QUFDQSxTQUFPQyxPQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsZUFBVCxDQUNFanRCLEVBREYsRUFFRWt0QixLQUZGLEVBR0VwSyxHQUhGLEVBSUVxSyxTQUpGLEVBS0U3SixFQUxGLEVBTUU7QUFDQSxNQUFJOWlCLElBQUosRUFBVTRzQixHQUFWLEVBQWVDLEdBQWYsRUFBb0Jwa0IsS0FBcEI7QUFDQSxPQUFLekksSUFBTCxJQUFhUixFQUFiLEVBQWlCO0FBQ2ZvdEIsVUFBTXB0QixHQUFHUSxJQUFILENBQU47QUFDQTZzQixVQUFNSCxNQUFNMXNCLElBQU4sQ0FBTjtBQUNBeUksWUFBUTJqQixlQUFlcHNCLElBQWYsQ0FBUjtBQUNBLFFBQUksQ0FBQzRzQixHQUFMLEVBQVU7QUFDUmh3QixjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLGlDQUFrQytHLE1BQU16SSxJQUF4QyxHQUFnRCxVQUFoRCxHQUE2RGdDLE9BQU80cUIsR0FBUCxDQUR0QixFQUV2QzlKLEVBRnVDLENBQXpDO0FBSUQsS0FMRCxNQUtPLElBQUksQ0FBQytKLEdBQUwsRUFBVTtBQUNmLFVBQUksQ0FBQ0QsSUFBSUwsR0FBVCxFQUFjO0FBQ1pLLGNBQU1wdEIsR0FBR1EsSUFBSCxJQUFXc3NCLGdCQUFnQk0sR0FBaEIsQ0FBakI7QUFDRDtBQUNEdEssVUFBSTdaLE1BQU16SSxJQUFWLEVBQWdCNHNCLEdBQWhCLEVBQXFCbmtCLE1BQU0vSSxJQUEzQixFQUFpQytJLE1BQU1rRyxPQUF2QztBQUNELEtBTE0sTUFLQSxJQUFJaWUsUUFBUUMsR0FBWixFQUFpQjtBQUN0QkEsVUFBSU4sR0FBSixHQUFVSyxHQUFWO0FBQ0FwdEIsU0FBR1EsSUFBSCxJQUFXNnNCLEdBQVg7QUFDRDtBQUNGO0FBQ0QsT0FBSzdzQixJQUFMLElBQWEwc0IsS0FBYixFQUFvQjtBQUNsQixRQUFJLENBQUNsdEIsR0FBR1EsSUFBSCxDQUFMLEVBQWU7QUFDYnlJLGNBQVEyakIsZUFBZXBzQixJQUFmLENBQVI7QUFDQTJzQixnQkFBVWxrQixNQUFNekksSUFBaEIsRUFBc0Iwc0IsTUFBTTFzQixJQUFOLENBQXRCLEVBQW1DeUksTUFBTWtHLE9BQXpDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBLFNBQVNtZSxjQUFULENBQXlCblUsR0FBekIsRUFBOEJvVSxPQUE5QixFQUF1QzVwQixJQUF2QyxFQUE2QztBQUMzQyxNQUFJcXBCLE9BQUo7QUFDQSxNQUFJUSxVQUFVclUsSUFBSW9VLE9BQUosQ0FBZDs7QUFFQSxXQUFTRSxXQUFULEdBQXdCO0FBQ3RCOXBCLFNBQUtuRSxLQUFMLENBQVcsSUFBWCxFQUFpQk4sU0FBakI7QUFDQTtBQUNBO0FBQ0E4ZCxXQUFPZ1EsUUFBUUQsR0FBZixFQUFvQlUsV0FBcEI7QUFDRDs7QUFFRCxNQUFJLENBQUNELE9BQUwsRUFBYztBQUNaO0FBQ0FSLGNBQVVGLGdCQUFnQixDQUFDVyxXQUFELENBQWhCLENBQVY7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBLFFBQUlELFFBQVFULEdBQVIsSUFBZVMsUUFBUUUsTUFBM0IsRUFBbUM7QUFDakM7QUFDQVYsZ0JBQVVRLE9BQVY7QUFDQVIsY0FBUUQsR0FBUixDQUFZM3RCLElBQVosQ0FBaUJxdUIsV0FBakI7QUFDRCxLQUpELE1BSU87QUFDTDtBQUNBVCxnQkFBVUYsZ0JBQWdCLENBQUNVLE9BQUQsRUFBVUMsV0FBVixDQUFoQixDQUFWO0FBQ0Q7QUFDRjs7QUFFRFQsVUFBUVUsTUFBUixHQUFpQixJQUFqQjtBQUNBdlUsTUFBSW9VLE9BQUosSUFBZVAsT0FBZjtBQUNEOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU1csdUJBQVQsQ0FBa0MvcUIsUUFBbEMsRUFBNEM7QUFDMUMsT0FBSyxJQUFJekQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUQsU0FBU25FLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QyxRQUFJRixNQUFNbUgsT0FBTixDQUFjeEQsU0FBU3pELENBQVQsQ0FBZCxDQUFKLEVBQWdDO0FBQzlCLGFBQU9GLE1BQU1NLFNBQU4sQ0FBZ0JiLE1BQWhCLENBQXVCYyxLQUF2QixDQUE2QixFQUE3QixFQUFpQ29ELFFBQWpDLENBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBT0EsUUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2dyQixpQkFBVCxDQUE0QmhyQixRQUE1QixFQUFzQztBQUNwQyxTQUFPd2EsWUFBWXhhLFFBQVosSUFDSCxDQUFDMnBCLGdCQUFnQjNwQixRQUFoQixDQUFELENBREcsR0FFSDNELE1BQU1tSCxPQUFOLENBQWN4RCxRQUFkLElBQ0VpckIsdUJBQXVCanJCLFFBQXZCLENBREYsR0FFRXVCLFNBSk47QUFLRDs7QUFFRCxTQUFTMHBCLHNCQUFULENBQWlDanJCLFFBQWpDLEVBQTJDa3JCLFdBQTNDLEVBQXdEO0FBQ3RELE1BQUlub0IsTUFBTSxFQUFWO0FBQ0EsTUFBSXhHLENBQUosRUFBT3VGLENBQVAsRUFBVXFwQixJQUFWO0FBQ0EsT0FBSzV1QixJQUFJLENBQVQsRUFBWUEsSUFBSXlELFNBQVNuRSxNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcEN1RixRQUFJOUIsU0FBU3pELENBQVQsQ0FBSjtBQUNBLFFBQUl1RixLQUFLLElBQUwsSUFBYSxPQUFPQSxDQUFQLEtBQWEsU0FBOUIsRUFBeUM7QUFBRTtBQUFVO0FBQ3JEcXBCLFdBQU9wb0IsSUFBSUEsSUFBSWxILE1BQUosR0FBYSxDQUFqQixDQUFQO0FBQ0E7QUFDQSxRQUFJUSxNQUFNbUgsT0FBTixDQUFjMUIsQ0FBZCxDQUFKLEVBQXNCO0FBQ3BCaUIsVUFBSXZHLElBQUosQ0FBU0ksS0FBVCxDQUFlbUcsR0FBZixFQUFvQmtvQix1QkFBdUJucEIsQ0FBdkIsRUFBMkIsQ0FBQ29wQixlQUFlLEVBQWhCLElBQXNCLEdBQXRCLEdBQTRCM3VCLENBQXZELENBQXBCO0FBQ0QsS0FGRCxNQUVPLElBQUlpZSxZQUFZMVksQ0FBWixDQUFKLEVBQW9CO0FBQ3pCLFVBQUlxcEIsUUFBUUEsS0FBS3JDLElBQWpCLEVBQXVCO0FBQ3JCcUMsYUFBS3JDLElBQUwsSUFBYWxwQixPQUFPa0MsQ0FBUCxDQUFiO0FBQ0QsT0FGRCxNQUVPLElBQUlBLE1BQU0sRUFBVixFQUFjO0FBQ25CO0FBQ0FpQixZQUFJdkcsSUFBSixDQUFTbXRCLGdCQUFnQjduQixDQUFoQixDQUFUO0FBQ0Q7QUFDRixLQVBNLE1BT0E7QUFDTCxVQUFJQSxFQUFFZ25CLElBQUYsSUFBVXFDLElBQVYsSUFBa0JBLEtBQUtyQyxJQUEzQixFQUFpQztBQUMvQi9sQixZQUFJQSxJQUFJbEgsTUFBSixHQUFhLENBQWpCLElBQXNCOHRCLGdCQUFnQndCLEtBQUtyQyxJQUFMLEdBQVlobkIsRUFBRWduQixJQUE5QixDQUF0QjtBQUNELE9BRkQsTUFFTztBQUNMO0FBQ0EsWUFBSWhuQixFQUFFa0UsR0FBRixJQUFTbEUsRUFBRWdCLEdBQUYsSUFBUyxJQUFsQixJQUEwQm9vQixlQUFlLElBQTdDLEVBQW1EO0FBQ2pEcHBCLFlBQUVnQixHQUFGLEdBQVEsWUFBWW9vQixXQUFaLEdBQTBCLEdBQTFCLEdBQWdDM3VCLENBQWhDLEdBQW9DLElBQTVDO0FBQ0Q7QUFDRHdHLFlBQUl2RyxJQUFKLENBQVNzRixDQUFUO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT2lCLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxTQUFTcW9CLHNCQUFULENBQWlDcHJCLFFBQWpDLEVBQTJDO0FBQ3pDLFNBQU9BLFlBQVlBLFNBQVNnRSxNQUFULENBQWdCLFVBQVVsQyxDQUFWLEVBQWE7QUFBRSxXQUFPQSxLQUFLQSxFQUFFbW5CLGdCQUFkO0FBQWlDLEdBQWhFLEVBQWtFLENBQWxFLENBQW5CO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU29DLFVBQVQsQ0FBcUIzSyxFQUFyQixFQUF5QjtBQUN2QkEsS0FBRzRLLE9BQUgsR0FBYWh0QixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBcVcsS0FBRzZLLGFBQUgsR0FBbUIsS0FBbkI7QUFDQTtBQUNBLE1BQUlDLFlBQVk5SyxHQUFHaFksUUFBSCxDQUFZK2lCLGdCQUE1QjtBQUNBLE1BQUlELFNBQUosRUFBZTtBQUNiRSw2QkFBeUJoTCxFQUF6QixFQUE2QjhLLFNBQTdCO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJaG1CLE1BQUo7O0FBRUEsU0FBUzBhLEdBQVQsQ0FBYzdaLEtBQWQsRUFBcUJ5TixFQUFyQixFQUF5Qm1XLE9BQXpCLEVBQWtDO0FBQ2hDLE1BQUlBLE9BQUosRUFBYTtBQUNYemtCLFdBQU9tbUIsS0FBUCxDQUFhdGxCLEtBQWIsRUFBb0J5TixFQUFwQjtBQUNELEdBRkQsTUFFTztBQUNMdE8sV0FBT29tQixHQUFQLENBQVd2bEIsS0FBWCxFQUFrQnlOLEVBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTK1gsUUFBVCxDQUFtQnhsQixLQUFuQixFQUEwQnlOLEVBQTFCLEVBQThCO0FBQzVCdE8sU0FBT3NtQixJQUFQLENBQVl6bEIsS0FBWixFQUFtQnlOLEVBQW5CO0FBQ0Q7O0FBRUQsU0FBUzRYLHdCQUFULENBQ0VoTCxFQURGLEVBRUU4SyxTQUZGLEVBR0VPLFlBSEYsRUFJRTtBQUNBdm1CLFdBQVNrYixFQUFUO0FBQ0EySixrQkFBZ0JtQixTQUFoQixFQUEyQk8sZ0JBQWdCLEVBQTNDLEVBQStDN0wsR0FBL0MsRUFBb0QyTCxRQUFwRCxFQUE4RG5MLEVBQTlEO0FBQ0Q7O0FBRUQsU0FBU3NMLFdBQVQsQ0FBc0JydEIsR0FBdEIsRUFBMkI7QUFDekIsTUFBSXN0QixTQUFTLFFBQWI7QUFDQXR0QixNQUFJaEMsU0FBSixDQUFjaXZCLEdBQWQsR0FBb0IsVUFBVXZsQixLQUFWLEVBQWlCeU4sRUFBakIsRUFBcUI7QUFDdkMsUUFBSXhOLFNBQVMsSUFBYjs7QUFFQSxRQUFJb2EsS0FBSyxJQUFUO0FBQ0EsUUFBSXJrQixNQUFNbUgsT0FBTixDQUFjNkMsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLFdBQUssSUFBSTlKLElBQUksQ0FBUixFQUFXMmUsSUFBSTdVLE1BQU14SyxNQUExQixFQUFrQ1UsSUFBSTJlLENBQXRDLEVBQXlDM2UsR0FBekMsRUFBOEM7QUFDNUMrSixlQUFPc2xCLEdBQVAsQ0FBV3ZsQixNQUFNOUosQ0FBTixDQUFYLEVBQXFCdVgsRUFBckI7QUFDRDtBQUNGLEtBSkQsTUFJTztBQUNMLE9BQUM0TSxHQUFHNEssT0FBSCxDQUFXamxCLEtBQVgsTUFBc0JxYSxHQUFHNEssT0FBSCxDQUFXamxCLEtBQVgsSUFBb0IsRUFBMUMsQ0FBRCxFQUFnRDdKLElBQWhELENBQXFEc1gsRUFBckQ7QUFDQTtBQUNBO0FBQ0EsVUFBSW1ZLE9BQU8vakIsSUFBUCxDQUFZN0IsS0FBWixDQUFKLEVBQXdCO0FBQ3RCcWEsV0FBRzZLLGFBQUgsR0FBbUIsSUFBbkI7QUFDRDtBQUNGO0FBQ0QsV0FBTzdLLEVBQVA7QUFDRCxHQWpCRDs7QUFtQkEvaEIsTUFBSWhDLFNBQUosQ0FBY2d2QixLQUFkLEdBQXNCLFVBQVV0bEIsS0FBVixFQUFpQnlOLEVBQWpCLEVBQXFCO0FBQ3pDLFFBQUk0TSxLQUFLLElBQVQ7QUFDQSxhQUFTdGpCLEVBQVQsR0FBZTtBQUNic2pCLFNBQUdvTCxJQUFILENBQVF6bEIsS0FBUixFQUFlakosRUFBZjtBQUNBMFcsU0FBR2xYLEtBQUgsQ0FBUzhqQixFQUFULEVBQWFwa0IsU0FBYjtBQUNEO0FBQ0RjLE9BQUcwVyxFQUFILEdBQVFBLEVBQVI7QUFDQTRNLE9BQUdrTCxHQUFILENBQU92bEIsS0FBUCxFQUFjakosRUFBZDtBQUNBLFdBQU9zakIsRUFBUDtBQUNELEdBVEQ7O0FBV0EvaEIsTUFBSWhDLFNBQUosQ0FBY212QixJQUFkLEdBQXFCLFVBQVV6bEIsS0FBVixFQUFpQnlOLEVBQWpCLEVBQXFCO0FBQ3hDLFFBQUl4TixTQUFTLElBQWI7O0FBRUEsUUFBSW9hLEtBQUssSUFBVDtBQUNBO0FBQ0EsUUFBSSxDQUFDcGtCLFVBQVVULE1BQWYsRUFBdUI7QUFDckI2a0IsU0FBRzRLLE9BQUgsR0FBYWh0QixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBLGFBQU9xVyxFQUFQO0FBQ0Q7QUFDRDtBQUNBLFFBQUlya0IsTUFBTW1ILE9BQU4sQ0FBYzZDLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixXQUFLLElBQUk2bEIsTUFBTSxDQUFWLEVBQWFoUixJQUFJN1UsTUFBTXhLLE1BQTVCLEVBQW9DcXdCLE1BQU1oUixDQUExQyxFQUE2Q2dSLEtBQTdDLEVBQW9EO0FBQ2xENWxCLGVBQU93bEIsSUFBUCxDQUFZemxCLE1BQU02bEIsR0FBTixDQUFaLEVBQXdCcFksRUFBeEI7QUFDRDtBQUNELGFBQU80TSxFQUFQO0FBQ0Q7QUFDRDtBQUNBLFFBQUk1SixNQUFNNEosR0FBRzRLLE9BQUgsQ0FBV2psQixLQUFYLENBQVY7QUFDQSxRQUFJLENBQUN5USxHQUFMLEVBQVU7QUFDUixhQUFPNEosRUFBUDtBQUNEO0FBQ0QsUUFBSXBrQixVQUFVVCxNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCNmtCLFNBQUc0SyxPQUFILENBQVdqbEIsS0FBWCxJQUFvQixJQUFwQjtBQUNBLGFBQU9xYSxFQUFQO0FBQ0Q7QUFDRDtBQUNBLFFBQUkzTSxFQUFKO0FBQ0EsUUFBSXhYLElBQUl1YSxJQUFJamIsTUFBWjtBQUNBLFdBQU9VLEdBQVAsRUFBWTtBQUNWd1gsV0FBSytDLElBQUl2YSxDQUFKLENBQUw7QUFDQSxVQUFJd1gsT0FBT0QsRUFBUCxJQUFhQyxHQUFHRCxFQUFILEtBQVVBLEVBQTNCLEVBQStCO0FBQzdCZ0QsWUFBSXdELE1BQUosQ0FBVy9kLENBQVgsRUFBYyxDQUFkO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsV0FBT21rQixFQUFQO0FBQ0QsR0FwQ0Q7O0FBc0NBL2hCLE1BQUloQyxTQUFKLENBQWN3dkIsS0FBZCxHQUFzQixVQUFVOWxCLEtBQVYsRUFBaUI7QUFDckMsUUFBSXFhLEtBQUssSUFBVDtBQUNBLFFBQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSXVwQixpQkFBaUIvbEIsTUFBTTZULFdBQU4sRUFBckI7QUFDQSxVQUFJa1MsbUJBQW1CL2xCLEtBQW5CLElBQTRCcWEsR0FBRzRLLE9BQUgsQ0FBV2MsY0FBWCxDQUFoQyxFQUE0RDtBQUMxRGhNLFlBQ0UsYUFBYWdNLGNBQWIsR0FBOEIsNkJBQTlCLEdBQ0MvTCxvQkFBb0JLLEVBQXBCLENBREQsR0FDNEIsdUNBRDVCLEdBQ3NFcmEsS0FEdEUsR0FDOEUsTUFEOUUsR0FFQSxvRUFGQSxHQUdBLGtFQUhBLEdBSUEsNEJBSkEsR0FJZ0MwVSxVQUFVMVUsS0FBVixDQUpoQyxHQUlvRCxrQkFKcEQsR0FJeUVBLEtBSnpFLEdBSWlGLEtBTG5GO0FBT0Q7QUFDRjtBQUNELFFBQUl5USxNQUFNNEosR0FBRzRLLE9BQUgsQ0FBV2psQixLQUFYLENBQVY7QUFDQSxRQUFJeVEsR0FBSixFQUFTO0FBQ1BBLFlBQU1BLElBQUlqYixNQUFKLEdBQWEsQ0FBYixHQUFpQnVmLFFBQVF0RSxHQUFSLENBQWpCLEdBQWdDQSxHQUF0QztBQUNBLFVBQUkxYSxPQUFPZ2YsUUFBUTllLFNBQVIsRUFBbUIsQ0FBbkIsQ0FBWDtBQUNBLFdBQUssSUFBSUMsSUFBSSxDQUFSLEVBQVcyZSxJQUFJcEUsSUFBSWpiLE1BQXhCLEVBQWdDVSxJQUFJMmUsQ0FBcEMsRUFBdUMzZSxHQUF2QyxFQUE0QztBQUMxQ3VhLFlBQUl2YSxDQUFKLEVBQU9LLEtBQVAsQ0FBYThqQixFQUFiLEVBQWlCdGtCLElBQWpCO0FBQ0Q7QUFDRjtBQUNELFdBQU9za0IsRUFBUDtBQUNELEdBdkJEO0FBd0JEOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTMkwsWUFBVCxDQUNFcnNCLFFBREYsRUFFRWdwQixPQUZGLEVBR0U7QUFDQSxNQUFJc0QsUUFBUSxFQUFaO0FBQ0EsTUFBSSxDQUFDdHNCLFFBQUwsRUFBZTtBQUNiLFdBQU9zc0IsS0FBUDtBQUNEO0FBQ0QsTUFBSUMsY0FBYyxFQUFsQjtBQUNBLE1BQUkzdUIsSUFBSixFQUFVdUQsS0FBVjtBQUNBLE9BQUssSUFBSTVFLElBQUksQ0FBUixFQUFXMmUsSUFBSWxiLFNBQVNuRSxNQUE3QixFQUFxQ1UsSUFBSTJlLENBQXpDLEVBQTRDM2UsR0FBNUMsRUFBaUQ7QUFDL0M0RSxZQUFRbkIsU0FBU3pELENBQVQsQ0FBUjtBQUNBO0FBQ0E7QUFDQSxRQUFJLENBQUM0RSxNQUFNNm5CLE9BQU4sS0FBa0JBLE9BQWxCLElBQTZCN25CLE1BQU1nb0IsaUJBQU4sS0FBNEJILE9BQTFELEtBQ0E3bkIsTUFBTWpCLElBRE4sS0FDZXRDLE9BQU91RCxNQUFNakIsSUFBTixDQUFXc3NCLElBRGpDLENBQUosRUFDNEM7QUFDMUMsVUFBSUEsT0FBUUYsTUFBTTF1QixJQUFOLE1BQWdCMHVCLE1BQU0xdUIsSUFBTixJQUFjLEVBQTlCLENBQVo7QUFDQSxVQUFJdUQsTUFBTTZFLEdBQU4sS0FBYyxVQUFsQixFQUE4QjtBQUM1QndtQixhQUFLaHdCLElBQUwsQ0FBVUksS0FBVixDQUFnQjR2QixJQUFoQixFQUFzQnJyQixNQUFNbkIsUUFBNUI7QUFDRCxPQUZELE1BRU87QUFDTHdzQixhQUFLaHdCLElBQUwsQ0FBVTJFLEtBQVY7QUFDRDtBQUNGLEtBUkQsTUFRTztBQUNMb3JCLGtCQUFZL3ZCLElBQVosQ0FBaUIyRSxLQUFqQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLE1BQUksQ0FBQ29yQixZQUFZbG5CLEtBQVosQ0FBa0JvbkIsWUFBbEIsQ0FBTCxFQUFzQztBQUNwQ0gsVUFBTTd0QixPQUFOLEdBQWdCOHRCLFdBQWhCO0FBQ0Q7QUFDRCxTQUFPRCxLQUFQO0FBQ0Q7O0FBRUQsU0FBU0csWUFBVCxDQUF1Qi9DLElBQXZCLEVBQTZCO0FBQzNCLFNBQU9BLEtBQUtKLFNBQUwsSUFBa0JJLEtBQUtaLElBQUwsS0FBYyxHQUF2QztBQUNEOztBQUVELFNBQVM0RCxrQkFBVCxDQUNFdkMsR0FERixFQUVFO0FBQ0EsTUFBSXBuQixNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUl4RyxJQUFJLENBQWIsRUFBZ0JBLElBQUk0dEIsSUFBSXR1QixNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDbkN3RyxRQUFJb25CLElBQUk1dEIsQ0FBSixFQUFPLENBQVAsQ0FBSixJQUFpQjR0QixJQUFJNXRCLENBQUosRUFBTyxDQUFQLENBQWpCO0FBQ0Q7QUFDRCxTQUFPd0csR0FBUDtBQUNEOztBQUVEOztBQUVBLElBQUk0cEIsaUJBQWlCLElBQXJCOztBQUVBLFNBQVNDLGFBQVQsQ0FBd0JsTSxFQUF4QixFQUE0QjtBQUMxQixNQUFJOVosVUFBVThaLEdBQUdoWSxRQUFqQjs7QUFFQTtBQUNBLE1BQUl6SSxTQUFTMkcsUUFBUTNHLE1BQXJCO0FBQ0EsTUFBSUEsVUFBVSxDQUFDMkcsUUFBUWltQixRQUF2QixFQUFpQztBQUMvQixXQUFPNXNCLE9BQU95SSxRQUFQLENBQWdCbWtCLFFBQWhCLElBQTRCNXNCLE9BQU9VLE9BQTFDLEVBQW1EO0FBQ2pEVixlQUFTQSxPQUFPVSxPQUFoQjtBQUNEO0FBQ0RWLFdBQU82c0IsU0FBUCxDQUFpQnR3QixJQUFqQixDQUFzQmtrQixFQUF0QjtBQUNEOztBQUVEQSxLQUFHL2YsT0FBSCxHQUFhVixNQUFiO0FBQ0F5Z0IsS0FBR3JZLEtBQUgsR0FBV3BJLFNBQVNBLE9BQU9vSSxLQUFoQixHQUF3QnFZLEVBQW5DOztBQUVBQSxLQUFHb00sU0FBSCxHQUFlLEVBQWY7QUFDQXBNLEtBQUdxTSxLQUFILEdBQVcsRUFBWDs7QUFFQXJNLEtBQUdzTSxRQUFILEdBQWMsSUFBZDtBQUNBdE0sS0FBR2hnQixTQUFILEdBQWUsSUFBZjtBQUNBZ2dCLEtBQUd1TSxlQUFILEdBQXFCLEtBQXJCO0FBQ0F2TSxLQUFHd00sVUFBSCxHQUFnQixLQUFoQjtBQUNBeE0sS0FBR3lNLFlBQUgsR0FBa0IsS0FBbEI7QUFDQXpNLEtBQUcwTSxpQkFBSCxHQUF1QixLQUF2QjtBQUNEOztBQUVELFNBQVNDLGNBQVQsQ0FBeUIxdUIsR0FBekIsRUFBOEI7QUFDNUJBLE1BQUloQyxTQUFKLENBQWMyd0IsT0FBZCxHQUF3QixVQUFVcnNCLEtBQVYsRUFBaUJzc0IsU0FBakIsRUFBNEI7QUFDbEQsUUFBSTdNLEtBQUssSUFBVDtBQUNBLFFBQUlBLEdBQUd3TSxVQUFQLEVBQW1CO0FBQ2pCTSxlQUFTOU0sRUFBVCxFQUFhLGNBQWI7QUFDRDtBQUNELFFBQUkrTSxTQUFTL00sR0FBR2dOLEdBQWhCO0FBQ0EsUUFBSUMsWUFBWWpOLEdBQUdrTixNQUFuQjtBQUNBLFFBQUlDLHFCQUFxQmxCLGNBQXpCO0FBQ0FBLHFCQUFpQmpNLEVBQWpCO0FBQ0FBLE9BQUdrTixNQUFILEdBQVkzc0IsS0FBWjtBQUNBO0FBQ0E7QUFDQSxRQUFJLENBQUMwc0IsU0FBTCxFQUFnQjtBQUNkO0FBQ0FqTixTQUFHZ04sR0FBSCxHQUFTaE4sR0FBR29OLFNBQUgsQ0FDUHBOLEdBQUdnTixHQURJLEVBQ0N6c0IsS0FERCxFQUNRc3NCLFNBRFIsRUFDbUIsS0FEbkIsQ0FDeUI7QUFEekIsUUFFUDdNLEdBQUdoWSxRQUFILENBQVlxbEIsVUFGTCxFQUdQck4sR0FBR2hZLFFBQUgsQ0FBWXNsQixPQUhMLENBQVQ7QUFLRCxLQVBELE1BT087QUFDTDtBQUNBdE4sU0FBR2dOLEdBQUgsR0FBU2hOLEdBQUdvTixTQUFILENBQWFILFNBQWIsRUFBd0Ixc0IsS0FBeEIsQ0FBVDtBQUNEO0FBQ0QwckIscUJBQWlCa0Isa0JBQWpCO0FBQ0E7QUFDQSxRQUFJSixNQUFKLEVBQVk7QUFDVkEsYUFBT1EsT0FBUCxHQUFpQixJQUFqQjtBQUNEO0FBQ0QsUUFBSXZOLEdBQUdnTixHQUFQLEVBQVk7QUFDVmhOLFNBQUdnTixHQUFILENBQU9PLE9BQVAsR0FBaUJ2TixFQUFqQjtBQUNEO0FBQ0Q7QUFDQSxRQUFJQSxHQUFHamdCLE1BQUgsSUFBYWlnQixHQUFHL2YsT0FBaEIsSUFBMkIrZixHQUFHamdCLE1BQUgsS0FBY2lnQixHQUFHL2YsT0FBSCxDQUFXaXRCLE1BQXhELEVBQWdFO0FBQzlEbE4sU0FBRy9mLE9BQUgsQ0FBVytzQixHQUFYLEdBQWlCaE4sR0FBR2dOLEdBQXBCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0QsR0FyQ0Q7O0FBdUNBL3VCLE1BQUloQyxTQUFKLENBQWN1eEIsWUFBZCxHQUE2QixZQUFZO0FBQ3ZDLFFBQUl4TixLQUFLLElBQVQ7QUFDQSxRQUFJQSxHQUFHc00sUUFBUCxFQUFpQjtBQUNmdE0sU0FBR3NNLFFBQUgsQ0FBWXJMLE1BQVo7QUFDRDtBQUNGLEdBTEQ7O0FBT0FoakIsTUFBSWhDLFNBQUosQ0FBY3d4QixRQUFkLEdBQXlCLFlBQVk7QUFDbkMsUUFBSXpOLEtBQUssSUFBVDtBQUNBLFFBQUlBLEdBQUcwTSxpQkFBUCxFQUEwQjtBQUN4QjtBQUNEO0FBQ0RJLGFBQVM5TSxFQUFULEVBQWEsZUFBYjtBQUNBQSxPQUFHME0saUJBQUgsR0FBdUIsSUFBdkI7QUFDQTtBQUNBLFFBQUludEIsU0FBU3lnQixHQUFHL2YsT0FBaEI7QUFDQSxRQUFJVixVQUFVLENBQUNBLE9BQU9tdEIsaUJBQWxCLElBQXVDLENBQUMxTSxHQUFHaFksUUFBSCxDQUFZbWtCLFFBQXhELEVBQWtFO0FBQ2hFelMsYUFBT25hLE9BQU82c0IsU0FBZCxFQUF5QnBNLEVBQXpCO0FBQ0Q7QUFDRDtBQUNBLFFBQUlBLEdBQUdzTSxRQUFQLEVBQWlCO0FBQ2Z0TSxTQUFHc00sUUFBSCxDQUFZb0IsUUFBWjtBQUNEO0FBQ0QsUUFBSTd4QixJQUFJbWtCLEdBQUcyTixTQUFILENBQWF4eUIsTUFBckI7QUFDQSxXQUFPVSxHQUFQLEVBQVk7QUFDVm1rQixTQUFHMk4sU0FBSCxDQUFhOXhCLENBQWIsRUFBZ0I2eEIsUUFBaEI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxRQUFJMU4sR0FBRzROLEtBQUgsQ0FBUy9MLE1BQWIsRUFBcUI7QUFDbkI3QixTQUFHNE4sS0FBSCxDQUFTL0wsTUFBVCxDQUFnQlUsT0FBaEI7QUFDRDtBQUNEO0FBQ0F2QyxPQUFHeU0sWUFBSCxHQUFrQixJQUFsQjtBQUNBSyxhQUFTOU0sRUFBVCxFQUFhLFdBQWI7QUFDQTtBQUNBQSxPQUFHb0wsSUFBSDtBQUNBO0FBQ0EsUUFBSXBMLEdBQUdnTixHQUFQLEVBQVk7QUFDVmhOLFNBQUdnTixHQUFILENBQU9PLE9BQVAsR0FBaUIsSUFBakI7QUFDRDtBQUNEO0FBQ0F2TixPQUFHb04sU0FBSCxDQUFhcE4sR0FBR2tOLE1BQWhCLEVBQXdCLElBQXhCO0FBQ0QsR0FwQ0Q7QUFxQ0Q7O0FBRUQsU0FBU1csY0FBVCxDQUNFN04sRUFERixFQUVFL08sRUFGRixFQUdFNGIsU0FIRixFQUlFO0FBQ0E3TSxLQUFHZ04sR0FBSCxHQUFTL2IsRUFBVDtBQUNBLE1BQUksQ0FBQytPLEdBQUdoWSxRQUFILENBQVk3SSxNQUFqQixFQUF5QjtBQUN2QjZnQixPQUFHaFksUUFBSCxDQUFZN0ksTUFBWixHQUFxQjRwQixnQkFBckI7QUFDQSxRQUFJanZCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0EsVUFBSzZkLEdBQUdoWSxRQUFILENBQVl4SixRQUFaLElBQXdCd2hCLEdBQUdoWSxRQUFILENBQVl4SixRQUFaLENBQXFCcUssTUFBckIsQ0FBNEIsQ0FBNUIsTUFBbUMsR0FBNUQsSUFDRm1YLEdBQUdoWSxRQUFILENBQVlpSixFQURWLElBQ2dCQSxFQURwQixFQUN3QjtBQUN0QnJTLGFBQ0Usb0VBQ0EsbUVBREEsR0FFQSx1REFIRixFQUlFb2hCLEVBSkY7QUFNRCxPQVJELE1BUU87QUFDTHBoQixhQUNFLHFFQURGLEVBRUVvaEIsRUFGRjtBQUlEO0FBQ0Y7QUFDRjtBQUNEOE0sV0FBUzlNLEVBQVQsRUFBYSxhQUFiOztBQUVBLE1BQUk4TixlQUFKO0FBQ0E7QUFDQSxNQUFJaDBCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDcEIsT0FBTzJSLFdBQWhELElBQStEa1YsSUFBbkUsRUFBeUU7QUFDdkVrRyxzQkFBa0IsWUFBWTtBQUM1QixVQUFJNXdCLE9BQU84aUIsR0FBRytOLEtBQWQ7QUFDQSxVQUFJdE4sS0FBS1QsR0FBR2dPLElBQVo7QUFDQSxVQUFJL0YsV0FBVyxvQkFBb0J4SCxFQUFuQztBQUNBLFVBQUl5SCxTQUFTLGtCQUFrQnpILEVBQS9COztBQUVBbUgsV0FBS0ssUUFBTDtBQUNBLFVBQUkxbkIsUUFBUXlmLEdBQUdpTyxPQUFILEVBQVo7QUFDQXJHLFdBQUtNLE1BQUw7QUFDQUwsY0FBUzNxQixPQUFPLFNBQWhCLEVBQTRCK3FCLFFBQTVCLEVBQXNDQyxNQUF0Qzs7QUFFQU4sV0FBS0ssUUFBTDtBQUNBakksU0FBRzRNLE9BQUgsQ0FBV3JzQixLQUFYLEVBQWtCc3NCLFNBQWxCO0FBQ0FqRixXQUFLTSxNQUFMO0FBQ0FMLGNBQVMzcUIsT0FBTyxRQUFoQixFQUEyQitxQixRQUEzQixFQUFxQ0MsTUFBckM7QUFDRCxLQWZEO0FBZ0JELEdBakJELE1BaUJPO0FBQ0w0RixzQkFBa0IsWUFBWTtBQUM1QjlOLFNBQUc0TSxPQUFILENBQVc1TSxHQUFHaU8sT0FBSCxFQUFYLEVBQXlCcEIsU0FBekI7QUFDRCxLQUZEO0FBR0Q7O0FBRUQ3TSxLQUFHc00sUUFBSCxHQUFjLElBQUk0QixPQUFKLENBQVlsTyxFQUFaLEVBQWdCOE4sZUFBaEIsRUFBaUNyeEIsSUFBakMsQ0FBZDtBQUNBb3dCLGNBQVksS0FBWjs7QUFFQTtBQUNBO0FBQ0EsTUFBSTdNLEdBQUdqZ0IsTUFBSCxJQUFhLElBQWpCLEVBQXVCO0FBQ3JCaWdCLE9BQUd3TSxVQUFILEdBQWdCLElBQWhCO0FBQ0FNLGFBQVM5TSxFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0QsU0FBT0EsRUFBUDtBQUNEOztBQUVELFNBQVNtTyxvQkFBVCxDQUNFbk8sRUFERixFQUVFNEQsU0FGRixFQUdFa0gsU0FIRixFQUlFc0QsV0FKRixFQUtFQyxjQUxGLEVBTUU7QUFDQTtBQUNBO0FBQ0EsTUFBSUMsY0FBYyxDQUFDLEVBQ2pCRCxrQkFBZ0M7QUFDaENyTyxLQUFHaFksUUFBSCxDQUFZdW1CLGVBRFosSUFDZ0M7QUFDaENILGNBQVk1dUIsSUFBWixDQUFpQmd2QixXQUZqQixJQUVnQztBQUNoQ3hPLEtBQUd5TyxZQUFILEtBQW9CaFMsV0FKSCxDQUllO0FBSmYsR0FBbkI7O0FBT0F1RCxLQUFHaFksUUFBSCxDQUFZMG1CLFlBQVosR0FBMkJOLFdBQTNCO0FBQ0FwTyxLQUFHamdCLE1BQUgsR0FBWXF1QixXQUFaLENBWEEsQ0FXeUI7QUFDekIsTUFBSXBPLEdBQUdrTixNQUFQLEVBQWU7QUFBRTtBQUNmbE4sT0FBR2tOLE1BQUgsQ0FBVTN0QixNQUFWLEdBQW1CNnVCLFdBQW5CO0FBQ0Q7QUFDRHBPLEtBQUdoWSxRQUFILENBQVl1bUIsZUFBWixHQUE4QkYsY0FBOUI7O0FBRUE7QUFDQSxNQUFJekssYUFBYTVELEdBQUdoWSxRQUFILENBQVloSixLQUE3QixFQUFvQztBQUNsQ21qQixrQkFBY0MsYUFBZCxHQUE4QixLQUE5QjtBQUNBLFFBQUl0b0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnZ0Isb0JBQWNFLGNBQWQsR0FBK0IsSUFBL0I7QUFDRDtBQUNELFFBQUlyakIsUUFBUWdoQixHQUFHc0csTUFBZjtBQUNBLFFBQUlxSSxXQUFXM08sR0FBR2hZLFFBQUgsQ0FBWTRtQixTQUFaLElBQXlCLEVBQXhDO0FBQ0EsU0FBSyxJQUFJL3lCLElBQUksQ0FBYixFQUFnQkEsSUFBSTh5QixTQUFTeHpCLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QyxVQUFJdUcsTUFBTXVzQixTQUFTOXlCLENBQVQsQ0FBVjtBQUNBbUQsWUFBTW9ELEdBQU4sSUFBYTBqQixhQUFhMWpCLEdBQWIsRUFBa0I0ZCxHQUFHaFksUUFBSCxDQUFZaEosS0FBOUIsRUFBcUM0a0IsU0FBckMsRUFBZ0Q1RCxFQUFoRCxDQUFiO0FBQ0Q7QUFDRG1DLGtCQUFjQyxhQUFkLEdBQThCLElBQTlCO0FBQ0EsUUFBSXRvQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2dnQixvQkFBY0UsY0FBZCxHQUErQixLQUEvQjtBQUNEO0FBQ0Q7QUFDQXJDLE9BQUdoWSxRQUFILENBQVk0YixTQUFaLEdBQXdCQSxTQUF4QjtBQUNEO0FBQ0Q7QUFDQSxNQUFJa0gsU0FBSixFQUFlO0FBQ2IsUUFBSU8sZUFBZXJMLEdBQUdoWSxRQUFILENBQVkraUIsZ0JBQS9CO0FBQ0EvSyxPQUFHaFksUUFBSCxDQUFZK2lCLGdCQUFaLEdBQStCRCxTQUEvQjtBQUNBRSw2QkFBeUJoTCxFQUF6QixFQUE2QjhLLFNBQTdCLEVBQXdDTyxZQUF4QztBQUNEO0FBQ0Q7QUFDQSxNQUFJaUQsV0FBSixFQUFpQjtBQUNmdE8sT0FBR3JaLE1BQUgsR0FBWWdsQixhQUFhMEMsY0FBYixFQUE2QkQsWUFBWTlGLE9BQXpDLENBQVo7QUFDQXRJLE9BQUd3TixZQUFIO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTcUIsZ0JBQVQsQ0FBMkI3TyxFQUEzQixFQUErQjtBQUM3QixTQUFPQSxPQUFPQSxLQUFLQSxHQUFHL2YsT0FBZixDQUFQLEVBQWdDO0FBQzlCLFFBQUkrZixHQUFHaGdCLFNBQVAsRUFBa0I7QUFBRSxhQUFPLElBQVA7QUFBYTtBQUNsQztBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVM4dUIsc0JBQVQsQ0FBaUM5TyxFQUFqQyxFQUFxQytPLE1BQXJDLEVBQTZDO0FBQzNDLE1BQUlBLE1BQUosRUFBWTtBQUNWL08sT0FBR3VNLGVBQUgsR0FBcUIsS0FBckI7QUFDQSxRQUFJc0MsaUJBQWlCN08sRUFBakIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0YsR0FMRCxNQUtPLElBQUlBLEdBQUd1TSxlQUFQLEVBQXdCO0FBQzdCO0FBQ0Q7QUFDRCxNQUFJdk0sR0FBR2hnQixTQUFILElBQWdCZ2dCLEdBQUdoZ0IsU0FBSCxJQUFnQixJQUFwQyxFQUEwQztBQUN4Q2dnQixPQUFHaGdCLFNBQUgsR0FBZSxLQUFmO0FBQ0EsU0FBSyxJQUFJbkUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWtCLEdBQUdvTSxTQUFILENBQWFqeEIsTUFBakMsRUFBeUNVLEdBQXpDLEVBQThDO0FBQzVDaXpCLDZCQUF1QjlPLEdBQUdvTSxTQUFILENBQWF2d0IsQ0FBYixDQUF2QjtBQUNEO0FBQ0RpeEIsYUFBUzlNLEVBQVQsRUFBYSxXQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTZ1Asd0JBQVQsQ0FBbUNoUCxFQUFuQyxFQUF1QytPLE1BQXZDLEVBQStDO0FBQzdDLE1BQUlBLE1BQUosRUFBWTtBQUNWL08sT0FBR3VNLGVBQUgsR0FBcUIsSUFBckI7QUFDQSxRQUFJc0MsaUJBQWlCN08sRUFBakIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0Y7QUFDRCxNQUFJLENBQUNBLEdBQUdoZ0IsU0FBUixFQUFtQjtBQUNqQmdnQixPQUFHaGdCLFNBQUgsR0FBZSxJQUFmO0FBQ0EsU0FBSyxJQUFJbkUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWtCLEdBQUdvTSxTQUFILENBQWFqeEIsTUFBakMsRUFBeUNVLEdBQXpDLEVBQThDO0FBQzVDbXpCLCtCQUF5QmhQLEdBQUdvTSxTQUFILENBQWF2d0IsQ0FBYixDQUF6QjtBQUNEO0FBQ0RpeEIsYUFBUzlNLEVBQVQsRUFBYSxhQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTOE0sUUFBVCxDQUFtQjlNLEVBQW5CLEVBQXVCM2YsSUFBdkIsRUFBNkI7QUFDM0IsTUFBSW9uQixXQUFXekgsR0FBR2hZLFFBQUgsQ0FBWTNILElBQVosQ0FBZjtBQUNBLE1BQUlvbkIsUUFBSixFQUFjO0FBQ1osU0FBSyxJQUFJNXJCLElBQUksQ0FBUixFQUFXc1IsSUFBSXNhLFNBQVN0c0IsTUFBN0IsRUFBcUNVLElBQUlzUixDQUF6QyxFQUE0Q3RSLEdBQTVDLEVBQWlEO0FBQy9DLFVBQUk7QUFDRjRyQixpQkFBUzVyQixDQUFULEVBQVlsQixJQUFaLENBQWlCcWxCLEVBQWpCO0FBQ0QsT0FGRCxDQUVFLE9BQU96bEIsQ0FBUCxFQUFVO0FBQ1Z1c0Isb0JBQVl2c0IsQ0FBWixFQUFleWxCLEVBQWYsRUFBb0IzZixPQUFPLE9BQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsTUFBSTJmLEdBQUc2SyxhQUFQLEVBQXNCO0FBQ3BCN0ssT0FBR3lMLEtBQUgsQ0FBUyxVQUFVcHJCLElBQW5CO0FBQ0Q7QUFDRjs7QUFFRDs7QUFHQSxJQUFJdkYsUUFBUSxFQUFaO0FBQ0EsSUFBSXlrQixNQUFNLEVBQVY7QUFDQSxJQUFJMFAsV0FBVyxFQUFmO0FBQ0EsSUFBSUMsVUFBVSxLQUFkO0FBQ0EsSUFBSUMsV0FBVyxLQUFmO0FBQ0EsSUFBSXh4QixRQUFRLENBQVo7O0FBRUE7OztBQUdBLFNBQVN5eEIsbUJBQVQsR0FBZ0M7QUFDOUJ0MEIsUUFBTUssTUFBTixHQUFlLENBQWY7QUFDQW9rQixRQUFNLEVBQU47QUFDQSxNQUFJemxCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOHNCLGVBQVcsRUFBWDtBQUNEO0FBQ0RDLFlBQVVDLFdBQVcsS0FBckI7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU0UsbUJBQVQsR0FBZ0M7QUFDOUJGLGFBQVcsSUFBWDtBQUNBLE1BQUlHLE9BQUosRUFBYTdPLEVBQWIsRUFBaUJULEVBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWxsQixRQUFNeTBCLElBQU4sQ0FBVyxVQUFVanJCLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUFFLFdBQU9ELEVBQUVtYyxFQUFGLEdBQU9sYyxFQUFFa2MsRUFBaEI7QUFBcUIsR0FBbEQ7O0FBRUE7QUFDQTtBQUNBLE9BQUs5aUIsUUFBUSxDQUFiLEVBQWdCQSxRQUFRN0MsTUFBTUssTUFBOUIsRUFBc0N3QyxPQUF0QyxFQUErQztBQUM3QzJ4QixjQUFVeDBCLE1BQU02QyxLQUFOLENBQVY7QUFDQThpQixTQUFLNk8sUUFBUTdPLEVBQWI7QUFDQWxCLFFBQUlrQixFQUFKLElBQVUsSUFBVjtBQUNBNk8sWUFBUTl6QixHQUFSO0FBQ0E7QUFDQSxRQUFJMUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNvZCxJQUFJa0IsRUFBSixLQUFXLElBQXhELEVBQThEO0FBQzVEd08sZUFBU3hPLEVBQVQsSUFBZSxDQUFDd08sU0FBU3hPLEVBQVQsS0FBZ0IsQ0FBakIsSUFBc0IsQ0FBckM7QUFDQSxVQUFJd08sU0FBU3hPLEVBQVQsSUFBZTFmLE9BQU95YixlQUExQixFQUEyQztBQUN6QzVkLGFBQ0UsMkNBQ0Uwd0IsUUFBUUUsSUFBUixHQUNLLGtDQUFtQ0YsUUFBUUcsVUFBM0MsR0FBeUQsSUFEOUQsR0FFSSxpQ0FITixDQURGLEVBTUVILFFBQVF0UCxFQU5WO0FBUUE7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxNQUFJMFAsV0FBVzUwQixNQUFNc0ksS0FBTixFQUFmO0FBQ0Fnc0I7O0FBRUE7QUFDQXp4QixVQUFRK3hCLFNBQVN2MEIsTUFBakI7QUFDQSxTQUFPd0MsT0FBUCxFQUFnQjtBQUNkMnhCLGNBQVVJLFNBQVMveEIsS0FBVCxDQUFWO0FBQ0FxaUIsU0FBS3NQLFFBQVF0UCxFQUFiO0FBQ0EsUUFBSUEsR0FBR3NNLFFBQUgsS0FBZ0JnRCxPQUFoQixJQUEyQnRQLEdBQUd3TSxVQUFsQyxFQUE4QztBQUM1Q00sZUFBUzlNLEVBQVQsRUFBYSxTQUFiO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsTUFBSW5FLFlBQVk5YSxPQUFPOGEsUUFBdkIsRUFBaUM7QUFDL0JBLGFBQVM3ZSxJQUFULENBQWMsT0FBZDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7O0FBS0EsU0FBUzJ5QixZQUFULENBQXVCTCxPQUF2QixFQUFnQztBQUM5QixNQUFJN08sS0FBSzZPLFFBQVE3TyxFQUFqQjtBQUNBLE1BQUlsQixJQUFJa0IsRUFBSixLQUFXLElBQWYsRUFBcUI7QUFDbkJsQixRQUFJa0IsRUFBSixJQUFVLElBQVY7QUFDQSxRQUFJLENBQUMwTyxRQUFMLEVBQWU7QUFDYnIwQixZQUFNZ0IsSUFBTixDQUFXd3pCLE9BQVg7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsVUFBSXp6QixJQUFJZixNQUFNSyxNQUFOLEdBQWUsQ0FBdkI7QUFDQSxhQUFPVSxLQUFLLENBQUwsSUFBVWYsTUFBTWUsQ0FBTixFQUFTNGtCLEVBQVQsR0FBYzZPLFFBQVE3TyxFQUF2QyxFQUEyQztBQUN6QzVrQjtBQUNEO0FBQ0RmLFlBQU04ZSxNQUFOLENBQWF0RSxLQUFLRCxHQUFMLENBQVN4WixDQUFULEVBQVk4QixLQUFaLElBQXFCLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDMnhCLE9BQXhDO0FBQ0Q7QUFDRDtBQUNBLFFBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQ1pBLGdCQUFVLElBQVY7QUFDQXp6QixlQUFTNHpCLG1CQUFUO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBLElBQUlPLFFBQVEsQ0FBWjs7QUFFQTs7Ozs7QUFLQSxJQUFJMUIsVUFBVSxTQUFTQSxPQUFULENBQ1psTyxFQURZLEVBRVo2UCxPQUZZLEVBR1p4YyxFQUhZLEVBSVpuTixPQUpZLEVBS1o7QUFDQSxPQUFLOFosRUFBTCxHQUFVQSxFQUFWO0FBQ0FBLEtBQUcyTixTQUFILENBQWE3eEIsSUFBYixDQUFrQixJQUFsQjtBQUNBO0FBQ0EsTUFBSW9LLE9BQUosRUFBYTtBQUNYLFNBQUs0cEIsSUFBTCxHQUFZLENBQUMsQ0FBQzVwQixRQUFRNHBCLElBQXRCO0FBQ0EsU0FBS04sSUFBTCxHQUFZLENBQUMsQ0FBQ3RwQixRQUFRc3BCLElBQXRCO0FBQ0EsU0FBS08sSUFBTCxHQUFZLENBQUMsQ0FBQzdwQixRQUFRNnBCLElBQXRCO0FBQ0EsU0FBS0MsSUFBTCxHQUFZLENBQUMsQ0FBQzlwQixRQUFROHBCLElBQXRCO0FBQ0QsR0FMRCxNQUtPO0FBQ0wsU0FBS0YsSUFBTCxHQUFZLEtBQUtOLElBQUwsR0FBWSxLQUFLTyxJQUFMLEdBQVksS0FBS0MsSUFBTCxHQUFZLEtBQWhEO0FBQ0Q7QUFDRCxPQUFLM2MsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBS29OLEVBQUwsR0FBVSxFQUFFbVAsS0FBWixDQWJBLENBYW1CO0FBQ25CLE9BQUtLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsT0FBS0MsS0FBTCxHQUFhLEtBQUtILElBQWxCLENBZkEsQ0Fld0I7QUFDeEIsT0FBS0ksSUFBTCxHQUFZLEVBQVo7QUFDQSxPQUFLQyxPQUFMLEdBQWUsRUFBZjtBQUNBLE9BQUtDLE1BQUwsR0FBYyxJQUFJalIsSUFBSixFQUFkO0FBQ0EsT0FBS2tSLFNBQUwsR0FBaUIsSUFBSWxSLElBQUosRUFBakI7QUFDQSxPQUFLcVEsVUFBTCxHQUFrQjMxQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixHQUNkMHRCLFFBQVF2dUIsUUFBUixFQURjLEdBRWQsRUFGSjtBQUdBO0FBQ0EsTUFBSSxPQUFPdXVCLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakMsU0FBS3pNLE1BQUwsR0FBY3lNLE9BQWQ7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLek0sTUFBTCxHQUFjbGEsVUFBVTJtQixPQUFWLENBQWQ7QUFDQSxRQUFJLENBQUMsS0FBS3pNLE1BQVYsRUFBa0I7QUFDaEIsV0FBS0EsTUFBTCxHQUFjLFlBQVksQ0FBRSxDQUE1QjtBQUNBdHBCLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsNkJBQTZCaXhCLE9BQTdCLEdBQXVDLEtBQXZDLEdBQ0EsbURBREEsR0FFQSwyQ0FIdUMsRUFJdkM3UCxFQUp1QyxDQUF6QztBQU1EO0FBQ0Y7QUFDRCxPQUFLbGlCLEtBQUwsR0FBYSxLQUFLaXlCLElBQUwsR0FDVGx2QixTQURTLEdBRVQsS0FBS3pDLEdBQUwsRUFGSjtBQUdELENBOUNEOztBQWdEQTs7O0FBR0E4dkIsUUFBUWp5QixTQUFSLENBQWtCbUMsR0FBbEIsR0FBd0IsU0FBU0EsR0FBVCxHQUFnQjtBQUN0QytpQixhQUFXLElBQVg7QUFDQSxNQUFJcmpCLEtBQUo7QUFDQSxNQUFJa2lCLEtBQUssS0FBS0EsRUFBZDtBQUNBLE1BQUksS0FBS3dQLElBQVQsRUFBZTtBQUNiLFFBQUk7QUFDRjF4QixjQUFRLEtBQUtzbEIsTUFBTCxDQUFZem9CLElBQVosQ0FBaUJxbEIsRUFBakIsRUFBcUJBLEVBQXJCLENBQVI7QUFDRCxLQUZELENBRUUsT0FBT3psQixDQUFQLEVBQVU7QUFDVnVzQixrQkFBWXZzQixDQUFaLEVBQWV5bEIsRUFBZixFQUFvQiwwQkFBMkIsS0FBS3lQLFVBQWhDLEdBQThDLElBQWxFO0FBQ0Q7QUFDRixHQU5ELE1BTU87QUFDTDN4QixZQUFRLEtBQUtzbEIsTUFBTCxDQUFZem9CLElBQVosQ0FBaUJxbEIsRUFBakIsRUFBcUJBLEVBQXJCLENBQVI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJLEtBQUs4UCxJQUFULEVBQWU7QUFDYlMsYUFBU3p5QixLQUFUO0FBQ0Q7QUFDRHVqQjtBQUNBLE9BQUttUCxXQUFMO0FBQ0EsU0FBTzF5QixLQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBOzs7QUFHQW93QixRQUFRanlCLFNBQVIsQ0FBa0I4a0IsTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxDQUFpQmlCLEdBQWpCLEVBQXNCO0FBQy9DLE1BQUl2QixLQUFLdUIsSUFBSXZCLEVBQWI7QUFDQSxNQUFJLENBQUMsS0FBSzZQLFNBQUwsQ0FBZS9RLEdBQWYsQ0FBbUJrQixFQUFuQixDQUFMLEVBQTZCO0FBQzNCLFNBQUs2UCxTQUFMLENBQWU5USxHQUFmLENBQW1CaUIsRUFBbkI7QUFDQSxTQUFLMlAsT0FBTCxDQUFhdDBCLElBQWIsQ0FBa0JrbUIsR0FBbEI7QUFDQSxRQUFJLENBQUMsS0FBS3FPLE1BQUwsQ0FBWTlRLEdBQVosQ0FBZ0JrQixFQUFoQixDQUFMLEVBQTBCO0FBQ3hCdUIsVUFBSXJCLE1BQUosQ0FBVyxJQUFYO0FBQ0Q7QUFDRjtBQUNGLENBVEQ7O0FBV0E7OztBQUdBdU4sUUFBUWp5QixTQUFSLENBQWtCdTBCLFdBQWxCLEdBQWdDLFNBQVNBLFdBQVQsR0FBd0I7QUFDcEQsTUFBSTVxQixTQUFTLElBQWI7O0FBRUYsTUFBSS9KLElBQUksS0FBS3MwQixJQUFMLENBQVVoMUIsTUFBbEI7QUFDQSxTQUFPVSxHQUFQLEVBQVk7QUFDVixRQUFJbW1CLE1BQU1wYyxPQUFPdXFCLElBQVAsQ0FBWXQwQixDQUFaLENBQVY7QUFDQSxRQUFJLENBQUMrSixPQUFPMHFCLFNBQVAsQ0FBaUIvUSxHQUFqQixDQUFxQnlDLElBQUl2QixFQUF6QixDQUFMLEVBQW1DO0FBQ2pDdUIsVUFBSW5CLFNBQUosQ0FBY2piLE1BQWQ7QUFDRDtBQUNGO0FBQ0QsTUFBSTZxQixNQUFNLEtBQUtKLE1BQWY7QUFDQSxPQUFLQSxNQUFMLEdBQWMsS0FBS0MsU0FBbkI7QUFDQSxPQUFLQSxTQUFMLEdBQWlCRyxHQUFqQjtBQUNBLE9BQUtILFNBQUwsQ0FBZTdRLEtBQWY7QUFDQWdSLFFBQU0sS0FBS04sSUFBWDtBQUNBLE9BQUtBLElBQUwsR0FBWSxLQUFLQyxPQUFqQjtBQUNBLE9BQUtBLE9BQUwsR0FBZUssR0FBZjtBQUNBLE9BQUtMLE9BQUwsQ0FBYWoxQixNQUFiLEdBQXNCLENBQXRCO0FBQ0QsQ0FsQkQ7O0FBb0JBOzs7O0FBSUEreUIsUUFBUWp5QixTQUFSLENBQWtCZ2xCLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDNUM7QUFDQSxNQUFJLEtBQUs4TyxJQUFULEVBQWU7QUFDYixTQUFLRyxLQUFMLEdBQWEsSUFBYjtBQUNELEdBRkQsTUFFTyxJQUFJLEtBQUtGLElBQVQsRUFBZTtBQUNwQixTQUFLeDBCLEdBQUw7QUFDRCxHQUZNLE1BRUE7QUFDTG0wQixpQkFBYSxJQUFiO0FBQ0Q7QUFDRixDQVREOztBQVdBOzs7O0FBSUF6QixRQUFRanlCLFNBQVIsQ0FBa0JULEdBQWxCLEdBQXdCLFNBQVNBLEdBQVQsR0FBZ0I7QUFDdEMsTUFBSSxLQUFLeTBCLE1BQVQsRUFBaUI7QUFDZixRQUFJbnlCLFFBQVEsS0FBS00sR0FBTCxFQUFaO0FBQ0EsUUFDRU4sVUFBVSxLQUFLQSxLQUFmO0FBQ0E7QUFDQTtBQUNBO0FBQ0FpVCxhQUFTalQsS0FBVCxDQUpBLElBS0EsS0FBS2d5QixJQU5QLEVBT0U7QUFDQTtBQUNBLFVBQUlZLFdBQVcsS0FBSzV5QixLQUFwQjtBQUNBLFdBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFVBQUksS0FBSzB4QixJQUFULEVBQWU7QUFDYixZQUFJO0FBQ0YsZUFBS25jLEVBQUwsQ0FBUTFZLElBQVIsQ0FBYSxLQUFLcWxCLEVBQWxCLEVBQXNCbGlCLEtBQXRCLEVBQTZCNHlCLFFBQTdCO0FBQ0QsU0FGRCxDQUVFLE9BQU9uMkIsQ0FBUCxFQUFVO0FBQ1Z1c0Isc0JBQVl2c0IsQ0FBWixFQUFlLEtBQUt5bEIsRUFBcEIsRUFBeUIsNEJBQTZCLEtBQUt5UCxVQUFsQyxHQUFnRCxJQUF6RTtBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0wsYUFBS3BjLEVBQUwsQ0FBUTFZLElBQVIsQ0FBYSxLQUFLcWxCLEVBQWxCLEVBQXNCbGlCLEtBQXRCLEVBQTZCNHlCLFFBQTdCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsQ0F6QkQ7O0FBMkJBOzs7O0FBSUF4QyxRQUFRanlCLFNBQVIsQ0FBa0IwMEIsUUFBbEIsR0FBNkIsU0FBU0EsUUFBVCxHQUFxQjtBQUNoRCxPQUFLN3lCLEtBQUwsR0FBYSxLQUFLTSxHQUFMLEVBQWI7QUFDQSxPQUFLOHhCLEtBQUwsR0FBYSxLQUFiO0FBQ0QsQ0FIRDs7QUFLQTs7O0FBR0FoQyxRQUFRanlCLFNBQVIsQ0FBa0I2a0IsTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxHQUFtQjtBQUMxQyxNQUFJbGIsU0FBUyxJQUFiOztBQUVGLE1BQUkvSixJQUFJLEtBQUtzMEIsSUFBTCxDQUFVaDFCLE1BQWxCO0FBQ0EsU0FBT1UsR0FBUCxFQUFZO0FBQ1YrSixXQUFPdXFCLElBQVAsQ0FBWXQwQixDQUFaLEVBQWVpbEIsTUFBZjtBQUNEO0FBQ0YsQ0FQRDs7QUFTQTs7O0FBR0FvTixRQUFRanlCLFNBQVIsQ0FBa0J5eEIsUUFBbEIsR0FBNkIsU0FBU0EsUUFBVCxHQUFxQjtBQUM5QyxNQUFJOW5CLFNBQVMsSUFBYjs7QUFFRixNQUFJLEtBQUtxcUIsTUFBVCxFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQyxLQUFLalEsRUFBTCxDQUFRME0saUJBQWIsRUFBZ0M7QUFDOUJoVCxhQUFPLEtBQUtzRyxFQUFMLENBQVEyTixTQUFmLEVBQTBCLElBQTFCO0FBQ0Q7QUFDRCxRQUFJOXhCLElBQUksS0FBS3MwQixJQUFMLENBQVVoMUIsTUFBbEI7QUFDQSxXQUFPVSxHQUFQLEVBQVk7QUFDVitKLGFBQU91cUIsSUFBUCxDQUFZdDBCLENBQVosRUFBZWdsQixTQUFmLENBQXlCamIsTUFBekI7QUFDRDtBQUNELFNBQUtxcUIsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGLENBaEJEOztBQWtCQTs7Ozs7QUFLQSxJQUFJVyxjQUFjLElBQUl4UixJQUFKLEVBQWxCO0FBQ0EsU0FBU21SLFFBQVQsQ0FBbUIzdEIsR0FBbkIsRUFBd0I7QUFDdEJndUIsY0FBWW5SLEtBQVo7QUFDQW9SLFlBQVVqdUIsR0FBVixFQUFlZ3VCLFdBQWY7QUFDRDs7QUFFRCxTQUFTQyxTQUFULENBQW9CanVCLEdBQXBCLEVBQXlCa3VCLElBQXpCLEVBQStCO0FBQzdCLE1BQUlqMUIsQ0FBSixFQUFPb0gsSUFBUDtBQUNBLE1BQUk4dEIsTUFBTXAxQixNQUFNbUgsT0FBTixDQUFjRixHQUFkLENBQVY7QUFDQSxNQUFLLENBQUNtdUIsR0FBRCxJQUFRLENBQUNoZ0IsU0FBU25PLEdBQVQsQ0FBVixJQUE0QixDQUFDaEYsT0FBT29sQixZQUFQLENBQW9CcGdCLEdBQXBCLENBQWpDLEVBQTJEO0FBQ3pEO0FBQ0Q7QUFDRCxNQUFJQSxJQUFJaWYsTUFBUixFQUFnQjtBQUNkLFFBQUltUCxRQUFRcHVCLElBQUlpZixNQUFKLENBQVdHLEdBQVgsQ0FBZXZCLEVBQTNCO0FBQ0EsUUFBSXFRLEtBQUt2UixHQUFMLENBQVN5UixLQUFULENBQUosRUFBcUI7QUFDbkI7QUFDRDtBQUNERixTQUFLdFIsR0FBTCxDQUFTd1IsS0FBVDtBQUNEO0FBQ0QsTUFBSUQsR0FBSixFQUFTO0FBQ1BsMUIsUUFBSStHLElBQUl6SCxNQUFSO0FBQ0EsV0FBT1UsR0FBUCxFQUFZO0FBQUVnMUIsZ0JBQVVqdUIsSUFBSS9HLENBQUosQ0FBVixFQUFrQmkxQixJQUFsQjtBQUEwQjtBQUN6QyxHQUhELE1BR087QUFDTDd0QixXQUFPckYsT0FBT3FGLElBQVAsQ0FBWUwsR0FBWixDQUFQO0FBQ0EvRyxRQUFJb0gsS0FBSzlILE1BQVQ7QUFDQSxXQUFPVSxHQUFQLEVBQVk7QUFBRWcxQixnQkFBVWp1QixJQUFJSyxLQUFLcEgsQ0FBTCxDQUFKLENBQVYsRUFBd0JpMUIsSUFBeEI7QUFBZ0M7QUFDL0M7QUFDRjs7QUFFRDs7QUFFQSxJQUFJRywyQkFBMkI7QUFDN0J0VSxjQUFZLElBRGlCO0FBRTdCRSxnQkFBYyxJQUZlO0FBRzdCemUsT0FBSzNCLElBSHdCO0FBSTdCNmlCLE9BQUs3aUI7QUFKd0IsQ0FBL0I7O0FBT0EsU0FBU3kwQixLQUFULENBQWdCcHNCLE1BQWhCLEVBQXdCcXNCLFNBQXhCLEVBQW1DL3VCLEdBQW5DLEVBQXdDO0FBQ3RDNnVCLDJCQUF5Qjd5QixHQUF6QixHQUErQixTQUFTZ3pCLFdBQVQsR0FBd0I7QUFDckQsV0FBTyxLQUFLRCxTQUFMLEVBQWdCL3VCLEdBQWhCLENBQVA7QUFDRCxHQUZEO0FBR0E2dUIsMkJBQXlCM1IsR0FBekIsR0FBK0IsU0FBUytSLFdBQVQsQ0FBc0J6dUIsR0FBdEIsRUFBMkI7QUFDeEQsU0FBS3V1QixTQUFMLEVBQWdCL3VCLEdBQWhCLElBQXVCUSxHQUF2QjtBQUNELEdBRkQ7QUFHQWhGLFNBQU9DLGNBQVAsQ0FBc0JpSCxNQUF0QixFQUE4QjFDLEdBQTlCLEVBQW1DNnVCLHdCQUFuQztBQUNEOztBQUVELFNBQVNLLFNBQVQsQ0FBb0J0UixFQUFwQixFQUF3QjtBQUN0QkEsS0FBRzJOLFNBQUgsR0FBZSxFQUFmO0FBQ0EsTUFBSTlnQixPQUFPbVQsR0FBR2hZLFFBQWQ7QUFDQSxNQUFJNkUsS0FBSzdOLEtBQVQsRUFBZ0I7QUFBRXV5QixjQUFVdlIsRUFBVixFQUFjblQsS0FBSzdOLEtBQW5CO0FBQTRCO0FBQzlDLE1BQUk2TixLQUFLNlgsT0FBVCxFQUFrQjtBQUFFOE0sZ0JBQVl4UixFQUFaLEVBQWdCblQsS0FBSzZYLE9BQXJCO0FBQWdDO0FBQ3BELE1BQUk3WCxLQUFLck4sSUFBVCxFQUFlO0FBQ2JpeUIsYUFBU3pSLEVBQVQ7QUFDRCxHQUZELE1BRU87QUFDTGhCLFlBQVFnQixHQUFHNE4sS0FBSCxHQUFXLEVBQW5CLEVBQXVCLElBQXZCLENBQTRCLGdCQUE1QjtBQUNEO0FBQ0QsTUFBSS9nQixLQUFLOFgsUUFBVCxFQUFtQjtBQUFFK00saUJBQWExUixFQUFiLEVBQWlCblQsS0FBSzhYLFFBQXRCO0FBQWtDO0FBQ3ZELE1BQUk5WCxLQUFLNFgsS0FBVCxFQUFnQjtBQUFFa04sY0FBVTNSLEVBQVYsRUFBY25ULEtBQUs0WCxLQUFuQjtBQUE0QjtBQUMvQzs7QUFFRCxJQUFJbU4saUJBQWlCLEVBQUV4dkIsS0FBSyxDQUFQLEVBQVUvQyxLQUFLLENBQWYsRUFBa0J5c0IsTUFBTSxDQUF4QixFQUFyQjs7QUFFQSxTQUFTeUYsU0FBVCxDQUFvQnZSLEVBQXBCLEVBQXdCNlIsWUFBeEIsRUFBc0M7QUFDcEMsTUFBSWpPLFlBQVk1RCxHQUFHaFksUUFBSCxDQUFZNGIsU0FBWixJQUF5QixFQUF6QztBQUNBLE1BQUk1a0IsUUFBUWdoQixHQUFHc0csTUFBSCxHQUFZLEVBQXhCO0FBQ0E7QUFDQTtBQUNBLE1BQUlyakIsT0FBTytjLEdBQUdoWSxRQUFILENBQVk0bUIsU0FBWixHQUF3QixFQUFuQztBQUNBLE1BQUlrRCxTQUFTLENBQUM5UixHQUFHL2YsT0FBakI7QUFDQTtBQUNBa2lCLGdCQUFjQyxhQUFkLEdBQThCMFAsTUFBOUI7QUFDQSxNQUFJQyxPQUFPLFVBQVczdkIsR0FBWCxFQUFpQjtBQUMxQmEsU0FBS25ILElBQUwsQ0FBVXNHLEdBQVY7QUFDQSxRQUFJdEUsUUFBUWdvQixhQUFhMWpCLEdBQWIsRUFBa0J5dkIsWUFBbEIsRUFBZ0NqTyxTQUFoQyxFQUEyQzVELEVBQTNDLENBQVo7QUFDQTtBQUNBLFFBQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSXl2QixlQUFleHZCLEdBQWYsQ0FBSixFQUF5QjtBQUN2QnhELGFBQ0csT0FBT3dELEdBQVAsR0FBYSxrRUFEaEIsRUFFRTRkLEVBRkY7QUFJRDtBQUNENEMsd0JBQWtCNWpCLEtBQWxCLEVBQXlCb0QsR0FBekIsRUFBOEJ0RSxLQUE5QixFQUFxQyxZQUFZO0FBQy9DLFlBQUlraUIsR0FBRy9mLE9BQUgsSUFBYyxDQUFDa2lCLGNBQWNFLGNBQWpDLEVBQWlEO0FBQy9DempCLGVBQ0UsNERBQ0Esd0RBREEsR0FFQSwrREFGQSxHQUdBLCtCQUhBLEdBR2tDd0QsR0FIbEMsR0FHd0MsSUFKMUMsRUFLRTRkLEVBTEY7QUFPRDtBQUNGLE9BVkQ7QUFXRCxLQWxCRCxNQWtCTztBQUNMNEMsd0JBQWtCNWpCLEtBQWxCLEVBQXlCb0QsR0FBekIsRUFBOEJ0RSxLQUE5QjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBSSxFQUFFc0UsT0FBTzRkLEVBQVQsQ0FBSixFQUFrQjtBQUNoQmtSLFlBQU1sUixFQUFOLEVBQVUsUUFBVixFQUFvQjVkLEdBQXBCO0FBQ0Q7QUFDRixHQS9CRDs7QUFpQ0EsT0FBSyxJQUFJQSxHQUFULElBQWdCeXZCLFlBQWhCLEVBQThCRSxLQUFNM3ZCLEdBQU47QUFDOUIrZixnQkFBY0MsYUFBZCxHQUE4QixJQUE5QjtBQUNEOztBQUVELFNBQVNxUCxRQUFULENBQW1CelIsRUFBbkIsRUFBdUI7QUFDckIsTUFBSXhnQixPQUFPd2dCLEdBQUdoWSxRQUFILENBQVl4SSxJQUF2QjtBQUNBQSxTQUFPd2dCLEdBQUc0TixLQUFILEdBQVcsT0FBT3B1QixJQUFQLEtBQWdCLFVBQWhCLEdBQ2R3eUIsUUFBUXh5QixJQUFSLEVBQWN3Z0IsRUFBZCxDQURjLEdBRWR4Z0IsUUFBUSxFQUZaO0FBR0EsTUFBSSxDQUFDdWIsY0FBY3ZiLElBQWQsQ0FBTCxFQUEwQjtBQUN4QkEsV0FBTyxFQUFQO0FBQ0ExRixZQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLDhDQUNBLG9FQUZ1QyxFQUd2Q29oQixFQUh1QyxDQUF6QztBQUtEO0FBQ0Q7QUFDQSxNQUFJL2MsT0FBT3JGLE9BQU9xRixJQUFQLENBQVl6RCxJQUFaLENBQVg7QUFDQSxNQUFJUixRQUFRZ2hCLEdBQUdoWSxRQUFILENBQVloSixLQUF4QjtBQUNBLE1BQUluRCxJQUFJb0gsS0FBSzlILE1BQWI7QUFDQSxTQUFPVSxHQUFQLEVBQVk7QUFDVixRQUFJbUQsU0FBUzZhLE9BQU83YSxLQUFQLEVBQWNpRSxLQUFLcEgsQ0FBTCxDQUFkLENBQWIsRUFBcUM7QUFDbkMvQixjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLHlCQUEwQnFFLEtBQUtwSCxDQUFMLENBQTFCLEdBQXFDLG9DQUFyQyxHQUNBLGlDQUZ1QyxFQUd2Q21rQixFQUh1QyxDQUF6QztBQUtELEtBTkQsTUFNTyxJQUFJLENBQUN0RCxXQUFXelosS0FBS3BILENBQUwsQ0FBWCxDQUFMLEVBQTBCO0FBQy9CcTFCLFlBQU1sUixFQUFOLEVBQVUsT0FBVixFQUFtQi9jLEtBQUtwSCxDQUFMLENBQW5CO0FBQ0Q7QUFDRjtBQUNEO0FBQ0FtakIsVUFBUXhmLElBQVIsRUFBYyxJQUFkLENBQW1CLGdCQUFuQjtBQUNEOztBQUVELFNBQVN3eUIsT0FBVCxDQUFrQnh5QixJQUFsQixFQUF3QndnQixFQUF4QixFQUE0QjtBQUMxQixNQUFJO0FBQ0YsV0FBT3hnQixLQUFLN0UsSUFBTCxDQUFVcWxCLEVBQVYsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPemxCLENBQVAsRUFBVTtBQUNWdXNCLGdCQUFZdnNCLENBQVosRUFBZXlsQixFQUFmLEVBQW1CLFFBQW5CO0FBQ0EsV0FBTyxFQUFQO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJaVMseUJBQXlCLEVBQUVsQyxNQUFNLElBQVIsRUFBN0I7O0FBRUEsU0FBUzJCLFlBQVQsQ0FBdUIxUixFQUF2QixFQUEyQjJFLFFBQTNCLEVBQXFDO0FBQ25DLE1BQUl1TixXQUFXbFMsR0FBR21TLGlCQUFILEdBQXVCdjBCLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUF0Qzs7QUFFQSxPQUFLLElBQUl2SCxHQUFULElBQWdCdWlCLFFBQWhCLEVBQTBCO0FBQ3hCLFFBQUl5TixVQUFVek4sU0FBU3ZpQixHQUFULENBQWQ7QUFDQSxRQUFJZ2hCLFNBQVMsT0FBT2dQLE9BQVAsS0FBbUIsVUFBbkIsR0FBZ0NBLE9BQWhDLEdBQTBDQSxRQUFRaDBCLEdBQS9EO0FBQ0E7QUFDQTh6QixhQUFTOXZCLEdBQVQsSUFBZ0IsSUFBSThyQixPQUFKLENBQVlsTyxFQUFaLEVBQWdCb0QsTUFBaEIsRUFBd0IzbUIsSUFBeEIsRUFBOEJ3MUIsc0JBQTlCLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUksRUFBRTd2QixPQUFPNGQsRUFBVCxDQUFKLEVBQWtCO0FBQ2hCcVMscUJBQWVyUyxFQUFmLEVBQW1CNWQsR0FBbkIsRUFBd0Jnd0IsT0FBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0MsY0FBVCxDQUF5QnZ0QixNQUF6QixFQUFpQzFDLEdBQWpDLEVBQXNDZ3dCLE9BQXRDLEVBQStDO0FBQzdDLE1BQUksT0FBT0EsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ25CLDZCQUF5Qjd5QixHQUF6QixHQUErQmswQixxQkFBcUJsd0IsR0FBckIsQ0FBL0I7QUFDQTZ1Qiw2QkFBeUIzUixHQUF6QixHQUErQjdpQixJQUEvQjtBQUNELEdBSEQsTUFHTztBQUNMdzBCLDZCQUF5Qjd5QixHQUF6QixHQUErQmcwQixRQUFRaDBCLEdBQVIsR0FDM0JnMEIsUUFBUXp5QixLQUFSLEtBQWtCLEtBQWxCLEdBQ0UyeUIscUJBQXFCbHdCLEdBQXJCLENBREYsR0FFRWd3QixRQUFRaDBCLEdBSGlCLEdBSTNCM0IsSUFKSjtBQUtBdzBCLDZCQUF5QjNSLEdBQXpCLEdBQStCOFMsUUFBUTlTLEdBQVIsR0FDM0I4UyxRQUFROVMsR0FEbUIsR0FFM0I3aUIsSUFGSjtBQUdEO0FBQ0RtQixTQUFPQyxjQUFQLENBQXNCaUgsTUFBdEIsRUFBOEIxQyxHQUE5QixFQUFtQzZ1Qix3QkFBbkM7QUFDRDs7QUFFRCxTQUFTcUIsb0JBQVQsQ0FBK0Jsd0IsR0FBL0IsRUFBb0M7QUFDbEMsU0FBTyxTQUFTbXdCLGNBQVQsR0FBMkI7QUFDaEMsUUFBSWpELFVBQVUsS0FBSzZDLGlCQUFMLElBQTBCLEtBQUtBLGlCQUFMLENBQXVCL3ZCLEdBQXZCLENBQXhDO0FBQ0EsUUFBSWt0QixPQUFKLEVBQWE7QUFDWCxVQUFJQSxRQUFRWSxLQUFaLEVBQW1CO0FBQ2pCWixnQkFBUXFCLFFBQVI7QUFDRDtBQUNELFVBQUluUSxJQUFJMWIsTUFBUixFQUFnQjtBQUNkd3FCLGdCQUFReE8sTUFBUjtBQUNEO0FBQ0QsYUFBT3dPLFFBQVF4eEIsS0FBZjtBQUNEO0FBQ0YsR0FYRDtBQVlEOztBQUVELFNBQVMwekIsV0FBVCxDQUFzQnhSLEVBQXRCLEVBQTBCMEUsT0FBMUIsRUFBbUM7QUFDakMsTUFBSTFsQixRQUFRZ2hCLEdBQUdoWSxRQUFILENBQVloSixLQUF4QjtBQUNBLE9BQUssSUFBSW9ELEdBQVQsSUFBZ0JzaUIsT0FBaEIsRUFBeUI7QUFDdkIxRSxPQUFHNWQsR0FBSCxJQUFVc2lCLFFBQVF0aUIsR0FBUixLQUFnQixJQUFoQixHQUF1QjNGLElBQXZCLEdBQThCZ1osS0FBS2lQLFFBQVF0aUIsR0FBUixDQUFMLEVBQW1CNGQsRUFBbkIsQ0FBeEM7QUFDQSxRQUFJbG1CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUl1aUIsUUFBUXRpQixHQUFSLEtBQWdCLElBQXBCLEVBQTBCO0FBQ3hCeEQsYUFDRSxjQUFjd0QsR0FBZCxHQUFvQix5REFBcEIsR0FDQSwyQ0FGRixFQUdFNGQsRUFIRjtBQUtEO0FBQ0QsVUFBSWhoQixTQUFTNmEsT0FBTzdhLEtBQVAsRUFBY29ELEdBQWQsQ0FBYixFQUFpQztBQUMvQnhELGFBQ0csY0FBY3dELEdBQWQsR0FBb0Isd0NBRHZCLEVBRUU0ZCxFQUZGO0FBSUQ7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsU0FBUzJSLFNBQVQsQ0FBb0IzUixFQUFwQixFQUF3QnlFLEtBQXhCLEVBQStCO0FBQzdCLE9BQUssSUFBSXJpQixHQUFULElBQWdCcWlCLEtBQWhCLEVBQXVCO0FBQ3JCLFFBQUlwZSxVQUFVb2UsTUFBTXJpQixHQUFOLENBQWQ7QUFDQSxRQUFJekcsTUFBTW1ILE9BQU4sQ0FBY3VELE9BQWQsQ0FBSixFQUE0QjtBQUMxQixXQUFLLElBQUl4SyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3SyxRQUFRbEwsTUFBNUIsRUFBb0NVLEdBQXBDLEVBQXlDO0FBQ3ZDMjJCLHNCQUFjeFMsRUFBZCxFQUFrQjVkLEdBQWxCLEVBQXVCaUUsUUFBUXhLLENBQVIsQ0FBdkI7QUFDRDtBQUNGLEtBSkQsTUFJTztBQUNMMjJCLG9CQUFjeFMsRUFBZCxFQUFrQjVkLEdBQWxCLEVBQXVCaUUsT0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU21zQixhQUFULENBQXdCeFMsRUFBeEIsRUFBNEI1ZCxHQUE1QixFQUFpQ2lFLE9BQWpDLEVBQTBDO0FBQ3hDLE1BQUlILE9BQUo7QUFDQSxNQUFJNlUsY0FBYzFVLE9BQWQsQ0FBSixFQUE0QjtBQUMxQkgsY0FBVUcsT0FBVjtBQUNBQSxjQUFVQSxRQUFRQSxPQUFsQjtBQUNEO0FBQ0QsTUFBSSxPQUFPQSxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CQSxjQUFVMlosR0FBRzNaLE9BQUgsQ0FBVjtBQUNEO0FBQ0QyWixLQUFHeVMsTUFBSCxDQUFVcndCLEdBQVYsRUFBZWlFLE9BQWYsRUFBd0JILE9BQXhCO0FBQ0Q7O0FBRUQsU0FBU3dzQixVQUFULENBQXFCejBCLEdBQXJCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQUkwMEIsVUFBVSxFQUFkO0FBQ0FBLFVBQVF2MEIsR0FBUixHQUFjLFlBQVk7QUFBRSxXQUFPLEtBQUt3dkIsS0FBWjtBQUFtQixHQUEvQztBQUNBLE1BQUlnRixXQUFXLEVBQWY7QUFDQUEsV0FBU3gwQixHQUFULEdBQWUsWUFBWTtBQUFFLFdBQU8sS0FBS2tvQixNQUFaO0FBQW9CLEdBQWpEO0FBQ0EsTUFBSXhzQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3d3QixZQUFRclQsR0FBUixHQUFjLFVBQVV1VCxPQUFWLEVBQW1CO0FBQy9CajBCLFdBQ0UsMENBQ0EscUNBRkYsRUFHRSxJQUhGO0FBS0QsS0FORDtBQU9BZzBCLGFBQVN0VCxHQUFULEdBQWUsWUFBWTtBQUN6QjFnQixXQUFLLHFCQUFMLEVBQTRCLElBQTVCO0FBQ0QsS0FGRDtBQUdEO0FBQ0RoQixTQUFPQyxjQUFQLENBQXNCSSxJQUFJaEMsU0FBMUIsRUFBcUMsT0FBckMsRUFBOEMwMkIsT0FBOUM7QUFDQS8wQixTQUFPQyxjQUFQLENBQXNCSSxJQUFJaEMsU0FBMUIsRUFBcUMsUUFBckMsRUFBK0MyMkIsUUFBL0M7O0FBRUEzMEIsTUFBSWhDLFNBQUosQ0FBYzYyQixJQUFkLEdBQXFCeFQsR0FBckI7QUFDQXJoQixNQUFJaEMsU0FBSixDQUFjODJCLE9BQWQsR0FBd0JwUCxHQUF4Qjs7QUFFQTFsQixNQUFJaEMsU0FBSixDQUFjdzJCLE1BQWQsR0FBdUIsVUFDckI1QyxPQURxQixFQUVyQnhjLEVBRnFCLEVBR3JCbk4sT0FIcUIsRUFJckI7QUFDQSxRQUFJOFosS0FBSyxJQUFUO0FBQ0E5WixjQUFVQSxXQUFXLEVBQXJCO0FBQ0FBLFlBQVFzcEIsSUFBUixHQUFlLElBQWY7QUFDQSxRQUFJRixVQUFVLElBQUlwQixPQUFKLENBQVlsTyxFQUFaLEVBQWdCNlAsT0FBaEIsRUFBeUJ4YyxFQUF6QixFQUE2Qm5OLE9BQTdCLENBQWQ7QUFDQSxRQUFJQSxRQUFROHNCLFNBQVosRUFBdUI7QUFDckIzZixTQUFHMVksSUFBSCxDQUFRcWxCLEVBQVIsRUFBWXNQLFFBQVF4eEIsS0FBcEI7QUFDRDtBQUNELFdBQU8sU0FBU20xQixTQUFULEdBQXNCO0FBQzNCM0QsY0FBUTVCLFFBQVI7QUFDRCxLQUZEO0FBR0QsR0FmRDtBQWdCRDs7QUFFRDs7QUFFQTtBQUNBLElBQUl3RixzQkFBc0I7QUFDeEI1eUIsUUFBTSxTQUFTQSxJQUFULENBQ0pDLEtBREksRUFFSnNzQixTQUZJLEVBR0pzRyxTQUhJLEVBSUpDLE1BSkksRUFLSjtBQUNBLFFBQUksQ0FBQzd5QixNQUFNbW9CLGlCQUFQLElBQTRCbm9CLE1BQU1tb0IsaUJBQU4sQ0FBd0IrRCxZQUF4RCxFQUFzRTtBQUNwRSxVQUFJaHNCLFFBQVFGLE1BQU1tb0IsaUJBQU4sR0FBMEIySyxnQ0FDcEM5eUIsS0FEb0MsRUFFcEMwckIsY0FGb0MsRUFHcENrSCxTQUhvQyxFQUlwQ0MsTUFKb0MsQ0FBdEM7QUFNQTN5QixZQUFNNnlCLE1BQU4sQ0FBYXpHLFlBQVl0c0IsTUFBTThuQixHQUFsQixHQUF3QnhuQixTQUFyQyxFQUFnRGdzQixTQUFoRDtBQUNELEtBUkQsTUFRTyxJQUFJdHNCLE1BQU1mLElBQU4sQ0FBVyt6QixTQUFmLEVBQTBCO0FBQy9CO0FBQ0EsVUFBSUMsY0FBY2p6QixLQUFsQixDQUYrQixDQUVOO0FBQ3pCMnlCLDBCQUFvQnh5QixRQUFwQixDQUE2Qjh5QixXQUE3QixFQUEwQ0EsV0FBMUM7QUFDRDtBQUNGLEdBcEJ1Qjs7QUFzQnhCOXlCLFlBQVUsU0FBU0EsUUFBVCxDQUFtQkMsUUFBbkIsRUFBNkJKLEtBQTdCLEVBQW9DO0FBQzVDLFFBQUkyRixVQUFVM0YsTUFBTWdvQixnQkFBcEI7QUFDQSxRQUFJOW5CLFFBQVFGLE1BQU1tb0IsaUJBQU4sR0FBMEIvbkIsU0FBUytuQixpQkFBL0M7QUFDQXlGLHlCQUNFMXRCLEtBREYsRUFFRXlGLFFBQVEwZCxTQUZWLEVBRXFCO0FBQ25CMWQsWUFBUTRrQixTQUhWLEVBR3FCO0FBQ25CdnFCLFNBSkYsRUFJUztBQUNQMkYsWUFBUTVHLFFBTFYsQ0FLbUI7QUFMbkI7QUFPRCxHQWhDdUI7O0FBa0N4Qm0wQixVQUFRLFNBQVNBLE1BQVQsQ0FBaUJsekIsS0FBakIsRUFBd0I7QUFDOUIsUUFBSSxDQUFDQSxNQUFNbW9CLGlCQUFOLENBQXdCOEQsVUFBN0IsRUFBeUM7QUFDdkNqc0IsWUFBTW1vQixpQkFBTixDQUF3QjhELFVBQXhCLEdBQXFDLElBQXJDO0FBQ0FNLGVBQVN2c0IsTUFBTW1vQixpQkFBZixFQUFrQyxTQUFsQztBQUNEO0FBQ0QsUUFBSW5vQixNQUFNZixJQUFOLENBQVcrekIsU0FBZixFQUEwQjtBQUN4QnpFLDZCQUF1QnZ1QixNQUFNbW9CLGlCQUE3QixFQUFnRCxJQUFoRCxDQUFxRCxZQUFyRDtBQUNEO0FBQ0YsR0ExQ3VCOztBQTRDeEI5bkIsV0FBUyxTQUFTQSxPQUFULENBQWtCTCxLQUFsQixFQUF5QjtBQUNoQyxRQUFJLENBQUNBLE1BQU1tb0IsaUJBQU4sQ0FBd0IrRCxZQUE3QixFQUEyQztBQUN6QyxVQUFJLENBQUNsc0IsTUFBTWYsSUFBTixDQUFXK3pCLFNBQWhCLEVBQTJCO0FBQ3pCaHpCLGNBQU1tb0IsaUJBQU4sQ0FBd0IrRSxRQUF4QjtBQUNELE9BRkQsTUFFTztBQUNMdUIsaUNBQXlCenVCLE1BQU1tb0IsaUJBQS9CLEVBQWtELElBQWxELENBQXVELFlBQXZEO0FBQ0Q7QUFDRjtBQUNGO0FBcER1QixDQUExQjs7QUF1REEsSUFBSWdMLGVBQWU5MUIsT0FBT3FGLElBQVAsQ0FBWWl3QixtQkFBWixDQUFuQjs7QUFFQSxTQUFTUyxlQUFULENBQ0UvVixJQURGLEVBRUVwZSxJQUZGLEVBR0U4b0IsT0FIRixFQUlFaHBCLFFBSkYsRUFLRWdHLEdBTEYsRUFNRTtBQUNBLE1BQUksQ0FBQ3NZLElBQUwsRUFBVztBQUNUO0FBQ0Q7O0FBRUQsTUFBSWdXLFdBQVd0TCxRQUFRdGdCLFFBQVIsQ0FBaUI2ckIsS0FBaEM7QUFDQSxNQUFJOWlCLFNBQVM2TSxJQUFULENBQUosRUFBb0I7QUFDbEJBLFdBQU9nVyxTQUFTL3NCLE1BQVQsQ0FBZ0IrVyxJQUFoQixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPQSxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCLFFBQUk5akIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN2RCxXQUFNLG1DQUFvQ00sT0FBTzBlLElBQVAsQ0FBMUMsRUFBMEQwSyxPQUExRDtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLE1BQUksQ0FBQzFLLEtBQUtrVyxHQUFWLEVBQWU7QUFDYixRQUFJbFcsS0FBSzdFLFFBQVQsRUFBbUI7QUFDakI2RSxhQUFPQSxLQUFLN0UsUUFBWjtBQUNELEtBRkQsTUFFTztBQUNMNkUsYUFBT21XLHNCQUFzQm5XLElBQXRCLEVBQTRCZ1csUUFBNUIsRUFBc0MsWUFBWTtBQUN2RDtBQUNBO0FBQ0F0TCxnQkFBUWtGLFlBQVI7QUFDRCxPQUpNLENBQVA7QUFLQSxVQUFJLENBQUM1UCxJQUFMLEVBQVc7QUFDVDtBQUNBO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBb1csNEJBQTBCcFcsSUFBMUI7O0FBRUFwZSxTQUFPQSxRQUFRLEVBQWY7O0FBRUE7QUFDQSxNQUFJQSxLQUFLeTBCLEtBQVQsRUFBZ0I7QUFDZEMsbUJBQWV0VyxLQUFLMVgsT0FBcEIsRUFBNkIxRyxJQUE3QjtBQUNEOztBQUVEO0FBQ0EsTUFBSW9rQixZQUFZdVEsYUFBYTMwQixJQUFiLEVBQW1Cb2UsSUFBbkIsRUFBeUJ0WSxHQUF6QixDQUFoQjs7QUFFQTtBQUNBLE1BQUlzWSxLQUFLMVgsT0FBTCxDQUFhbkgsVUFBakIsRUFBNkI7QUFDM0IsV0FBT3ExQiwwQkFBMEJ4VyxJQUExQixFQUFnQ2dHLFNBQWhDLEVBQTJDcGtCLElBQTNDLEVBQWlEOG9CLE9BQWpELEVBQTBEaHBCLFFBQTFELENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSXdyQixZQUFZdHJCLEtBQUs5QyxFQUFyQjtBQUNBO0FBQ0E4QyxPQUFLOUMsRUFBTCxHQUFVOEMsS0FBSzYwQixRQUFmOztBQUVBLE1BQUl6VyxLQUFLMVgsT0FBTCxDQUFhaW1CLFFBQWpCLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQTNzQixXQUFPLEVBQVA7QUFDRDs7QUFFRDtBQUNBODBCLGFBQVc5MEIsSUFBWDs7QUFFQTtBQUNBLE1BQUl0QyxPQUFPMGdCLEtBQUsxWCxPQUFMLENBQWFoSixJQUFiLElBQXFCb0ksR0FBaEM7QUFDQSxNQUFJL0UsUUFBUSxJQUFJNG5CLEtBQUosQ0FDVCxtQkFBb0J2SyxLQUFLa1csR0FBekIsSUFBaUM1MkIsT0FBUSxNQUFNQSxJQUFkLEdBQXNCLEVBQXZELENBRFMsRUFFVnNDLElBRlUsRUFFSnFCLFNBRkksRUFFT0EsU0FGUCxFQUVrQkEsU0FGbEIsRUFFNkJ5bkIsT0FGN0IsRUFHVixFQUFFMUssTUFBTUEsSUFBUixFQUFjZ0csV0FBV0EsU0FBekIsRUFBb0NrSCxXQUFXQSxTQUEvQyxFQUEwRHhsQixLQUFLQSxHQUEvRCxFQUFvRWhHLFVBQVVBLFFBQTlFLEVBSFUsQ0FBWjtBQUtBLFNBQU9pQixLQUFQO0FBQ0Q7O0FBRUQsU0FBUzZ6Qix5QkFBVCxDQUNFeFcsSUFERixFQUVFZ0csU0FGRixFQUdFcGtCLElBSEYsRUFJRThvQixPQUpGLEVBS0VocEIsUUFMRixFQU1FO0FBQ0EsTUFBSU4sUUFBUSxFQUFaO0FBQ0EsTUFBSSttQixjQUFjbkksS0FBSzFYLE9BQUwsQ0FBYWxILEtBQS9CO0FBQ0EsTUFBSSttQixXQUFKLEVBQWlCO0FBQ2YsU0FBSyxJQUFJM2pCLEdBQVQsSUFBZ0IyakIsV0FBaEIsRUFBNkI7QUFDM0IvbUIsWUFBTW9ELEdBQU4sSUFBYTBqQixhQUFhMWpCLEdBQWIsRUFBa0IyakIsV0FBbEIsRUFBK0JuQyxTQUEvQixDQUFiO0FBQ0Q7QUFDRjtBQUNEO0FBQ0E7QUFDQSxNQUFJMlEsV0FBVzMyQixPQUFPK0wsTUFBUCxDQUFjMmUsT0FBZCxDQUFmO0FBQ0EsTUFBSWxwQixJQUFJLFVBQVVrRixDQUFWLEVBQWFDLENBQWIsRUFBZ0JuRCxDQUFoQixFQUFtQm96QixDQUFuQixFQUFzQjtBQUFFLFdBQU9DLGNBQWNGLFFBQWQsRUFBd0Jqd0IsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCbkQsQ0FBOUIsRUFBaUNvekIsQ0FBakMsRUFBb0MsSUFBcEMsQ0FBUDtBQUFtRCxHQUFuRjtBQUNBLE1BQUlqMEIsUUFBUXFkLEtBQUsxWCxPQUFMLENBQWEvRyxNQUFiLENBQW9CeEUsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0J5RSxDQUEvQixFQUFrQztBQUM1Q0osV0FBT0EsS0FEcUM7QUFFNUNRLFVBQU1BLElBRnNDO0FBRzVDRCxZQUFRK29CLE9BSG9DO0FBSTVDaHBCLGNBQVVBLFFBSmtDO0FBSzVDc3NCLFdBQU8sWUFBWTtBQUFFLGFBQU9ELGFBQWFyc0IsUUFBYixFQUF1QmdwQixPQUF2QixDQUFQO0FBQXlDO0FBTGxCLEdBQWxDLENBQVo7QUFPQSxNQUFJL25CLGlCQUFpQjRuQixLQUFyQixFQUE0QjtBQUMxQjVuQixVQUFNa29CLGlCQUFOLEdBQTBCSCxPQUExQjtBQUNBLFFBQUk5b0IsS0FBS3NzQixJQUFULEVBQWU7QUFDYixPQUFDdnJCLE1BQU1mLElBQU4sS0FBZWUsTUFBTWYsSUFBTixHQUFhLEVBQTVCLENBQUQsRUFBa0Nzc0IsSUFBbEMsR0FBeUN0c0IsS0FBS3NzQixJQUE5QztBQUNEO0FBQ0Y7QUFDRCxTQUFPdnJCLEtBQVA7QUFDRDs7QUFFRCxTQUFTOHlCLCtCQUFULENBQ0U5eUIsS0FERixFQUNTO0FBQ1BoQixNQUZGLEVBRVU7QUFDUjR6QixTQUhGLEVBSUVDLE1BSkYsRUFLRTtBQUNBLE1BQUlzQix3QkFBd0JuMEIsTUFBTWdvQixnQkFBbEM7QUFDQSxNQUFJcmlCLFVBQVU7QUFDWnl1QixrQkFBYyxJQURGO0FBRVpwMUIsWUFBUUEsTUFGSTtBQUdacWtCLGVBQVc4USxzQkFBc0I5USxTQUhyQjtBQUlaeEQsbUJBQWVzVSxzQkFBc0JwdkIsR0FKekI7QUFLWm9wQixrQkFBY251QixLQUxGO0FBTVp3cUIsc0JBQWtCMkosc0JBQXNCNUosU0FONUI7QUFPWnlELHFCQUFpQm1HLHNCQUFzQnAxQixRQVAzQjtBQVFaK3RCLGdCQUFZOEYsYUFBYSxJQVJiO0FBU1o3RixhQUFTOEYsVUFBVTtBQVRQLEdBQWQ7QUFXQTtBQUNBLE1BQUl3QixpQkFBaUJyMEIsTUFBTWYsSUFBTixDQUFXbzFCLGNBQWhDO0FBQ0EsTUFBSUEsY0FBSixFQUFvQjtBQUNsQjF1QixZQUFRL0csTUFBUixHQUFpQnkxQixlQUFlejFCLE1BQWhDO0FBQ0ErRyxZQUFRMnVCLGVBQVIsR0FBMEJELGVBQWVDLGVBQXpDO0FBQ0Q7QUFDRCxTQUFPLElBQUlILHNCQUFzQjlXLElBQTFCLENBQStCMVgsT0FBL0IsQ0FBUDtBQUNEOztBQUVELFNBQVM2dEIscUJBQVQsQ0FDRXYyQixPQURGLEVBRUVvMkIsUUFGRixFQUdFdmdCLEVBSEYsRUFJRTtBQUNBLE1BQUk3VixRQUFRczNCLFNBQVosRUFBdUI7QUFDckI7QUFDQXQzQixZQUFRdTNCLGdCQUFSLENBQXlCajVCLElBQXpCLENBQThCdVgsRUFBOUI7QUFDRCxHQUhELE1BR087QUFDTDdWLFlBQVFzM0IsU0FBUixHQUFvQixJQUFwQjtBQUNBLFFBQUkxZSxNQUFNNVksUUFBUXUzQixnQkFBUixHQUEyQixDQUFDMWhCLEVBQUQsQ0FBckM7QUFDQSxRQUFJMmMsT0FBTyxJQUFYOztBQUVBLFFBQUlqcUIsVUFBVSxVQUFVMUQsR0FBVixFQUFlO0FBQzNCLFVBQUkwTyxTQUFTMU8sR0FBVCxDQUFKLEVBQW1CO0FBQ2pCQSxjQUFNdXhCLFNBQVMvc0IsTUFBVCxDQUFnQnhFLEdBQWhCLENBQU47QUFDRDtBQUNEO0FBQ0E3RSxjQUFRdWIsUUFBUixHQUFtQjFXLEdBQW5CO0FBQ0E7QUFDQTtBQUNBLFVBQUksQ0FBQzJ0QixJQUFMLEVBQVc7QUFDVCxhQUFLLElBQUluMEIsSUFBSSxDQUFSLEVBQVcyZSxJQUFJcEUsSUFBSWpiLE1BQXhCLEVBQWdDVSxJQUFJMmUsQ0FBcEMsRUFBdUMzZSxHQUF2QyxFQUE0QztBQUMxQ3VhLGNBQUl2YSxDQUFKLEVBQU93RyxHQUFQO0FBQ0Q7QUFDRjtBQUNGLEtBYkQ7O0FBZUEsUUFBSXFVLFNBQVMsVUFBVUMsTUFBVixFQUFrQjtBQUM3QjdjLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsd0NBQXlDTSxPQUFPMUIsT0FBUCxDQUF6QyxJQUNDbVosU0FBVSxlQUFlQSxNQUF6QixHQUFtQyxFQURwQyxDQUR1QyxDQUF6QztBQUlELEtBTEQ7O0FBT0EsUUFBSXRVLE1BQU03RSxRQUFRdUksT0FBUixFQUFpQjJRLE1BQWpCLENBQVY7O0FBRUE7QUFDQSxRQUFJclUsT0FBTyxPQUFPQSxJQUFJdVUsSUFBWCxLQUFvQixVQUEzQixJQUF5QyxDQUFDcFosUUFBUXViLFFBQXRELEVBQWdFO0FBQzlEMVcsVUFBSXVVLElBQUosQ0FBUzdRLE9BQVQsRUFBa0IyUSxNQUFsQjtBQUNEOztBQUVEc1osV0FBTyxLQUFQO0FBQ0E7QUFDQSxXQUFPeHlCLFFBQVF1YixRQUFmO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTb2IsWUFBVCxDQUF1QjMwQixJQUF2QixFQUE2Qm9lLElBQTdCLEVBQW1DdFksR0FBbkMsRUFBd0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBSXlnQixjQUFjbkksS0FBSzFYLE9BQUwsQ0FBYWxILEtBQS9CO0FBQ0EsTUFBSSxDQUFDK21CLFdBQUwsRUFBa0I7QUFDaEI7QUFDRDtBQUNELE1BQUkxakIsTUFBTSxFQUFWO0FBQ0EsTUFBSW9FLFFBQVFqSCxLQUFLaUgsS0FBakI7QUFDQSxNQUFJekgsUUFBUVEsS0FBS1IsS0FBakI7QUFDQSxNQUFJZzJCLFdBQVd4MUIsS0FBS3cxQixRQUFwQjtBQUNBLE1BQUl2dUIsU0FBU3pILEtBQVQsSUFBa0JnMkIsUUFBdEIsRUFBZ0M7QUFDOUIsU0FBSyxJQUFJNXlCLEdBQVQsSUFBZ0IyakIsV0FBaEIsRUFBNkI7QUFDM0IsVUFBSWtQLFNBQVM1YSxVQUFValksR0FBVixDQUFiO0FBQ0EsVUFBSXRJLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFlBQUkreUIsaUJBQWlCOXlCLElBQUlvWCxXQUFKLEVBQXJCO0FBQ0EsWUFDRXBYLFFBQVE4eUIsY0FBUixJQUNBenVCLEtBREEsSUFDU0EsTUFBTThJLGNBQU4sQ0FBcUIybEIsY0FBckIsQ0FGWCxFQUdFO0FBQ0F4VixjQUNFLFlBQVl3VixjQUFaLEdBQTZCLDRCQUE3QixHQUNDdlYsb0JBQW9CcmEsT0FBT3NZLElBQTNCLENBREQsR0FDcUMsZ0NBRHJDLEdBRUEsS0FGQSxHQUVReGIsR0FGUixHQUVjLE1BRmQsR0FHQSxnRUFIQSxHQUlBLG1FQUpBLEdBS0EsdUNBTEEsR0FLMEM2eUIsTUFMMUMsR0FLbUQsa0JBTG5ELEdBS3dFN3lCLEdBTHhFLEdBSzhFLEtBTmhGO0FBUUQ7QUFDRjtBQUNEK3lCLGdCQUFVOXlCLEdBQVYsRUFBZXJELEtBQWYsRUFBc0JvRCxHQUF0QixFQUEyQjZ5QixNQUEzQixFQUFtQyxJQUFuQyxLQUNBRSxVQUFVOXlCLEdBQVYsRUFBZW9FLEtBQWYsRUFBc0JyRSxHQUF0QixFQUEyQjZ5QixNQUEzQixDQURBLElBRUFFLFVBQVU5eUIsR0FBVixFQUFlMnlCLFFBQWYsRUFBeUI1eUIsR0FBekIsRUFBOEI2eUIsTUFBOUIsQ0FGQTtBQUdEO0FBQ0Y7QUFDRCxTQUFPNXlCLEdBQVA7QUFDRDs7QUFFRCxTQUFTOHlCLFNBQVQsQ0FDRTl5QixHQURGLEVBRUV5QixJQUZGLEVBR0UxQixHQUhGLEVBSUU2eUIsTUFKRixFQUtFRyxRQUxGLEVBTUU7QUFDQSxNQUFJdHhCLElBQUosRUFBVTtBQUNSLFFBQUkrVixPQUFPL1YsSUFBUCxFQUFhMUIsR0FBYixDQUFKLEVBQXVCO0FBQ3JCQyxVQUFJRCxHQUFKLElBQVcwQixLQUFLMUIsR0FBTCxDQUFYO0FBQ0EsVUFBSSxDQUFDZ3pCLFFBQUwsRUFBZTtBQUNiLGVBQU90eEIsS0FBSzFCLEdBQUwsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0FORCxNQU1PLElBQUl5WCxPQUFPL1YsSUFBUCxFQUFhbXhCLE1BQWIsQ0FBSixFQUEwQjtBQUMvQjV5QixVQUFJRCxHQUFKLElBQVcwQixLQUFLbXhCLE1BQUwsQ0FBWDtBQUNBLFVBQUksQ0FBQ0csUUFBTCxFQUFlO0FBQ2IsZUFBT3R4QixLQUFLbXhCLE1BQUwsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVNYLFVBQVQsQ0FBcUI5MEIsSUFBckIsRUFBMkI7QUFDekIsTUFBSSxDQUFDQSxLQUFLYSxJQUFWLEVBQWdCO0FBQ2RiLFNBQUthLElBQUwsR0FBWSxFQUFaO0FBQ0Q7QUFDRCxPQUFLLElBQUl4RSxJQUFJLENBQWIsRUFBZ0JBLElBQUk2M0IsYUFBYXY0QixNQUFqQyxFQUF5Q1UsR0FBekMsRUFBOEM7QUFDNUMsUUFBSXVHLE1BQU1zeEIsYUFBYTczQixDQUFiLENBQVY7QUFDQSxRQUFJdzVCLGFBQWE3MUIsS0FBS2EsSUFBTCxDQUFVK0IsR0FBVixDQUFqQjtBQUNBLFFBQUlrekIsT0FBT3BDLG9CQUFvQjl3QixHQUFwQixDQUFYO0FBQ0E1QyxTQUFLYSxJQUFMLENBQVUrQixHQUFWLElBQWlCaXpCLGFBQWFFLFlBQVlELElBQVosRUFBa0JELFVBQWxCLENBQWIsR0FBNkNDLElBQTlEO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxXQUFULENBQXNCQyxHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7QUFDOUIsU0FBTyxVQUFVbnhCLENBQVYsRUFBYUMsQ0FBYixFQUFnQm5ELENBQWhCLEVBQW1Cb3pCLENBQW5CLEVBQXNCO0FBQzNCZ0IsUUFBSWx4QixDQUFKLEVBQU9DLENBQVAsRUFBVW5ELENBQVYsRUFBYW96QixDQUFiO0FBQ0FpQixRQUFJbnhCLENBQUosRUFBT0MsQ0FBUCxFQUFVbkQsQ0FBVixFQUFhb3pCLENBQWI7QUFDRCxHQUhEO0FBSUQ7O0FBRUQ7QUFDQTtBQUNBLFNBQVNOLGNBQVQsQ0FBeUJodUIsT0FBekIsRUFBa0MxRyxJQUFsQyxFQUF3QztBQUN0QyxNQUFJd21CLE9BQVE5ZixRQUFRK3RCLEtBQVIsSUFBaUIvdEIsUUFBUSt0QixLQUFSLENBQWNqTyxJQUFoQyxJQUF5QyxPQUFwRDtBQUNBLE1BQUlyZ0IsUUFBU08sUUFBUSt0QixLQUFSLElBQWlCL3RCLFFBQVErdEIsS0FBUixDQUFjdHVCLEtBQWhDLElBQTBDLE9BQXRELENBQThELENBQUNuRyxLQUFLUixLQUFMLEtBQWVRLEtBQUtSLEtBQUwsR0FBYSxFQUE1QixDQUFELEVBQWtDZ25CLElBQWxDLElBQTBDeG1CLEtBQUt5MEIsS0FBTCxDQUFXbjJCLEtBQXJEO0FBQzlELE1BQUlwQixLQUFLOEMsS0FBSzlDLEVBQUwsS0FBWThDLEtBQUs5QyxFQUFMLEdBQVUsRUFBdEIsQ0FBVDtBQUNBLE1BQUlBLEdBQUdpSixLQUFILENBQUosRUFBZTtBQUNiakosT0FBR2lKLEtBQUgsSUFBWSxDQUFDbkcsS0FBS3kwQixLQUFMLENBQVd5QixRQUFaLEVBQXNCdDZCLE1BQXRCLENBQTZCc0IsR0FBR2lKLEtBQUgsQ0FBN0IsQ0FBWjtBQUNELEdBRkQsTUFFTztBQUNMakosT0FBR2lKLEtBQUgsSUFBWW5HLEtBQUt5MEIsS0FBTCxDQUFXeUIsUUFBdkI7QUFDRDtBQUNGOztBQUVEOztBQUVBLElBQUlDLG1CQUFtQixDQUF2QjtBQUNBLElBQUlDLG1CQUFtQixDQUF2Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBU25CLGFBQVQsQ0FDRW5NLE9BREYsRUFFRWhqQixHQUZGLEVBR0U5RixJQUhGLEVBSUVGLFFBSkYsRUFLRXUyQixpQkFMRixFQU1FQyxlQU5GLEVBT0U7QUFDQSxNQUFJbjZCLE1BQU1tSCxPQUFOLENBQWN0RCxJQUFkLEtBQXVCc2EsWUFBWXRhLElBQVosQ0FBM0IsRUFBOEM7QUFDNUNxMkIsd0JBQW9CdjJCLFFBQXBCO0FBQ0FBLGVBQVdFLElBQVg7QUFDQUEsV0FBT3FCLFNBQVA7QUFDRDtBQUNELE1BQUlpMUIsZUFBSixFQUFxQjtBQUFFRCx3QkFBb0JELGdCQUFwQjtBQUF1QztBQUM5RCxTQUFPRyxlQUFlek4sT0FBZixFQUF3QmhqQixHQUF4QixFQUE2QjlGLElBQTdCLEVBQW1DRixRQUFuQyxFQUE2Q3UyQixpQkFBN0MsQ0FBUDtBQUNEOztBQUVELFNBQVNFLGNBQVQsQ0FDRXpOLE9BREYsRUFFRWhqQixHQUZGLEVBR0U5RixJQUhGLEVBSUVGLFFBSkYsRUFLRXUyQixpQkFMRixFQU1FO0FBQ0EsTUFBSXIyQixRQUFRQSxLQUFLcWlCLE1BQWpCLEVBQXlCO0FBQ3ZCL25CLFlBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMscURBQXNEcU8sS0FBS0MsU0FBTCxDQUFlMU4sSUFBZixDQUF0RCxHQUE4RSxJQUE5RSxHQUNBLHdEQUZ1QyxFQUd2QzhvQixPQUh1QyxDQUF6QztBQUtBLFdBQU9TLGtCQUFQO0FBQ0Q7QUFDRCxNQUFJLENBQUN6akIsR0FBTCxFQUFVO0FBQ1I7QUFDQSxXQUFPeWpCLGtCQUFQO0FBQ0Q7QUFDRDtBQUNBLE1BQUlwdEIsTUFBTW1ILE9BQU4sQ0FBY3hELFFBQWQsS0FDQSxPQUFPQSxTQUFTLENBQVQsQ0FBUCxLQUF1QixVQUQzQixFQUN1QztBQUNyQ0UsV0FBT0EsUUFBUSxFQUFmO0FBQ0FBLFNBQUtndkIsV0FBTCxHQUFtQixFQUFFendCLFNBQVN1QixTQUFTLENBQVQsQ0FBWCxFQUFuQjtBQUNBQSxhQUFTbkUsTUFBVCxHQUFrQixDQUFsQjtBQUNEO0FBQ0QsTUFBSTA2QixzQkFBc0JELGdCQUExQixFQUE0QztBQUMxQ3QyQixlQUFXZ3JCLGtCQUFrQmhyQixRQUFsQixDQUFYO0FBQ0QsR0FGRCxNQUVPLElBQUl1MkIsc0JBQXNCRixnQkFBMUIsRUFBNEM7QUFDakRyMkIsZUFBVytxQix3QkFBd0IvcUIsUUFBeEIsQ0FBWDtBQUNEO0FBQ0QsTUFBSWlCLEtBQUosRUFBV2lvQixFQUFYO0FBQ0EsTUFBSSxPQUFPbGpCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJc1ksSUFBSjtBQUNBNEssU0FBS3puQixPQUFPb2IsZUFBUCxDQUF1QjdXLEdBQXZCLENBQUw7QUFDQSxRQUFJdkUsT0FBT2tiLGFBQVAsQ0FBcUIzVyxHQUFyQixDQUFKLEVBQStCO0FBQzdCO0FBQ0EvRSxjQUFRLElBQUk0bkIsS0FBSixDQUNOcG5CLE9BQU9xYixvQkFBUCxDQUE0QjlXLEdBQTVCLENBRE0sRUFDNEI5RixJQUQ1QixFQUNrQ0YsUUFEbEMsRUFFTnVCLFNBRk0sRUFFS0EsU0FGTCxFQUVnQnluQixPQUZoQixDQUFSO0FBSUQsS0FORCxNQU1PLElBQUsxSyxPQUFPNkgsYUFBYTZDLFFBQVF0Z0IsUUFBckIsRUFBK0IsWUFBL0IsRUFBNkMxQyxHQUE3QyxDQUFaLEVBQWdFO0FBQ3JFO0FBQ0EvRSxjQUFRb3pCLGdCQUFnQi9WLElBQWhCLEVBQXNCcGUsSUFBdEIsRUFBNEI4b0IsT0FBNUIsRUFBcUNocEIsUUFBckMsRUFBK0NnRyxHQUEvQyxDQUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0w7QUFDQTtBQUNBO0FBQ0EvRSxjQUFRLElBQUk0bkIsS0FBSixDQUNON2lCLEdBRE0sRUFDRDlGLElBREMsRUFDS0YsUUFETCxFQUVOdUIsU0FGTSxFQUVLQSxTQUZMLEVBRWdCeW5CLE9BRmhCLENBQVI7QUFJRDtBQUNGLEdBckJELE1BcUJPO0FBQ0w7QUFDQS9uQixZQUFRb3pCLGdCQUFnQnJ1QixHQUFoQixFQUFxQjlGLElBQXJCLEVBQTJCOG9CLE9BQTNCLEVBQW9DaHBCLFFBQXBDLENBQVI7QUFDRDtBQUNELE1BQUlpQixLQUFKLEVBQVc7QUFDVCxRQUFJaW9CLEVBQUosRUFBUTtBQUFFd04sY0FBUXoxQixLQUFSLEVBQWVpb0IsRUFBZjtBQUFxQjtBQUMvQixXQUFPam9CLEtBQVA7QUFDRCxHQUhELE1BR087QUFDTCxXQUFPd29CLGtCQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTaU4sT0FBVCxDQUFrQnoxQixLQUFsQixFQUF5QmlvQixFQUF6QixFQUE2QjtBQUMzQmpvQixRQUFNaW9CLEVBQU4sR0FBV0EsRUFBWDtBQUNBLE1BQUlqb0IsTUFBTStFLEdBQU4sS0FBYyxlQUFsQixFQUFtQztBQUNqQztBQUNBO0FBQ0Q7QUFDRCxNQUFJL0UsTUFBTWpCLFFBQVYsRUFBb0I7QUFDbEIsU0FBSyxJQUFJekQsSUFBSSxDQUFSLEVBQVcyZSxJQUFJamEsTUFBTWpCLFFBQU4sQ0FBZW5FLE1BQW5DLEVBQTJDVSxJQUFJMmUsQ0FBL0MsRUFBa0QzZSxHQUFsRCxFQUF1RDtBQUNyRCxVQUFJNEUsUUFBUUYsTUFBTWpCLFFBQU4sQ0FBZXpELENBQWYsQ0FBWjtBQUNBLFVBQUk0RSxNQUFNNkUsR0FBTixJQUFhLENBQUM3RSxNQUFNK25CLEVBQXhCLEVBQTRCO0FBQzFCd04sZ0JBQVF2MUIsS0FBUixFQUFlK25CLEVBQWY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBU3lOLFVBQVQsQ0FDRXJ6QixHQURGLEVBRUV6RCxNQUZGLEVBR0U7QUFDQSxNQUFJeWIsR0FBSixFQUFTL2UsQ0FBVCxFQUFZMmUsQ0FBWixFQUFldlgsSUFBZixFQUFxQmIsR0FBckI7QUFDQSxNQUFJekcsTUFBTW1ILE9BQU4sQ0FBY0YsR0FBZCxLQUFzQixPQUFPQSxHQUFQLEtBQWUsUUFBekMsRUFBbUQ7QUFDakRnWSxVQUFNLElBQUlqZixLQUFKLENBQVVpSCxJQUFJekgsTUFBZCxDQUFOO0FBQ0EsU0FBS1UsSUFBSSxDQUFKLEVBQU8yZSxJQUFJNVgsSUFBSXpILE1BQXBCLEVBQTRCVSxJQUFJMmUsQ0FBaEMsRUFBbUMzZSxHQUFuQyxFQUF3QztBQUN0QytlLFVBQUkvZSxDQUFKLElBQVNzRCxPQUFPeUQsSUFBSS9HLENBQUosQ0FBUCxFQUFlQSxDQUFmLENBQVQ7QUFDRDtBQUNGLEdBTEQsTUFLTyxJQUFJLE9BQU8rRyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENnWSxVQUFNLElBQUlqZixLQUFKLENBQVVpSCxHQUFWLENBQU47QUFDQSxTQUFLL0csSUFBSSxDQUFULEVBQVlBLElBQUkrRyxHQUFoQixFQUFxQi9HLEdBQXJCLEVBQTBCO0FBQ3hCK2UsVUFBSS9lLENBQUosSUFBU3NELE9BQU90RCxJQUFJLENBQVgsRUFBY0EsQ0FBZCxDQUFUO0FBQ0Q7QUFDRixHQUxNLE1BS0EsSUFBSWtWLFNBQVNuTyxHQUFULENBQUosRUFBbUI7QUFDeEJLLFdBQU9yRixPQUFPcUYsSUFBUCxDQUFZTCxHQUFaLENBQVA7QUFDQWdZLFVBQU0sSUFBSWpmLEtBQUosQ0FBVXNILEtBQUs5SCxNQUFmLENBQU47QUFDQSxTQUFLVSxJQUFJLENBQUosRUFBTzJlLElBQUl2WCxLQUFLOUgsTUFBckIsRUFBNkJVLElBQUkyZSxDQUFqQyxFQUFvQzNlLEdBQXBDLEVBQXlDO0FBQ3ZDdUcsWUFBTWEsS0FBS3BILENBQUwsQ0FBTjtBQUNBK2UsVUFBSS9lLENBQUosSUFBU3NELE9BQU95RCxJQUFJUixHQUFKLENBQVAsRUFBaUJBLEdBQWpCLEVBQXNCdkcsQ0FBdEIsQ0FBVDtBQUNEO0FBQ0Y7QUFDRCxTQUFPK2UsR0FBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTc2IsVUFBVCxDQUNFaDVCLElBREYsRUFFRXVhLFFBRkYsRUFHRXpZLEtBSEYsRUFJRW0zQixVQUpGLEVBS0U7QUFDQSxNQUFJQyxlQUFlLEtBQUszSCxZQUFMLENBQWtCdnhCLElBQWxCLENBQW5CO0FBQ0EsTUFBSWs1QixZQUFKLEVBQWtCO0FBQUU7QUFDbEJwM0IsWUFBUUEsU0FBUyxFQUFqQjtBQUNBLFFBQUltM0IsVUFBSixFQUFnQjtBQUNkdHZCLGFBQU83SCxLQUFQLEVBQWNtM0IsVUFBZDtBQUNEO0FBQ0QsV0FBT0MsYUFBYXAzQixLQUFiLEtBQXVCeVksUUFBOUI7QUFDRCxHQU5ELE1BTU87QUFDTCxRQUFJNGUsWUFBWSxLQUFLMXZCLE1BQUwsQ0FBWXpKLElBQVosQ0FBaEI7QUFDQTtBQUNBLFFBQUltNUIsYUFBYXY4QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUExQyxFQUF3RDtBQUN0RGswQixnQkFBVUMsU0FBVixJQUF1QjEzQixLQUNyQixrQ0FBa0MxQixJQUFsQyxHQUF5QyxtQ0FBekMsR0FDQSx5Q0FGcUIsRUFHckIsSUFIcUIsQ0FBdkI7QUFLQW01QixnQkFBVUMsU0FBVixHQUFzQixJQUF0QjtBQUNEO0FBQ0QsV0FBT0QsYUFBYTVlLFFBQXBCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBUzhlLGFBQVQsQ0FBd0I5VixFQUF4QixFQUE0QjtBQUMxQixTQUFPZ0YsYUFBYSxLQUFLemQsUUFBbEIsRUFBNEIsU0FBNUIsRUFBdUN5WSxFQUF2QyxFQUEyQyxJQUEzQyxLQUFvRHZGLFFBQTNEO0FBQ0Q7O0FBRUQ7O0FBRUE7OztBQUdBLFNBQVNzYixhQUFULENBQ0VDLFlBREYsRUFFRXIwQixHQUZGLEVBR0VzMEIsWUFIRixFQUlFO0FBQ0EsTUFBSTFhLFdBQVdqYixPQUFPaWIsUUFBUCxDQUFnQjVaLEdBQWhCLEtBQXdCczBCLFlBQXZDO0FBQ0EsTUFBSS82QixNQUFNbUgsT0FBTixDQUFja1osUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFdBQU9BLFNBQVNqWCxPQUFULENBQWlCMHhCLFlBQWpCLE1BQW1DLENBQUMsQ0FBM0M7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPemEsYUFBYXlhLFlBQXBCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBU0UsZUFBVCxDQUNFbjNCLElBREYsRUFFRThGLEdBRkYsRUFHRXhILEtBSEYsRUFJRTg0QixNQUpGLEVBS0U7QUFDQSxNQUFJOTRCLEtBQUosRUFBVztBQUNULFFBQUksQ0FBQ2lULFNBQVNqVCxLQUFULENBQUwsRUFBc0I7QUFDcEJoRSxjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLDBEQUR1QyxFQUV2QyxJQUZ1QyxDQUF6QztBQUlELEtBTEQsTUFLTztBQUNMLFVBQUlqRCxNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCQSxnQkFBUWtkLFNBQVNsZCxLQUFULENBQVI7QUFDRDtBQUNELFVBQUlnRyxJQUFKO0FBQ0EsV0FBSyxJQUFJMUIsR0FBVCxJQUFnQnRFLEtBQWhCLEVBQXVCO0FBQ3JCLFlBQUlzRSxRQUFRLE9BQVIsSUFBbUJBLFFBQVEsT0FBL0IsRUFBd0M7QUFDdEMwQixpQkFBT3RFLElBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFJUCxPQUFPTyxLQUFLaUgsS0FBTCxJQUFjakgsS0FBS2lILEtBQUwsQ0FBV3hILElBQXBDO0FBQ0E2RSxpQkFBTzh5QixVQUFVNzFCLE9BQU9zYixXQUFQLENBQW1CL1csR0FBbkIsRUFBd0JyRyxJQUF4QixFQUE4Qm1ELEdBQTlCLENBQVYsR0FDSDVDLEtBQUt3MUIsUUFBTCxLQUFrQngxQixLQUFLdzFCLFFBQUwsR0FBZ0IsRUFBbEMsQ0FERyxHQUVIeDFCLEtBQUtpSCxLQUFMLEtBQWVqSCxLQUFLaUgsS0FBTCxHQUFhLEVBQTVCLENBRko7QUFHRDtBQUNELFlBQUksRUFBRXJFLE9BQU8wQixJQUFULENBQUosRUFBb0I7QUFDbEJBLGVBQUsxQixHQUFMLElBQVl0RSxNQUFNc0UsR0FBTixDQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxTQUFPNUMsSUFBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTcTNCLFlBQVQsQ0FDRWw1QixLQURGLEVBRUVtNUIsT0FGRixFQUdFO0FBQ0EsTUFBSUMsT0FBTyxLQUFLQyxZQUFMLENBQWtCcjVCLEtBQWxCLENBQVg7QUFDQTtBQUNBO0FBQ0EsTUFBSW81QixRQUFRLENBQUNELE9BQWIsRUFBc0I7QUFDcEIsV0FBT243QixNQUFNbUgsT0FBTixDQUFjaTBCLElBQWQsSUFDSDNOLFlBQVkyTixJQUFaLENBREcsR0FFSDdOLFdBQVc2TixJQUFYLENBRko7QUFHRDtBQUNEO0FBQ0FBLFNBQU8sS0FBS0MsWUFBTCxDQUFrQnI1QixLQUFsQixJQUNMLEtBQUtxSyxRQUFMLENBQWM2c0IsZUFBZCxDQUE4QmwzQixLQUE5QixFQUFxQ2hELElBQXJDLENBQTBDLEtBQUtndEIsWUFBL0MsQ0FERjtBQUVBc1AsYUFBV0YsSUFBWCxFQUFrQixlQUFlcDVCLEtBQWpDLEVBQXlDLEtBQXpDO0FBQ0EsU0FBT281QixJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxTQUFTRyxRQUFULENBQ0VILElBREYsRUFFRXA1QixLQUZGLEVBR0V5RSxHQUhGLEVBSUU7QUFDQTYwQixhQUFXRixJQUFYLEVBQWtCLGFBQWFwNUIsS0FBYixJQUFzQnlFLE1BQU8sTUFBTUEsR0FBYixHQUFvQixFQUExQyxDQUFsQixFQUFrRSxJQUFsRTtBQUNBLFNBQU8yMEIsSUFBUDtBQUNEOztBQUVELFNBQVNFLFVBQVQsQ0FDRUYsSUFERixFQUVFMzBCLEdBRkYsRUFHRTBtQixNQUhGLEVBSUU7QUFDQSxNQUFJbnRCLE1BQU1tSCxPQUFOLENBQWNpMEIsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFNBQUssSUFBSWw3QixJQUFJLENBQWIsRUFBZ0JBLElBQUlrN0IsS0FBSzU3QixNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcEMsVUFBSWs3QixLQUFLbDdCLENBQUwsS0FBVyxPQUFPazdCLEtBQUtsN0IsQ0FBTCxDQUFQLEtBQW1CLFFBQWxDLEVBQTRDO0FBQzFDczdCLHVCQUFlSixLQUFLbDdCLENBQUwsQ0FBZixFQUF5QnVHLE1BQU0sR0FBTixHQUFZdkcsQ0FBckMsRUFBeUNpdEIsTUFBekM7QUFDRDtBQUNGO0FBQ0YsR0FORCxNQU1PO0FBQ0xxTyxtQkFBZUosSUFBZixFQUFxQjMwQixHQUFyQixFQUEwQjBtQixNQUExQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3FPLGNBQVQsQ0FBeUJuTyxJQUF6QixFQUErQjVtQixHQUEvQixFQUFvQzBtQixNQUFwQyxFQUE0QztBQUMxQ0UsT0FBS3BpQixRQUFMLEdBQWdCLElBQWhCO0FBQ0FvaUIsT0FBSzVtQixHQUFMLEdBQVdBLEdBQVg7QUFDQTRtQixPQUFLRixNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRDs7QUFFQSxTQUFTc08sVUFBVCxDQUFxQnBYLEVBQXJCLEVBQXlCO0FBQ3ZCQSxLQUFHamdCLE1BQUgsR0FBWSxJQUFaLENBRHVCLENBQ0w7QUFDbEJpZ0IsS0FBR2tOLE1BQUgsR0FBWSxJQUFaLENBRnVCLENBRUw7QUFDbEJsTixLQUFHZ1gsWUFBSCxHQUFrQixJQUFsQjtBQUNBLE1BQUk1SSxjQUFjcE8sR0FBR2hZLFFBQUgsQ0FBWTBtQixZQUE5QjtBQUNBLE1BQUkySSxnQkFBZ0JqSixlQUFlQSxZQUFZOUYsT0FBL0M7QUFDQXRJLEtBQUdyWixNQUFILEdBQVlnbEIsYUFBYTNMLEdBQUdoWSxRQUFILENBQVl1bUIsZUFBekIsRUFBMEM4SSxhQUExQyxDQUFaO0FBQ0FyWCxLQUFHeU8sWUFBSCxHQUFrQmhTLFdBQWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXVELEtBQUdzWCxFQUFILEdBQVEsVUFBVWh6QixDQUFWLEVBQWFDLENBQWIsRUFBZ0JuRCxDQUFoQixFQUFtQm96QixDQUFuQixFQUFzQjtBQUFFLFdBQU9DLGNBQWN6VSxFQUFkLEVBQWtCMWIsQ0FBbEIsRUFBcUJDLENBQXJCLEVBQXdCbkQsQ0FBeEIsRUFBMkJvekIsQ0FBM0IsRUFBOEIsS0FBOUIsQ0FBUDtBQUE4QyxHQUE5RTtBQUNBO0FBQ0E7QUFDQXhVLEtBQUd1WCxjQUFILEdBQW9CLFVBQVVqekIsQ0FBVixFQUFhQyxDQUFiLEVBQWdCbkQsQ0FBaEIsRUFBbUJvekIsQ0FBbkIsRUFBc0I7QUFBRSxXQUFPQyxjQUFjelUsRUFBZCxFQUFrQjFiLENBQWxCLEVBQXFCQyxDQUFyQixFQUF3Qm5ELENBQXhCLEVBQTJCb3pCLENBQTNCLEVBQThCLElBQTlCLENBQVA7QUFBNkMsR0FBekY7QUFDRDs7QUFFRCxTQUFTZ0QsV0FBVCxDQUFzQnY1QixHQUF0QixFQUEyQjtBQUN6QkEsTUFBSWhDLFNBQUosQ0FBYzBVLFNBQWQsR0FBMEIsVUFBVXlDLEVBQVYsRUFBYztBQUN0QyxXQUFPM1gsU0FBUzJYLEVBQVQsRUFBYSxJQUFiLENBQVA7QUFDRCxHQUZEOztBQUlBblYsTUFBSWhDLFNBQUosQ0FBY2d5QixPQUFkLEdBQXdCLFlBQVk7QUFDbEMsUUFBSWpPLEtBQUssSUFBVDtBQUNBLFFBQUkzZ0IsTUFBTTJnQixHQUFHaFksUUFBYjtBQUNBLFFBQUk3SSxTQUFTRSxJQUFJRixNQUFqQjtBQUNBLFFBQUkwMUIsa0JBQWtCeDFCLElBQUl3MUIsZUFBMUI7QUFDQSxRQUFJbkcsZUFBZXJ2QixJQUFJcXZCLFlBQXZCOztBQUVBLFFBQUkxTyxHQUFHd00sVUFBUCxFQUFtQjtBQUNqQjtBQUNBLFdBQUssSUFBSXBxQixHQUFULElBQWdCNGQsR0FBR3JaLE1BQW5CLEVBQTJCO0FBQ3pCcVosV0FBR3JaLE1BQUgsQ0FBVXZFLEdBQVYsSUFBaUJnbkIsWUFBWXBKLEdBQUdyWixNQUFILENBQVV2RSxHQUFWLENBQVosQ0FBakI7QUFDRDtBQUNGOztBQUVENGQsT0FBR3lPLFlBQUgsR0FBbUJDLGdCQUFnQkEsYUFBYWx2QixJQUFiLENBQWtCZ3ZCLFdBQW5DLElBQW1EL1IsV0FBckU7O0FBRUEsUUFBSW9ZLG1CQUFtQixDQUFDN1UsR0FBR2dYLFlBQTNCLEVBQXlDO0FBQ3ZDaFgsU0FBR2dYLFlBQUgsR0FBa0IsRUFBbEI7QUFDRDtBQUNEO0FBQ0E7QUFDQWhYLE9BQUdqZ0IsTUFBSCxHQUFZMnVCLFlBQVo7QUFDQTtBQUNBLFFBQUludUIsS0FBSjtBQUNBLFFBQUk7QUFDRkEsY0FBUXBCLE9BQU94RSxJQUFQLENBQVlxbEIsR0FBRzJILFlBQWYsRUFBNkIzSCxHQUFHdVgsY0FBaEMsQ0FBUjtBQUNELEtBRkQsQ0FFRSxPQUFPaDlCLENBQVAsRUFBVTtBQUNWdXNCLGtCQUFZdnNCLENBQVosRUFBZXlsQixFQUFmLEVBQW1CLGlCQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM1QixnQkFBUXlmLEdBQUdoWSxRQUFILENBQVl5dkIsV0FBWixHQUNKelgsR0FBR2hZLFFBQUgsQ0FBWXl2QixXQUFaLENBQXdCOThCLElBQXhCLENBQTZCcWxCLEdBQUcySCxZQUFoQyxFQUE4QzNILEdBQUd1WCxjQUFqRCxFQUFpRWg5QixDQUFqRSxDQURJLEdBRUp5bEIsR0FBR2tOLE1BRlA7QUFHRCxPQUpELE1BSU87QUFDTDNzQixnQkFBUXlmLEdBQUdrTixNQUFYO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsUUFBSSxFQUFFM3NCLGlCQUFpQjRuQixLQUFuQixDQUFKLEVBQStCO0FBQzdCLFVBQUlydUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN4RyxNQUFNbUgsT0FBTixDQUFjdkMsS0FBZCxDQUE3QyxFQUFtRTtBQUNqRTNCLGFBQ0Usd0VBQ0EsbUNBRkYsRUFHRW9oQixFQUhGO0FBS0Q7QUFDRHpmLGNBQVF3b0Isa0JBQVI7QUFDRDtBQUNEO0FBQ0F4b0IsVUFBTWhCLE1BQU4sR0FBZW12QixZQUFmO0FBQ0EsV0FBT251QixLQUFQO0FBQ0QsR0FyREQ7O0FBdURBO0FBQ0E7QUFDQTtBQUNBdEMsTUFBSWhDLFNBQUosQ0FBY3k3QixFQUFkLEdBQW1CUixRQUFuQjtBQUNBajVCLE1BQUloQyxTQUFKLENBQWMwN0IsRUFBZCxHQUFtQnplLFFBQW5CO0FBQ0FqYixNQUFJaEMsU0FBSixDQUFjMjdCLEVBQWQsR0FBbUIzZSxTQUFuQjtBQUNBaGIsTUFBSWhDLFNBQUosQ0FBYzQ3QixFQUFkLEdBQW1CNUIsVUFBbkI7QUFDQWg0QixNQUFJaEMsU0FBSixDQUFjNjdCLEVBQWQsR0FBbUI1QixVQUFuQjtBQUNBajRCLE1BQUloQyxTQUFKLENBQWM4N0IsRUFBZCxHQUFtQnhjLFVBQW5CO0FBQ0F0ZCxNQUFJaEMsU0FBSixDQUFjKzdCLEVBQWQsR0FBbUJ0YyxZQUFuQjtBQUNBemQsTUFBSWhDLFNBQUosQ0FBY2c4QixFQUFkLEdBQW1CcEIsWUFBbkI7QUFDQTU0QixNQUFJaEMsU0FBSixDQUFjaThCLEVBQWQsR0FBbUIzQixhQUFuQjtBQUNBdDRCLE1BQUloQyxTQUFKLENBQWNrOEIsRUFBZCxHQUFtQjNCLGFBQW5CO0FBQ0F2NEIsTUFBSWhDLFNBQUosQ0FBY204QixFQUFkLEdBQW1CekIsZUFBbkI7QUFDQTE0QixNQUFJaEMsU0FBSixDQUFjbzhCLEVBQWQsR0FBbUJwUCxlQUFuQjtBQUNBaHJCLE1BQUloQyxTQUFKLENBQWNxOEIsRUFBZCxHQUFtQnZQLGdCQUFuQjtBQUNBOXFCLE1BQUloQyxTQUFKLENBQWNzOEIsRUFBZCxHQUFtQnZNLGtCQUFuQjtBQUNEOztBQUVEOztBQUVBLFNBQVN3TSxXQUFULENBQXNCeFksRUFBdEIsRUFBMEI7QUFDeEIsTUFBSXlZLFVBQVV6WSxHQUFHaFksUUFBSCxDQUFZeXdCLE9BQTFCO0FBQ0EsTUFBSUEsT0FBSixFQUFhO0FBQ1h6WSxPQUFHMFksU0FBSCxHQUFlLE9BQU9ELE9BQVAsS0FBbUIsVUFBbkIsR0FDWEEsUUFBUTk5QixJQUFSLENBQWFxbEIsRUFBYixDQURXLEdBRVh5WSxPQUZKO0FBR0Q7QUFDRjs7QUFFRCxTQUFTRSxjQUFULENBQXlCM1ksRUFBekIsRUFBNkI7QUFDM0IsTUFBSTRZLFNBQVM1WSxHQUFHaFksUUFBSCxDQUFZNHdCLE1BQXpCO0FBQ0EsTUFBSUEsTUFBSixFQUFZO0FBQ1Y7QUFDQTtBQUNBLFFBQUk5MUIsVUFBVW5ILE1BQU1tSCxPQUFOLENBQWM4MUIsTUFBZCxDQUFkO0FBQ0EsUUFBSTMxQixPQUFPSCxVQUNQODFCLE1BRE8sR0FFUC9hLFlBQ0VFLFFBQVFDLE9BQVIsQ0FBZ0I0YSxNQUFoQixDQURGLEdBRUVoN0IsT0FBT3FGLElBQVAsQ0FBWTIxQixNQUFaLENBSk47O0FBTUEsUUFBSTdHLE9BQU8sVUFBV2wyQixDQUFYLEVBQWU7QUFDeEIsVUFBSXVHLE1BQU1hLEtBQUtwSCxDQUFMLENBQVY7QUFDQSxVQUFJZzlCLGFBQWEvMUIsVUFBVVYsR0FBVixHQUFnQncyQixPQUFPeDJCLEdBQVAsQ0FBakM7QUFDQSxVQUFJc0wsU0FBU3NTLEVBQWI7QUFDQSxhQUFPdFMsTUFBUCxFQUFlO0FBQ2IsWUFBSUEsT0FBT2dyQixTQUFQLElBQW9CRyxjQUFjbnJCLE9BQU9nckIsU0FBN0MsRUFBd0Q7QUFDdEQ7QUFDQSxjQUFJNStCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDeWdCLDhCQUFrQjVDLEVBQWxCLEVBQXNCNWQsR0FBdEIsRUFBMkJzTCxPQUFPZ3JCLFNBQVAsQ0FBaUJHLFVBQWpCLENBQTNCLEVBQXlELFlBQVk7QUFDbkVqNkIsbUJBQ0UseUVBQ0EsMERBREEsR0FFQSw2QkFGQSxHQUVnQ3dELEdBRmhDLEdBRXNDLElBSHhDLEVBSUU0ZCxFQUpGO0FBTUQsYUFQRDtBQVFELFdBVEQsTUFTTztBQUNMNEMsOEJBQWtCNUMsRUFBbEIsRUFBc0I1ZCxHQUF0QixFQUEyQnNMLE9BQU9nckIsU0FBUCxDQUFpQkcsVUFBakIsQ0FBM0I7QUFDRDtBQUNEO0FBQ0Q7QUFDRG5yQixpQkFBU0EsT0FBT3pOLE9BQWhCO0FBQ0Q7QUFDRixLQXZCRDs7QUF5QkEsU0FBSyxJQUFJcEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb0gsS0FBSzlILE1BQXpCLEVBQWlDVSxHQUFqQyxFQUFzQ2syQixLQUFNbDJCLENBQU47QUFDdkM7QUFDRjs7QUFFRDs7QUFFQSxJQUFJaTlCLE1BQU0sQ0FBVjs7QUFFQSxTQUFTQyxTQUFULENBQW9COTZCLEdBQXBCLEVBQXlCO0FBQ3ZCQSxNQUFJaEMsU0FBSixDQUFjKzhCLEtBQWQsR0FBc0IsVUFBVTl5QixPQUFWLEVBQW1CO0FBQ3ZDLFFBQUk4WixLQUFLLElBQVQ7QUFDQTtBQUNBQSxPQUFHZ08sSUFBSCxHQUFVOEssS0FBVjs7QUFFQSxRQUFJN1EsUUFBSixFQUFjQyxNQUFkO0FBQ0E7QUFDQSxRQUFJcHVCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDcEIsT0FBTzJSLFdBQWhELElBQStEa1YsSUFBbkUsRUFBeUU7QUFDdkVLLGlCQUFXLG1CQUFvQmpJLEdBQUdnTyxJQUFsQztBQUNBOUYsZUFBUyxrQkFBbUJsSSxHQUFHZ08sSUFBL0I7QUFDQXBHLFdBQUtLLFFBQUw7QUFDRDs7QUFFRDtBQUNBakksT0FBR0csTUFBSCxHQUFZLElBQVo7QUFDQTtBQUNBLFFBQUlqYSxXQUFXQSxRQUFReXVCLFlBQXZCLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBc0UsNEJBQXNCalosRUFBdEIsRUFBMEI5WixPQUExQjtBQUNELEtBTEQsTUFLTztBQUNMOFosU0FBR2hZLFFBQUgsR0FBY2tkLGFBQ1o4TywwQkFBMEJoVSxHQUFHN0ksV0FBN0IsQ0FEWSxFQUVaalIsV0FBVyxFQUZDLEVBR1o4WixFQUhZLENBQWQ7QUFLRDtBQUNEO0FBQ0EsUUFBSWxtQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzZrQixnQkFBVWhILEVBQVY7QUFDRCxLQUZELE1BRU87QUFDTEEsU0FBRzJILFlBQUgsR0FBa0IzSCxFQUFsQjtBQUNEO0FBQ0Q7QUFDQUEsT0FBR2taLEtBQUgsR0FBV2xaLEVBQVg7QUFDQWtNLGtCQUFjbE0sRUFBZDtBQUNBMkssZUFBVzNLLEVBQVg7QUFDQW9YLGVBQVdwWCxFQUFYO0FBQ0E4TSxhQUFTOU0sRUFBVCxFQUFhLGNBQWI7QUFDQTJZLG1CQUFlM1ksRUFBZixFQXhDdUMsQ0F3Q25CO0FBQ3BCc1IsY0FBVXRSLEVBQVY7QUFDQXdZLGdCQUFZeFksRUFBWixFQTFDdUMsQ0EwQ3RCO0FBQ2pCOE0sYUFBUzlNLEVBQVQsRUFBYSxTQUFiOztBQUVBO0FBQ0EsUUFBSWxtQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BCLE9BQU8yUixXQUFoRCxJQUErRGtWLElBQW5FLEVBQXlFO0FBQ3ZFNUgsU0FBRytOLEtBQUgsR0FBV3BPLG9CQUFvQkssRUFBcEIsRUFBd0IsS0FBeEIsQ0FBWDtBQUNBNEgsV0FBS00sTUFBTDtBQUNBTCxjQUFVN0gsR0FBRytOLEtBQUosR0FBYSxPQUF0QixFQUFnQzlGLFFBQWhDLEVBQTBDQyxNQUExQztBQUNEOztBQUVELFFBQUlsSSxHQUFHaFksUUFBSCxDQUFZaUosRUFBaEIsRUFBb0I7QUFDbEIrTyxTQUFHc1QsTUFBSCxDQUFVdFQsR0FBR2hZLFFBQUgsQ0FBWWlKLEVBQXRCO0FBQ0Q7QUFDRixHQXZERDtBQXdERDs7QUFFRCxTQUFTZ29CLHFCQUFULENBQWdDalosRUFBaEMsRUFBb0M5WixPQUFwQyxFQUE2QztBQUMzQyxNQUFJMkcsT0FBT21ULEdBQUdoWSxRQUFILEdBQWNwSyxPQUFPK0wsTUFBUCxDQUFjcVcsR0FBRzdJLFdBQUgsQ0FBZWpSLE9BQTdCLENBQXpCO0FBQ0E7QUFDQTJHLE9BQUt0TixNQUFMLEdBQWMyRyxRQUFRM0csTUFBdEI7QUFDQXNOLE9BQUsrVyxTQUFMLEdBQWlCMWQsUUFBUTBkLFNBQXpCO0FBQ0EvVyxPQUFLNmhCLFlBQUwsR0FBb0J4b0IsUUFBUXdvQixZQUE1QjtBQUNBN2hCLE9BQUtrZSxnQkFBTCxHQUF3QjdrQixRQUFRNmtCLGdCQUFoQztBQUNBbGUsT0FBSzBoQixlQUFMLEdBQXVCcm9CLFFBQVFxb0IsZUFBL0I7QUFDQTFoQixPQUFLdVQsYUFBTCxHQUFxQmxhLFFBQVFrYSxhQUE3QjtBQUNBdlQsT0FBS3dnQixVQUFMLEdBQWtCbm5CLFFBQVFtbkIsVUFBMUI7QUFDQXhnQixPQUFLeWdCLE9BQUwsR0FBZXBuQixRQUFRb25CLE9BQXZCO0FBQ0EsTUFBSXBuQixRQUFRL0csTUFBWixFQUFvQjtBQUNsQjBOLFNBQUsxTixNQUFMLEdBQWMrRyxRQUFRL0csTUFBdEI7QUFDQTBOLFNBQUtnb0IsZUFBTCxHQUF1QjN1QixRQUFRMnVCLGVBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTYix5QkFBVCxDQUFvQ3BXLElBQXBDLEVBQTBDO0FBQ3hDLE1BQUkxWCxVQUFVMFgsS0FBSzFYLE9BQW5CO0FBQ0EsTUFBSTBYLEtBQUt1YixLQUFULEVBQWdCO0FBQ2QsUUFBSUMsZUFBZXBGLDBCQUEwQnBXLEtBQUt1YixLQUEvQixDQUFuQjtBQUNBLFFBQUlFLHFCQUFxQnpiLEtBQUt3YixZQUE5QjtBQUNBLFFBQUlBLGlCQUFpQkMsa0JBQXJCLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQXpiLFdBQUt3YixZQUFMLEdBQW9CQSxZQUFwQjtBQUNBO0FBQ0EsVUFBSUUsa0JBQWtCQyx1QkFBdUIzYixJQUF2QixDQUF0QjtBQUNBO0FBQ0EsVUFBSTBiLGVBQUosRUFBcUI7QUFDbkJ6eUIsZUFBTytXLEtBQUs0YixhQUFaLEVBQTJCRixlQUEzQjtBQUNEO0FBQ0RwekIsZ0JBQVUwWCxLQUFLMVgsT0FBTCxHQUFlZ2YsYUFBYWtVLFlBQWIsRUFBMkJ4YixLQUFLNGIsYUFBaEMsQ0FBekI7QUFDQSxVQUFJdHpCLFFBQVFoSixJQUFaLEVBQWtCO0FBQ2hCZ0osZ0JBQVEvRixVQUFSLENBQW1CK0YsUUFBUWhKLElBQTNCLElBQW1DMGdCLElBQW5DO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBTzFYLE9BQVA7QUFDRDs7QUFFRCxTQUFTcXpCLHNCQUFULENBQWlDM2IsSUFBakMsRUFBdUM7QUFDckMsTUFBSTZiLFFBQUo7QUFDQSxNQUFJQyxTQUFTOWIsS0FBSzFYLE9BQWxCO0FBQ0EsTUFBSXl6QixTQUFTL2IsS0FBS2djLGFBQWxCO0FBQ0EsT0FBSyxJQUFJeDNCLEdBQVQsSUFBZ0JzM0IsTUFBaEIsRUFBd0I7QUFDdEIsUUFBSUEsT0FBT3QzQixHQUFQLE1BQWdCdTNCLE9BQU92M0IsR0FBUCxDQUFwQixFQUFpQztBQUMvQixVQUFJLENBQUNxM0IsUUFBTCxFQUFlO0FBQUVBLG1CQUFXLEVBQVg7QUFBZ0I7QUFDakNBLGVBQVNyM0IsR0FBVCxJQUFnQnkzQixPQUFPSCxPQUFPdDNCLEdBQVAsQ0FBUCxFQUFvQnUzQixPQUFPdjNCLEdBQVAsQ0FBcEIsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsU0FBT3EzQixRQUFQO0FBQ0Q7O0FBRUQsU0FBU0ksTUFBVCxDQUFpQkgsTUFBakIsRUFBeUJDLE1BQXpCLEVBQWlDO0FBQy9CO0FBQ0E7QUFDQSxNQUFJaCtCLE1BQU1tSCxPQUFOLENBQWM0MkIsTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLFFBQUlyM0IsTUFBTSxFQUFWO0FBQ0FzM0IsYUFBU2grQixNQUFNbUgsT0FBTixDQUFjNjJCLE1BQWQsSUFBd0JBLE1BQXhCLEdBQWlDLENBQUNBLE1BQUQsQ0FBMUM7QUFDQSxTQUFLLElBQUk5OUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNjlCLE9BQU92K0IsTUFBM0IsRUFBbUNVLEdBQW5DLEVBQXdDO0FBQ3RDLFVBQUk4OUIsT0FBTzUwQixPQUFQLENBQWUyMEIsT0FBTzc5QixDQUFQLENBQWYsSUFBNEIsQ0FBaEMsRUFBbUM7QUFDakN3RyxZQUFJdkcsSUFBSixDQUFTNDlCLE9BQU83OUIsQ0FBUCxDQUFUO0FBQ0Q7QUFDRjtBQUNELFdBQU93RyxHQUFQO0FBQ0QsR0FURCxNQVNPO0FBQ0wsV0FBT3EzQixNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTcFUsS0FBVCxDQUFnQnBmLE9BQWhCLEVBQXlCO0FBQ3ZCLE1BQUlwTSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUNGLEVBQUUsZ0JBQWdCbWpCLEtBQWxCLENBREYsRUFDNEI7QUFDMUIxbUIsU0FBSyxrRUFBTDtBQUNEO0FBQ0QsT0FBS282QixLQUFMLENBQVc5eUIsT0FBWDtBQUNEOztBQUVENnlCLFVBQVV6VCxLQUFWO0FBQ0FvTixXQUFXcE4sS0FBWDtBQUNBZ0csWUFBWWhHLEtBQVo7QUFDQXFILGVBQWVySCxLQUFmO0FBQ0FrUyxZQUFZbFMsS0FBWjs7QUFFQTs7QUFFQSxTQUFTd1UsT0FBVCxDQUFrQjc3QixHQUFsQixFQUF1QjtBQUNyQkEsTUFBSSthLEdBQUosR0FBVSxVQUFVK2dCLE1BQVYsRUFBa0I7QUFDMUI7QUFDQSxRQUFJQSxPQUFPcnlCLFNBQVgsRUFBc0I7QUFDcEI7QUFDRDtBQUNEO0FBQ0EsUUFBSWhNLE9BQU9nZixRQUFROWUsU0FBUixFQUFtQixDQUFuQixDQUFYO0FBQ0FGLFNBQUswSSxPQUFMLENBQWEsSUFBYjtBQUNBLFFBQUksT0FBTzIxQixPQUFPLzdCLE9BQWQsS0FBMEIsVUFBOUIsRUFBMEM7QUFDeEMrN0IsYUFBTy83QixPQUFQLENBQWU5QixLQUFmLENBQXFCNjlCLE1BQXJCLEVBQTZCcitCLElBQTdCO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBT3ErQixNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQ3ZDQSxhQUFPNzlCLEtBQVAsQ0FBYSxJQUFiLEVBQW1CUixJQUFuQjtBQUNEO0FBQ0RxK0IsV0FBT3J5QixTQUFQLEdBQW1CLElBQW5CO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0FmRDtBQWdCRDs7QUFFRDs7QUFFQSxTQUFTc3lCLFdBQVQsQ0FBc0IvN0IsR0FBdEIsRUFBMkI7QUFDekJBLE1BQUk2SixLQUFKLEdBQVksVUFBVUEsS0FBVixFQUFpQjtBQUMzQixTQUFLNUIsT0FBTCxHQUFlZ2YsYUFBYSxLQUFLaGYsT0FBbEIsRUFBMkI0QixLQUEzQixDQUFmO0FBQ0QsR0FGRDtBQUdEOztBQUVEOztBQUVBLFNBQVNteUIsVUFBVCxDQUFxQmg4QixHQUFyQixFQUEwQjtBQUN4Qjs7Ozs7QUFLQUEsTUFBSTYxQixHQUFKLEdBQVUsQ0FBVjtBQUNBLE1BQUlBLE1BQU0sQ0FBVjs7QUFFQTs7O0FBR0E3MUIsTUFBSTRJLE1BQUosR0FBYSxVQUFVMnlCLGFBQVYsRUFBeUI7QUFDcENBLG9CQUFnQkEsaUJBQWlCLEVBQWpDO0FBQ0EsUUFBSVUsUUFBUSxJQUFaO0FBQ0EsUUFBSUMsVUFBVUQsTUFBTXBHLEdBQXBCO0FBQ0EsUUFBSXNHLGNBQWNaLGNBQWNhLEtBQWQsS0FBd0JiLGNBQWNhLEtBQWQsR0FBc0IsRUFBOUMsQ0FBbEI7QUFDQSxRQUFJRCxZQUFZRCxPQUFaLENBQUosRUFBMEI7QUFDeEIsYUFBT0MsWUFBWUQsT0FBWixDQUFQO0FBQ0Q7O0FBRUQsUUFBSWo5QixPQUFPczhCLGNBQWN0OEIsSUFBZCxJQUFzQmc5QixNQUFNaDBCLE9BQU4sQ0FBY2hKLElBQS9DO0FBQ0EsUUFBSXBELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUksQ0FBQyxtQkFBbUJxRixJQUFuQixDQUF3QnRLLElBQXhCLENBQUwsRUFBb0M7QUFDbEMwQixhQUNFLDhCQUE4QjFCLElBQTlCLEdBQXFDLHFCQUFyQyxHQUNBLDJEQURBLEdBRUEsK0JBSEY7QUFLRDtBQUNGOztBQUVELFFBQUlvOUIsTUFBTSxTQUFTQyxZQUFULENBQXVCcjBCLE9BQXZCLEVBQWdDO0FBQ3hDLFdBQUs4eUIsS0FBTCxDQUFXOXlCLE9BQVg7QUFDRCxLQUZEO0FBR0FvMEIsUUFBSXIrQixTQUFKLEdBQWdCMkIsT0FBTytMLE1BQVAsQ0FBY3V3QixNQUFNaitCLFNBQXBCLENBQWhCO0FBQ0FxK0IsUUFBSXIrQixTQUFKLENBQWNrYixXQUFkLEdBQTRCbWpCLEdBQTVCO0FBQ0FBLFFBQUl4RyxHQUFKLEdBQVVBLEtBQVY7QUFDQXdHLFFBQUlwMEIsT0FBSixHQUFjZ2YsYUFDWmdWLE1BQU1oMEIsT0FETSxFQUVac3pCLGFBRlksQ0FBZDtBQUlBYyxRQUFJLE9BQUosSUFBZUosS0FBZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFJSSxJQUFJcDBCLE9BQUosQ0FBWWxILEtBQWhCLEVBQXVCO0FBQ3JCdzdCLGtCQUFZRixHQUFaO0FBQ0Q7QUFDRCxRQUFJQSxJQUFJcDBCLE9BQUosQ0FBWXllLFFBQWhCLEVBQTBCO0FBQ3hCOFYscUJBQWVILEdBQWY7QUFDRDs7QUFFRDtBQUNBQSxRQUFJenpCLE1BQUosR0FBYXF6QixNQUFNcnpCLE1BQW5CO0FBQ0F5ekIsUUFBSXh5QixLQUFKLEdBQVlveUIsTUFBTXB5QixLQUFsQjtBQUNBd3lCLFFBQUl0aEIsR0FBSixHQUFVa2hCLE1BQU1saEIsR0FBaEI7O0FBRUE7QUFDQTtBQUNBalksV0FBT3ViLFdBQVAsQ0FBbUI5WixPQUFuQixDQUEyQixVQUFVdkQsSUFBVixFQUFnQjtBQUN6Q3E3QixVQUFJcjdCLElBQUosSUFBWWk3QixNQUFNajdCLElBQU4sQ0FBWjtBQUNELEtBRkQ7QUFHQTtBQUNBLFFBQUkvQixJQUFKLEVBQVU7QUFDUm85QixVQUFJcDBCLE9BQUosQ0FBWS9GLFVBQVosQ0FBdUJqRCxJQUF2QixJQUErQm85QixHQUEvQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBQSxRQUFJbEIsWUFBSixHQUFtQmMsTUFBTWgwQixPQUF6QjtBQUNBbzBCLFFBQUlkLGFBQUosR0FBb0JBLGFBQXBCO0FBQ0FjLFFBQUlWLGFBQUosR0FBb0IveUIsT0FBTyxFQUFQLEVBQVd5ekIsSUFBSXAwQixPQUFmLENBQXBCOztBQUVBO0FBQ0FrMEIsZ0JBQVlELE9BQVosSUFBdUJHLEdBQXZCO0FBQ0EsV0FBT0EsR0FBUDtBQUNELEdBbkVEO0FBb0VEOztBQUVELFNBQVNFLFdBQVQsQ0FBc0JFLElBQXRCLEVBQTRCO0FBQzFCLE1BQUkxN0IsUUFBUTA3QixLQUFLeDBCLE9BQUwsQ0FBYWxILEtBQXpCO0FBQ0EsT0FBSyxJQUFJb0QsR0FBVCxJQUFnQnBELEtBQWhCLEVBQXVCO0FBQ3JCa3lCLFVBQU13SixLQUFLeitCLFNBQVgsRUFBc0IsUUFBdEIsRUFBZ0NtRyxHQUFoQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU3E0QixjQUFULENBQXlCQyxJQUF6QixFQUErQjtBQUM3QixNQUFJL1YsV0FBVytWLEtBQUt4MEIsT0FBTCxDQUFheWUsUUFBNUI7QUFDQSxPQUFLLElBQUl2aUIsR0FBVCxJQUFnQnVpQixRQUFoQixFQUEwQjtBQUN4QjBOLG1CQUFlcUksS0FBS3orQixTQUFwQixFQUErQm1HLEdBQS9CLEVBQW9DdWlCLFNBQVN2aUIsR0FBVCxDQUFwQztBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsU0FBU3U0QixrQkFBVCxDQUE2QjE4QixHQUE3QixFQUFrQztBQUNoQzs7O0FBR0E4QyxTQUFPdWIsV0FBUCxDQUFtQjlaLE9BQW5CLENBQTJCLFVBQVV2RCxJQUFWLEVBQWdCO0FBQ3pDaEIsUUFBSWdCLElBQUosSUFBWSxVQUNWd2hCLEVBRFUsRUFFVm1hLFVBRlUsRUFHVjtBQUNBLFVBQUksQ0FBQ0EsVUFBTCxFQUFpQjtBQUNmLGVBQU8sS0FBSzEwQixPQUFMLENBQWFqSCxPQUFPLEdBQXBCLEVBQXlCd2hCLEVBQXpCLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBLFlBQUkzbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsY0FBSWxELFNBQVMsV0FBVCxJQUF3QjhCLE9BQU9rYixhQUFQLENBQXFCd0UsRUFBckIsQ0FBNUIsRUFBc0Q7QUFDcEQ3aEIsaUJBQ0UsZ0VBQ0EsTUFEQSxHQUNTNmhCLEVBRlg7QUFJRDtBQUNGO0FBQ0QsWUFBSXhoQixTQUFTLFdBQVQsSUFBd0I4YixjQUFjNmYsVUFBZCxDQUE1QixFQUF1RDtBQUNyREEscUJBQVcxOUIsSUFBWCxHQUFrQjA5QixXQUFXMTlCLElBQVgsSUFBbUJ1akIsRUFBckM7QUFDQW1hLHVCQUFhLEtBQUsxMEIsT0FBTCxDQUFhMnRCLEtBQWIsQ0FBbUJodEIsTUFBbkIsQ0FBMEIrekIsVUFBMUIsQ0FBYjtBQUNEO0FBQ0QsWUFBSTM3QixTQUFTLFdBQVQsSUFBd0IsT0FBTzI3QixVQUFQLEtBQXNCLFVBQWxELEVBQThEO0FBQzVEQSx1QkFBYSxFQUFFbmxCLE1BQU1tbEIsVUFBUixFQUFvQjNaLFFBQVEyWixVQUE1QixFQUFiO0FBQ0Q7QUFDRCxhQUFLMTBCLE9BQUwsQ0FBYWpILE9BQU8sR0FBcEIsRUFBeUJ3aEIsRUFBekIsSUFBK0JtYSxVQUEvQjtBQUNBLGVBQU9BLFVBQVA7QUFDRDtBQUNGLEtBMUJEO0FBMkJELEdBNUJEO0FBNkJEOztBQUVEOztBQUVBLElBQUlDLGVBQWUsQ0FBQzM3QixNQUFELEVBQVNpTSxNQUFULENBQW5COztBQUVBLFNBQVMydkIsZ0JBQVQsQ0FBMkJqdUIsSUFBM0IsRUFBaUM7QUFDL0IsU0FBT0EsU0FBU0EsS0FBSytRLElBQUwsQ0FBVTFYLE9BQVYsQ0FBa0JoSixJQUFsQixJQUEwQjJQLEtBQUt2SCxHQUF4QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3NILE9BQVQsQ0FBa0JSLE9BQWxCLEVBQTJCbFAsSUFBM0IsRUFBaUM7QUFDL0IsTUFBSSxPQUFPa1AsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixXQUFPQSxRQUFRN0osS0FBUixDQUFjLEdBQWQsRUFBbUJ3QyxPQUFuQixDQUEyQjdILElBQTNCLElBQW1DLENBQUMsQ0FBM0M7QUFDRCxHQUZELE1BRU8sSUFBSWtQLG1CQUFtQmpCLE1BQXZCLEVBQStCO0FBQ3BDLFdBQU9pQixRQUFRNUUsSUFBUixDQUFhdEssSUFBYixDQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVM2OUIsVUFBVCxDQUFxQnA3QixLQUFyQixFQUE0QjJELE1BQTVCLEVBQW9DO0FBQ2xDLE9BQUssSUFBSWxCLEdBQVQsSUFBZ0J6QyxLQUFoQixFQUF1QjtBQUNyQixRQUFJcTdCLGFBQWFyN0IsTUFBTXlDLEdBQU4sQ0FBakI7QUFDQSxRQUFJNDRCLFVBQUosRUFBZ0I7QUFDZCxVQUFJOTlCLE9BQU80OUIsaUJBQWlCRSxXQUFXelMsZ0JBQTVCLENBQVg7QUFDQSxVQUFJcnJCLFFBQVEsQ0FBQ29HLE9BQU9wRyxJQUFQLENBQWIsRUFBMkI7QUFDekIrOUIsd0JBQWdCRCxVQUFoQjtBQUNBcjdCLGNBQU15QyxHQUFOLElBQWEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQVM2NEIsZUFBVCxDQUEwQjE2QixLQUExQixFQUFpQztBQUMvQixNQUFJQSxLQUFKLEVBQVc7QUFDVCxRQUFJLENBQUNBLE1BQU1tb0IsaUJBQU4sQ0FBd0Ixb0IsU0FBN0IsRUFBd0M7QUFDdEM4c0IsZUFBU3ZzQixNQUFNbW9CLGlCQUFmLEVBQWtDLGFBQWxDO0FBQ0Q7QUFDRG5vQixVQUFNbW9CLGlCQUFOLENBQXdCK0UsUUFBeEI7QUFDRDtBQUNGOztBQUVELElBQUl5TixZQUFZO0FBQ2RoK0IsUUFBTSxZQURRO0FBRWRpdkIsWUFBVSxJQUZJOztBQUlkbnRCLFNBQU87QUFDTG04QixhQUFTTixZQURKO0FBRUxPLGFBQVNQO0FBRkosR0FKTzs7QUFTZHR5QixXQUFTLFNBQVNBLE9BQVQsR0FBb0I7QUFDM0IsU0FBSzVJLEtBQUwsR0FBYS9CLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFiO0FBQ0QsR0FYYTs7QUFhZDB4QixhQUFXLFNBQVNBLFNBQVQsR0FBc0I7QUFDL0IsUUFBSXoxQixTQUFTLElBQWI7O0FBRUEsU0FBSyxJQUFJeEQsR0FBVCxJQUFnQndELE9BQU9qRyxLQUF2QixFQUE4QjtBQUM1QnM3QixzQkFBZ0JyMUIsT0FBT2pHLEtBQVAsQ0FBYXlDLEdBQWIsQ0FBaEI7QUFDRDtBQUNGLEdBbkJhOztBQXFCZHFpQixTQUFPO0FBQ0wwVyxhQUFTLFNBQVNBLE9BQVQsQ0FBa0J2NEIsR0FBbEIsRUFBdUI7QUFDOUJtNEIsaUJBQVcsS0FBS3A3QixLQUFoQixFQUF1QixVQUFVekMsSUFBVixFQUFnQjtBQUFFLGVBQU8wUCxRQUFRaEssR0FBUixFQUFhMUYsSUFBYixDQUFQO0FBQTRCLE9BQXJFO0FBQ0QsS0FISTtBQUlMaytCLGFBQVMsU0FBU0EsT0FBVCxDQUFrQng0QixHQUFsQixFQUF1QjtBQUM5Qm00QixpQkFBVyxLQUFLcDdCLEtBQWhCLEVBQXVCLFVBQVV6QyxJQUFWLEVBQWdCO0FBQUUsZUFBTyxDQUFDMFAsUUFBUWhLLEdBQVIsRUFBYTFGLElBQWIsQ0FBUjtBQUE2QixPQUF0RTtBQUNEO0FBTkksR0FyQk87O0FBOEJkaUMsVUFBUSxTQUFTQSxNQUFULEdBQW1CO0FBQ3pCLFFBQUlvQixRQUFRbXFCLHVCQUF1QixLQUFLL2pCLE1BQUwsQ0FBWTVJLE9BQW5DLENBQVo7QUFDQSxRQUFJd3FCLG1CQUFtQmhvQixTQUFTQSxNQUFNZ29CLGdCQUF0QztBQUNBLFFBQUlBLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0EsVUFBSXJyQixPQUFPNDlCLGlCQUFpQnZTLGdCQUFqQixDQUFYO0FBQ0EsVUFBSXJyQixTQUNELEtBQUtpK0IsT0FBTCxJQUFnQixDQUFDdnVCLFFBQVEsS0FBS3V1QixPQUFiLEVBQXNCaitCLElBQXRCLENBQWxCLElBQ0MsS0FBS2srQixPQUFMLElBQWdCeHVCLFFBQVEsS0FBS3d1QixPQUFiLEVBQXNCbCtCLElBQXRCLENBRmYsQ0FBSixFQUdHO0FBQ0QsZUFBT3FELEtBQVA7QUFDRDtBQUNELFVBQUk2QixNQUFNN0IsTUFBTTZCLEdBQU4sSUFBYTtBQUNyQjtBQUNBO0FBRlEsUUFHTm1tQixpQkFBaUIzSyxJQUFqQixDQUFzQmtXLEdBQXRCLElBQTZCdkwsaUJBQWlCampCLEdBQWpCLEdBQXdCLE9BQVFpakIsaUJBQWlCampCLEdBQWpELEdBQXlELEVBQXRGLENBSE0sR0FJTi9FLE1BQU02QixHQUpWO0FBS0EsVUFBSSxLQUFLekMsS0FBTCxDQUFXeUMsR0FBWCxDQUFKLEVBQXFCO0FBQ25CN0IsY0FBTW1vQixpQkFBTixHQUEwQixLQUFLL29CLEtBQUwsQ0FBV3lDLEdBQVgsRUFBZ0JzbUIsaUJBQTFDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSy9vQixLQUFMLENBQVd5QyxHQUFYLElBQWtCN0IsS0FBbEI7QUFDRDtBQUNEQSxZQUFNZixJQUFOLENBQVcrekIsU0FBWCxHQUF1QixJQUF2QjtBQUNEO0FBQ0QsV0FBT2h6QixLQUFQO0FBQ0Q7QUF2RGEsQ0FBaEI7O0FBMERBLElBQUkrNkIsb0JBQW9CO0FBQ3RCSixhQUFXQTtBQURXLENBQXhCOztBQUlBOztBQUVBLFNBQVNLLGFBQVQsQ0FBd0J0OUIsR0FBeEIsRUFBNkI7QUFDM0I7QUFDQSxNQUFJdTlCLFlBQVksRUFBaEI7QUFDQUEsWUFBVXA5QixHQUFWLEdBQWdCLFlBQVk7QUFBRSxXQUFPMkMsTUFBUDtBQUFnQixHQUE5QztBQUNBLE1BQUlqSCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3E1QixjQUFVbGMsR0FBVixHQUFnQixZQUFZO0FBQzFCMWdCLFdBQ0Usc0VBREY7QUFHRCxLQUpEO0FBS0Q7QUFDRGhCLFNBQU9DLGNBQVAsQ0FBc0JJLEdBQXRCLEVBQTJCLFFBQTNCLEVBQXFDdTlCLFNBQXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBdjlCLE1BQUk4SSxJQUFKLEdBQVc7QUFDVG5JLFVBQU1BLElBREc7QUFFVGlJLFlBQVFBLE1BRkM7QUFHVHFlLGtCQUFjQSxZQUhMO0FBSVRqZCxvQkFBZ0IyYTtBQUpQLEdBQVg7O0FBT0Eza0IsTUFBSXFoQixHQUFKLEdBQVVBLEdBQVY7QUFDQXJoQixNQUFJdzlCLE1BQUosR0FBYTlYLEdBQWI7QUFDQTFsQixNQUFJeEMsUUFBSixHQUFlQSxRQUFmOztBQUVBd0MsTUFBSWlJLE9BQUosR0FBY3RJLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFkO0FBQ0E1SSxTQUFPdWIsV0FBUCxDQUFtQjlaLE9BQW5CLENBQTJCLFVBQVV2RCxJQUFWLEVBQWdCO0FBQ3pDaEIsUUFBSWlJLE9BQUosQ0FBWWpILE9BQU8sR0FBbkIsSUFBMEJyQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBMUI7QUFDRCxHQUZEOztBQUlBO0FBQ0E7QUFDQTFMLE1BQUlpSSxPQUFKLENBQVkydEIsS0FBWixHQUFvQjUxQixHQUFwQjs7QUFFQTRJLFNBQU81SSxJQUFJaUksT0FBSixDQUFZL0YsVUFBbkIsRUFBK0JtN0IsaUJBQS9COztBQUVBeEIsVUFBUTc3QixHQUFSO0FBQ0ErN0IsY0FBWS83QixHQUFaO0FBQ0FnOEIsYUFBV2g4QixHQUFYO0FBQ0EwOEIscUJBQW1CMThCLEdBQW5CO0FBQ0Q7O0FBRURzOUIsY0FBY2pXLEtBQWQ7O0FBRUExbkIsT0FBT0MsY0FBUCxDQUFzQnluQixNQUFNcnBCLFNBQTVCLEVBQXVDLFdBQXZDLEVBQW9EO0FBQ2xEbUMsT0FBS29mO0FBRDZDLENBQXBEOztBQUlBOEgsTUFBTS9vQixPQUFOLEdBQWdCLE9BQWhCOztBQUVBOztBQUVBO0FBQ0EsSUFBSW0vQixjQUFjcmlCLFFBQVEsOEJBQVIsQ0FBbEI7QUFDQSxJQUFJZ0QsY0FBYyxVQUFVL1csR0FBVixFQUFlckcsSUFBZixFQUFxQjA4QixJQUFyQixFQUEyQjtBQUMzQyxTQUNHQSxTQUFTLE9BQVQsSUFBb0JELFlBQVlwMkIsR0FBWixDQUFyQixJQUEwQ3JHLFNBQVMsUUFBbkQsSUFDQzA4QixTQUFTLFVBQVQsSUFBdUJyMkIsUUFBUSxRQURoQyxJQUVDcTJCLFNBQVMsU0FBVCxJQUFzQnIyQixRQUFRLE9BRi9CLElBR0NxMkIsU0FBUyxPQUFULElBQW9CcjJCLFFBQVEsT0FKL0I7QUFNRCxDQVBEOztBQVNBLElBQUlzMkIsbUJBQW1CdmlCLFFBQVEsc0NBQVIsQ0FBdkI7O0FBRUEsSUFBSXdpQixnQkFBZ0J4aUIsUUFDbEIsK0VBQ0EscUVBREEsR0FFQSxrRkFGQSxHQUdBLDRFQUhBLEdBSUEsZ0VBSkEsR0FLQSxpQ0FOa0IsQ0FBcEI7O0FBU0EsSUFBSXlpQixVQUFVLDhCQUFkOztBQUVBLElBQUlDLFVBQVUsVUFBVTcrQixJQUFWLEVBQWdCO0FBQzVCLFNBQU9BLEtBQUsyTCxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFuQixJQUEwQjNMLEtBQUtrRyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsTUFBcUIsT0FBdEQ7QUFDRCxDQUZEOztBQUlBLElBQUk0NEIsZUFBZSxVQUFVOStCLElBQVYsRUFBZ0I7QUFDakMsU0FBTzYrQixRQUFRNytCLElBQVIsSUFBZ0JBLEtBQUtrRyxLQUFMLENBQVcsQ0FBWCxFQUFjbEcsS0FBSy9CLE1BQW5CLENBQWhCLEdBQTZDLEVBQXBEO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJOGdDLG1CQUFtQixVQUFVcjVCLEdBQVYsRUFBZTtBQUNwQyxTQUFPQSxPQUFPLElBQVAsSUFBZUEsUUFBUSxLQUE5QjtBQUNELENBRkQ7O0FBSUE7O0FBRUEsU0FBU3M1QixnQkFBVCxDQUEyQjM3QixLQUEzQixFQUFrQztBQUNoQyxNQUFJZixPQUFPZSxNQUFNZixJQUFqQjtBQUNBLE1BQUkyOEIsYUFBYTU3QixLQUFqQjtBQUNBLE1BQUk2N0IsWUFBWTc3QixLQUFoQjtBQUNBLFNBQU82N0IsVUFBVTFULGlCQUFqQixFQUFvQztBQUNsQzBULGdCQUFZQSxVQUFVMVQsaUJBQVYsQ0FBNEJ3RSxNQUF4QztBQUNBLFFBQUlrUCxVQUFVNThCLElBQWQsRUFBb0I7QUFDbEJBLGFBQU82OEIsZUFBZUQsVUFBVTU4QixJQUF6QixFQUErQkEsSUFBL0IsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFRMjhCLGFBQWFBLFdBQVc1OEIsTUFBaEMsRUFBeUM7QUFDdkMsUUFBSTQ4QixXQUFXMzhCLElBQWYsRUFBcUI7QUFDbkJBLGFBQU82OEIsZUFBZTc4QixJQUFmLEVBQXFCMjhCLFdBQVczOEIsSUFBaEMsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPODhCLGlCQUFpQjk4QixJQUFqQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzY4QixjQUFULENBQXlCNTdCLEtBQXpCLEVBQWdDbEIsTUFBaEMsRUFBd0M7QUFDdEMsU0FBTztBQUNMZzlCLGlCQUFhbmhDLE9BQU9xRixNQUFNODdCLFdBQWIsRUFBMEJoOUIsT0FBT2c5QixXQUFqQyxDQURSO0FBRUwvMUIsV0FBTy9GLE1BQU0rRixLQUFOLEdBQ0gsQ0FBQy9GLE1BQU0rRixLQUFQLEVBQWNqSCxPQUFPaUgsS0FBckIsQ0FERyxHQUVIakgsT0FBT2lIO0FBSk4sR0FBUDtBQU1EOztBQUVELFNBQVM4MUIsZ0JBQVQsQ0FBMkI5OEIsSUFBM0IsRUFBaUM7QUFDL0IsTUFBSWc5QixlQUFlaDlCLEtBQUtnSCxLQUF4QjtBQUNBLE1BQUkrMUIsY0FBYy84QixLQUFLKzhCLFdBQXZCO0FBQ0EsTUFBSUEsZUFBZUMsWUFBbkIsRUFBaUM7QUFDL0IsV0FBT3BoQyxPQUFPbWhDLFdBQVAsRUFBb0JFLGVBQWVELFlBQWYsQ0FBcEIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFPLEVBQVA7QUFDRDs7QUFFRCxTQUFTcGhDLE1BQVQsQ0FBaUJrSixDQUFqQixFQUFvQkMsQ0FBcEIsRUFBdUI7QUFDckIsU0FBT0QsSUFBSUMsSUFBS0QsSUFBSSxHQUFKLEdBQVVDLENBQWYsR0FBb0JELENBQXhCLEdBQTZCQyxLQUFLLEVBQXpDO0FBQ0Q7O0FBRUQsU0FBU2s0QixjQUFULENBQXlCMytCLEtBQXpCLEVBQWdDO0FBQzlCLE1BQUl1RSxNQUFNLEVBQVY7QUFDQSxNQUFJLENBQUN2RSxLQUFMLEVBQVk7QUFDVixXQUFPdUUsR0FBUDtBQUNEO0FBQ0QsTUFBSSxPQUFPdkUsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixXQUFPQSxLQUFQO0FBQ0Q7QUFDRCxNQUFJbkMsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixRQUFJNCtCLFdBQUo7QUFDQSxTQUFLLElBQUk3Z0MsSUFBSSxDQUFSLEVBQVcyZSxJQUFJMWMsTUFBTTNDLE1BQTFCLEVBQWtDVSxJQUFJMmUsQ0FBdEMsRUFBeUMzZSxHQUF6QyxFQUE4QztBQUM1QyxVQUFJaUMsTUFBTWpDLENBQU4sQ0FBSixFQUFjO0FBQ1osWUFBSzZnQyxjQUFjRCxlQUFlMytCLE1BQU1qQyxDQUFOLENBQWYsQ0FBbkIsRUFBOEM7QUFDNUN3RyxpQkFBT3E2QixjQUFjLEdBQXJCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBT3I2QixJQUFJZSxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUFQO0FBQ0Q7QUFDRCxNQUFJMk4sU0FBU2pULEtBQVQsQ0FBSixFQUFxQjtBQUNuQixTQUFLLElBQUlzRSxHQUFULElBQWdCdEUsS0FBaEIsRUFBdUI7QUFDckIsVUFBSUEsTUFBTXNFLEdBQU4sQ0FBSixFQUFnQjtBQUFFQyxlQUFPRCxNQUFNLEdBQWI7QUFBbUI7QUFDdEM7QUFDRCxXQUFPQyxJQUFJZSxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9mLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJczZCLGVBQWU7QUFDakJDLE9BQUssNEJBRFk7QUFFakJDLFFBQU07QUFGVyxDQUFuQjs7QUFLQSxJQUFJQyxZQUFZempCLFFBQ2QsK0NBQ0EsMkVBREEsR0FFQSw0REFGQSxHQUdBLHdFQUhBLEdBSUEsNkVBSkEsR0FLQSwyREFMQSxHQU1BLGtEQU5BLEdBT0EseUVBUEEsR0FRQSxrQ0FSQSxHQVNBLHVDQVRBLEdBVUEsaUNBWGMsQ0FBaEI7O0FBY0E7QUFDQTtBQUNBLElBQUkwakIsUUFBUTFqQixRQUNWLDJFQUNBLDBFQURBLEdBRUEsa0VBSFUsRUFJVixJQUpVLENBQVo7O0FBT0EsSUFBSTJqQixXQUFXLFVBQVUxM0IsR0FBVixFQUFlO0FBQUUsU0FBT0EsUUFBUSxLQUFmO0FBQXVCLENBQXZEOztBQUVBLElBQUkyVyxnQkFBZ0IsVUFBVTNXLEdBQVYsRUFBZTtBQUNqQyxTQUFPdzNCLFVBQVV4M0IsR0FBVixLQUFrQnkzQixNQUFNejNCLEdBQU4sQ0FBekI7QUFDRCxDQUZEOztBQUlBLFNBQVM2VyxlQUFULENBQTBCN1csR0FBMUIsRUFBK0I7QUFDN0IsTUFBSXkzQixNQUFNejNCLEdBQU4sQ0FBSixFQUFnQjtBQUNkLFdBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLE1BQUlBLFFBQVEsTUFBWixFQUFvQjtBQUNsQixXQUFPLE1BQVA7QUFDRDtBQUNGOztBQUVELElBQUkyM0Isc0JBQXNCci9CLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUExQjtBQUNBLFNBQVN1UyxnQkFBVCxDQUEyQjVXLEdBQTNCLEVBQWdDO0FBQzlCO0FBQ0EsTUFBSSxDQUFDa0QsU0FBTCxFQUFnQjtBQUNkLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSXlULGNBQWMzVyxHQUFkLENBQUosRUFBd0I7QUFDdEIsV0FBTyxLQUFQO0FBQ0Q7QUFDREEsUUFBTUEsSUFBSWtVLFdBQUosRUFBTjtBQUNBO0FBQ0EsTUFBSXlqQixvQkFBb0IzM0IsR0FBcEIsS0FBNEIsSUFBaEMsRUFBc0M7QUFDcEMsV0FBTzIzQixvQkFBb0IzM0IsR0FBcEIsQ0FBUDtBQUNEO0FBQ0QsTUFBSTJMLEtBQUtDLFNBQVN1akIsYUFBVCxDQUF1Qm52QixHQUF2QixDQUFUO0FBQ0EsTUFBSUEsSUFBSVAsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6QjtBQUNBLFdBQVFrNEIsb0JBQW9CMzNCLEdBQXBCLElBQ04yTCxHQUFHa0csV0FBSCxLQUFtQjFPLE9BQU95MEIsa0JBQTFCLElBQ0Fqc0IsR0FBR2tHLFdBQUgsS0FBbUIxTyxPQUFPMDBCLFdBRjVCO0FBSUQsR0FORCxNQU1PO0FBQ0wsV0FBUUYsb0JBQW9CMzNCLEdBQXBCLElBQTJCLHFCQUFxQmtDLElBQXJCLENBQTBCeUosR0FBRzNQLFFBQUgsRUFBMUIsQ0FBbkM7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTUyxLQUFULENBQWdCa1AsRUFBaEIsRUFBb0I7QUFDbEIsTUFBSSxPQUFPQSxFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIsUUFBSW1zQixXQUFXbHNCLFNBQVNDLGFBQVQsQ0FBdUJGLEVBQXZCLENBQWY7QUFDQSxRQUFJLENBQUNtc0IsUUFBTCxFQUFlO0FBQ2J0akMsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QywwQkFBMEJxUyxFQURhLENBQXpDO0FBR0EsYUFBT0MsU0FBU3VqQixhQUFULENBQXVCLEtBQXZCLENBQVA7QUFDRDtBQUNELFdBQU8ySSxRQUFQO0FBQ0QsR0FURCxNQVNPO0FBQ0wsV0FBT25zQixFQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxTQUFTb3NCLGVBQVQsQ0FBMEJDLE9BQTFCLEVBQW1DLzhCLEtBQW5DLEVBQTBDO0FBQ3hDLE1BQUk4bkIsTUFBTW5YLFNBQVN1akIsYUFBVCxDQUF1QjZJLE9BQXZCLENBQVY7QUFDQSxNQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQ3hCLFdBQU9qVixHQUFQO0FBQ0Q7QUFDRDtBQUNBLE1BQUk5bkIsTUFBTWYsSUFBTixJQUFjZSxNQUFNZixJQUFOLENBQVdpSCxLQUF6QixJQUFrQ2xHLE1BQU1mLElBQU4sQ0FBV2lILEtBQVgsQ0FBaUI4MkIsUUFBakIsS0FBOEIxOEIsU0FBcEUsRUFBK0U7QUFDN0V3bkIsUUFBSW1WLFlBQUosQ0FBaUIsVUFBakIsRUFBNkIsVUFBN0I7QUFDRDtBQUNELFNBQU9uVixHQUFQO0FBQ0Q7O0FBRUQsU0FBU29WLGVBQVQsQ0FBMEJDLFNBQTFCLEVBQXFDSixPQUFyQyxFQUE4QztBQUM1QyxTQUFPcHNCLFNBQVN1c0IsZUFBVCxDQUF5QmQsYUFBYWUsU0FBYixDQUF6QixFQUFrREosT0FBbEQsQ0FBUDtBQUNEOztBQUVELFNBQVN2ZSxjQUFULENBQXlCcUosSUFBekIsRUFBK0I7QUFDN0IsU0FBT2xYLFNBQVM2TixjQUFULENBQXdCcUosSUFBeEIsQ0FBUDtBQUNEOztBQUVELFNBQVN1VixhQUFULENBQXdCdlYsSUFBeEIsRUFBOEI7QUFDNUIsU0FBT2xYLFNBQVN5c0IsYUFBVCxDQUF1QnZWLElBQXZCLENBQVA7QUFDRDs7QUFFRCxTQUFTd1YsWUFBVCxDQUF1QnpCLFVBQXZCLEVBQW1DMEIsT0FBbkMsRUFBNENDLGFBQTVDLEVBQTJEO0FBQ3pEM0IsYUFBV3lCLFlBQVgsQ0FBd0JDLE9BQXhCLEVBQWlDQyxhQUFqQztBQUNEOztBQUVELFNBQVNDLFdBQVQsQ0FBc0IvVSxJQUF0QixFQUE0QnZvQixLQUE1QixFQUFtQztBQUNqQ3VvQixPQUFLK1UsV0FBTCxDQUFpQnQ5QixLQUFqQjtBQUNEOztBQUVELFNBQVN1OUIsV0FBVCxDQUFzQmhWLElBQXRCLEVBQTRCdm9CLEtBQTVCLEVBQW1DO0FBQ2pDdW9CLE9BQUtnVixXQUFMLENBQWlCdjlCLEtBQWpCO0FBQ0Q7O0FBRUQsU0FBUzA3QixVQUFULENBQXFCblQsSUFBckIsRUFBMkI7QUFDekIsU0FBT0EsS0FBS21ULFVBQVo7QUFDRDs7QUFFRCxTQUFTOEIsV0FBVCxDQUFzQmpWLElBQXRCLEVBQTRCO0FBQzFCLFNBQU9BLEtBQUtpVixXQUFaO0FBQ0Q7O0FBRUQsU0FBU1gsT0FBVCxDQUFrQnRVLElBQWxCLEVBQXdCO0FBQ3RCLFNBQU9BLEtBQUtzVSxPQUFaO0FBQ0Q7O0FBRUQsU0FBU1ksY0FBVCxDQUF5QmxWLElBQXpCLEVBQStCWixJQUEvQixFQUFxQztBQUNuQ1ksT0FBS21WLFdBQUwsR0FBbUIvVixJQUFuQjtBQUNEOztBQUVELFNBQVNvVixZQUFULENBQXVCeFUsSUFBdkIsRUFBNkI1bUIsR0FBN0IsRUFBa0NRLEdBQWxDLEVBQXVDO0FBQ3JDb21CLE9BQUt3VSxZQUFMLENBQWtCcDdCLEdBQWxCLEVBQXVCUSxHQUF2QjtBQUNEOztBQUdELElBQUl3N0IsVUFBVXhnQyxPQUFPc0csTUFBUCxDQUFjO0FBQzNCdXdCLGlCQUFlNEksZUFEWTtBQUUzQkksbUJBQWlCQSxlQUZVO0FBRzNCMWUsa0JBQWdCQSxjQUhXO0FBSTNCNGUsaUJBQWVBLGFBSlk7QUFLM0JDLGdCQUFjQSxZQUxhO0FBTTNCRyxlQUFhQSxXQU5jO0FBTzNCQyxlQUFhQSxXQVBjO0FBUTNCN0IsY0FBWUEsVUFSZTtBQVMzQjhCLGVBQWFBLFdBVGM7QUFVM0JYLFdBQVNBLE9BVmtCO0FBVzNCWSxrQkFBZ0JBLGNBWFc7QUFZM0JWLGdCQUFjQTtBQVphLENBQWQsQ0FBZDs7QUFlQTs7QUFFQSxJQUFJbitCLE1BQU07QUFDUnNLLFVBQVEsU0FBU0EsTUFBVCxDQUFpQjBNLENBQWpCLEVBQW9COVYsS0FBcEIsRUFBMkI7QUFDakM4OUIsZ0JBQVk5OUIsS0FBWjtBQUNELEdBSE87QUFJUjBnQixVQUFRLFNBQVNBLE1BQVQsQ0FBaUJ0Z0IsUUFBakIsRUFBMkJKLEtBQTNCLEVBQWtDO0FBQ3hDLFFBQUlJLFNBQVNuQixJQUFULENBQWNILEdBQWQsS0FBc0JrQixNQUFNZixJQUFOLENBQVdILEdBQXJDLEVBQTBDO0FBQ3hDZy9CLGtCQUFZMTlCLFFBQVosRUFBc0IsSUFBdEI7QUFDQTA5QixrQkFBWTk5QixLQUFaO0FBQ0Q7QUFDRixHQVRPO0FBVVJLLFdBQVMsU0FBU0EsT0FBVCxDQUFrQkwsS0FBbEIsRUFBeUI7QUFDaEM4OUIsZ0JBQVk5OUIsS0FBWixFQUFtQixJQUFuQjtBQUNEO0FBWk8sQ0FBVjs7QUFlQSxTQUFTODlCLFdBQVQsQ0FBc0I5OUIsS0FBdEIsRUFBNkIrOUIsU0FBN0IsRUFBd0M7QUFDdEMsTUFBSWw4QixNQUFNN0IsTUFBTWYsSUFBTixDQUFXSCxHQUFyQjtBQUNBLE1BQUksQ0FBQytDLEdBQUwsRUFBVTtBQUFFO0FBQVE7O0FBRXBCLE1BQUk0ZCxLQUFLemYsTUFBTStuQixPQUFmO0FBQ0EsTUFBSWpwQixNQUFNa0IsTUFBTW1vQixpQkFBTixJQUEyQm5vQixNQUFNOG5CLEdBQTNDO0FBQ0EsTUFBSWtXLE9BQU92ZSxHQUFHcU0sS0FBZDtBQUNBLE1BQUlpUyxTQUFKLEVBQWU7QUFDYixRQUFJM2lDLE1BQU1tSCxPQUFOLENBQWN5N0IsS0FBS244QixHQUFMLENBQWQsQ0FBSixFQUE4QjtBQUM1QnNYLGFBQU82a0IsS0FBS244QixHQUFMLENBQVAsRUFBa0IvQyxHQUFsQjtBQUNELEtBRkQsTUFFTyxJQUFJay9CLEtBQUtuOEIsR0FBTCxNQUFjL0MsR0FBbEIsRUFBdUI7QUFDNUJrL0IsV0FBS244QixHQUFMLElBQVl2QixTQUFaO0FBQ0Q7QUFDRixHQU5ELE1BTU87QUFDTCxRQUFJTixNQUFNZixJQUFOLENBQVdnL0IsUUFBZixFQUF5QjtBQUN2QixVQUFJN2lDLE1BQU1tSCxPQUFOLENBQWN5N0IsS0FBS244QixHQUFMLENBQWQsS0FBNEJtOEIsS0FBS244QixHQUFMLEVBQVUyQyxPQUFWLENBQWtCMUYsR0FBbEIsSUFBeUIsQ0FBekQsRUFBNEQ7QUFDMURrL0IsYUFBS244QixHQUFMLEVBQVV0RyxJQUFWLENBQWV1RCxHQUFmO0FBQ0QsT0FGRCxNQUVPO0FBQ0xrL0IsYUFBS244QixHQUFMLElBQVksQ0FBQy9DLEdBQUQsQ0FBWjtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0xrL0IsV0FBS244QixHQUFMLElBQVkvQyxHQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUlvL0IsWUFBWSxJQUFJdFcsS0FBSixDQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCLEVBQWxCLENBQWhCOztBQUVBLElBQUkvbkIsUUFBUSxDQUFDLFFBQUQsRUFBVyxVQUFYLEVBQXVCLFFBQXZCLEVBQWlDLFFBQWpDLEVBQTJDLFNBQTNDLENBQVo7O0FBRUEsU0FBU3MrQixPQUFULENBQWtCdHNCLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLE1BQU12UixTQUFOLElBQW1CdVIsTUFBTSxJQUFoQztBQUNEOztBQUVELFNBQVN1c0IsS0FBVCxDQUFnQnZzQixDQUFoQixFQUFtQjtBQUNqQixTQUFPQSxNQUFNdlIsU0FBTixJQUFtQnVSLE1BQU0sSUFBaEM7QUFDRDs7QUFFRCxTQUFTd3NCLE1BQVQsQ0FBaUJ4c0IsQ0FBakIsRUFBb0I7QUFDbEIsU0FBT0EsTUFBTSxJQUFiO0FBQ0Q7O0FBRUQsU0FBU3lzQixTQUFULENBQW9CdjZCLENBQXBCLEVBQXVCQyxDQUF2QixFQUEwQjtBQUN4QixTQUNFRCxFQUFFbEMsR0FBRixLQUFVbUMsRUFBRW5DLEdBQVosSUFDQWtDLEVBQUVnQixHQUFGLEtBQVVmLEVBQUVlLEdBRFosSUFFQWhCLEVBQUVza0IsU0FBRixLQUFnQnJrQixFQUFFcWtCLFNBRmxCLElBR0ErVixNQUFNcjZCLEVBQUU5RSxJQUFSLE1BQWtCbS9CLE1BQU1wNkIsRUFBRS9FLElBQVIsQ0FIbEIsSUFJQXMvQixjQUFjeDZCLENBQWQsRUFBaUJDLENBQWpCLENBTEY7QUFPRDs7QUFFRDtBQUNBO0FBQ0EsU0FBU3U2QixhQUFULENBQXdCeDZCLENBQXhCLEVBQTJCQyxDQUEzQixFQUE4QjtBQUM1QixNQUFJRCxFQUFFZ0IsR0FBRixLQUFVLE9BQWQsRUFBdUI7QUFBRSxXQUFPLElBQVA7QUFBYTtBQUN0QyxNQUFJekosQ0FBSjtBQUNBLE1BQUlrakMsUUFBUUosTUFBTTlpQyxJQUFJeUksRUFBRTlFLElBQVosS0FBcUJtL0IsTUFBTTlpQyxJQUFJQSxFQUFFNEssS0FBWixDQUFyQixJQUEyQzVLLEVBQUVvRCxJQUF6RDtBQUNBLE1BQUkrL0IsUUFBUUwsTUFBTTlpQyxJQUFJMEksRUFBRS9FLElBQVosS0FBcUJtL0IsTUFBTTlpQyxJQUFJQSxFQUFFNEssS0FBWixDQUFyQixJQUEyQzVLLEVBQUVvRCxJQUF6RDtBQUNBLFNBQU84L0IsVUFBVUMsS0FBakI7QUFDRDs7QUFFRCxTQUFTQyxpQkFBVCxDQUE0QjMvQixRQUE1QixFQUFzQzQvQixRQUF0QyxFQUFnREMsTUFBaEQsRUFBd0Q7QUFDdEQsTUFBSXRqQyxDQUFKLEVBQU91RyxHQUFQO0FBQ0EsTUFBSWMsTUFBTSxFQUFWO0FBQ0EsT0FBS3JILElBQUlxakMsUUFBVCxFQUFtQnJqQyxLQUFLc2pDLE1BQXhCLEVBQWdDLEVBQUV0akMsQ0FBbEMsRUFBcUM7QUFDbkN1RyxVQUFNOUMsU0FBU3pELENBQVQsRUFBWXVHLEdBQWxCO0FBQ0EsUUFBSXU4QixNQUFNdjhCLEdBQU4sQ0FBSixFQUFnQjtBQUFFYyxVQUFJZCxHQUFKLElBQVd2RyxDQUFYO0FBQWU7QUFDbEM7QUFDRCxTQUFPcUgsR0FBUDtBQUNEOztBQUVELFNBQVNrOEIsbUJBQVQsQ0FBOEJDLE9BQTlCLEVBQXVDO0FBQ3JDLE1BQUl4akMsQ0FBSixFQUFPc1IsQ0FBUDtBQUNBLE1BQUlpSixNQUFNLEVBQVY7O0FBRUEsTUFBSWdGLFVBQVVpa0IsUUFBUWprQixPQUF0QjtBQUNBLE1BQUlnakIsVUFBVWlCLFFBQVFqQixPQUF0Qjs7QUFFQSxPQUFLdmlDLElBQUksQ0FBVCxFQUFZQSxJQUFJdUUsTUFBTWpGLE1BQXRCLEVBQThCLEVBQUVVLENBQWhDLEVBQW1DO0FBQ2pDdWEsUUFBSWhXLE1BQU12RSxDQUFOLENBQUosSUFBZ0IsRUFBaEI7QUFDQSxTQUFLc1IsSUFBSSxDQUFULEVBQVlBLElBQUlpTyxRQUFRamdCLE1BQXhCLEVBQWdDLEVBQUVnUyxDQUFsQyxFQUFxQztBQUNuQyxVQUFJd3hCLE1BQU12akIsUUFBUWpPLENBQVIsRUFBVy9NLE1BQU12RSxDQUFOLENBQVgsQ0FBTixDQUFKLEVBQWlDO0FBQy9CdWEsWUFBSWhXLE1BQU12RSxDQUFOLENBQUosRUFBY0MsSUFBZCxDQUFtQnNmLFFBQVFqTyxDQUFSLEVBQVcvTSxNQUFNdkUsQ0FBTixDQUFYLENBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVN5akMsV0FBVCxDQUFzQmpYLEdBQXRCLEVBQTJCO0FBQ3pCLFdBQU8sSUFBSUYsS0FBSixDQUFVaVcsUUFBUWQsT0FBUixDQUFnQmpWLEdBQWhCLEVBQXFCN08sV0FBckIsRUFBVixFQUE4QyxFQUE5QyxFQUFrRCxFQUFsRCxFQUFzRDNZLFNBQXRELEVBQWlFd25CLEdBQWpFLENBQVA7QUFDRDs7QUFFRCxXQUFTa1gsVUFBVCxDQUFxQkMsUUFBckIsRUFBK0IxVSxTQUEvQixFQUEwQztBQUN4QyxhQUFTakIsU0FBVCxHQUFzQjtBQUNwQixVQUFJLEVBQUVBLFVBQVVpQixTQUFaLEtBQTBCLENBQTlCLEVBQWlDO0FBQy9CMlUsbUJBQVdELFFBQVg7QUFDRDtBQUNGO0FBQ0QzVixjQUFVaUIsU0FBVixHQUFzQkEsU0FBdEI7QUFDQSxXQUFPakIsU0FBUDtBQUNEOztBQUVELFdBQVM0VixVQUFULENBQXFCeHVCLEVBQXJCLEVBQXlCO0FBQ3ZCLFFBQUkxUixTQUFTNitCLFFBQVFqQyxVQUFSLENBQW1CbHJCLEVBQW5CLENBQWI7QUFDQTtBQUNBLFFBQUkwdEIsTUFBTXAvQixNQUFOLENBQUosRUFBbUI7QUFDakI2K0IsY0FBUUwsV0FBUixDQUFvQngrQixNQUFwQixFQUE0QjBSLEVBQTVCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJeXVCLFFBQVEsQ0FBWjtBQUNBLFdBQVNDLFNBQVQsQ0FBb0JwL0IsS0FBcEIsRUFBMkJxL0Isa0JBQTNCLEVBQStDek0sU0FBL0MsRUFBMERDLE1BQTFELEVBQWtFeU0sTUFBbEUsRUFBMEU7QUFDeEV0L0IsVUFBTW9vQixZQUFOLEdBQXFCLENBQUNrWCxNQUF0QixDQUR3RSxDQUMxQztBQUM5QixRQUFJbE0sZ0JBQWdCcHpCLEtBQWhCLEVBQXVCcS9CLGtCQUF2QixFQUEyQ3pNLFNBQTNDLEVBQXNEQyxNQUF0RCxDQUFKLEVBQW1FO0FBQ2pFO0FBQ0Q7O0FBRUQsUUFBSTV6QixPQUFPZSxNQUFNZixJQUFqQjtBQUNBLFFBQUlGLFdBQVdpQixNQUFNakIsUUFBckI7QUFDQSxRQUFJZ0csTUFBTS9FLE1BQU0rRSxHQUFoQjtBQUNBLFFBQUlxNUIsTUFBTXI1QixHQUFOLENBQUosRUFBZ0I7QUFDZCxVQUFJeEwsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsWUFBSTNDLFFBQVFBLEtBQUtzZ0MsR0FBakIsRUFBc0I7QUFDcEJKO0FBQ0Q7QUFDRCxZQUNFLENBQUNBLEtBQUQsSUFDQSxDQUFDbi9CLE1BQU1pb0IsRUFEUCxJQUVBLEVBQUV6bkIsT0FBT2diLGVBQVAsQ0FBdUI1Z0IsTUFBdkIsSUFBaUM0RixPQUFPZ2IsZUFBUCxDQUF1QmhYLE9BQXZCLENBQStCTyxHQUEvQixJQUFzQyxDQUFDLENBQTFFLENBRkEsSUFHQXZFLE9BQU9tYixnQkFBUCxDQUF3QjVXLEdBQXhCLENBSkYsRUFLRTtBQUNBMUcsZUFDRSw4QkFBOEIwRyxHQUE5QixHQUFvQyxjQUFwQyxHQUNBLDhEQURBLEdBRUEseUNBSEYsRUFJRS9FLE1BQU0rbkIsT0FKUjtBQU1EO0FBQ0Y7QUFDRC9uQixZQUFNOG5CLEdBQU4sR0FBWTluQixNQUFNaW9CLEVBQU4sR0FDUjRWLFFBQVFYLGVBQVIsQ0FBd0JsOUIsTUFBTWlvQixFQUE5QixFQUFrQ2xqQixHQUFsQyxDQURRLEdBRVI4NEIsUUFBUTNKLGFBQVIsQ0FBc0JudkIsR0FBdEIsRUFBMkIvRSxLQUEzQixDQUZKO0FBR0F3L0IsZUFBU3gvQixLQUFUOztBQUVBO0FBQ0E7QUFDRXkvQix1QkFBZXovQixLQUFmLEVBQXNCakIsUUFBdEIsRUFBZ0NzZ0Msa0JBQWhDO0FBQ0EsWUFBSWpCLE1BQU1uL0IsSUFBTixDQUFKLEVBQWlCO0FBQ2Z5Z0MsNEJBQWtCMS9CLEtBQWxCLEVBQXlCcS9CLGtCQUF6QjtBQUNEO0FBQ0RuTSxlQUFPTixTQUFQLEVBQWtCNXlCLE1BQU04bkIsR0FBeEIsRUFBNkIrSyxNQUE3QjtBQUNEOztBQUVELFVBQUl0NUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUMzQyxJQUF6QyxJQUFpREEsS0FBS3NnQyxHQUExRCxFQUErRDtBQUM3REo7QUFDRDtBQUNGLEtBcENELE1Bb0NPLElBQUlkLE9BQU9yK0IsTUFBTXFvQixTQUFiLENBQUosRUFBNkI7QUFDbENyb0IsWUFBTThuQixHQUFOLEdBQVkrVixRQUFRVCxhQUFSLENBQXNCcDlCLE1BQU02bkIsSUFBNUIsQ0FBWjtBQUNBcUwsYUFBT04sU0FBUCxFQUFrQjV5QixNQUFNOG5CLEdBQXhCLEVBQTZCK0ssTUFBN0I7QUFDRCxLQUhNLE1BR0E7QUFDTDd5QixZQUFNOG5CLEdBQU4sR0FBWStWLFFBQVFyZixjQUFSLENBQXVCeGUsTUFBTTZuQixJQUE3QixDQUFaO0FBQ0FxTCxhQUFPTixTQUFQLEVBQWtCNXlCLE1BQU04bkIsR0FBeEIsRUFBNkIrSyxNQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU08sZUFBVCxDQUEwQnB6QixLQUExQixFQUFpQ3EvQixrQkFBakMsRUFBcUR6TSxTQUFyRCxFQUFnRUMsTUFBaEUsRUFBd0U7QUFDdEUsUUFBSXYzQixJQUFJMEUsTUFBTWYsSUFBZDtBQUNBLFFBQUltL0IsTUFBTTlpQyxDQUFOLENBQUosRUFBYztBQUNaLFVBQUlxa0MsZ0JBQWdCdkIsTUFBTXArQixNQUFNbW9CLGlCQUFaLEtBQWtDN3NCLEVBQUUwM0IsU0FBeEQ7QUFDQSxVQUFJb0wsTUFBTTlpQyxJQUFJQSxFQUFFd0UsSUFBWixLQUFxQnMrQixNQUFNOWlDLElBQUlBLEVBQUV5RSxJQUFaLENBQXpCLEVBQTRDO0FBQzFDekUsVUFBRTBFLEtBQUYsRUFBUyxLQUFULENBQWUsZUFBZixFQUFnQzR5QixTQUFoQyxFQUEyQ0MsTUFBM0M7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSXVMLE1BQU1wK0IsTUFBTW1vQixpQkFBWixDQUFKLEVBQW9DO0FBQ2xDeVgsc0JBQWM1L0IsS0FBZCxFQUFxQnEvQixrQkFBckI7QUFDQSxZQUFJaEIsT0FBT3NCLGFBQVAsQ0FBSixFQUEyQjtBQUN6QkUsOEJBQW9CNy9CLEtBQXBCLEVBQTJCcS9CLGtCQUEzQixFQUErQ3pNLFNBQS9DLEVBQTBEQyxNQUExRDtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVMrTSxhQUFULENBQXdCNS9CLEtBQXhCLEVBQStCcS9CLGtCQUEvQixFQUFtRDtBQUNqRCxRQUFJakIsTUFBTXArQixNQUFNZixJQUFOLENBQVc2Z0MsYUFBakIsQ0FBSixFQUFxQztBQUNuQ1QseUJBQW1COWpDLElBQW5CLENBQXdCSSxLQUF4QixDQUE4QjBqQyxrQkFBOUIsRUFBa0RyL0IsTUFBTWYsSUFBTixDQUFXNmdDLGFBQTdEO0FBQ0Q7QUFDRDkvQixVQUFNOG5CLEdBQU4sR0FBWTluQixNQUFNbW9CLGlCQUFOLENBQXdCc0UsR0FBcEM7QUFDQSxRQUFJc1QsWUFBWS8vQixLQUFaLENBQUosRUFBd0I7QUFDdEIwL0Isd0JBQWtCMS9CLEtBQWxCLEVBQXlCcS9CLGtCQUF6QjtBQUNBRyxlQUFTeC9CLEtBQVQ7QUFDRCxLQUhELE1BR087QUFDTDtBQUNBO0FBQ0E4OUIsa0JBQVk5OUIsS0FBWjtBQUNBO0FBQ0FxL0IseUJBQW1COWpDLElBQW5CLENBQXdCeUUsS0FBeEI7QUFDRDtBQUNGOztBQUVELFdBQVM2L0IsbUJBQVQsQ0FBOEI3L0IsS0FBOUIsRUFBcUNxL0Isa0JBQXJDLEVBQXlEek0sU0FBekQsRUFBb0VDLE1BQXBFLEVBQTRFO0FBQzFFLFFBQUl2M0IsQ0FBSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSTBrQyxZQUFZaGdDLEtBQWhCO0FBQ0EsV0FBT2dnQyxVQUFVN1gsaUJBQWpCLEVBQW9DO0FBQ2xDNlgsa0JBQVlBLFVBQVU3WCxpQkFBVixDQUE0QndFLE1BQXhDO0FBQ0EsVUFBSXlSLE1BQU05aUMsSUFBSTBrQyxVQUFVL2dDLElBQXBCLEtBQTZCbS9CLE1BQU05aUMsSUFBSUEsRUFBRTJrQyxVQUFaLENBQWpDLEVBQTBEO0FBQ3hELGFBQUsza0MsSUFBSSxDQUFULEVBQVlBLElBQUl1YSxJQUFJcXFCLFFBQUosQ0FBYXRsQyxNQUE3QixFQUFxQyxFQUFFVSxDQUF2QyxFQUEwQztBQUN4Q3VhLGNBQUlxcUIsUUFBSixDQUFhNWtDLENBQWIsRUFBZ0I0aUMsU0FBaEIsRUFBMkI4QixTQUEzQjtBQUNEO0FBQ0RYLDJCQUFtQjlqQyxJQUFuQixDQUF3QnlrQyxTQUF4QjtBQUNBO0FBQ0Q7QUFDRjtBQUNEO0FBQ0E7QUFDQTlNLFdBQU9OLFNBQVAsRUFBa0I1eUIsTUFBTThuQixHQUF4QixFQUE2QitLLE1BQTdCO0FBQ0Q7O0FBRUQsV0FBU0ssTUFBVCxDQUFpQmwwQixNQUFqQixFQUF5QjhvQixHQUF6QixFQUE4QmhwQixHQUE5QixFQUFtQztBQUNqQyxRQUFJcy9CLE1BQU1wL0IsTUFBTixDQUFKLEVBQW1CO0FBQ2pCLFVBQUlvL0IsTUFBTXQvQixHQUFOLENBQUosRUFBZ0I7QUFDZCsrQixnQkFBUVIsWUFBUixDQUFxQnIrQixNQUFyQixFQUE2QjhvQixHQUE3QixFQUFrQ2hwQixHQUFsQztBQUNELE9BRkQsTUFFTztBQUNMKytCLGdCQUFRSixXQUFSLENBQW9CeitCLE1BQXBCLEVBQTRCOG9CLEdBQTVCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVMyWCxjQUFULENBQXlCei9CLEtBQXpCLEVBQWdDakIsUUFBaEMsRUFBMENzZ0Msa0JBQTFDLEVBQThEO0FBQzVELFFBQUlqa0MsTUFBTW1ILE9BQU4sQ0FBY3hELFFBQWQsQ0FBSixFQUE2QjtBQUMzQixXQUFLLElBQUl6RCxJQUFJLENBQWIsRUFBZ0JBLElBQUl5RCxTQUFTbkUsTUFBN0IsRUFBcUMsRUFBRVUsQ0FBdkMsRUFBMEM7QUFDeEM4akMsa0JBQVVyZ0MsU0FBU3pELENBQVQsQ0FBVixFQUF1QitqQyxrQkFBdkIsRUFBMkNyL0IsTUFBTThuQixHQUFqRCxFQUFzRCxJQUF0RCxFQUE0RCxJQUE1RDtBQUNEO0FBQ0YsS0FKRCxNQUlPLElBQUl2TyxZQUFZdlosTUFBTTZuQixJQUFsQixDQUFKLEVBQTZCO0FBQ2xDZ1csY0FBUUosV0FBUixDQUFvQno5QixNQUFNOG5CLEdBQTFCLEVBQStCK1YsUUFBUXJmLGNBQVIsQ0FBdUJ4ZSxNQUFNNm5CLElBQTdCLENBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTa1ksV0FBVCxDQUFzQi8vQixLQUF0QixFQUE2QjtBQUMzQixXQUFPQSxNQUFNbW9CLGlCQUFiLEVBQWdDO0FBQzlCbm9CLGNBQVFBLE1BQU1tb0IsaUJBQU4sQ0FBd0J3RSxNQUFoQztBQUNEO0FBQ0QsV0FBT3lSLE1BQU1wK0IsTUFBTStFLEdBQVosQ0FBUDtBQUNEOztBQUVELFdBQVMyNkIsaUJBQVQsQ0FBNEIxL0IsS0FBNUIsRUFBbUNxL0Isa0JBQW5DLEVBQXVEO0FBQ3JELFNBQUssSUFBSXBVLE1BQU0sQ0FBZixFQUFrQkEsTUFBTXBWLElBQUl6TSxNQUFKLENBQVd4TyxNQUFuQyxFQUEyQyxFQUFFcXdCLEdBQTdDLEVBQWtEO0FBQ2hEcFYsVUFBSXpNLE1BQUosQ0FBVzZoQixHQUFYLEVBQWdCaVQsU0FBaEIsRUFBMkJsK0IsS0FBM0I7QUFDRDtBQUNEMUUsUUFBSTBFLE1BQU1mLElBQU4sQ0FBV2EsSUFBZixDQUpxRCxDQUloQztBQUNyQixRQUFJcytCLE1BQU05aUMsQ0FBTixDQUFKLEVBQWM7QUFDWixVQUFJOGlDLE1BQU05aUMsRUFBRThOLE1BQVIsQ0FBSixFQUFxQjtBQUFFOU4sVUFBRThOLE1BQUYsQ0FBUzgwQixTQUFULEVBQW9CbCtCLEtBQXBCO0FBQTZCO0FBQ3BELFVBQUlvK0IsTUFBTTlpQyxFQUFFNDNCLE1BQVIsQ0FBSixFQUFxQjtBQUFFbU0sMkJBQW1COWpDLElBQW5CLENBQXdCeUUsS0FBeEI7QUFBaUM7QUFDekQ7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFTdy9CLFFBQVQsQ0FBbUJ4L0IsS0FBbkIsRUFBMEI7QUFDeEIsUUFBSTFFLENBQUo7QUFDQSxRQUFJNmtDLFdBQVduZ0MsS0FBZjtBQUNBLFdBQU9tZ0MsUUFBUCxFQUFpQjtBQUNmLFVBQUkvQixNQUFNOWlDLElBQUk2a0MsU0FBU3BZLE9BQW5CLEtBQStCcVcsTUFBTTlpQyxJQUFJQSxFQUFFbU0sUUFBRixDQUFXMjRCLFFBQXJCLENBQW5DLEVBQW1FO0FBQ2pFdkMsZ0JBQVFaLFlBQVIsQ0FBcUJqOUIsTUFBTThuQixHQUEzQixFQUFnQ3hzQixDQUFoQyxFQUFtQyxFQUFuQztBQUNEO0FBQ0Q2a0MsaUJBQVdBLFNBQVNuaEMsTUFBcEI7QUFDRDtBQUNEO0FBQ0EsUUFBSW8vQixNQUFNOWlDLElBQUlvd0IsY0FBVixLQUNBcHdCLE1BQU0wRSxNQUFNK25CLE9BRFosSUFFQXFXLE1BQU05aUMsSUFBSUEsRUFBRW1NLFFBQUYsQ0FBVzI0QixRQUFyQixDQUZKLEVBRW9DO0FBQ2xDdkMsY0FBUVosWUFBUixDQUFxQmo5QixNQUFNOG5CLEdBQTNCLEVBQWdDeHNCLENBQWhDLEVBQW1DLEVBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTK2tDLFNBQVQsQ0FBb0J6TixTQUFwQixFQUErQkMsTUFBL0IsRUFBdUMvSixNQUF2QyxFQUErQ3dYLFFBQS9DLEVBQXlEMUIsTUFBekQsRUFBaUVTLGtCQUFqRSxFQUFxRjtBQUNuRixXQUFPaUIsWUFBWTFCLE1BQW5CLEVBQTJCLEVBQUUwQixRQUE3QixFQUF1QztBQUNyQ2xCLGdCQUFVdFcsT0FBT3dYLFFBQVAsQ0FBVixFQUE0QmpCLGtCQUE1QixFQUFnRHpNLFNBQWhELEVBQTJEQyxNQUEzRDtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzBOLGlCQUFULENBQTRCdmdDLEtBQTVCLEVBQW1DO0FBQ2pDLFFBQUkxRSxDQUFKLEVBQU9zUixDQUFQO0FBQ0EsUUFBSTNOLE9BQU9lLE1BQU1mLElBQWpCO0FBQ0EsUUFBSW0vQixNQUFNbi9CLElBQU4sQ0FBSixFQUFpQjtBQUNmLFVBQUltL0IsTUFBTTlpQyxJQUFJMkQsS0FBS2EsSUFBZixLQUF3QnMrQixNQUFNOWlDLElBQUlBLEVBQUUrRSxPQUFaLENBQTVCLEVBQWtEO0FBQUUvRSxVQUFFMEUsS0FBRjtBQUFXO0FBQy9ELFdBQUsxRSxJQUFJLENBQVQsRUFBWUEsSUFBSXVhLElBQUl4VixPQUFKLENBQVl6RixNQUE1QixFQUFvQyxFQUFFVSxDQUF0QyxFQUF5QztBQUFFdWEsWUFBSXhWLE9BQUosQ0FBWS9FLENBQVosRUFBZTBFLEtBQWY7QUFBd0I7QUFDcEU7QUFDRCxRQUFJbytCLE1BQU05aUMsSUFBSTBFLE1BQU1qQixRQUFoQixDQUFKLEVBQStCO0FBQzdCLFdBQUs2TixJQUFJLENBQVQsRUFBWUEsSUFBSTVNLE1BQU1qQixRQUFOLENBQWVuRSxNQUEvQixFQUF1QyxFQUFFZ1MsQ0FBekMsRUFBNEM7QUFDMUMyekIsMEJBQWtCdmdDLE1BQU1qQixRQUFOLENBQWU2TixDQUFmLENBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVM0ekIsWUFBVCxDQUF1QjVOLFNBQXZCLEVBQWtDOUosTUFBbEMsRUFBMEN3WCxRQUExQyxFQUFvRDFCLE1BQXBELEVBQTREO0FBQzFELFdBQU8wQixZQUFZMUIsTUFBbkIsRUFBMkIsRUFBRTBCLFFBQTdCLEVBQXVDO0FBQ3JDLFVBQUlHLEtBQUszWCxPQUFPd1gsUUFBUCxDQUFUO0FBQ0EsVUFBSWxDLE1BQU1xQyxFQUFOLENBQUosRUFBZTtBQUNiLFlBQUlyQyxNQUFNcUMsR0FBRzE3QixHQUFULENBQUosRUFBbUI7QUFDakIyN0Isb0NBQTBCRCxFQUExQjtBQUNBRiw0QkFBa0JFLEVBQWxCO0FBQ0QsU0FIRCxNQUdPO0FBQUU7QUFDUHZCLHFCQUFXdUIsR0FBRzNZLEdBQWQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTNFkseUJBQVQsQ0FBb0MxZ0MsS0FBcEMsRUFBMkMyZ0MsRUFBM0MsRUFBK0M7QUFDN0MsUUFBSXZDLE1BQU11QyxFQUFOLEtBQWF2QyxNQUFNcCtCLE1BQU1mLElBQVosQ0FBakIsRUFBb0M7QUFDbEMsVUFBSXNyQixZQUFZMVUsSUFBSXNELE1BQUosQ0FBV3ZlLE1BQVgsR0FBb0IsQ0FBcEM7QUFDQSxVQUFJd2pDLE1BQU11QyxFQUFOLENBQUosRUFBZTtBQUNiO0FBQ0E7QUFDQUEsV0FBR3BXLFNBQUgsSUFBZ0JBLFNBQWhCO0FBQ0QsT0FKRCxNQUlPO0FBQ0w7QUFDQW9XLGFBQUszQixXQUFXaC9CLE1BQU04bkIsR0FBakIsRUFBc0J5QyxTQUF0QixDQUFMO0FBQ0Q7QUFDRDtBQUNBLFVBQUk2VCxNQUFNOWlDLElBQUkwRSxNQUFNbW9CLGlCQUFoQixLQUFzQ2lXLE1BQU05aUMsSUFBSUEsRUFBRXF4QixNQUFaLENBQXRDLElBQTZEeVIsTUFBTTlpQyxFQUFFMkQsSUFBUixDQUFqRSxFQUFnRjtBQUM5RXloQyxrQ0FBMEJwbEMsQ0FBMUIsRUFBNkJxbEMsRUFBN0I7QUFDRDtBQUNELFdBQUtybEMsSUFBSSxDQUFULEVBQVlBLElBQUl1YSxJQUFJc0QsTUFBSixDQUFXdmUsTUFBM0IsRUFBbUMsRUFBRVUsQ0FBckMsRUFBd0M7QUFDdEN1YSxZQUFJc0QsTUFBSixDQUFXN2QsQ0FBWCxFQUFjMEUsS0FBZCxFQUFxQjJnQyxFQUFyQjtBQUNEO0FBQ0QsVUFBSXZDLE1BQU05aUMsSUFBSTBFLE1BQU1mLElBQU4sQ0FBV2EsSUFBckIsS0FBOEJzK0IsTUFBTTlpQyxJQUFJQSxFQUFFNmQsTUFBWixDQUFsQyxFQUF1RDtBQUNyRDdkLFVBQUUwRSxLQUFGLEVBQVMyZ0MsRUFBVDtBQUNELE9BRkQsTUFFTztBQUNMQTtBQUNEO0FBQ0YsS0F0QkQsTUFzQk87QUFDTHpCLGlCQUFXbC9CLE1BQU04bkIsR0FBakI7QUFDRDtBQUNGOztBQUVELFdBQVM4WSxjQUFULENBQXlCaE8sU0FBekIsRUFBb0NpTyxLQUFwQyxFQUEyQ0MsS0FBM0MsRUFBa0R6QixrQkFBbEQsRUFBc0UwQixVQUF0RSxFQUFrRjtBQUNoRixRQUFJQyxjQUFjLENBQWxCO0FBQ0EsUUFBSUMsY0FBYyxDQUFsQjtBQUNBLFFBQUlDLFlBQVlMLE1BQU1qbUMsTUFBTixHQUFlLENBQS9CO0FBQ0EsUUFBSXVtQyxnQkFBZ0JOLE1BQU0sQ0FBTixDQUFwQjtBQUNBLFFBQUlPLGNBQWNQLE1BQU1LLFNBQU4sQ0FBbEI7QUFDQSxRQUFJRyxZQUFZUCxNQUFNbG1DLE1BQU4sR0FBZSxDQUEvQjtBQUNBLFFBQUkwbUMsZ0JBQWdCUixNQUFNLENBQU4sQ0FBcEI7QUFDQSxRQUFJUyxjQUFjVCxNQUFNTyxTQUFOLENBQWxCO0FBQ0EsUUFBSUcsV0FBSixFQUFpQkMsUUFBakIsRUFBMkJDLFNBQTNCLEVBQXNDN08sTUFBdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSThPLFVBQVUsQ0FBQ1osVUFBZjs7QUFFQSxXQUFPQyxlQUFlRSxTQUFmLElBQTRCRCxlQUFlSSxTQUFsRCxFQUE2RDtBQUMzRCxVQUFJbEQsUUFBUWdELGFBQVIsQ0FBSixFQUE0QjtBQUMxQkEsd0JBQWdCTixNQUFNLEVBQUVHLFdBQVIsQ0FBaEIsQ0FEMEIsQ0FDWTtBQUN2QyxPQUZELE1BRU8sSUFBSTdDLFFBQVFpRCxXQUFSLENBQUosRUFBMEI7QUFDL0JBLHNCQUFjUCxNQUFNLEVBQUVLLFNBQVIsQ0FBZDtBQUNELE9BRk0sTUFFQSxJQUFJNUMsVUFBVTZDLGFBQVYsRUFBeUJHLGFBQXpCLENBQUosRUFBNkM7QUFDbERNLG1CQUFXVCxhQUFYLEVBQTBCRyxhQUExQixFQUF5Q2pDLGtCQUF6QztBQUNBOEIsd0JBQWdCTixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDQU0sd0JBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxPQUpNLE1BSUEsSUFBSTNDLFVBQVU4QyxXQUFWLEVBQXVCRyxXQUF2QixDQUFKLEVBQXlDO0FBQzlDSyxtQkFBV1IsV0FBWCxFQUF3QkcsV0FBeEIsRUFBcUNsQyxrQkFBckM7QUFDQStCLHNCQUFjUCxNQUFNLEVBQUVLLFNBQVIsQ0FBZDtBQUNBSyxzQkFBY1QsTUFBTSxFQUFFTyxTQUFSLENBQWQ7QUFDRCxPQUpNLE1BSUEsSUFBSS9DLFVBQVU2QyxhQUFWLEVBQXlCSSxXQUF6QixDQUFKLEVBQTJDO0FBQUU7QUFDbERLLG1CQUFXVCxhQUFYLEVBQTBCSSxXQUExQixFQUF1Q2xDLGtCQUF2QztBQUNBc0MsbUJBQVc5RCxRQUFRUixZQUFSLENBQXFCekssU0FBckIsRUFBZ0N1TyxjQUFjclosR0FBOUMsRUFBbUQrVixRQUFRSCxXQUFSLENBQW9CMEQsWUFBWXRaLEdBQWhDLENBQW5ELENBQVg7QUFDQXFaLHdCQUFnQk4sTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0FPLHNCQUFjVCxNQUFNLEVBQUVPLFNBQVIsQ0FBZDtBQUNELE9BTE0sTUFLQSxJQUFJL0MsVUFBVThDLFdBQVYsRUFBdUJFLGFBQXZCLENBQUosRUFBMkM7QUFBRTtBQUNsRE0sbUJBQVdSLFdBQVgsRUFBd0JFLGFBQXhCLEVBQXVDakMsa0JBQXZDO0FBQ0FzQyxtQkFBVzlELFFBQVFSLFlBQVIsQ0FBcUJ6SyxTQUFyQixFQUFnQ3dPLFlBQVl0WixHQUE1QyxFQUFpRHFaLGNBQWNyWixHQUEvRCxDQUFYO0FBQ0FzWixzQkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDQUksd0JBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxPQUxNLE1BS0E7QUFDTCxZQUFJOUMsUUFBUXFELFdBQVIsQ0FBSixFQUEwQjtBQUFFQSx3QkFBYzlDLGtCQUFrQm1DLEtBQWxCLEVBQXlCRyxXQUF6QixFQUFzQ0UsU0FBdEMsQ0FBZDtBQUFpRTtBQUM3Rk8sbUJBQVdyRCxNQUFNa0QsY0FBY3ovQixHQUFwQixJQUEyQjIvQixZQUFZRixjQUFjei9CLEdBQTFCLENBQTNCLEdBQTRELElBQXZFO0FBQ0EsWUFBSXM4QixRQUFRc0QsUUFBUixDQUFKLEVBQXVCO0FBQUU7QUFDdkJyQyxvQkFBVWtDLGFBQVYsRUFBeUJqQyxrQkFBekIsRUFBNkN6TSxTQUE3QyxFQUF3RHVPLGNBQWNyWixHQUF0RTtBQUNBd1osMEJBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxTQUhELE1BR087QUFDTFMsc0JBQVliLE1BQU1ZLFFBQU4sQ0FBWjtBQUNBO0FBQ0EsY0FBSWxvQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDOC9CLFNBQTlDLEVBQXlEO0FBQ3ZEcmpDLGlCQUNFLHdFQUNBLDZDQUZGO0FBSUQ7QUFDRCxjQUFJaWdDLFVBQVVvRCxTQUFWLEVBQXFCSixhQUFyQixDQUFKLEVBQXlDO0FBQ3ZDTSx1QkFBV0YsU0FBWCxFQUFzQkosYUFBdEIsRUFBcUNqQyxrQkFBckM7QUFDQXdCLGtCQUFNWSxRQUFOLElBQWtCbmhDLFNBQWxCO0FBQ0FxaEMsdUJBQVc5RCxRQUFRUixZQUFSLENBQXFCekssU0FBckIsRUFBZ0MwTyxjQUFjeFosR0FBOUMsRUFBbURxWixjQUFjclosR0FBakUsQ0FBWDtBQUNBd1osNEJBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxXQUxELE1BS087QUFDTDtBQUNBN0Isc0JBQVVrQyxhQUFWLEVBQXlCakMsa0JBQXpCLEVBQTZDek0sU0FBN0MsRUFBd0R1TyxjQUFjclosR0FBdEU7QUFDQXdaLDRCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxRQUFJRCxjQUFjRSxTQUFsQixFQUE2QjtBQUMzQnJPLGVBQVNzTCxRQUFRMkMsTUFBTU8sWUFBWSxDQUFsQixDQUFSLElBQWdDLElBQWhDLEdBQXVDUCxNQUFNTyxZQUFZLENBQWxCLEVBQXFCdlosR0FBckU7QUFDQXVZLGdCQUFVek4sU0FBVixFQUFxQkMsTUFBckIsRUFBNkJpTyxLQUE3QixFQUFvQ0csV0FBcEMsRUFBaURJLFNBQWpELEVBQTREaEMsa0JBQTVEO0FBQ0QsS0FIRCxNQUdPLElBQUk0QixjQUFjSSxTQUFsQixFQUE2QjtBQUNsQ2IsbUJBQWE1TixTQUFiLEVBQXdCaU8sS0FBeEIsRUFBK0JHLFdBQS9CLEVBQTRDRSxTQUE1QztBQUNEO0FBQ0Y7O0FBRUQsV0FBU1UsVUFBVCxDQUFxQnhoQyxRQUFyQixFQUErQkosS0FBL0IsRUFBc0NxL0Isa0JBQXRDLEVBQTBEMEIsVUFBMUQsRUFBc0U7QUFDcEUsUUFBSTNnQyxhQUFhSixLQUFqQixFQUF3QjtBQUN0QjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJcStCLE9BQU9yK0IsTUFBTXFHLFFBQWIsS0FDQWc0QixPQUFPaitCLFNBQVNpRyxRQUFoQixDQURBLElBRUFyRyxNQUFNNkIsR0FBTixLQUFjekIsU0FBU3lCLEdBRnZCLEtBR0N3OEIsT0FBT3IrQixNQUFNc29CLFFBQWIsS0FBMEIrVixPQUFPcitCLE1BQU11b0IsTUFBYixDQUgzQixDQUFKLEVBR3NEO0FBQ3BEdm9CLFlBQU04bkIsR0FBTixHQUFZMW5CLFNBQVMwbkIsR0FBckI7QUFDQTluQixZQUFNbW9CLGlCQUFOLEdBQTBCL25CLFNBQVMrbkIsaUJBQW5DO0FBQ0E7QUFDRDtBQUNELFFBQUk3c0IsQ0FBSjtBQUNBLFFBQUkyRCxPQUFPZSxNQUFNZixJQUFqQjtBQUNBLFFBQUltL0IsTUFBTW4vQixJQUFOLEtBQWVtL0IsTUFBTTlpQyxJQUFJMkQsS0FBS2EsSUFBZixDQUFmLElBQXVDcytCLE1BQU05aUMsSUFBSUEsRUFBRTZFLFFBQVosQ0FBM0MsRUFBa0U7QUFDaEU3RSxRQUFFOEUsUUFBRixFQUFZSixLQUFaO0FBQ0Q7QUFDRCxRQUFJOG5CLE1BQU05bkIsTUFBTThuQixHQUFOLEdBQVkxbkIsU0FBUzBuQixHQUEvQjtBQUNBLFFBQUkrWSxRQUFRemdDLFNBQVNyQixRQUFyQjtBQUNBLFFBQUkwaEMsS0FBS3pnQyxNQUFNakIsUUFBZjtBQUNBLFFBQUlxL0IsTUFBTW4vQixJQUFOLEtBQWU4Z0MsWUFBWS8vQixLQUFaLENBQW5CLEVBQXVDO0FBQ3JDLFdBQUsxRSxJQUFJLENBQVQsRUFBWUEsSUFBSXVhLElBQUk2SyxNQUFKLENBQVc5bEIsTUFBM0IsRUFBbUMsRUFBRVUsQ0FBckMsRUFBd0M7QUFBRXVhLFlBQUk2SyxNQUFKLENBQVdwbEIsQ0FBWCxFQUFjOEUsUUFBZCxFQUF3QkosS0FBeEI7QUFBaUM7QUFDM0UsVUFBSW8rQixNQUFNOWlDLElBQUkyRCxLQUFLYSxJQUFmLEtBQXdCcytCLE1BQU05aUMsSUFBSUEsRUFBRW9sQixNQUFaLENBQTVCLEVBQWlEO0FBQUVwbEIsVUFBRThFLFFBQUYsRUFBWUosS0FBWjtBQUFxQjtBQUN6RTtBQUNELFFBQUltK0IsUUFBUW4rQixNQUFNNm5CLElBQWQsQ0FBSixFQUF5QjtBQUN2QixVQUFJdVcsTUFBTXlDLEtBQU4sS0FBZ0J6QyxNQUFNcUMsRUFBTixDQUFwQixFQUErQjtBQUM3QixZQUFJSSxVQUFVSixFQUFkLEVBQWtCO0FBQUVHLHlCQUFlOVksR0FBZixFQUFvQitZLEtBQXBCLEVBQTJCSixFQUEzQixFQUErQnBCLGtCQUEvQixFQUFtRDBCLFVBQW5EO0FBQWlFO0FBQ3RGLE9BRkQsTUFFTyxJQUFJM0MsTUFBTXFDLEVBQU4sQ0FBSixFQUFlO0FBQ3BCLFlBQUlyQyxNQUFNaCtCLFNBQVN5bkIsSUFBZixDQUFKLEVBQTBCO0FBQUVnVyxrQkFBUUYsY0FBUixDQUF1QjdWLEdBQXZCLEVBQTRCLEVBQTVCO0FBQWtDO0FBQzlEdVksa0JBQVV2WSxHQUFWLEVBQWUsSUFBZixFQUFxQjJZLEVBQXJCLEVBQXlCLENBQXpCLEVBQTRCQSxHQUFHN2xDLE1BQUgsR0FBWSxDQUF4QyxFQUEyQ3lrQyxrQkFBM0M7QUFDRCxPQUhNLE1BR0EsSUFBSWpCLE1BQU15QyxLQUFOLENBQUosRUFBa0I7QUFDdkJMLHFCQUFhMVksR0FBYixFQUFrQitZLEtBQWxCLEVBQXlCLENBQXpCLEVBQTRCQSxNQUFNam1DLE1BQU4sR0FBZSxDQUEzQztBQUNELE9BRk0sTUFFQSxJQUFJd2pDLE1BQU1oK0IsU0FBU3luQixJQUFmLENBQUosRUFBMEI7QUFDL0JnVyxnQkFBUUYsY0FBUixDQUF1QjdWLEdBQXZCLEVBQTRCLEVBQTVCO0FBQ0Q7QUFDRixLQVhELE1BV08sSUFBSTFuQixTQUFTeW5CLElBQVQsS0FBa0I3bkIsTUFBTTZuQixJQUE1QixFQUFrQztBQUN2Q2dXLGNBQVFGLGNBQVIsQ0FBdUI3VixHQUF2QixFQUE0QjluQixNQUFNNm5CLElBQWxDO0FBQ0Q7QUFDRCxRQUFJdVcsTUFBTW4vQixJQUFOLENBQUosRUFBaUI7QUFDZixVQUFJbS9CLE1BQU05aUMsSUFBSTJELEtBQUthLElBQWYsS0FBd0JzK0IsTUFBTTlpQyxJQUFJQSxFQUFFdW1DLFNBQVosQ0FBNUIsRUFBb0Q7QUFBRXZtQyxVQUFFOEUsUUFBRixFQUFZSixLQUFaO0FBQXFCO0FBQzVFO0FBQ0Y7O0FBRUQsV0FBUzhoQyxnQkFBVCxDQUEyQjloQyxLQUEzQixFQUFrQ3pGLEtBQWxDLEVBQXlDd25DLE9BQXpDLEVBQWtEO0FBQ2hEO0FBQ0E7QUFDQSxRQUFJMUQsT0FBTzBELE9BQVAsS0FBbUIzRCxNQUFNcCtCLE1BQU1oQixNQUFaLENBQXZCLEVBQTRDO0FBQzFDZ0IsWUFBTWhCLE1BQU4sQ0FBYUMsSUFBYixDQUFrQjZnQyxhQUFsQixHQUFrQ3ZsQyxLQUFsQztBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssSUFBSWUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZixNQUFNSyxNQUExQixFQUFrQyxFQUFFVSxDQUFwQyxFQUF1QztBQUNyQ2YsY0FBTWUsQ0FBTixFQUFTMkQsSUFBVCxDQUFjYSxJQUFkLENBQW1Cb3pCLE1BQW5CLENBQTBCMzRCLE1BQU1lLENBQU4sQ0FBMUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSTBtQyxTQUFTLEtBQWI7QUFDQTtBQUNBO0FBQ0EsTUFBSUMsbUJBQW1CbnBCLFFBQVEsK0NBQVIsQ0FBdkI7O0FBRUE7QUFDQSxXQUFTb3BCLE9BQVQsQ0FBa0JwYSxHQUFsQixFQUF1QjluQixLQUF2QixFQUE4QnEvQixrQkFBOUIsRUFBa0Q7QUFDaEQsUUFBSTlsQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJLENBQUN1Z0MsZ0JBQWdCcmEsR0FBaEIsRUFBcUI5bkIsS0FBckIsQ0FBTCxFQUFrQztBQUNoQyxlQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0RBLFVBQU04bkIsR0FBTixHQUFZQSxHQUFaO0FBQ0EsUUFBSS9pQixNQUFNL0UsTUFBTStFLEdBQWhCO0FBQ0EsUUFBSTlGLE9BQU9lLE1BQU1mLElBQWpCO0FBQ0EsUUFBSUYsV0FBV2lCLE1BQU1qQixRQUFyQjtBQUNBLFFBQUlxL0IsTUFBTW4vQixJQUFOLENBQUosRUFBaUI7QUFDZixVQUFJbS9CLE1BQU05aUMsSUFBSTJELEtBQUthLElBQWYsS0FBd0JzK0IsTUFBTTlpQyxJQUFJQSxFQUFFeUUsSUFBWixDQUE1QixFQUErQztBQUFFekUsVUFBRTBFLEtBQUYsRUFBUyxJQUFULENBQWMsZUFBZDtBQUFpQztBQUNsRixVQUFJbytCLE1BQU05aUMsSUFBSTBFLE1BQU1tb0IsaUJBQWhCLENBQUosRUFBd0M7QUFDdEM7QUFDQXlYLHNCQUFjNS9CLEtBQWQsRUFBcUJxL0Isa0JBQXJCO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFFBQUlqQixNQUFNcjVCLEdBQU4sQ0FBSixFQUFnQjtBQUNkLFVBQUlxNUIsTUFBTXIvQixRQUFOLENBQUosRUFBcUI7QUFDbkI7QUFDQSxZQUFJLENBQUMrb0IsSUFBSXNhLGFBQUosRUFBTCxFQUEwQjtBQUN4QjNDLHlCQUFlei9CLEtBQWYsRUFBc0JqQixRQUF0QixFQUFnQ3NnQyxrQkFBaEM7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFJZ0QsZ0JBQWdCLElBQXBCO0FBQ0EsY0FBSXhHLFlBQVkvVCxJQUFJd2EsVUFBcEI7QUFDQSxlQUFLLElBQUlyWCxNQUFNLENBQWYsRUFBa0JBLE1BQU1sc0IsU0FBU25FLE1BQWpDLEVBQXlDcXdCLEtBQXpDLEVBQWdEO0FBQzlDLGdCQUFJLENBQUM0USxTQUFELElBQWMsQ0FBQ3FHLFFBQVFyRyxTQUFSLEVBQW1COThCLFNBQVNrc0IsR0FBVCxDQUFuQixFQUFrQ29VLGtCQUFsQyxDQUFuQixFQUEwRTtBQUN4RWdELDhCQUFnQixLQUFoQjtBQUNBO0FBQ0Q7QUFDRHhHLHdCQUFZQSxVQUFVNkIsV0FBdEI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxjQUFJLENBQUMyRSxhQUFELElBQWtCeEcsU0FBdEIsRUFBaUM7QUFDL0IsZ0JBQUl0aUMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFDQSxPQUFPdEQsT0FBUCxLQUFtQixXQURuQixJQUVBLENBQUMwakMsTUFGTCxFQUVhO0FBQ1hBLHVCQUFTLElBQVQ7QUFDQTFqQyxzQkFBUUQsSUFBUixDQUFhLFVBQWIsRUFBeUJ5cEIsR0FBekI7QUFDQXhwQixzQkFBUUQsSUFBUixDQUFhLHFDQUFiLEVBQW9EeXBCLElBQUl5YSxVQUF4RCxFQUFvRXhqQyxRQUFwRTtBQUNEO0FBQ0QsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFVBQUlxL0IsTUFBTW4vQixJQUFOLENBQUosRUFBaUI7QUFDZixhQUFLLElBQUk0QyxHQUFULElBQWdCNUMsSUFBaEIsRUFBc0I7QUFDcEIsY0FBSSxDQUFDZ2pDLGlCQUFpQnBnQyxHQUFqQixDQUFMLEVBQTRCO0FBQzFCNjlCLDhCQUFrQjEvQixLQUFsQixFQUF5QnEvQixrQkFBekI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBckNELE1BcUNPLElBQUl2WCxJQUFJN29CLElBQUosS0FBYWUsTUFBTTZuQixJQUF2QixFQUE2QjtBQUNsQ0MsVUFBSTdvQixJQUFKLEdBQVdlLE1BQU02bkIsSUFBakI7QUFDRDtBQUNELFdBQU8sSUFBUDtBQUNEOztBQUVELFdBQVNzYSxlQUFULENBQTBCMVosSUFBMUIsRUFBZ0N6b0IsS0FBaEMsRUFBdUM7QUFDckMsUUFBSW8rQixNQUFNcCtCLE1BQU0rRSxHQUFaLENBQUosRUFBc0I7QUFDcEIsYUFDRS9FLE1BQU0rRSxHQUFOLENBQVVQLE9BQVYsQ0FBa0IsZUFBbEIsTUFBdUMsQ0FBdkMsSUFDQXhFLE1BQU0rRSxHQUFOLENBQVVrVSxXQUFWLFFBQTZCd1AsS0FBS3NVLE9BQUwsSUFBZ0J0VSxLQUFLc1UsT0FBTCxDQUFhOWpCLFdBQWIsRUFBN0MsQ0FGRjtBQUlELEtBTEQsTUFLTztBQUNMLGFBQU93UCxLQUFLK1osUUFBTCxNQUFtQnhpQyxNQUFNcW9CLFNBQU4sR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBekMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxTQUFTb2EsS0FBVCxDQUFnQnJpQyxRQUFoQixFQUEwQkosS0FBMUIsRUFBaUNzc0IsU0FBakMsRUFBNEN5VSxVQUE1QyxFQUF3RG5PLFNBQXhELEVBQW1FQyxNQUFuRSxFQUEyRTtBQUNoRixRQUFJc0wsUUFBUW4rQixLQUFSLENBQUosRUFBb0I7QUFDbEIsVUFBSW8rQixNQUFNaCtCLFFBQU4sQ0FBSixFQUFxQjtBQUFFbWdDLDBCQUFrQm5nQyxRQUFsQjtBQUE4QjtBQUNyRDtBQUNEOztBQUVELFFBQUlzaUMsaUJBQWlCLEtBQXJCO0FBQ0EsUUFBSXJELHFCQUFxQixFQUF6Qjs7QUFFQSxRQUFJbEIsUUFBUS85QixRQUFSLENBQUosRUFBdUI7QUFDckI7QUFDQXNpQyx1QkFBaUIsSUFBakI7QUFDQXRELGdCQUFVcC9CLEtBQVYsRUFBaUJxL0Isa0JBQWpCLEVBQXFDek0sU0FBckMsRUFBZ0RDLE1BQWhEO0FBQ0QsS0FKRCxNQUlPO0FBQ0wsVUFBSThQLGdCQUFnQnZFLE1BQU1oK0IsU0FBU29pQyxRQUFmLENBQXBCO0FBQ0EsVUFBSSxDQUFDRyxhQUFELElBQWtCckUsVUFBVWwrQixRQUFWLEVBQW9CSixLQUFwQixDQUF0QixFQUFrRDtBQUNoRDtBQUNBNGhDLG1CQUFXeGhDLFFBQVgsRUFBcUJKLEtBQXJCLEVBQTRCcS9CLGtCQUE1QixFQUFnRDBCLFVBQWhEO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSTRCLGFBQUosRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBSXZpQyxTQUFTb2lDLFFBQVQsS0FBc0IsQ0FBdEIsSUFBMkJwaUMsU0FBU3dpQyxZQUFULENBQXNCLGlCQUF0QixDQUEvQixFQUF5RTtBQUN2RXhpQyxxQkFBU3lpQyxlQUFULENBQXlCLGlCQUF6QjtBQUNBdlcsd0JBQVksSUFBWjtBQUNEO0FBQ0QsY0FBSStSLE9BQU8vUixTQUFQLENBQUosRUFBdUI7QUFDckIsZ0JBQUk0VixRQUFROWhDLFFBQVIsRUFBa0JKLEtBQWxCLEVBQXlCcS9CLGtCQUF6QixDQUFKLEVBQWtEO0FBQ2hEeUMsK0JBQWlCOWhDLEtBQWpCLEVBQXdCcS9CLGtCQUF4QixFQUE0QyxJQUE1QztBQUNBLHFCQUFPai9CLFFBQVA7QUFDRCxhQUhELE1BR08sSUFBSTdHLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEdkQsbUJBQ0UsK0RBQ0EsOERBREEsR0FFQSwrREFGQSxHQUdBLDREQUhBLEdBSUEsMEJBTEY7QUFPRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBK0IscUJBQVcyK0IsWUFBWTMrQixRQUFaLENBQVg7QUFDRDtBQUNEO0FBQ0EsWUFBSTBpQyxTQUFTMWlDLFNBQVMwbkIsR0FBdEI7QUFDQSxZQUFJaWIsY0FBY2xGLFFBQVFqQyxVQUFSLENBQW1Ca0gsTUFBbkIsQ0FBbEI7QUFDQTFELGtCQUNFcC9CLEtBREYsRUFFRXEvQixrQkFGRjtBQUdFO0FBQ0E7QUFDQTtBQUNBeUQsZUFBT0UsUUFBUCxHQUFrQixJQUFsQixHQUF5QkQsV0FOM0IsRUFPRWxGLFFBQVFILFdBQVIsQ0FBb0JvRixNQUFwQixDQVBGOztBQVVBLFlBQUkxRSxNQUFNcCtCLE1BQU1oQixNQUFaLENBQUosRUFBeUI7QUFDdkI7QUFDQTtBQUNBLGNBQUltaEMsV0FBV25nQyxNQUFNaEIsTUFBckI7QUFDQSxpQkFBT21oQyxRQUFQLEVBQWlCO0FBQ2ZBLHFCQUFTclksR0FBVCxHQUFlOW5CLE1BQU04bkIsR0FBckI7QUFDQXFZLHVCQUFXQSxTQUFTbmhDLE1BQXBCO0FBQ0Q7QUFDRCxjQUFJK2dDLFlBQVkvL0IsS0FBWixDQUFKLEVBQXdCO0FBQ3RCLGlCQUFLLElBQUkxRSxJQUFJLENBQWIsRUFBZ0JBLElBQUl1YSxJQUFJek0sTUFBSixDQUFXeE8sTUFBL0IsRUFBdUMsRUFBRVUsQ0FBekMsRUFBNEM7QUFDMUN1YSxrQkFBSXpNLE1BQUosQ0FBVzlOLENBQVgsRUFBYzRpQyxTQUFkLEVBQXlCbCtCLE1BQU1oQixNQUEvQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJby9CLE1BQU0yRSxXQUFOLENBQUosRUFBd0I7QUFDdEJ2Qyx1QkFBYXVDLFdBQWIsRUFBMEIsQ0FBQzNpQyxRQUFELENBQTFCLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDO0FBQ0QsU0FGRCxNQUVPLElBQUlnK0IsTUFBTWgrQixTQUFTMkUsR0FBZixDQUFKLEVBQXlCO0FBQzlCdzdCLDRCQUFrQm5nQyxRQUFsQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDBoQyxxQkFBaUI5aEMsS0FBakIsRUFBd0JxL0Isa0JBQXhCLEVBQTRDcUQsY0FBNUM7QUFDQSxXQUFPMWlDLE1BQU04bkIsR0FBYjtBQUNELEdBbkZEO0FBb0ZEOztBQUVEOztBQUVBLElBQUlwRCxhQUFhO0FBQ2Z0YixVQUFRNjVCLGdCQURPO0FBRWZ2aUIsVUFBUXVpQixnQkFGTztBQUdmNWlDLFdBQVMsU0FBUzZpQyxnQkFBVCxDQUEyQmxqQyxLQUEzQixFQUFrQztBQUN6Q2lqQyxxQkFBaUJqakMsS0FBakIsRUFBd0JrK0IsU0FBeEI7QUFDRDtBQUxjLENBQWpCOztBQVFBLFNBQVMrRSxnQkFBVCxDQUEyQjdpQyxRQUEzQixFQUFxQ0osS0FBckMsRUFBNEM7QUFDMUMsTUFBSUksU0FBU25CLElBQVQsQ0FBY3lsQixVQUFkLElBQTRCMWtCLE1BQU1mLElBQU4sQ0FBV3lsQixVQUEzQyxFQUF1RDtBQUNyRDJILFlBQVFqc0IsUUFBUixFQUFrQkosS0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQVNxc0IsT0FBVCxDQUFrQmpzQixRQUFsQixFQUE0QkosS0FBNUIsRUFBbUM7QUFDakMsTUFBSW1qQyxXQUFXL2lDLGFBQWE4OUIsU0FBNUI7QUFDQSxNQUFJa0YsWUFBWXBqQyxVQUFVaytCLFNBQTFCO0FBQ0EsTUFBSW1GLFVBQVVDLHNCQUFzQmxqQyxTQUFTbkIsSUFBVCxDQUFjeWxCLFVBQXBDLEVBQWdEdGtCLFNBQVMybkIsT0FBekQsQ0FBZDtBQUNBLE1BQUl3YixVQUFVRCxzQkFBc0J0akMsTUFBTWYsSUFBTixDQUFXeWxCLFVBQWpDLEVBQTZDMWtCLE1BQU0rbkIsT0FBbkQsQ0FBZDs7QUFFQSxNQUFJeWIsaUJBQWlCLEVBQXJCO0FBQ0EsTUFBSUMsb0JBQW9CLEVBQXhCOztBQUVBLE1BQUk1aEMsR0FBSixFQUFTNmhDLE1BQVQsRUFBaUI1bUMsR0FBakI7QUFDQSxPQUFLK0UsR0FBTCxJQUFZMGhDLE9BQVosRUFBcUI7QUFDbkJHLGFBQVNMLFFBQVF4aEMsR0FBUixDQUFUO0FBQ0EvRSxVQUFNeW1DLFFBQVExaEMsR0FBUixDQUFOO0FBQ0EsUUFBSSxDQUFDNmhDLE1BQUwsRUFBYTtBQUNYO0FBQ0FDLGlCQUFXN21DLEdBQVgsRUFBZ0IsTUFBaEIsRUFBd0JrRCxLQUF4QixFQUErQkksUUFBL0I7QUFDQSxVQUFJdEQsSUFBSXdZLEdBQUosSUFBV3hZLElBQUl3WSxHQUFKLENBQVFpTSxRQUF2QixFQUFpQztBQUMvQmlpQix1QkFBZWpvQyxJQUFmLENBQW9CdUIsR0FBcEI7QUFDRDtBQUNGLEtBTkQsTUFNTztBQUNMO0FBQ0FBLFVBQUlxekIsUUFBSixHQUFldVQsT0FBT25tQyxLQUF0QjtBQUNBb21DLGlCQUFXN21DLEdBQVgsRUFBZ0IsUUFBaEIsRUFBMEJrRCxLQUExQixFQUFpQ0ksUUFBakM7QUFDQSxVQUFJdEQsSUFBSXdZLEdBQUosSUFBV3hZLElBQUl3WSxHQUFKLENBQVFzdUIsZ0JBQXZCLEVBQXlDO0FBQ3ZDSCwwQkFBa0Jsb0MsSUFBbEIsQ0FBdUJ1QixHQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJMG1DLGVBQWU1b0MsTUFBbkIsRUFBMkI7QUFDekIsUUFBSWlwQyxhQUFhLFlBQVk7QUFDM0IsV0FBSyxJQUFJdm9DLElBQUksQ0FBYixFQUFnQkEsSUFBSWtvQyxlQUFlNW9DLE1BQW5DLEVBQTJDVSxHQUEzQyxFQUFnRDtBQUM5Q3FvQyxtQkFBV0gsZUFBZWxvQyxDQUFmLENBQVgsRUFBOEIsVUFBOUIsRUFBMEMwRSxLQUExQyxFQUFpREksUUFBakQ7QUFDRDtBQUNGLEtBSkQ7QUFLQSxRQUFJK2lDLFFBQUosRUFBYztBQUNaMVoscUJBQWV6cEIsTUFBTWYsSUFBTixDQUFXYSxJQUFYLEtBQW9CRSxNQUFNZixJQUFOLENBQVdhLElBQVgsR0FBa0IsRUFBdEMsQ0FBZixFQUEwRCxRQUExRCxFQUFvRStqQyxVQUFwRTtBQUNELEtBRkQsTUFFTztBQUNMQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUosa0JBQWtCN29DLE1BQXRCLEVBQThCO0FBQzVCNnVCLG1CQUFlenBCLE1BQU1mLElBQU4sQ0FBV2EsSUFBWCxLQUFvQkUsTUFBTWYsSUFBTixDQUFXYSxJQUFYLEdBQWtCLEVBQXRDLENBQWYsRUFBMEQsV0FBMUQsRUFBdUUsWUFBWTtBQUNqRixXQUFLLElBQUl4RSxJQUFJLENBQWIsRUFBZ0JBLElBQUltb0Msa0JBQWtCN29DLE1BQXRDLEVBQThDVSxHQUE5QyxFQUFtRDtBQUNqRHFvQyxtQkFBV0Ysa0JBQWtCbm9DLENBQWxCLENBQVgsRUFBaUMsa0JBQWpDLEVBQXFEMEUsS0FBckQsRUFBNERJLFFBQTVEO0FBQ0Q7QUFDRixLQUpEO0FBS0Q7O0FBRUQsTUFBSSxDQUFDK2lDLFFBQUwsRUFBZTtBQUNiLFNBQUt0aEMsR0FBTCxJQUFZd2hDLE9BQVosRUFBcUI7QUFDbkIsVUFBSSxDQUFDRSxRQUFRMWhDLEdBQVIsQ0FBTCxFQUFtQjtBQUNqQjtBQUNBOGhDLG1CQUFXTixRQUFReGhDLEdBQVIsQ0FBWCxFQUF5QixRQUF6QixFQUFtQ3pCLFFBQW5DLEVBQTZDQSxRQUE3QyxFQUF1RGdqQyxTQUF2RDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELElBQUlVLGlCQUFpQnptQyxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBckI7O0FBRUEsU0FBU2s2QixxQkFBVCxDQUNFN2UsSUFERixFQUVFaEYsRUFGRixFQUdFO0FBQ0EsTUFBSTNkLE1BQU16RSxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLE1BQUksQ0FBQ3FiLElBQUwsRUFBVztBQUNULFdBQU8zaUIsR0FBUDtBQUNEO0FBQ0QsTUFBSXhHLENBQUosRUFBT3dCLEdBQVA7QUFDQSxPQUFLeEIsSUFBSSxDQUFULEVBQVlBLElBQUltcEIsS0FBSzdwQixNQUFyQixFQUE2QlUsR0FBN0IsRUFBa0M7QUFDaEN3QixVQUFNMm5CLEtBQUtucEIsQ0FBTCxDQUFOO0FBQ0EsUUFBSSxDQUFDd0IsSUFBSWluQyxTQUFULEVBQW9CO0FBQ2xCam5DLFVBQUlpbkMsU0FBSixHQUFnQkQsY0FBaEI7QUFDRDtBQUNEaGlDLFFBQUlraUMsY0FBY2xuQyxHQUFkLENBQUosSUFBMEJBLEdBQTFCO0FBQ0FBLFFBQUl3WSxHQUFKLEdBQVU0UCxhQUFhekYsR0FBR2hZLFFBQWhCLEVBQTBCLFlBQTFCLEVBQXdDM0ssSUFBSUgsSUFBNUMsRUFBa0QsSUFBbEQsQ0FBVjtBQUNEO0FBQ0QsU0FBT21GLEdBQVA7QUFDRDs7QUFFRCxTQUFTa2lDLGFBQVQsQ0FBd0JsbkMsR0FBeEIsRUFBNkI7QUFDM0IsU0FBT0EsSUFBSW1uQyxPQUFKLElBQWlCbm5DLElBQUlILElBQUwsR0FBYSxHQUFiLEdBQW9CVSxPQUFPcUYsSUFBUCxDQUFZNUYsSUFBSWluQyxTQUFKLElBQWlCLEVBQTdCLEVBQWlDemhDLElBQWpDLENBQXNDLEdBQXRDLENBQTNDO0FBQ0Q7O0FBRUQsU0FBU3FoQyxVQUFULENBQXFCN21DLEdBQXJCLEVBQTBCZ0QsSUFBMUIsRUFBZ0NFLEtBQWhDLEVBQXVDSSxRQUF2QyxFQUFpRGdqQyxTQUFqRCxFQUE0RDtBQUMxRCxNQUFJdndCLEtBQUsvVixJQUFJd1ksR0FBSixJQUFXeFksSUFBSXdZLEdBQUosQ0FBUXhWLElBQVIsQ0FBcEI7QUFDQSxNQUFJK1MsRUFBSixFQUFRO0FBQ05BLE9BQUc3UyxNQUFNOG5CLEdBQVQsRUFBY2hyQixHQUFkLEVBQW1Ca0QsS0FBbkIsRUFBMEJJLFFBQTFCLEVBQW9DZ2pDLFNBQXBDO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJYyxjQUFjLENBQ2hCcGxDLEdBRGdCLEVBRWhCNGxCLFVBRmdCLENBQWxCOztBQUtBOztBQUVBLFNBQVN5ZixXQUFULENBQXNCL2pDLFFBQXRCLEVBQWdDSixLQUFoQyxFQUF1QztBQUNyQyxNQUFJLENBQUNJLFNBQVNuQixJQUFULENBQWNpSCxLQUFmLElBQXdCLENBQUNsRyxNQUFNZixJQUFOLENBQVdpSCxLQUF4QyxFQUErQztBQUM3QztBQUNEO0FBQ0QsTUFBSXJFLEdBQUosRUFBUzBuQixHQUFULEVBQWNDLEdBQWQ7QUFDQSxNQUFJMUIsTUFBTTluQixNQUFNOG5CLEdBQWhCO0FBQ0EsTUFBSXNjLFdBQVdoa0MsU0FBU25CLElBQVQsQ0FBY2lILEtBQWQsSUFBdUIsRUFBdEM7QUFDQSxNQUFJQSxRQUFRbEcsTUFBTWYsSUFBTixDQUFXaUgsS0FBWCxJQUFvQixFQUFoQztBQUNBO0FBQ0EsTUFBSUEsTUFBTW9iLE1BQVYsRUFBa0I7QUFDaEJwYixZQUFRbEcsTUFBTWYsSUFBTixDQUFXaUgsS0FBWCxHQUFtQkksT0FBTyxFQUFQLEVBQVdKLEtBQVgsQ0FBM0I7QUFDRDs7QUFFRCxPQUFLckUsR0FBTCxJQUFZcUUsS0FBWixFQUFtQjtBQUNqQnFqQixVQUFNcmpCLE1BQU1yRSxHQUFOLENBQU47QUFDQTJuQixVQUFNNGEsU0FBU3ZpQyxHQUFULENBQU47QUFDQSxRQUFJMm5CLFFBQVFELEdBQVosRUFBaUI7QUFDZjhhLGNBQVF2YyxHQUFSLEVBQWFqbUIsR0FBYixFQUFrQjBuQixHQUFsQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsTUFBSTVNLFNBQVN6VyxNQUFNM0ksS0FBTixLQUFnQjZtQyxTQUFTN21DLEtBQXRDLEVBQTZDO0FBQzNDOG1DLFlBQVF2YyxHQUFSLEVBQWEsT0FBYixFQUFzQjVoQixNQUFNM0ksS0FBNUI7QUFDRDtBQUNELE9BQUtzRSxHQUFMLElBQVl1aUMsUUFBWixFQUFzQjtBQUNwQixRQUFJbCtCLE1BQU1yRSxHQUFOLEtBQWMsSUFBbEIsRUFBd0I7QUFDdEIsVUFBSTI1QixRQUFRMzVCLEdBQVIsQ0FBSixFQUFrQjtBQUNoQmltQixZQUFJd2MsaUJBQUosQ0FBc0IvSSxPQUF0QixFQUErQkUsYUFBYTU1QixHQUFiLENBQS9CO0FBQ0QsT0FGRCxNQUVPLElBQUksQ0FBQ3c1QixpQkFBaUJ4NUIsR0FBakIsQ0FBTCxFQUE0QjtBQUNqQ2ltQixZQUFJK2EsZUFBSixDQUFvQmhoQyxHQUFwQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQVN3aUMsT0FBVCxDQUFrQjN6QixFQUFsQixFQUFzQjdPLEdBQXRCLEVBQTJCdEUsS0FBM0IsRUFBa0M7QUFDaEMsTUFBSSs5QixjQUFjejVCLEdBQWQsQ0FBSixFQUF3QjtBQUN0QjtBQUNBO0FBQ0EsUUFBSTY1QixpQkFBaUJuK0IsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm1ULFNBQUdteUIsZUFBSCxDQUFtQmhoQyxHQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMNk8sU0FBR3VzQixZQUFILENBQWdCcDdCLEdBQWhCLEVBQXFCQSxHQUFyQjtBQUNEO0FBQ0YsR0FSRCxNQVFPLElBQUl3NUIsaUJBQWlCeDVCLEdBQWpCLENBQUosRUFBMkI7QUFDaEM2TyxPQUFHdXNCLFlBQUgsQ0FBZ0JwN0IsR0FBaEIsRUFBcUI2NUIsaUJBQWlCbitCLEtBQWpCLEtBQTJCQSxVQUFVLE9BQXJDLEdBQStDLE9BQS9DLEdBQXlELE1BQTlFO0FBQ0QsR0FGTSxNQUVBLElBQUlpK0IsUUFBUTM1QixHQUFSLENBQUosRUFBa0I7QUFDdkIsUUFBSTY1QixpQkFBaUJuK0IsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm1ULFNBQUc0ekIsaUJBQUgsQ0FBcUIvSSxPQUFyQixFQUE4QkUsYUFBYTU1QixHQUFiLENBQTlCO0FBQ0QsS0FGRCxNQUVPO0FBQ0w2TyxTQUFHNnpCLGNBQUgsQ0FBa0JoSixPQUFsQixFQUEyQjE1QixHQUEzQixFQUFnQ3RFLEtBQWhDO0FBQ0Q7QUFDRixHQU5NLE1BTUE7QUFDTCxRQUFJbStCLGlCQUFpQm4rQixLQUFqQixDQUFKLEVBQTZCO0FBQzNCbVQsU0FBR215QixlQUFILENBQW1CaGhDLEdBQW5CO0FBQ0QsS0FGRCxNQUVPO0FBQ0w2TyxTQUFHdXNCLFlBQUgsQ0FBZ0JwN0IsR0FBaEIsRUFBcUJ0RSxLQUFyQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJMkksUUFBUTtBQUNWa0QsVUFBUSs2QixXQURFO0FBRVZ6akIsVUFBUXlqQjtBQUZFLENBQVo7O0FBS0E7O0FBRUEsU0FBU0ssV0FBVCxDQUFzQnBrQyxRQUF0QixFQUFnQ0osS0FBaEMsRUFBdUM7QUFDckMsTUFBSTBRLEtBQUsxUSxNQUFNOG5CLEdBQWY7QUFDQSxNQUFJN29CLE9BQU9lLE1BQU1mLElBQWpCO0FBQ0EsTUFBSXdsQyxVQUFVcmtDLFNBQVNuQixJQUF2QjtBQUNBLE1BQUksQ0FBQ0EsS0FBSys4QixXQUFOLElBQXFCLENBQUMvOEIsS0FBS2dILEtBQTNCLEtBQ0MsQ0FBQ3crQixPQUFELElBQWEsQ0FBQ0EsUUFBUXpJLFdBQVQsSUFBd0IsQ0FBQ3lJLFFBQVF4K0IsS0FEL0MsQ0FBSixFQUM0RDtBQUMxRDtBQUNEOztBQUVELE1BQUl5K0IsTUFBTS9JLGlCQUFpQjM3QixLQUFqQixDQUFWOztBQUVBO0FBQ0EsTUFBSTJrQyxrQkFBa0JqMEIsR0FBR2swQixrQkFBekI7QUFDQSxNQUFJRCxlQUFKLEVBQXFCO0FBQ25CRCxVQUFNN3BDLE9BQU82cEMsR0FBUCxFQUFZeEksZUFBZXlJLGVBQWYsQ0FBWixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJRCxRQUFRaDBCLEdBQUdtMEIsVUFBZixFQUEyQjtBQUN6Qm4wQixPQUFHdXNCLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUJ5SCxHQUF6QjtBQUNBaDBCLE9BQUdtMEIsVUFBSCxHQUFnQkgsR0FBaEI7QUFDRDtBQUNGOztBQUVELElBQUlJLFFBQVE7QUFDVjE3QixVQUFRbzdCLFdBREU7QUFFVjlqQixVQUFROGpCO0FBRkUsQ0FBWjs7QUFLQTs7QUFFQSxJQUFJTyxzQkFBc0IsZUFBMUI7O0FBRUEsU0FBU0MsWUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsTUFBSUMsV0FBVyxLQUFmO0FBQ0EsTUFBSUMsV0FBVyxLQUFmO0FBQ0EsTUFBSUMsbUJBQW1CLEtBQXZCO0FBQ0EsTUFBSUMsVUFBVSxLQUFkO0FBQ0EsTUFBSUMsUUFBUSxDQUFaO0FBQ0EsTUFBSUMsU0FBUyxDQUFiO0FBQ0EsTUFBSUMsUUFBUSxDQUFaO0FBQ0EsTUFBSUMsa0JBQWtCLENBQXRCO0FBQ0EsTUFBSTVrQyxDQUFKLEVBQU84VCxJQUFQLEVBQWFyWixDQUFiLEVBQWdCNHpCLFVBQWhCLEVBQTRCd1csT0FBNUI7O0FBRUEsT0FBS3BxQyxJQUFJLENBQVQsRUFBWUEsSUFBSTJwQyxJQUFJcnFDLE1BQXBCLEVBQTRCVSxHQUE1QixFQUFpQztBQUMvQnFaLFdBQU85VCxDQUFQO0FBQ0FBLFFBQUlva0MsSUFBSW5rQyxVQUFKLENBQWV4RixDQUFmLENBQUo7QUFDQSxRQUFJNHBDLFFBQUosRUFBYztBQUNaLFVBQUlya0MsTUFBTSxJQUFOLElBQWM4VCxTQUFTLElBQTNCLEVBQWlDO0FBQUV1d0IsbUJBQVcsS0FBWDtBQUFtQjtBQUN2RCxLQUZELE1BRU8sSUFBSUMsUUFBSixFQUFjO0FBQ25CLFVBQUl0a0MsTUFBTSxJQUFOLElBQWM4VCxTQUFTLElBQTNCLEVBQWlDO0FBQUV3d0IsbUJBQVcsS0FBWDtBQUFtQjtBQUN2RCxLQUZNLE1BRUEsSUFBSUMsZ0JBQUosRUFBc0I7QUFDM0IsVUFBSXZrQyxNQUFNLElBQU4sSUFBYzhULFNBQVMsSUFBM0IsRUFBaUM7QUFBRXl3QiwyQkFBbUIsS0FBbkI7QUFBMkI7QUFDL0QsS0FGTSxNQUVBLElBQUlDLE9BQUosRUFBYTtBQUNsQixVQUFJeGtDLE1BQU0sSUFBTixJQUFjOFQsU0FBUyxJQUEzQixFQUFpQztBQUFFMHdCLGtCQUFVLEtBQVY7QUFBa0I7QUFDdEQsS0FGTSxNQUVBLElBQ0x4a0MsTUFBTSxJQUFOLElBQWM7QUFDZG9rQyxRQUFJbmtDLFVBQUosQ0FBZXhGLElBQUksQ0FBbkIsTUFBMEIsSUFEMUIsSUFFQTJwQyxJQUFJbmtDLFVBQUosQ0FBZXhGLElBQUksQ0FBbkIsTUFBMEIsSUFGMUIsSUFHQSxDQUFDZ3FDLEtBSEQsSUFHVSxDQUFDQyxNQUhYLElBR3FCLENBQUNDLEtBSmpCLEVBS0w7QUFDQSxVQUFJdFcsZUFBZTV1QixTQUFuQixFQUE4QjtBQUM1QjtBQUNBbWxDLDBCQUFrQm5xQyxJQUFJLENBQXRCO0FBQ0E0ekIscUJBQWErVixJQUFJcGlDLEtBQUosQ0FBVSxDQUFWLEVBQWF2SCxDQUFiLEVBQWdCeUcsSUFBaEIsRUFBYjtBQUNELE9BSkQsTUFJTztBQUNMNGpDO0FBQ0Q7QUFDRixLQWJNLE1BYUE7QUFDTCxjQUFROWtDLENBQVI7QUFDRSxhQUFLLElBQUw7QUFBV3NrQyxxQkFBVyxJQUFYLENBQWlCLE1BRDlCLENBQzRDO0FBQzFDLGFBQUssSUFBTDtBQUFXRCxxQkFBVyxJQUFYLENBQWlCLE1BRjlCLENBRTRDO0FBQzFDLGFBQUssSUFBTDtBQUFXRSw2QkFBbUIsSUFBbkIsQ0FBeUIsTUFIdEMsQ0FHNEM7QUFDMUMsYUFBSyxJQUFMO0FBQVdJLGtCQUFTLE1BSnRCLENBSTRDO0FBQzFDLGFBQUssSUFBTDtBQUFXQSxrQkFBUyxNQUx0QixDQUs0QztBQUMxQyxhQUFLLElBQUw7QUFBV0QsbUJBQVUsTUFOdkIsQ0FNNEM7QUFDMUMsYUFBSyxJQUFMO0FBQVdBLG1CQUFVLE1BUHZCLENBTzRDO0FBQzFDLGFBQUssSUFBTDtBQUFXRCxrQkFBUyxNQVJ0QixDQVE0QztBQUMxQyxhQUFLLElBQUw7QUFBV0Esa0JBQVMsTUFUdEIsQ0FTNEM7QUFUNUM7QUFXQSxVQUFJemtDLE1BQU0sSUFBVixFQUFnQjtBQUFFO0FBQ2hCLFlBQUkrTCxJQUFJdFIsSUFBSSxDQUFaO0FBQ0EsWUFBSXlpQixJQUFLLEtBQUssQ0FBZDtBQUNBO0FBQ0EsZUFBT25SLEtBQUssQ0FBWixFQUFlQSxHQUFmLEVBQW9CO0FBQ2xCbVIsY0FBSWtuQixJQUFJMzhCLE1BQUosQ0FBV3NFLENBQVgsQ0FBSjtBQUNBLGNBQUltUixNQUFNLEdBQVYsRUFBZTtBQUFFO0FBQU87QUFDekI7QUFDRCxZQUFJLENBQUNBLENBQUQsSUFBTSxDQUFDZ25CLG9CQUFvQjk5QixJQUFwQixDQUF5QjhXLENBQXpCLENBQVgsRUFBd0M7QUFDdENzbkIsb0JBQVUsSUFBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELE1BQUluVyxlQUFlNXVCLFNBQW5CLEVBQThCO0FBQzVCNHVCLGlCQUFhK1YsSUFBSXBpQyxLQUFKLENBQVUsQ0FBVixFQUFhdkgsQ0FBYixFQUFnQnlHLElBQWhCLEVBQWI7QUFDRCxHQUZELE1BRU8sSUFBSTBqQyxvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDaENFO0FBQ0Q7O0FBRUQsV0FBU0EsVUFBVCxHQUF1QjtBQUNyQixLQUFDRCxZQUFZQSxVQUFVLEVBQXRCLENBQUQsRUFBNEJucUMsSUFBNUIsQ0FBaUMwcEMsSUFBSXBpQyxLQUFKLENBQVU0aUMsZUFBVixFQUEyQm5xQyxDQUEzQixFQUE4QnlHLElBQTlCLEVBQWpDO0FBQ0EwakMsc0JBQWtCbnFDLElBQUksQ0FBdEI7QUFDRDs7QUFFRCxNQUFJb3FDLE9BQUosRUFBYTtBQUNYLFNBQUtwcUMsSUFBSSxDQUFULEVBQVlBLElBQUlvcUMsUUFBUTlxQyxNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDbkM0ekIsbUJBQWEwVyxXQUFXMVcsVUFBWCxFQUF1QndXLFFBQVFwcUMsQ0FBUixDQUF2QixDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPNHpCLFVBQVA7QUFDRDs7QUFFRCxTQUFTMFcsVUFBVCxDQUFxQlgsR0FBckIsRUFBMEJsaUMsTUFBMUIsRUFBa0M7QUFDaEMsTUFBSXpILElBQUl5SCxPQUFPeUIsT0FBUCxDQUFlLEdBQWYsQ0FBUjtBQUNBLE1BQUlsSixJQUFJLENBQVIsRUFBVztBQUNUO0FBQ0EsV0FBUSxVQUFVeUgsTUFBVixHQUFtQixNQUFuQixHQUE0QmtpQyxHQUE1QixHQUFrQyxHQUExQztBQUNELEdBSEQsTUFHTztBQUNMLFFBQUl0b0MsT0FBT29HLE9BQU9GLEtBQVAsQ0FBYSxDQUFiLEVBQWdCdkgsQ0FBaEIsQ0FBWDtBQUNBLFFBQUlILE9BQU80SCxPQUFPRixLQUFQLENBQWF2SCxJQUFJLENBQWpCLENBQVg7QUFDQSxXQUFRLFVBQVVxQixJQUFWLEdBQWlCLE1BQWpCLEdBQTBCc29DLEdBQTFCLEdBQWdDLEdBQWhDLEdBQXNDOXBDLElBQTlDO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxTQUFTMHFDLFFBQVQsQ0FBbUJybUIsR0FBbkIsRUFBd0I7QUFDdEJsaEIsVUFBUTRmLEtBQVIsQ0FBZSxxQkFBcUJzQixHQUFwQztBQUNEOztBQUVELFNBQVNzbUIsbUJBQVQsQ0FDRWpyQixPQURGLEVBRUVoWixHQUZGLEVBR0U7QUFDQSxTQUFPZ1osVUFDSEEsUUFBUWxZLEdBQVIsQ0FBWSxVQUFVc0ksQ0FBVixFQUFhO0FBQUUsV0FBT0EsRUFBRXBKLEdBQUYsQ0FBUDtBQUFnQixHQUEzQyxFQUE2Q2tCLE1BQTdDLENBQW9ELFVBQVUrUyxDQUFWLEVBQWE7QUFBRSxXQUFPQSxDQUFQO0FBQVcsR0FBOUUsQ0FERyxHQUVILEVBRko7QUFHRDs7QUFFRCxTQUFTaXdCLE9BQVQsQ0FBa0JyMUIsRUFBbEIsRUFBc0IvVCxJQUF0QixFQUE0QlksS0FBNUIsRUFBbUM7QUFDakMsR0FBQ21ULEdBQUdqUyxLQUFILEtBQWFpUyxHQUFHalMsS0FBSCxHQUFXLEVBQXhCLENBQUQsRUFBOEJsRCxJQUE5QixDQUFtQyxFQUFFb0IsTUFBTUEsSUFBUixFQUFjWSxPQUFPQSxLQUFyQixFQUFuQztBQUNEOztBQUVELFNBQVN5b0MsT0FBVCxDQUFrQnQxQixFQUFsQixFQUFzQi9ULElBQXRCLEVBQTRCWSxLQUE1QixFQUFtQztBQUNqQyxHQUFDbVQsR0FBR3hLLEtBQUgsS0FBYXdLLEdBQUd4SyxLQUFILEdBQVcsRUFBeEIsQ0FBRCxFQUE4QjNLLElBQTlCLENBQW1DLEVBQUVvQixNQUFNQSxJQUFSLEVBQWNZLE9BQU9BLEtBQXJCLEVBQW5DO0FBQ0Q7O0FBRUQsU0FBUzBvQyxZQUFULENBQ0V2MUIsRUFERixFQUVFL1QsSUFGRixFQUdFc25DLE9BSEYsRUFJRTFtQyxLQUpGLEVBS0Uyb0MsR0FMRixFQU1FbkMsU0FORixFQU9FO0FBQ0EsR0FBQ3J6QixHQUFHZ1UsVUFBSCxLQUFrQmhVLEdBQUdnVSxVQUFILEdBQWdCLEVBQWxDLENBQUQsRUFBd0NucEIsSUFBeEMsQ0FBNkMsRUFBRW9CLE1BQU1BLElBQVIsRUFBY3NuQyxTQUFTQSxPQUF2QixFQUFnQzFtQyxPQUFPQSxLQUF2QyxFQUE4QzJvQyxLQUFLQSxHQUFuRCxFQUF3RG5DLFdBQVdBLFNBQW5FLEVBQTdDO0FBQ0Q7O0FBRUQsU0FBU29DLFVBQVQsQ0FDRXoxQixFQURGLEVBRUUvVCxJQUZGLEVBR0VZLEtBSEYsRUFJRXdtQyxTQUpGLEVBS0VxQyxTQUxGLEVBTUU7QUFDQTtBQUNBLE1BQUlyQyxhQUFhQSxVQUFVejRCLE9BQTNCLEVBQW9DO0FBQ2xDLFdBQU95NEIsVUFBVXo0QixPQUFqQjtBQUNBM08sV0FBTyxNQUFNQSxJQUFiLENBRmtDLENBRWY7QUFDcEI7QUFDRCxNQUFJb25DLGFBQWFBLFVBQVUxbkMsSUFBM0IsRUFBaUM7QUFDL0IsV0FBTzBuQyxVQUFVMW5DLElBQWpCO0FBQ0FNLFdBQU8sTUFBTUEsSUFBYixDQUYrQixDQUVaO0FBQ3BCO0FBQ0QsTUFBSTBwQyxNQUFKO0FBQ0EsTUFBSXRDLGFBQWFBLFVBQVV1QyxNQUEzQixFQUFtQztBQUNqQyxXQUFPdkMsVUFBVXVDLE1BQWpCO0FBQ0FELGFBQVMzMUIsR0FBRzYxQixZQUFILEtBQW9CNzFCLEdBQUc2MUIsWUFBSCxHQUFrQixFQUF0QyxDQUFUO0FBQ0QsR0FIRCxNQUdPO0FBQ0xGLGFBQVMzMUIsR0FBRzIxQixNQUFILEtBQWMzMUIsR0FBRzIxQixNQUFILEdBQVksRUFBMUIsQ0FBVDtBQUNEO0FBQ0QsTUFBSUcsYUFBYSxFQUFFanBDLE9BQU9BLEtBQVQsRUFBZ0J3bUMsV0FBV0EsU0FBM0IsRUFBakI7QUFDQSxNQUFJN2MsV0FBV21mLE9BQU8xcEMsSUFBUCxDQUFmO0FBQ0E7QUFDQSxNQUFJdkIsTUFBTW1ILE9BQU4sQ0FBYzJrQixRQUFkLENBQUosRUFBNkI7QUFDM0JrZixnQkFBWWxmLFNBQVNyakIsT0FBVCxDQUFpQjJpQyxVQUFqQixDQUFaLEdBQTJDdGYsU0FBUzNyQixJQUFULENBQWNpckMsVUFBZCxDQUEzQztBQUNELEdBRkQsTUFFTyxJQUFJdGYsUUFBSixFQUFjO0FBQ25CbWYsV0FBTzFwQyxJQUFQLElBQWV5cEMsWUFBWSxDQUFDSSxVQUFELEVBQWF0ZixRQUFiLENBQVosR0FBcUMsQ0FBQ0EsUUFBRCxFQUFXc2YsVUFBWCxDQUFwRDtBQUNELEdBRk0sTUFFQTtBQUNMSCxXQUFPMXBDLElBQVAsSUFBZTZwQyxVQUFmO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxjQUFULENBQ0UvMUIsRUFERixFQUVFL1QsSUFGRixFQUdFK3BDLFNBSEYsRUFJRTtBQUNBLE1BQUlDLGVBQ0ZDLGlCQUFpQmwyQixFQUFqQixFQUFxQixNQUFNL1QsSUFBM0IsS0FDQWlxQyxpQkFBaUJsMkIsRUFBakIsRUFBcUIsWUFBWS9ULElBQWpDLENBRkY7QUFHQSxNQUFJZ3FDLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixXQUFPM0IsYUFBYTJCLFlBQWIsQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJRCxjQUFjLEtBQWxCLEVBQXlCO0FBQzlCLFFBQUlHLGNBQWNELGlCQUFpQmwyQixFQUFqQixFQUFxQi9ULElBQXJCLENBQWxCO0FBQ0EsUUFBSWtxQyxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGFBQU9uNkIsS0FBS0MsU0FBTCxDQUFlazZCLFdBQWYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTRCxnQkFBVCxDQUEyQmwyQixFQUEzQixFQUErQi9ULElBQS9CLEVBQXFDO0FBQ25DLE1BQUkwRixHQUFKO0FBQ0EsTUFBSSxDQUFDQSxNQUFNcU8sR0FBR28yQixRQUFILENBQVlucUMsSUFBWixDQUFQLEtBQTZCLElBQWpDLEVBQXVDO0FBQ3JDLFFBQUlxYyxPQUFPdEksR0FBR3EyQixTQUFkO0FBQ0EsU0FBSyxJQUFJenJDLElBQUksQ0FBUixFQUFXMmUsSUFBSWpCLEtBQUtwZSxNQUF6QixFQUFpQ1UsSUFBSTJlLENBQXJDLEVBQXdDM2UsR0FBeEMsRUFBNkM7QUFDM0MsVUFBSTBkLEtBQUsxZCxDQUFMLEVBQVFxQixJQUFSLEtBQWlCQSxJQUFyQixFQUEyQjtBQUN6QnFjLGFBQUtLLE1BQUwsQ0FBWS9kLENBQVosRUFBZSxDQUFmO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPK0csR0FBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTMmtDLGlCQUFULENBQ0V0MkIsRUFERixFQUVFblQsS0FGRixFQUdFd21DLFNBSEYsRUFJRTtBQUNBLE1BQUlqbEMsTUFBTWlsQyxhQUFhLEVBQXZCO0FBQ0EsTUFBSWtELFNBQVNub0MsSUFBSW1vQyxNQUFqQjtBQUNBLE1BQUlsbEMsT0FBT2pELElBQUlpRCxJQUFmOztBQUVBLE1BQUltbEMsc0JBQXNCLEtBQTFCO0FBQ0EsTUFBSUMsa0JBQWtCRCxtQkFBdEI7QUFDQSxNQUFJbmxDLElBQUosRUFBVTtBQUNSb2xDLHNCQUNFLGFBQWFELG1CQUFiLEdBQW1DLGVBQW5DLEdBQ0UsSUFERixHQUNTQSxtQkFEVCxHQUMrQixTQUQvQixHQUVFLElBRkYsR0FFU0EsbUJBRlQsR0FFK0IsR0FIakM7QUFJRDtBQUNELE1BQUlELE1BQUosRUFBWTtBQUNWRSxzQkFBa0IsUUFBUUEsZUFBUixHQUEwQixHQUE1QztBQUNEO0FBQ0QsTUFBSUMsYUFBYUMsa0JBQWtCOXBDLEtBQWxCLEVBQXlCNHBDLGVBQXpCLENBQWpCOztBQUVBejJCLEtBQUdnakIsS0FBSCxHQUFXO0FBQ1RuMkIsV0FBUSxNQUFNQSxLQUFOLEdBQWMsR0FEYjtBQUVUMnhCLGdCQUFhLE9BQU8zeEIsS0FBUCxHQUFlLElBRm5CO0FBR1Q0M0IsY0FBVyxlQUFlK1IsbUJBQWYsR0FBcUMsS0FBckMsR0FBNkNFLFVBQTdDLEdBQTBEO0FBSDVELEdBQVg7QUFLRDs7QUFFRDs7O0FBR0EsU0FBU0MsaUJBQVQsQ0FDRTlwQyxLQURGLEVBRUU2cEMsVUFGRixFQUdFO0FBQ0EsTUFBSUUsVUFBVUMsV0FBV2hxQyxLQUFYLENBQWQ7QUFDQSxNQUFJK3BDLFFBQVFFLEdBQVIsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsV0FBUWpxQyxRQUFRLEdBQVIsR0FBYzZwQyxVQUF0QjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8saUJBQWtCRSxRQUFRckMsR0FBMUIsR0FBaUMsWUFBakMsR0FBaURxQyxRQUFRRSxHQUF6RCxHQUFnRSxHQUFoRSxHQUNMLDZCQURLLEdBRUhqcUMsS0FGRyxHQUVLLEdBRkwsR0FFVzZwQyxVQUZYLEdBRXdCLEdBRnhCLEdBR0wsOEJBSEssR0FHNEJBLFVBSDVCLEdBR3lDLElBSGhEO0FBSUQ7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJcHNDLEdBQUo7QUFDQSxJQUFJa0csR0FBSjtBQUNBLElBQUl1bUMsR0FBSjtBQUNBLElBQUkxOUIsT0FBSjtBQUNBLElBQUkyOUIsYUFBSjtBQUNBLElBQUlDLGdCQUFKOztBQUVBLFNBQVNKLFVBQVQsQ0FBcUJsbEMsR0FBckIsRUFBMEI7QUFDeEJuQixRQUFNbUIsR0FBTjtBQUNBckgsUUFBTWtHLElBQUl0RyxNQUFWO0FBQ0FtUCxZQUFVMjlCLGdCQUFnQkMsbUJBQW1CLENBQTdDOztBQUVBLE1BQUl0bEMsSUFBSW1DLE9BQUosQ0FBWSxHQUFaLElBQW1CLENBQW5CLElBQXdCbkMsSUFBSXVsQyxXQUFKLENBQWdCLEdBQWhCLElBQXVCNXNDLE1BQU0sQ0FBekQsRUFBNEQ7QUFDMUQsV0FBTztBQUNMaXFDLFdBQUs1aUMsR0FEQTtBQUVMbWxDLFdBQUs7QUFGQSxLQUFQO0FBSUQ7O0FBRUQsU0FBTyxDQUFDSyxLQUFSLEVBQWU7QUFDYkosVUFBTXI4QixNQUFOO0FBQ0E7QUFDQSxRQUFJMDhCLGNBQWNMLEdBQWQsQ0FBSixFQUF3QjtBQUN0Qk0sa0JBQVlOLEdBQVo7QUFDRCxLQUZELE1BRU8sSUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ3ZCTyxtQkFBYVAsR0FBYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTztBQUNMeEMsU0FBSzVpQyxJQUFJNGxDLFNBQUosQ0FBYyxDQUFkLEVBQWlCUCxhQUFqQixDQURBO0FBRUxGLFNBQUtubEMsSUFBSTRsQyxTQUFKLENBQWNQLGdCQUFnQixDQUE5QixFQUFpQ0MsZ0JBQWpDO0FBRkEsR0FBUDtBQUlEOztBQUVELFNBQVN2OEIsSUFBVCxHQUFpQjtBQUNmLFNBQU9sSyxJQUFJSixVQUFKLENBQWUsRUFBRWlKLE9BQWpCLENBQVA7QUFDRDs7QUFFRCxTQUFTODlCLEdBQVQsR0FBZ0I7QUFDZCxTQUFPOTlCLFdBQVcvTyxHQUFsQjtBQUNEOztBQUVELFNBQVM4c0MsYUFBVCxDQUF3QkwsR0FBeEIsRUFBNkI7QUFDM0IsU0FBT0EsUUFBUSxJQUFSLElBQWdCQSxRQUFRLElBQS9CO0FBQ0Q7O0FBRUQsU0FBU08sWUFBVCxDQUF1QlAsR0FBdkIsRUFBNEI7QUFDMUIsTUFBSVMsWUFBWSxDQUFoQjtBQUNBUixrQkFBZ0IzOUIsT0FBaEI7QUFDQSxTQUFPLENBQUM4OUIsS0FBUixFQUFlO0FBQ2JKLFVBQU1yOEIsTUFBTjtBQUNBLFFBQUkwOEIsY0FBY0wsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCTSxrQkFBWU4sR0FBWjtBQUNBO0FBQ0Q7QUFDRCxRQUFJQSxRQUFRLElBQVosRUFBa0I7QUFBRVM7QUFBYztBQUNsQyxRQUFJVCxRQUFRLElBQVosRUFBa0I7QUFBRVM7QUFBYztBQUNsQyxRQUFJQSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CUCx5QkFBbUI1OUIsT0FBbkI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTZytCLFdBQVQsQ0FBc0JOLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUlVLGNBQWNWLEdBQWxCO0FBQ0EsU0FBTyxDQUFDSSxLQUFSLEVBQWU7QUFDYkosVUFBTXI4QixNQUFOO0FBQ0EsUUFBSXE4QixRQUFRVSxXQUFaLEVBQXlCO0FBQ3ZCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBLElBQUlDLE1BQUo7O0FBRUE7QUFDQTtBQUNBLElBQUlDLGNBQWMsS0FBbEI7QUFDQSxJQUFJQyx1QkFBdUIsS0FBM0I7O0FBRUEsU0FBUzVVLEtBQVQsQ0FDRWhqQixFQURGLEVBRUU1VCxHQUZGLEVBR0V5ckMsS0FIRixFQUlFO0FBQ0FILFdBQVNHLEtBQVQ7QUFDQSxNQUFJaHJDLFFBQVFULElBQUlTLEtBQWhCO0FBQ0EsTUFBSXdtQyxZQUFZam5DLElBQUlpbkMsU0FBcEI7QUFDQSxNQUFJaC9CLE1BQU0yTCxHQUFHM0wsR0FBYjtBQUNBLE1BQUlyRyxPQUFPZ1MsR0FBR28yQixRQUFILENBQVlwb0MsSUFBdkI7O0FBRUEsTUFBSW5GLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUk0bUMsY0FBYzkzQixHQUFHbzJCLFFBQUgsQ0FBWSxhQUFaLEtBQThCcDJCLEdBQUdvMkIsUUFBSCxDQUFZLE9BQVosQ0FBaEQ7QUFDQSxRQUFJL2hDLFFBQVEsT0FBUixJQUFtQnlqQyxXQUF2QixFQUFvQztBQUNsQ0osYUFDRSxvQkFBb0JJLFdBQXBCLEdBQWtDLGVBQWxDLEdBQW9EanJDLEtBQXBELEdBQTRELFFBQTVELEdBQ0EsMEVBRkY7QUFJRDtBQUNEO0FBQ0E7QUFDQSxRQUFJd0gsUUFBUSxPQUFSLElBQW1CckcsU0FBUyxNQUFoQyxFQUF3QztBQUN0QzBwQyxhQUNFLE1BQU8xM0IsR0FBRzNMLEdBQVYsR0FBaUIsYUFBakIsR0FBaUN4SCxLQUFqQyxHQUF5QyxzQkFBekMsR0FDQSxnRUFGRjtBQUlEO0FBQ0Y7O0FBRUQsTUFBSXdILFFBQVEsUUFBWixFQUFzQjtBQUNwQjBqQyxjQUFVLzNCLEVBQVYsRUFBY25ULEtBQWQsRUFBcUJ3bUMsU0FBckI7QUFDRCxHQUZELE1BRU8sSUFBSWgvQixRQUFRLE9BQVIsSUFBbUJyRyxTQUFTLFVBQWhDLEVBQTRDO0FBQ2pEZ3FDLHFCQUFpQmg0QixFQUFqQixFQUFxQm5ULEtBQXJCLEVBQTRCd21DLFNBQTVCO0FBQ0QsR0FGTSxNQUVBLElBQUloL0IsUUFBUSxPQUFSLElBQW1CckcsU0FBUyxPQUFoQyxFQUF5QztBQUM5Q2lxQyxrQkFBY2o0QixFQUFkLEVBQWtCblQsS0FBbEIsRUFBeUJ3bUMsU0FBekI7QUFDRCxHQUZNLE1BRUEsSUFBSWgvQixRQUFRLE9BQVIsSUFBbUJBLFFBQVEsVUFBL0IsRUFBMkM7QUFDaEQ2akMsb0JBQWdCbDRCLEVBQWhCLEVBQW9CblQsS0FBcEIsRUFBMkJ3bUMsU0FBM0I7QUFDRCxHQUZNLE1BRUEsSUFBSSxDQUFDdmpDLE9BQU9rYixhQUFQLENBQXFCM1csR0FBckIsQ0FBTCxFQUFnQztBQUNyQ2lpQyxzQkFBa0J0MkIsRUFBbEIsRUFBc0JuVCxLQUF0QixFQUE2QndtQyxTQUE3QjtBQUNBO0FBQ0EsV0FBTyxLQUFQO0FBQ0QsR0FKTSxNQUlBLElBQUl4cUMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaER3bUMsV0FDRSxNQUFPMTNCLEdBQUczTCxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDeEgsS0FBakMsR0FBeUMsT0FBekMsR0FDQSxpREFEQSxHQUVBLGdFQUZBLEdBR0Esc0VBSkY7QUFNRDs7QUFFRDtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVNtckMsZ0JBQVQsQ0FDRWg0QixFQURGLEVBRUVuVCxLQUZGLEVBR0V3bUMsU0FIRixFQUlFO0FBQ0EsTUFBSWtELFNBQVNsRCxhQUFhQSxVQUFVa0QsTUFBcEM7QUFDQSxNQUFJNEIsZUFBZXBDLGVBQWUvMUIsRUFBZixFQUFtQixPQUFuQixLQUErQixNQUFsRDtBQUNBLE1BQUlvNEIsbUJBQW1CckMsZUFBZS8xQixFQUFmLEVBQW1CLFlBQW5CLEtBQW9DLE1BQTNEO0FBQ0EsTUFBSXE0QixvQkFBb0J0QyxlQUFlLzFCLEVBQWYsRUFBbUIsYUFBbkIsS0FBcUMsT0FBN0Q7QUFDQXExQixVQUFRcjFCLEVBQVIsRUFBWSxTQUFaLEVBQ0UsbUJBQW1CblQsS0FBbkIsR0FBMkIsR0FBM0IsR0FDRSxNQURGLEdBQ1dBLEtBRFgsR0FDbUIsR0FEbkIsR0FDeUJzckMsWUFEekIsR0FDd0MsTUFEeEMsSUFFSUMscUJBQXFCLE1BQXJCLEdBQ0ssT0FBT3ZyQyxLQUFQLEdBQWUsR0FEcEIsR0FFSyxTQUFTQSxLQUFULEdBQWlCLEdBQWpCLEdBQXVCdXJDLGdCQUF2QixHQUEwQyxHQUpuRCxDQURGO0FBUUEzQyxhQUFXejFCLEVBQVgsRUFBZTQzQixvQkFBZixFQUNFLGFBQWEvcUMsS0FBYixHQUFxQixHQUFyQixHQUNJLHFCQURKLEdBRUksb0JBRkosR0FFMkJ1ckMsZ0JBRjNCLEdBRThDLEtBRjlDLEdBRXNEQyxpQkFGdEQsR0FFMEUsSUFGMUUsR0FHQSx5QkFIQSxHQUlFLFVBSkYsSUFJZ0I5QixTQUFTLFFBQVE0QixZQUFSLEdBQXVCLEdBQWhDLEdBQXNDQSxZQUp0RCxJQUlzRSxHQUp0RSxHQUtNLGtCQUxOLEdBTUUsa0JBTkYsR0FNdUJ0ckMsS0FOdkIsR0FNK0Isb0JBTi9CLEdBT0UsZ0JBUEYsR0FPcUJBLEtBUHJCLEdBTzZCLDhDQVA3QixHQVFBLFFBUkEsR0FRV0EsS0FSWCxHQVFtQixPQVRyQixFQVVFLElBVkYsRUFVUSxJQVZSO0FBWUQ7O0FBRUQsU0FBU29yQyxhQUFULENBQ0lqNEIsRUFESixFQUVJblQsS0FGSixFQUdJd21DLFNBSEosRUFJRTtBQUNBLE1BQUlrRCxTQUFTbEQsYUFBYUEsVUFBVWtELE1BQXBDO0FBQ0EsTUFBSTRCLGVBQWVwQyxlQUFlLzFCLEVBQWYsRUFBbUIsT0FBbkIsS0FBK0IsTUFBbEQ7QUFDQW00QixpQkFBZTVCLFNBQVUsUUFBUTRCLFlBQVIsR0FBdUIsR0FBakMsR0FBd0NBLFlBQXZEO0FBQ0E5QyxVQUFRcjFCLEVBQVIsRUFBWSxTQUFaLEVBQXdCLFFBQVFuVCxLQUFSLEdBQWdCLEdBQWhCLEdBQXNCc3JDLFlBQXRCLEdBQXFDLEdBQTdEO0FBQ0ExQyxhQUFXejFCLEVBQVgsRUFBZTQzQixvQkFBZixFQUFxQ2pCLGtCQUFrQjlwQyxLQUFsQixFQUF5QnNyQyxZQUF6QixDQUFyQyxFQUE2RSxJQUE3RSxFQUFtRixJQUFuRjtBQUNEOztBQUVELFNBQVNKLFNBQVQsQ0FDSS8zQixFQURKLEVBRUluVCxLQUZKLEVBR0l3bUMsU0FISixFQUlFO0FBQ0EsTUFBSWtELFNBQVNsRCxhQUFhQSxVQUFVa0QsTUFBcEM7QUFDQSxNQUFJK0IsY0FBYywyQkFDaEIsNkRBRGdCLEdBRWhCLGtFQUZnQixHQUdoQixTQUhnQixJQUdIL0IsU0FBUyxTQUFULEdBQXFCLEtBSGxCLElBRzJCLElBSDdDOztBQUtBLE1BQUlHLGFBQWEsMkRBQWpCO0FBQ0EsTUFBSTZCLE9BQU8seUJBQXlCRCxXQUF6QixHQUF1QyxHQUFsRDtBQUNBQyxTQUFPQSxPQUFPLEdBQVAsR0FBYzVCLGtCQUFrQjlwQyxLQUFsQixFQUF5QjZwQyxVQUF6QixDQUFyQjtBQUNBakIsYUFBV3oxQixFQUFYLEVBQWUsUUFBZixFQUF5QnU0QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQztBQUNEOztBQUVELFNBQVNMLGVBQVQsQ0FDRWw0QixFQURGLEVBRUVuVCxLQUZGLEVBR0V3bUMsU0FIRixFQUlFO0FBQ0EsTUFBSXJsQyxPQUFPZ1MsR0FBR28yQixRQUFILENBQVlwb0MsSUFBdkI7QUFDQSxNQUFJSSxNQUFNaWxDLGFBQWEsRUFBdkI7QUFDQSxNQUFJdlUsT0FBTzF3QixJQUFJMHdCLElBQWY7QUFDQSxNQUFJeVgsU0FBU25vQyxJQUFJbW9DLE1BQWpCO0FBQ0EsTUFBSWxsQyxPQUFPakQsSUFBSWlELElBQWY7QUFDQSxNQUFJbW5DLHVCQUF1QixDQUFDMVosSUFBRCxJQUFTOXdCLFNBQVMsT0FBN0M7QUFDQSxNQUFJMEcsUUFBUW9xQixPQUNSLFFBRFEsR0FFUjl3QixTQUFTLE9BQVQsR0FDRTJwQyxXQURGLEdBRUUsT0FKTjs7QUFNQSxNQUFJbEIsa0JBQWtCLHFCQUF0QjtBQUNBLE1BQUlwbEMsSUFBSixFQUFVO0FBQ1JvbEMsc0JBQWtCLDRCQUFsQjtBQUNEO0FBQ0QsTUFBSUYsTUFBSixFQUFZO0FBQ1ZFLHNCQUFrQixRQUFRQSxlQUFSLEdBQTBCLEdBQTVDO0FBQ0Q7O0FBRUQsTUFBSThCLE9BQU81QixrQkFBa0I5cEMsS0FBbEIsRUFBeUI0cEMsZUFBekIsQ0FBWDtBQUNBLE1BQUkrQixvQkFBSixFQUEwQjtBQUN4QkQsV0FBTyx1Q0FBdUNBLElBQTlDO0FBQ0Q7O0FBRURsRCxVQUFRcjFCLEVBQVIsRUFBWSxPQUFaLEVBQXNCLE1BQU1uVCxLQUFOLEdBQWMsR0FBcEM7QUFDQTRvQyxhQUFXejFCLEVBQVgsRUFBZXRMLEtBQWYsRUFBc0I2akMsSUFBdEIsRUFBNEIsSUFBNUIsRUFBa0MsSUFBbEM7QUFDQSxNQUFJbG5DLFFBQVFrbEMsTUFBUixJQUFrQnZvQyxTQUFTLFFBQS9CLEVBQXlDO0FBQ3ZDeW5DLGVBQVd6MUIsRUFBWCxFQUFlLE1BQWYsRUFBdUIsZ0JBQXZCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN5NEIsZUFBVCxDQUEwQmh0QyxFQUExQixFQUE4QjtBQUM1QixNQUFJaUosS0FBSjtBQUNBO0FBQ0EsTUFBSWpKLEdBQUdrc0MsV0FBSCxDQUFKLEVBQXFCO0FBQ25CO0FBQ0FqakMsWUFBUXNYLE9BQU8sUUFBUCxHQUFrQixPQUExQjtBQUNBdmdCLE9BQUdpSixLQUFILElBQVksR0FBR3ZLLE1BQUgsQ0FBVXNCLEdBQUdrc0MsV0FBSCxDQUFWLEVBQTJCbHNDLEdBQUdpSixLQUFILEtBQWEsRUFBeEMsQ0FBWjtBQUNBLFdBQU9qSixHQUFHa3NDLFdBQUgsQ0FBUDtBQUNEO0FBQ0QsTUFBSWxzQyxHQUFHbXNDLG9CQUFILENBQUosRUFBOEI7QUFDNUI7QUFDQWxqQyxZQUFRMlgsV0FBVyxPQUFYLEdBQXFCLFFBQTdCO0FBQ0E1Z0IsT0FBR2lKLEtBQUgsSUFBWSxHQUFHdkssTUFBSCxDQUFVc0IsR0FBR21zQyxvQkFBSCxDQUFWLEVBQW9DbnNDLEdBQUdpSixLQUFILEtBQWEsRUFBakQsQ0FBWjtBQUNBLFdBQU9qSixHQUFHbXNDLG9CQUFILENBQVA7QUFDRDtBQUNGOztBQUVELElBQUljLFFBQUo7O0FBRUEsU0FBU0MsS0FBVCxDQUNFamtDLEtBREYsRUFFRVUsT0FGRixFQUdFekosSUFIRixFQUlFaVAsT0FKRixFQUtFO0FBQ0EsTUFBSWpQLElBQUosRUFBVTtBQUNSLFFBQUlpdEMsYUFBYXhqQyxPQUFqQjtBQUNBLFFBQUkrYSxVQUFVdW9CLFFBQWQsQ0FGUSxDQUVnQjtBQUN4QnRqQyxjQUFVLFVBQVV5akMsRUFBVixFQUFjO0FBQ3RCLFVBQUl6bkMsTUFBTXpHLFVBQVVULE1BQVYsS0FBcUIsQ0FBckIsR0FDTjB1QyxXQUFXQyxFQUFYLENBRE0sR0FFTkQsV0FBVzN0QyxLQUFYLENBQWlCLElBQWpCLEVBQXVCTixTQUF2QixDQUZKO0FBR0EsVUFBSXlHLFFBQVEsSUFBWixFQUFrQjtBQUNoQjBuQyxpQkFBU3BrQyxLQUFULEVBQWdCVSxPQUFoQixFQUF5QndGLE9BQXpCLEVBQWtDdVYsT0FBbEM7QUFDRDtBQUNGLEtBUEQ7QUFRRDtBQUNEdW9CLFdBQVMxNUIsZ0JBQVQsQ0FBMEJ0SyxLQUExQixFQUFpQ1UsT0FBakMsRUFBMEN3RixPQUExQztBQUNEOztBQUVELFNBQVNrK0IsUUFBVCxDQUNFcGtDLEtBREYsRUFFRVUsT0FGRixFQUdFd0YsT0FIRixFQUlFdVYsT0FKRixFQUtFO0FBQ0EsR0FBQ0EsV0FBV3VvQixRQUFaLEVBQXNCSyxtQkFBdEIsQ0FBMENya0MsS0FBMUMsRUFBaURVLE9BQWpELEVBQTBEd0YsT0FBMUQ7QUFDRDs7QUFFRCxTQUFTbytCLGtCQUFULENBQTZCdHBDLFFBQTdCLEVBQXVDSixLQUF2QyxFQUE4QztBQUM1QyxNQUFJLENBQUNJLFNBQVNuQixJQUFULENBQWM5QyxFQUFmLElBQXFCLENBQUM2RCxNQUFNZixJQUFOLENBQVc5QyxFQUFyQyxFQUF5QztBQUN2QztBQUNEO0FBQ0QsTUFBSUEsS0FBSzZELE1BQU1mLElBQU4sQ0FBVzlDLEVBQVgsSUFBaUIsRUFBMUI7QUFDQSxNQUFJa3RCLFFBQVFqcEIsU0FBU25CLElBQVQsQ0FBYzlDLEVBQWQsSUFBb0IsRUFBaEM7QUFDQWl0QyxhQUFXcHBDLE1BQU04bkIsR0FBakI7QUFDQXFoQixrQkFBZ0JodEMsRUFBaEI7QUFDQWl0QixrQkFBZ0JqdEIsRUFBaEIsRUFBb0JrdEIsS0FBcEIsRUFBMkJnZ0IsS0FBM0IsRUFBa0NHLFFBQWxDLEVBQTRDeHBDLE1BQU0rbkIsT0FBbEQ7QUFDRDs7QUFFRCxJQUFJc2UsU0FBUztBQUNYajlCLFVBQVFzZ0Msa0JBREc7QUFFWGhwQixVQUFRZ3BCO0FBRkcsQ0FBYjs7QUFLQTs7QUFFQSxTQUFTQyxjQUFULENBQXlCdnBDLFFBQXpCLEVBQW1DSixLQUFuQyxFQUEwQztBQUN4QyxNQUFJLENBQUNJLFNBQVNuQixJQUFULENBQWN3MUIsUUFBZixJQUEyQixDQUFDejBCLE1BQU1mLElBQU4sQ0FBV3cxQixRQUEzQyxFQUFxRDtBQUNuRDtBQUNEO0FBQ0QsTUFBSTV5QixHQUFKLEVBQVMwbkIsR0FBVDtBQUNBLE1BQUl6QixNQUFNOW5CLE1BQU04bkIsR0FBaEI7QUFDQSxNQUFJOGhCLFdBQVd4cEMsU0FBU25CLElBQVQsQ0FBY3cxQixRQUFkLElBQTBCLEVBQXpDO0FBQ0EsTUFBSWgyQixRQUFRdUIsTUFBTWYsSUFBTixDQUFXdzFCLFFBQVgsSUFBdUIsRUFBbkM7QUFDQTtBQUNBLE1BQUloMkIsTUFBTTZpQixNQUFWLEVBQWtCO0FBQ2hCN2lCLFlBQVF1QixNQUFNZixJQUFOLENBQVd3MUIsUUFBWCxHQUFzQm51QixPQUFPLEVBQVAsRUFBVzdILEtBQVgsQ0FBOUI7QUFDRDs7QUFFRCxPQUFLb0QsR0FBTCxJQUFZK25DLFFBQVosRUFBc0I7QUFDcEIsUUFBSW5yQyxNQUFNb0QsR0FBTixLQUFjLElBQWxCLEVBQXdCO0FBQ3RCaW1CLFVBQUlqbUIsR0FBSixJQUFXLEVBQVg7QUFDRDtBQUNGO0FBQ0QsT0FBS0EsR0FBTCxJQUFZcEQsS0FBWixFQUFtQjtBQUNqQjhxQixVQUFNOXFCLE1BQU1vRCxHQUFOLENBQU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJQSxRQUFRLGFBQVIsSUFBeUJBLFFBQVEsV0FBckMsRUFBa0Q7QUFDaEQsVUFBSTdCLE1BQU1qQixRQUFWLEVBQW9CO0FBQUVpQixjQUFNakIsUUFBTixDQUFlbkUsTUFBZixHQUF3QixDQUF4QjtBQUE0QjtBQUNsRCxVQUFJMnVCLFFBQVFxZ0IsU0FBUy9uQyxHQUFULENBQVosRUFBMkI7QUFBRTtBQUFVO0FBQ3hDOztBQUVELFFBQUlBLFFBQVEsT0FBWixFQUFxQjtBQUNuQjtBQUNBO0FBQ0FpbUIsVUFBSStoQixNQUFKLEdBQWF0Z0IsR0FBYjtBQUNBO0FBQ0EsVUFBSXVnQixTQUFTdmdCLE9BQU8sSUFBUCxHQUFjLEVBQWQsR0FBbUI1cUIsT0FBTzRxQixHQUFQLENBQWhDO0FBQ0EsVUFBSXdnQixrQkFBa0JqaUIsR0FBbEIsRUFBdUI5bkIsS0FBdkIsRUFBOEI4cEMsTUFBOUIsQ0FBSixFQUEyQztBQUN6Q2hpQixZQUFJdnFCLEtBQUosR0FBWXVzQyxNQUFaO0FBQ0Q7QUFDRixLQVRELE1BU087QUFDTGhpQixVQUFJam1CLEdBQUosSUFBVzBuQixHQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxTQUFTd2dCLGlCQUFULENBQ0VqaUIsR0FERixFQUVFOW5CLEtBRkYsRUFHRWdxQyxRQUhGLEVBSUU7QUFDQSxTQUFRLENBQUNsaUIsSUFBSW1pQixTQUFMLEtBQ05qcUMsTUFBTStFLEdBQU4sS0FBYyxRQUFkLElBQ0FtbEMsUUFBUXBpQixHQUFSLEVBQWFraUIsUUFBYixDQURBLElBRUFHLGVBQWVyaUIsR0FBZixFQUFvQmtpQixRQUFwQixDQUhNLENBQVI7QUFLRDs7QUFFRCxTQUFTRSxPQUFULENBQWtCcGlCLEdBQWxCLEVBQXVCa2lCLFFBQXZCLEVBQWlDO0FBQy9CO0FBQ0EsU0FBT3I1QixTQUFTeTVCLGFBQVQsS0FBMkJ0aUIsR0FBM0IsSUFBa0NBLElBQUl2cUIsS0FBSixLQUFjeXNDLFFBQXZEO0FBQ0Q7O0FBRUQsU0FBU0csY0FBVCxDQUF5QnJpQixHQUF6QixFQUE4QjNFLE1BQTlCLEVBQXNDO0FBQ3BDLE1BQUk1bEIsUUFBUXVxQixJQUFJdnFCLEtBQWhCO0FBQ0EsTUFBSXdtQyxZQUFZamMsSUFBSXVpQixXQUFwQixDQUZvQyxDQUVIO0FBQ2pDLE1BQUt0RyxhQUFhQSxVQUFVa0QsTUFBeEIsSUFBbUNuZixJQUFJcHBCLElBQUosS0FBYSxRQUFwRCxFQUE4RDtBQUM1RCxXQUFPaWEsU0FBU3BiLEtBQVQsTUFBb0JvYixTQUFTd0ssTUFBVCxDQUEzQjtBQUNEO0FBQ0QsTUFBSTRnQixhQUFhQSxVQUFVaGlDLElBQTNCLEVBQWlDO0FBQy9CLFdBQU94RSxNQUFNd0UsSUFBTixPQUFpQm9oQixPQUFPcGhCLElBQVAsRUFBeEI7QUFDRDtBQUNELFNBQU94RSxVQUFVNGxCLE1BQWpCO0FBQ0Q7O0FBRUQsSUFBSXNSLFdBQVc7QUFDYnJyQixVQUFRdWdDLGNBREs7QUFFYmpwQixVQUFRaXBCO0FBRkssQ0FBZjs7QUFLQTs7QUFFQSxJQUFJVyxpQkFBaUI5d0IsT0FBTyxVQUFVK3dCLE9BQVYsRUFBbUI7QUFDN0MsTUFBSXpvQyxNQUFNLEVBQVY7QUFDQSxNQUFJMG9DLGdCQUFnQixlQUFwQjtBQUNBLE1BQUlDLG9CQUFvQixPQUF4QjtBQUNBRixVQUFRdm9DLEtBQVIsQ0FBY3dvQyxhQUFkLEVBQTZCdm9DLE9BQTdCLENBQXFDLFVBQVVtWCxJQUFWLEVBQWdCO0FBQ25ELFFBQUlBLElBQUosRUFBVTtBQUNSLFVBQUk4VyxNQUFNOVcsS0FBS3BYLEtBQUwsQ0FBV3lvQyxpQkFBWCxDQUFWO0FBQ0F2YSxVQUFJdDFCLE1BQUosR0FBYSxDQUFiLEtBQW1Ca0gsSUFBSW91QixJQUFJLENBQUosRUFBT251QixJQUFQLEVBQUosSUFBcUJtdUIsSUFBSSxDQUFKLEVBQU9udUIsSUFBUCxFQUF4QztBQUNEO0FBQ0YsR0FMRDtBQU1BLFNBQU9ELEdBQVA7QUFDRCxDQVhvQixDQUFyQjs7QUFhQTtBQUNBLFNBQVM0b0Msa0JBQVQsQ0FBNkJ6ckMsSUFBN0IsRUFBbUM7QUFDakMsTUFBSTByQyxRQUFRQyxzQkFBc0IzckMsS0FBSzByQyxLQUEzQixDQUFaO0FBQ0E7QUFDQTtBQUNBLFNBQU8xckMsS0FBSzRyQyxXQUFMLEdBQ0h2a0MsT0FBT3JILEtBQUs0ckMsV0FBWixFQUF5QkYsS0FBekIsQ0FERyxHQUVIQSxLQUZKO0FBR0Q7O0FBRUQ7QUFDQSxTQUFTQyxxQkFBVCxDQUFnQ0UsWUFBaEMsRUFBOEM7QUFDNUMsTUFBSTF2QyxNQUFNbUgsT0FBTixDQUFjdW9DLFlBQWQsQ0FBSixFQUFpQztBQUMvQixXQUFPcndCLFNBQVNxd0IsWUFBVCxDQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQU9BLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEMsV0FBT1IsZUFBZVEsWUFBZixDQUFQO0FBQ0Q7QUFDRCxTQUFPQSxZQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxTQUFTQyxRQUFULENBQW1CL3FDLEtBQW5CLEVBQTBCZ3JDLFVBQTFCLEVBQXNDO0FBQ3BDLE1BQUlscEMsTUFBTSxFQUFWO0FBQ0EsTUFBSW1wQyxTQUFKOztBQUVBLE1BQUlELFVBQUosRUFBZ0I7QUFDZCxRQUFJblAsWUFBWTc3QixLQUFoQjtBQUNBLFdBQU82N0IsVUFBVTFULGlCQUFqQixFQUFvQztBQUNsQzBULGtCQUFZQSxVQUFVMVQsaUJBQVYsQ0FBNEJ3RSxNQUF4QztBQUNBLFVBQUlrUCxVQUFVNThCLElBQVYsS0FBbUJnc0MsWUFBWVAsbUJBQW1CN08sVUFBVTU4QixJQUE3QixDQUEvQixDQUFKLEVBQXdFO0FBQ3RFcUgsZUFBT3hFLEdBQVAsRUFBWW1wQyxTQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQUtBLFlBQVlQLG1CQUFtQjFxQyxNQUFNZixJQUF6QixDQUFqQixFQUFrRDtBQUNoRHFILFdBQU94RSxHQUFQLEVBQVltcEMsU0FBWjtBQUNEOztBQUVELE1BQUlyUCxhQUFhNTdCLEtBQWpCO0FBQ0EsU0FBUTQ3QixhQUFhQSxXQUFXNThCLE1BQWhDLEVBQXlDO0FBQ3ZDLFFBQUk0OEIsV0FBVzM4QixJQUFYLEtBQW9CZ3NDLFlBQVlQLG1CQUFtQjlPLFdBQVczOEIsSUFBOUIsQ0FBaEMsQ0FBSixFQUEwRTtBQUN4RXFILGFBQU94RSxHQUFQLEVBQVltcEMsU0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPbnBDLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJb3BDLFdBQVcsS0FBZjtBQUNBLElBQUlDLGNBQWMsZ0JBQWxCO0FBQ0EsSUFBSUMsVUFBVSxVQUFVMTZCLEVBQVYsRUFBYy9ULElBQWQsRUFBb0IwRixHQUFwQixFQUF5QjtBQUNyQztBQUNBLE1BQUk2b0MsU0FBU2prQyxJQUFULENBQWN0SyxJQUFkLENBQUosRUFBeUI7QUFDdkIrVCxPQUFHaTZCLEtBQUgsQ0FBU1UsV0FBVCxDQUFxQjF1QyxJQUFyQixFQUEyQjBGLEdBQTNCO0FBQ0QsR0FGRCxNQUVPLElBQUk4b0MsWUFBWWxrQyxJQUFaLENBQWlCNUUsR0FBakIsQ0FBSixFQUEyQjtBQUNoQ3FPLE9BQUdpNkIsS0FBSCxDQUFTVSxXQUFULENBQXFCMXVDLElBQXJCLEVBQTJCMEYsSUFBSWpCLE9BQUosQ0FBWStwQyxXQUFaLEVBQXlCLEVBQXpCLENBQTNCLEVBQXlELFdBQXpEO0FBQ0QsR0FGTSxNQUVBO0FBQ0x6NkIsT0FBR2k2QixLQUFILENBQVNXLFVBQVUzdUMsSUFBVixDQUFULElBQTRCMEYsR0FBNUI7QUFDRDtBQUNGLENBVEQ7O0FBV0EsSUFBSWtwQyxXQUFXLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsQ0FBZjs7QUFFQSxJQUFJQyxNQUFKO0FBQ0EsSUFBSUYsWUFBWTl4QixPQUFPLFVBQVVpTSxJQUFWLEVBQWdCO0FBQ3JDK2xCLFdBQVNBLFVBQVU3NkIsU0FBU3VqQixhQUFULENBQXVCLEtBQXZCLENBQW5CO0FBQ0F6TyxTQUFPOUwsU0FBUzhMLElBQVQsQ0FBUDtBQUNBLE1BQUlBLFNBQVMsUUFBVCxJQUFzQkEsUUFBUStsQixPQUFPYixLQUF6QyxFQUFpRDtBQUMvQyxXQUFPbGxCLElBQVA7QUFDRDtBQUNELE1BQUlnbUIsUUFBUWhtQixLQUFLbmQsTUFBTCxDQUFZLENBQVosRUFBZTZELFdBQWYsS0FBK0JzWixLQUFLNWlCLEtBQUwsQ0FBVyxDQUFYLENBQTNDO0FBQ0EsT0FBSyxJQUFJdkgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaXdDLFNBQVMzd0MsTUFBN0IsRUFBcUNVLEdBQXJDLEVBQTBDO0FBQ3hDLFFBQUlvd0MsV0FBV0gsU0FBU2p3QyxDQUFULElBQWNtd0MsS0FBN0I7QUFDQSxRQUFJQyxZQUFZRixPQUFPYixLQUF2QixFQUE4QjtBQUM1QixhQUFPZSxRQUFQO0FBQ0Q7QUFDRjtBQUNGLENBYmUsQ0FBaEI7O0FBZUEsU0FBU0MsV0FBVCxDQUFzQnZyQyxRQUF0QixFQUFnQ0osS0FBaEMsRUFBdUM7QUFDckMsTUFBSWYsT0FBT2UsTUFBTWYsSUFBakI7QUFDQSxNQUFJd2xDLFVBQVVya0MsU0FBU25CLElBQXZCOztBQUVBLE1BQUksQ0FBQ0EsS0FBSzRyQyxXQUFOLElBQXFCLENBQUM1ckMsS0FBSzByQyxLQUEzQixJQUNBLENBQUNsRyxRQUFRb0csV0FEVCxJQUN3QixDQUFDcEcsUUFBUWtHLEtBRHJDLEVBQzRDO0FBQzFDO0FBQ0Q7O0FBRUQsTUFBSXBoQixHQUFKLEVBQVM1c0IsSUFBVDtBQUNBLE1BQUkrVCxLQUFLMVEsTUFBTThuQixHQUFmO0FBQ0EsTUFBSThqQixpQkFBaUJ4ckMsU0FBU25CLElBQVQsQ0FBYzRyQyxXQUFuQztBQUNBLE1BQUlnQixrQkFBa0J6ckMsU0FBU25CLElBQVQsQ0FBYzByQyxLQUFkLElBQXVCLEVBQTdDOztBQUVBO0FBQ0EsTUFBSW1CLFdBQVdGLGtCQUFrQkMsZUFBakM7O0FBRUEsTUFBSWxCLFFBQVFDLHNCQUFzQjVxQyxNQUFNZixJQUFOLENBQVcwckMsS0FBakMsS0FBMkMsRUFBdkQ7O0FBRUEzcUMsUUFBTWYsSUFBTixDQUFXMHJDLEtBQVgsR0FBbUJBLE1BQU1ycEIsTUFBTixHQUFlaGIsT0FBTyxFQUFQLEVBQVdxa0MsS0FBWCxDQUFmLEdBQW1DQSxLQUF0RDs7QUFFQSxNQUFJb0IsV0FBV2hCLFNBQVMvcUMsS0FBVCxFQUFnQixJQUFoQixDQUFmOztBQUVBLE9BQUtyRCxJQUFMLElBQWFtdkMsUUFBYixFQUF1QjtBQUNyQixRQUFJQyxTQUFTcHZDLElBQVQsS0FBa0IsSUFBdEIsRUFBNEI7QUFDMUJ5dUMsY0FBUTE2QixFQUFSLEVBQVkvVCxJQUFaLEVBQWtCLEVBQWxCO0FBQ0Q7QUFDRjtBQUNELE9BQUtBLElBQUwsSUFBYW92QyxRQUFiLEVBQXVCO0FBQ3JCeGlCLFVBQU13aUIsU0FBU3B2QyxJQUFULENBQU47QUFDQSxRQUFJNHNCLFFBQVF1aUIsU0FBU252QyxJQUFULENBQVosRUFBNEI7QUFDMUI7QUFDQXl1QyxjQUFRMTZCLEVBQVIsRUFBWS9ULElBQVosRUFBa0I0c0IsT0FBTyxJQUFQLEdBQWMsRUFBZCxHQUFtQkEsR0FBckM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsSUFBSW9oQixRQUFRO0FBQ1Z2aEMsVUFBUXVpQyxXQURFO0FBRVZqckIsVUFBUWlyQjtBQUZFLENBQVo7O0FBS0E7O0FBRUE7Ozs7QUFJQSxTQUFTSyxRQUFULENBQW1CdDdCLEVBQW5CLEVBQXVCZzBCLEdBQXZCLEVBQTRCO0FBQzFCO0FBQ0EsTUFBSSxDQUFDQSxHQUFELElBQVEsRUFBRUEsTUFBTUEsSUFBSTNpQyxJQUFKLEVBQVIsQ0FBWixFQUFpQztBQUMvQjtBQUNEOztBQUVEO0FBQ0EsTUFBSTJPLEdBQUd1N0IsU0FBUCxFQUFrQjtBQUNoQixRQUFJdkgsSUFBSWxnQyxPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCa2dDLFVBQUkxaUMsS0FBSixDQUFVLEtBQVYsRUFBaUJDLE9BQWpCLENBQXlCLFVBQVVwQixDQUFWLEVBQWE7QUFBRSxlQUFPNlAsR0FBR3U3QixTQUFILENBQWFodEIsR0FBYixDQUFpQnBlLENBQWpCLENBQVA7QUFBNkIsT0FBckU7QUFDRCxLQUZELE1BRU87QUFDTDZQLFNBQUd1N0IsU0FBSCxDQUFhaHRCLEdBQWIsQ0FBaUJ5bEIsR0FBakI7QUFDRDtBQUNGLEdBTkQsTUFNTztBQUNMLFFBQUluYixNQUFNLE9BQU83WSxHQUFHMUosWUFBSCxDQUFnQixPQUFoQixLQUE0QixFQUFuQyxJQUF5QyxHQUFuRDtBQUNBLFFBQUl1aUIsSUFBSS9rQixPQUFKLENBQVksTUFBTWtnQyxHQUFOLEdBQVksR0FBeEIsSUFBK0IsQ0FBbkMsRUFBc0M7QUFDcENoMEIsU0FBR3VzQixZQUFILENBQWdCLE9BQWhCLEVBQXlCLENBQUMxVCxNQUFNbWIsR0FBUCxFQUFZM2lDLElBQVosRUFBekI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxTQUFTbXFDLFdBQVQsQ0FBc0J4N0IsRUFBdEIsRUFBMEJnMEIsR0FBMUIsRUFBK0I7QUFDN0I7QUFDQSxNQUFJLENBQUNBLEdBQUQsSUFBUSxFQUFFQSxNQUFNQSxJQUFJM2lDLElBQUosRUFBUixDQUFaLEVBQWlDO0FBQy9CO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJMk8sR0FBR3U3QixTQUFQLEVBQWtCO0FBQ2hCLFFBQUl2SCxJQUFJbGdDLE9BQUosQ0FBWSxHQUFaLElBQW1CLENBQUMsQ0FBeEIsRUFBMkI7QUFDekJrZ0MsVUFBSTFpQyxLQUFKLENBQVUsS0FBVixFQUFpQkMsT0FBakIsQ0FBeUIsVUFBVXBCLENBQVYsRUFBYTtBQUFFLGVBQU82UCxHQUFHdTdCLFNBQUgsQ0FBYTl5QixNQUFiLENBQW9CdFksQ0FBcEIsQ0FBUDtBQUFnQyxPQUF4RTtBQUNELEtBRkQsTUFFTztBQUNMNlAsU0FBR3U3QixTQUFILENBQWE5eUIsTUFBYixDQUFvQnVyQixHQUFwQjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wsUUFBSW5iLE1BQU0sT0FBTzdZLEdBQUcxSixZQUFILENBQWdCLE9BQWhCLEtBQTRCLEVBQW5DLElBQXlDLEdBQW5EO0FBQ0EsUUFBSW1sQyxNQUFNLE1BQU16SCxHQUFOLEdBQVksR0FBdEI7QUFDQSxXQUFPbmIsSUFBSS9rQixPQUFKLENBQVkybkMsR0FBWixLQUFvQixDQUEzQixFQUE4QjtBQUM1QjVpQixZQUFNQSxJQUFJbm9CLE9BQUosQ0FBWStxQyxHQUFaLEVBQWlCLEdBQWpCLENBQU47QUFDRDtBQUNEejdCLE9BQUd1c0IsWUFBSCxDQUFnQixPQUFoQixFQUF5QjFULElBQUl4bkIsSUFBSixFQUF6QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsU0FBU3FxQyxpQkFBVCxDQUE0QkMsTUFBNUIsRUFBb0M7QUFDbEMsTUFBSSxDQUFDQSxNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0Q7QUFDQSxNQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsUUFBSXZxQyxNQUFNLEVBQVY7QUFDQSxRQUFJdXFDLE9BQU9DLEdBQVAsS0FBZSxLQUFuQixFQUEwQjtBQUN4QmhtQyxhQUFPeEUsR0FBUCxFQUFZeXFDLGtCQUFrQkYsT0FBTzF2QyxJQUFQLElBQWUsR0FBakMsQ0FBWjtBQUNEO0FBQ0QySixXQUFPeEUsR0FBUCxFQUFZdXFDLE1BQVo7QUFDQSxXQUFPdnFDLEdBQVA7QUFDRCxHQVBELE1BT08sSUFBSSxPQUFPdXFDLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDckMsV0FBT0Usa0JBQWtCRixNQUFsQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJRSxvQkFBb0IveUIsT0FBTyxVQUFVN2MsSUFBVixFQUFnQjtBQUM3QyxTQUFPO0FBQ0w2dkMsZ0JBQWE3dkMsT0FBTyxRQURmO0FBRUw4dkMsa0JBQWU5dkMsT0FBTyxXQUZqQjtBQUdMK3ZDLHNCQUFtQi92QyxPQUFPLGVBSHJCO0FBSUxnd0MsZ0JBQWFod0MsT0FBTyxRQUpmO0FBS0xpd0Msa0JBQWVqd0MsT0FBTyxXQUxqQjtBQU1Ma3dDLHNCQUFtQmx3QyxPQUFPO0FBTnJCLEdBQVA7QUFRRCxDQVR1QixDQUF4Qjs7QUFXQSxJQUFJbXdDLGdCQUFnQjdrQyxhQUFhLENBQUMwVSxLQUFsQztBQUNBLElBQUlvd0IsYUFBYSxZQUFqQjtBQUNBLElBQUlDLFlBQVksV0FBaEI7O0FBRUE7QUFDQSxJQUFJQyxpQkFBaUIsWUFBckI7QUFDQSxJQUFJQyxxQkFBcUIsZUFBekI7QUFDQSxJQUFJQyxnQkFBZ0IsV0FBcEI7QUFDQSxJQUFJQyxvQkFBb0IsY0FBeEI7QUFDQSxJQUFJTixhQUFKLEVBQW1CO0FBQ2pCO0FBQ0EsTUFBSTVrQyxPQUFPbWxDLGVBQVAsS0FBMkIvc0MsU0FBM0IsSUFDRjRILE9BQU9vbEMscUJBQVAsS0FBaUNodEMsU0FEbkMsRUFDOEM7QUFDNUMyc0MscUJBQWlCLGtCQUFqQjtBQUNBQyx5QkFBcUIscUJBQXJCO0FBQ0Q7QUFDRCxNQUFJaGxDLE9BQU9xbEMsY0FBUCxLQUEwQmp0QyxTQUExQixJQUNGNEgsT0FBT3NsQyxvQkFBUCxLQUFnQ2x0QyxTQURsQyxFQUM2QztBQUMzQzZzQyxvQkFBZ0IsaUJBQWhCO0FBQ0FDLHdCQUFvQixvQkFBcEI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsSUFBSUssTUFBTXhsQyxhQUFhQyxPQUFPd2xDLHFCQUFwQixHQUNOeGxDLE9BQU93bEMscUJBQVAsQ0FBNkJ4NEIsSUFBN0IsQ0FBa0NoTixNQUFsQyxDQURNLEdBRU5uTyxVQUZKOztBQUlBLFNBQVM0ekMsU0FBVCxDQUFvQjk2QixFQUFwQixFQUF3QjtBQUN0QjQ2QixNQUFJLFlBQVk7QUFDZEEsUUFBSTU2QixFQUFKO0FBQ0QsR0FGRDtBQUdEOztBQUVELFNBQVMrNkIsa0JBQVQsQ0FBNkJsOUIsRUFBN0IsRUFBaUNnMEIsR0FBakMsRUFBc0M7QUFDcEMsR0FBQ2gwQixHQUFHazBCLGtCQUFILEtBQTBCbDBCLEdBQUdrMEIsa0JBQUgsR0FBd0IsRUFBbEQsQ0FBRCxFQUF3RHJwQyxJQUF4RCxDQUE2RG1wQyxHQUE3RDtBQUNBc0gsV0FBU3Q3QixFQUFULEVBQWFnMEIsR0FBYjtBQUNEOztBQUVELFNBQVNtSixxQkFBVCxDQUFnQ245QixFQUFoQyxFQUFvQ2cwQixHQUFwQyxFQUF5QztBQUN2QyxNQUFJaDBCLEdBQUdrMEIsa0JBQVAsRUFBMkI7QUFDekJ6ckIsV0FBT3pJLEdBQUdrMEIsa0JBQVYsRUFBOEJGLEdBQTlCO0FBQ0Q7QUFDRHdILGNBQVl4N0IsRUFBWixFQUFnQmcwQixHQUFoQjtBQUNEOztBQUVELFNBQVNvSixrQkFBVCxDQUNFcDlCLEVBREYsRUFFRTJWLFlBRkYsRUFHRXZULEVBSEYsRUFJRTtBQUNBLE1BQUloVSxNQUFNaXZDLGtCQUFrQnI5QixFQUFsQixFQUFzQjJWLFlBQXRCLENBQVY7QUFDQSxNQUFJM25CLE9BQU9JLElBQUlKLElBQWY7QUFDQSxNQUFJM0QsVUFBVStELElBQUkvRCxPQUFsQjtBQUNBLE1BQUlpekMsWUFBWWx2QyxJQUFJa3ZDLFNBQXBCO0FBQ0EsTUFBSSxDQUFDdHZDLElBQUwsRUFBVztBQUFFLFdBQU9vVSxJQUFQO0FBQWE7QUFDMUIsTUFBSTFOLFFBQVExRyxTQUFTcXVDLFVBQVQsR0FBc0JHLGtCQUF0QixHQUEyQ0UsaUJBQXZEO0FBQ0EsTUFBSWEsUUFBUSxDQUFaO0FBQ0EsTUFBSXhnQyxNQUFNLFlBQVk7QUFDcEJpRCxPQUFHKzRCLG1CQUFILENBQXVCcmtDLEtBQXZCLEVBQThCOG9DLEtBQTlCO0FBQ0FwN0I7QUFDRCxHQUhEO0FBSUEsTUFBSW83QixRQUFRLFVBQVVsMEMsQ0FBVixFQUFhO0FBQ3ZCLFFBQUlBLEVBQUV1SyxNQUFGLEtBQWFtTSxFQUFqQixFQUFxQjtBQUNuQixVQUFJLEVBQUV1OUIsS0FBRixJQUFXRCxTQUFmLEVBQTBCO0FBQ3hCdmdDO0FBQ0Q7QUFDRjtBQUNGLEdBTkQ7QUFPQTFULGFBQVcsWUFBWTtBQUNyQixRQUFJazBDLFFBQVFELFNBQVosRUFBdUI7QUFDckJ2Z0M7QUFDRDtBQUNGLEdBSkQsRUFJRzFTLFVBQVUsQ0FKYjtBQUtBMlYsS0FBR2hCLGdCQUFILENBQW9CdEssS0FBcEIsRUFBMkI4b0MsS0FBM0I7QUFDRDs7QUFFRCxJQUFJQyxjQUFjLHdCQUFsQjs7QUFFQSxTQUFTSixpQkFBVCxDQUE0QnI5QixFQUE1QixFQUFnQzJWLFlBQWhDLEVBQThDO0FBQzVDLE1BQUkrbkIsU0FBU2xtQyxPQUFPbW1DLGdCQUFQLENBQXdCMzlCLEVBQXhCLENBQWI7QUFDQSxNQUFJNDlCLG1CQUFtQkYsT0FBT25CLGlCQUFpQixPQUF4QixFQUFpQ2pyQyxLQUFqQyxDQUF1QyxJQUF2QyxDQUF2QjtBQUNBLE1BQUl1c0Msc0JBQXNCSCxPQUFPbkIsaUJBQWlCLFVBQXhCLEVBQW9DanJDLEtBQXBDLENBQTBDLElBQTFDLENBQTFCO0FBQ0EsTUFBSXdzQyxvQkFBb0JDLFdBQVdILGdCQUFYLEVBQTZCQyxtQkFBN0IsQ0FBeEI7QUFDQSxNQUFJRyxrQkFBa0JOLE9BQU9qQixnQkFBZ0IsT0FBdkIsRUFBZ0NuckMsS0FBaEMsQ0FBc0MsSUFBdEMsQ0FBdEI7QUFDQSxNQUFJMnNDLHFCQUFxQlAsT0FBT2pCLGdCQUFnQixVQUF2QixFQUFtQ25yQyxLQUFuQyxDQUF5QyxJQUF6QyxDQUF6QjtBQUNBLE1BQUk0c0MsbUJBQW1CSCxXQUFXQyxlQUFYLEVBQTRCQyxrQkFBNUIsQ0FBdkI7O0FBRUEsTUFBSWp3QyxJQUFKO0FBQ0EsTUFBSTNELFVBQVUsQ0FBZDtBQUNBLE1BQUlpekMsWUFBWSxDQUFoQjtBQUNBO0FBQ0EsTUFBSTNuQixpQkFBaUIwbUIsVUFBckIsRUFBaUM7QUFDL0IsUUFBSXlCLG9CQUFvQixDQUF4QixFQUEyQjtBQUN6Qjl2QyxhQUFPcXVDLFVBQVA7QUFDQWh5QyxnQkFBVXl6QyxpQkFBVjtBQUNBUixrQkFBWU8sb0JBQW9CM3pDLE1BQWhDO0FBQ0Q7QUFDRixHQU5ELE1BTU8sSUFBSXlyQixpQkFBaUIybUIsU0FBckIsRUFBZ0M7QUFDckMsUUFBSTRCLG1CQUFtQixDQUF2QixFQUEwQjtBQUN4Qmx3QyxhQUFPc3VDLFNBQVA7QUFDQWp5QyxnQkFBVTZ6QyxnQkFBVjtBQUNBWixrQkFBWVcsbUJBQW1CL3pDLE1BQS9CO0FBQ0Q7QUFDRixHQU5NLE1BTUE7QUFDTEcsY0FBVWdhLEtBQUtELEdBQUwsQ0FBUzA1QixpQkFBVCxFQUE0QkksZ0JBQTVCLENBQVY7QUFDQWx3QyxXQUFPM0QsVUFBVSxDQUFWLEdBQ0h5ekMsb0JBQW9CSSxnQkFBcEIsR0FDRTdCLFVBREYsR0FFRUMsU0FIQyxHQUlILElBSko7QUFLQWdCLGdCQUFZdHZDLE9BQ1JBLFNBQVNxdUMsVUFBVCxHQUNFd0Isb0JBQW9CM3pDLE1BRHRCLEdBRUUrekMsbUJBQW1CL3pDLE1BSGIsR0FJUixDQUpKO0FBS0Q7QUFDRCxNQUFJaTBDLGVBQ0Zud0MsU0FBU3F1QyxVQUFULElBQ0FvQixZQUFZbG5DLElBQVosQ0FBaUJtbkMsT0FBT25CLGlCQUFpQixVQUF4QixDQUFqQixDQUZGO0FBR0EsU0FBTztBQUNMdnVDLFVBQU1BLElBREQ7QUFFTDNELGFBQVNBLE9BRko7QUFHTGl6QyxlQUFXQSxTQUhOO0FBSUxhLGtCQUFjQTtBQUpULEdBQVA7QUFNRDs7QUFFRCxTQUFTSixVQUFULENBQXFCSyxNQUFyQixFQUE2QkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQSxTQUFPRCxPQUFPbDBDLE1BQVAsR0FBZ0JtMEMsVUFBVW4wQyxNQUFqQyxFQUF5QztBQUN2Q2swQyxhQUFTQSxPQUFPajBDLE1BQVAsQ0FBY2kwQyxNQUFkLENBQVQ7QUFDRDs7QUFFRCxTQUFPLzVCLEtBQUtELEdBQUwsQ0FBU25aLEtBQVQsQ0FBZSxJQUFmLEVBQXFCb3pDLFVBQVVwc0MsR0FBVixDQUFjLFVBQVVzeEIsQ0FBVixFQUFhMzRCLENBQWIsRUFBZ0I7QUFDeEQsV0FBTzB6QyxLQUFLL2EsQ0FBTCxJQUFVK2EsS0FBS0YsT0FBT3h6QyxDQUFQLENBQUwsQ0FBakI7QUFDRCxHQUYyQixDQUFyQixDQUFQO0FBR0Q7O0FBRUQsU0FBUzB6QyxJQUFULENBQWVDLENBQWYsRUFBa0I7QUFDaEIsU0FBT0MsT0FBT0QsRUFBRXBzQyxLQUFGLENBQVEsQ0FBUixFQUFXLENBQUMsQ0FBWixDQUFQLElBQXlCLElBQWhDO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU3NzQyxLQUFULENBQWdCbnZDLEtBQWhCLEVBQXVCb3ZDLGFBQXZCLEVBQXNDO0FBQ3BDLE1BQUkxK0IsS0FBSzFRLE1BQU04bkIsR0FBZjs7QUFFQTtBQUNBLE1BQUlwWCxHQUFHc3lCLFFBQVAsRUFBaUI7QUFDZnR5QixPQUFHc3lCLFFBQUgsQ0FBWXFNLFNBQVosR0FBd0IsSUFBeEI7QUFDQTMrQixPQUFHc3lCLFFBQUg7QUFDRDs7QUFFRCxNQUFJL2pDLE9BQU9tdEMsa0JBQWtCcHNDLE1BQU1mLElBQU4sQ0FBV2doQyxVQUE3QixDQUFYO0FBQ0EsTUFBSSxDQUFDaGhDLElBQUwsRUFBVztBQUNUO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJeVIsR0FBRzQrQixRQUFILElBQWU1K0IsR0FBRzh4QixRQUFILEtBQWdCLENBQW5DLEVBQXNDO0FBQ3BDO0FBQ0Q7O0FBRUQsTUFBSThKLE1BQU1ydEMsS0FBS3F0QyxHQUFmO0FBQ0EsTUFBSTV0QyxPQUFPTyxLQUFLUCxJQUFoQjtBQUNBLE1BQUk4dEMsYUFBYXZ0QyxLQUFLdXRDLFVBQXRCO0FBQ0EsTUFBSUMsZUFBZXh0QyxLQUFLd3RDLFlBQXhCO0FBQ0EsTUFBSUMsbUJBQW1CenRDLEtBQUt5dEMsZ0JBQTVCO0FBQ0EsTUFBSTZDLGNBQWN0d0MsS0FBS3N3QyxXQUF2QjtBQUNBLE1BQUlDLGdCQUFnQnZ3QyxLQUFLdXdDLGFBQXpCO0FBQ0EsTUFBSUMsb0JBQW9CeHdDLEtBQUt3d0MsaUJBQTdCO0FBQ0EsTUFBSS9sQyxjQUFjekssS0FBS3lLLFdBQXZCO0FBQ0EsTUFBSXlsQyxRQUFRbHdDLEtBQUtrd0MsS0FBakI7QUFDQSxNQUFJTyxhQUFhendDLEtBQUt5d0MsVUFBdEI7QUFDQSxNQUFJQyxpQkFBaUIxd0MsS0FBSzB3QyxjQUExQjtBQUNBLE1BQUlDLGVBQWUzd0MsS0FBSzJ3QyxZQUF4QjtBQUNBLE1BQUlDLFNBQVM1d0MsS0FBSzR3QyxNQUFsQjtBQUNBLE1BQUlDLGNBQWM3d0MsS0FBSzZ3QyxXQUF2QjtBQUNBLE1BQUlDLGtCQUFrQjl3QyxLQUFLOHdDLGVBQTNCO0FBQ0EsTUFBSUMsV0FBVy93QyxLQUFLK3dDLFFBQXBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSWpvQixVQUFVMkQsY0FBZDtBQUNBLE1BQUl1a0IsaUJBQWlCdmtCLGVBQWVsc0IsTUFBcEM7QUFDQSxTQUFPeXdDLGtCQUFrQkEsZUFBZWp4QyxNQUF4QyxFQUFnRDtBQUM5Q2l4QyxxQkFBaUJBLGVBQWVqeEMsTUFBaEM7QUFDQStvQixjQUFVa29CLGVBQWVsb0IsT0FBekI7QUFDRDs7QUFFRCxNQUFJbW9CLFdBQVcsQ0FBQ25vQixRQUFRa0UsVUFBVCxJQUF1QixDQUFDanNCLE1BQU1vb0IsWUFBN0M7O0FBRUEsTUFBSThuQixZQUFZLENBQUNMLE1BQWIsSUFBdUJBLFdBQVcsRUFBdEMsRUFBMEM7QUFDeEM7QUFDRDs7QUFFRCxNQUFJTSxhQUFhRCxZQUFZWCxXQUFaLEdBQ2JBLFdBRGEsR0FFYi9DLFVBRko7QUFHQSxNQUFJcm5DLGNBQWMrcUMsWUFBWVQsaUJBQVosR0FDZEEsaUJBRGMsR0FFZC9DLGdCQUZKO0FBR0EsTUFBSTBELFVBQVVGLFlBQVlWLGFBQVosR0FDVkEsYUFEVSxHQUVWL0MsWUFGSjs7QUFJQSxNQUFJNEQsa0JBQWtCSCxXQUNqQk4sZ0JBQWdCbG1DLFdBREMsR0FFbEJBLFdBRko7QUFHQSxNQUFJNG1DLFlBQVlKLFdBQ1gsT0FBT0wsTUFBUCxLQUFrQixVQUFsQixHQUErQkEsTUFBL0IsR0FBd0NWLEtBRDdCLEdBRVpBLEtBRko7QUFHQSxNQUFJb0IsaUJBQWlCTCxXQUNoQkosZUFBZUosVUFEQyxHQUVqQkEsVUFGSjtBQUdBLE1BQUljLHFCQUFxQk4sV0FDcEJILG1CQUFtQkosY0FEQyxHQUVyQkEsY0FGSjs7QUFJQSxNQUFJYyx3QkFBd0I5M0IsU0FDMUJuSSxTQUFTdy9CLFFBQVQsSUFDSUEsU0FBU2IsS0FEYixHQUVJYSxRQUhzQixDQUE1Qjs7QUFNQSxNQUFJejJDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDNnVDLHlCQUF5QixJQUF0RSxFQUE0RTtBQUMxRUMsa0JBQWNELHFCQUFkLEVBQXFDLE9BQXJDLEVBQThDendDLEtBQTlDO0FBQ0Q7O0FBRUQsTUFBSTJ3QyxhQUFhckUsUUFBUSxLQUFSLElBQWlCLENBQUMzdkIsS0FBbkM7QUFDQSxNQUFJaTBCLG1CQUFtQkMsdUJBQXVCUCxTQUF2QixDQUF2Qjs7QUFFQSxNQUFJeDlCLEtBQUtwQyxHQUFHNCtCLFFBQUgsR0FBY2p6QyxLQUFLLFlBQVk7QUFDdEMsUUFBSXMwQyxVQUFKLEVBQWdCO0FBQ2Q5Qyw0QkFBc0JuOUIsRUFBdEIsRUFBMEIwL0IsT0FBMUI7QUFDQXZDLDRCQUFzQm45QixFQUF0QixFQUEwQnZMLFdBQTFCO0FBQ0Q7QUFDRCxRQUFJMk4sR0FBR3U4QixTQUFQLEVBQWtCO0FBQ2hCLFVBQUlzQixVQUFKLEVBQWdCO0FBQ2Q5Qyw4QkFBc0JuOUIsRUFBdEIsRUFBMEJ5L0IsVUFBMUI7QUFDRDtBQUNESyw0QkFBc0JBLG1CQUFtQjkvQixFQUFuQixDQUF0QjtBQUNELEtBTEQsTUFLTztBQUNMNi9CLHdCQUFrQkEsZUFBZTcvQixFQUFmLENBQWxCO0FBQ0Q7QUFDREEsT0FBRzQrQixRQUFILEdBQWMsSUFBZDtBQUNELEdBZHNCLENBQXZCOztBQWdCQSxNQUFJLENBQUN0dkMsTUFBTWYsSUFBTixDQUFXNnhDLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0FybkIsbUJBQWV6cEIsTUFBTWYsSUFBTixDQUFXYSxJQUFYLEtBQW9CRSxNQUFNZixJQUFOLENBQVdhLElBQVgsR0FBa0IsRUFBdEMsQ0FBZixFQUEwRCxRQUExRCxFQUFvRSxZQUFZO0FBQzlFLFVBQUlkLFNBQVMwUixHQUFHa3JCLFVBQWhCO0FBQ0EsVUFBSW1WLGNBQWMveEMsVUFBVUEsT0FBT2d5QyxRQUFqQixJQUE2Qmh5QyxPQUFPZ3lDLFFBQVAsQ0FBZ0JoeEMsTUFBTTZCLEdBQXRCLENBQS9DO0FBQ0EsVUFBSWt2QyxlQUNBQSxZQUFZaHNDLEdBQVosS0FBb0IvRSxNQUFNK0UsR0FEMUIsSUFFQWdzQyxZQUFZanBCLEdBQVosQ0FBZ0JrYixRQUZwQixFQUU4QjtBQUM1QitOLG9CQUFZanBCLEdBQVosQ0FBZ0JrYixRQUFoQjtBQUNEO0FBQ0RzTixtQkFBYUEsVUFBVTUvQixFQUFWLEVBQWNvQyxFQUFkLENBQWI7QUFDRCxLQVREO0FBVUQ7O0FBRUQ7QUFDQXU5QixxQkFBbUJBLGdCQUFnQjMvQixFQUFoQixDQUFuQjtBQUNBLE1BQUlpZ0MsVUFBSixFQUFnQjtBQUNkL0MsdUJBQW1CbDlCLEVBQW5CLEVBQXVCeS9CLFVBQXZCO0FBQ0F2Qyx1QkFBbUJsOUIsRUFBbkIsRUFBdUJ2TCxXQUF2QjtBQUNBd29DLGNBQVUsWUFBWTtBQUNwQkMseUJBQW1CbDlCLEVBQW5CLEVBQXVCMC9CLE9BQXZCO0FBQ0F2Qyw0QkFBc0JuOUIsRUFBdEIsRUFBMEJ5L0IsVUFBMUI7QUFDQSxVQUFJLENBQUNyOUIsR0FBR3U4QixTQUFKLElBQWlCLENBQUN1QixnQkFBdEIsRUFBd0M7QUFDdEMsWUFBSUssZ0JBQWdCUixxQkFBaEIsQ0FBSixFQUE0QztBQUMxQzEyQyxxQkFBVytZLEVBQVgsRUFBZTI5QixxQkFBZjtBQUNELFNBRkQsTUFFTztBQUNMM0MsNkJBQW1CcDlCLEVBQW5CLEVBQXVCaFMsSUFBdkIsRUFBNkJvVSxFQUE3QjtBQUNEO0FBQ0Y7QUFDRixLQVZEO0FBV0Q7O0FBRUQsTUFBSTlTLE1BQU1mLElBQU4sQ0FBVzZ4QyxJQUFmLEVBQXFCO0FBQ25CMUIscUJBQWlCQSxlQUFqQjtBQUNBa0IsaUJBQWFBLFVBQVU1L0IsRUFBVixFQUFjb0MsRUFBZCxDQUFiO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDNjlCLFVBQUQsSUFBZSxDQUFDQyxnQkFBcEIsRUFBc0M7QUFDcEM5OUI7QUFDRDtBQUNGOztBQUVELFNBQVNvK0IsS0FBVCxDQUFnQmx4QyxLQUFoQixFQUF1QjJnQyxFQUF2QixFQUEyQjtBQUN6QixNQUFJandCLEtBQUsxUSxNQUFNOG5CLEdBQWY7O0FBRUE7QUFDQSxNQUFJcFgsR0FBRzQrQixRQUFQLEVBQWlCO0FBQ2Y1K0IsT0FBRzQrQixRQUFILENBQVlELFNBQVosR0FBd0IsSUFBeEI7QUFDQTMrQixPQUFHNCtCLFFBQUg7QUFDRDs7QUFFRCxNQUFJcndDLE9BQU9tdEMsa0JBQWtCcHNDLE1BQU1mLElBQU4sQ0FBV2doQyxVQUE3QixDQUFYO0FBQ0EsTUFBSSxDQUFDaGhDLElBQUwsRUFBVztBQUNULFdBQU8waEMsSUFBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSWp3QixHQUFHc3lCLFFBQUgsSUFBZXR5QixHQUFHOHhCLFFBQUgsS0FBZ0IsQ0FBbkMsRUFBc0M7QUFDcEM7QUFDRDs7QUFFRCxNQUFJOEosTUFBTXJ0QyxLQUFLcXRDLEdBQWY7QUFDQSxNQUFJNXRDLE9BQU9PLEtBQUtQLElBQWhCO0FBQ0EsTUFBSWl1QyxhQUFhMXRDLEtBQUswdEMsVUFBdEI7QUFDQSxNQUFJQyxlQUFlM3RDLEtBQUsydEMsWUFBeEI7QUFDQSxNQUFJQyxtQkFBbUI1dEMsS0FBSzR0QyxnQkFBNUI7QUFDQSxNQUFJc0UsY0FBY2x5QyxLQUFLa3lDLFdBQXZCO0FBQ0EsTUFBSUQsUUFBUWp5QyxLQUFLaXlDLEtBQWpCO0FBQ0EsTUFBSUUsYUFBYW55QyxLQUFLbXlDLFVBQXRCO0FBQ0EsTUFBSUMsaUJBQWlCcHlDLEtBQUtveUMsY0FBMUI7QUFDQSxNQUFJQyxhQUFhcnlDLEtBQUtxeUMsVUFBdEI7QUFDQSxNQUFJdEIsV0FBVy93QyxLQUFLK3dDLFFBQXBCOztBQUVBLE1BQUlXLGFBQWFyRSxRQUFRLEtBQVIsSUFBaUIsQ0FBQzN2QixLQUFuQztBQUNBLE1BQUlpMEIsbUJBQW1CQyx1QkFBdUJLLEtBQXZCLENBQXZCOztBQUVBLE1BQUlLLHdCQUF3QjU0QixTQUMxQm5JLFNBQVN3L0IsUUFBVCxJQUNJQSxTQUFTa0IsS0FEYixHQUVJbEIsUUFIc0IsQ0FBNUI7O0FBTUEsTUFBSXoyQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzJ2Qyx5QkFBeUIsSUFBdEUsRUFBNEU7QUFDMUViLGtCQUFjYSxxQkFBZCxFQUFxQyxPQUFyQyxFQUE4Q3Z4QyxLQUE5QztBQUNEOztBQUVELE1BQUk4UyxLQUFLcEMsR0FBR3N5QixRQUFILEdBQWMzbUMsS0FBSyxZQUFZO0FBQ3RDLFFBQUlxVSxHQUFHa3JCLFVBQUgsSUFBaUJsckIsR0FBR2tyQixVQUFILENBQWNvVixRQUFuQyxFQUE2QztBQUMzQ3RnQyxTQUFHa3JCLFVBQUgsQ0FBY29WLFFBQWQsQ0FBdUJoeEMsTUFBTTZCLEdBQTdCLElBQW9DLElBQXBDO0FBQ0Q7QUFDRCxRQUFJOHVDLFVBQUosRUFBZ0I7QUFDZDlDLDRCQUFzQm45QixFQUF0QixFQUEwQms4QixZQUExQjtBQUNBaUIsNEJBQXNCbjlCLEVBQXRCLEVBQTBCbThCLGdCQUExQjtBQUNEO0FBQ0QsUUFBSS81QixHQUFHdThCLFNBQVAsRUFBa0I7QUFDaEIsVUFBSXNCLFVBQUosRUFBZ0I7QUFDZDlDLDhCQUFzQm45QixFQUF0QixFQUEwQmk4QixVQUExQjtBQUNEO0FBQ0QwRSx3QkFBa0JBLGVBQWUzZ0MsRUFBZixDQUFsQjtBQUNELEtBTEQsTUFLTztBQUNMaXdCO0FBQ0F5USxvQkFBY0EsV0FBVzFnQyxFQUFYLENBQWQ7QUFDRDtBQUNEQSxPQUFHc3lCLFFBQUgsR0FBYyxJQUFkO0FBQ0QsR0FsQnNCLENBQXZCOztBQW9CQSxNQUFJc08sVUFBSixFQUFnQjtBQUNkQSxlQUFXRSxZQUFYO0FBQ0QsR0FGRCxNQUVPO0FBQ0xBO0FBQ0Q7O0FBRUQsV0FBU0EsWUFBVCxHQUF5QjtBQUN2QjtBQUNBLFFBQUkxK0IsR0FBR3U4QixTQUFQLEVBQWtCO0FBQ2hCO0FBQ0Q7QUFDRDtBQUNBLFFBQUksQ0FBQ3J2QyxNQUFNZixJQUFOLENBQVc2eEMsSUFBaEIsRUFBc0I7QUFDcEIsT0FBQ3BnQyxHQUFHa3JCLFVBQUgsQ0FBY29WLFFBQWQsS0FBMkJ0Z0MsR0FBR2tyQixVQUFILENBQWNvVixRQUFkLEdBQXlCLEVBQXBELENBQUQsRUFBMERoeEMsTUFBTTZCLEdBQWhFLElBQXVFN0IsS0FBdkU7QUFDRDtBQUNEbXhDLG1CQUFlQSxZQUFZemdDLEVBQVosQ0FBZjtBQUNBLFFBQUlpZ0MsVUFBSixFQUFnQjtBQUNkL0MseUJBQW1CbDlCLEVBQW5CLEVBQXVCaThCLFVBQXZCO0FBQ0FpQix5QkFBbUJsOUIsRUFBbkIsRUFBdUJtOEIsZ0JBQXZCO0FBQ0FjLGdCQUFVLFlBQVk7QUFDcEJDLDJCQUFtQmw5QixFQUFuQixFQUF1Qms4QixZQUF2QjtBQUNBaUIsOEJBQXNCbjlCLEVBQXRCLEVBQTBCaThCLFVBQTFCO0FBQ0EsWUFBSSxDQUFDNzVCLEdBQUd1OEIsU0FBSixJQUFpQixDQUFDdUIsZ0JBQXRCLEVBQXdDO0FBQ3RDLGNBQUlLLGdCQUFnQk0scUJBQWhCLENBQUosRUFBNEM7QUFDMUN4M0MsdUJBQVcrWSxFQUFYLEVBQWV5K0IscUJBQWY7QUFDRCxXQUZELE1BRU87QUFDTHpELCtCQUFtQnA5QixFQUFuQixFQUF1QmhTLElBQXZCLEVBQTZCb1UsRUFBN0I7QUFDRDtBQUNGO0FBQ0YsT0FWRDtBQVdEO0FBQ0RvK0IsYUFBU0EsTUFBTXhnQyxFQUFOLEVBQVVvQyxFQUFWLENBQVQ7QUFDQSxRQUFJLENBQUM2OUIsVUFBRCxJQUFlLENBQUNDLGdCQUFwQixFQUFzQztBQUNwQzk5QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLFNBQVM0OUIsYUFBVCxDQUF3QnJ1QyxHQUF4QixFQUE2QjFGLElBQTdCLEVBQW1DcUQsS0FBbkMsRUFBMEM7QUFDeEMsTUFBSSxPQUFPcUMsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCaEUsU0FDRSwyQkFBMkIxQixJQUEzQixHQUFrQyxvQ0FBbEMsR0FDQSxNQURBLEdBQ1UrUCxLQUFLQyxTQUFMLENBQWV0SyxHQUFmLENBRFYsR0FDaUMsR0FGbkMsRUFHRXJDLE1BQU0rbkIsT0FIUjtBQUtELEdBTkQsTUFNTyxJQUFJbFAsTUFBTXhXLEdBQU4sQ0FBSixFQUFnQjtBQUNyQmhFLFNBQ0UsMkJBQTJCMUIsSUFBM0IsR0FBa0MscUJBQWxDLEdBQ0EsNkNBRkYsRUFHRXFELE1BQU0rbkIsT0FIUjtBQUtEO0FBQ0Y7O0FBRUQsU0FBU2twQixlQUFULENBQTBCNXVDLEdBQTFCLEVBQStCO0FBQzdCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkIsQ0FBQ3dXLE1BQU14VyxHQUFOLENBQW5DO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVN3dUMsc0JBQVQsQ0FBaUNoK0IsRUFBakMsRUFBcUM7QUFDbkMsTUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFBRSxXQUFPLEtBQVA7QUFBYztBQUN6QixNQUFJNCtCLGFBQWE1K0IsR0FBR3FXLEdBQXBCO0FBQ0EsTUFBSXVvQixVQUFKLEVBQWdCO0FBQ2Q7QUFDQSxXQUFPWix1QkFDTHoxQyxNQUFNbUgsT0FBTixDQUFja3ZDLFVBQWQsSUFDSUEsV0FBVyxDQUFYLENBREosR0FFSUEsVUFIQyxDQUFQO0FBS0QsR0FQRCxNQU9PO0FBQ0wsV0FBTyxDQUFDNStCLEdBQUdxSCxPQUFILElBQWNySCxHQUFHalksTUFBbEIsSUFBNEIsQ0FBbkM7QUFDRDtBQUNGOztBQUVELFNBQVM4MkMsTUFBVCxDQUFpQjU3QixDQUFqQixFQUFvQjlWLEtBQXBCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0EsTUFBTWYsSUFBTixDQUFXNnhDLElBQWhCLEVBQXNCO0FBQ3BCM0IsVUFBTW52QyxLQUFOO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJaWdDLGFBQWFoNEIsWUFBWTtBQUMzQm1CLFVBQVFzb0MsTUFEbUI7QUFFM0J4UixZQUFVd1IsTUFGaUI7QUFHM0J2NEIsVUFBUSxTQUFTbVEsU0FBVCxDQUFvQnRwQixLQUFwQixFQUEyQjJnQyxFQUEzQixFQUErQjtBQUNyQztBQUNBLFFBQUksQ0FBQzNnQyxNQUFNZixJQUFOLENBQVc2eEMsSUFBaEIsRUFBc0I7QUFDcEJJLFlBQU1seEMsS0FBTixFQUFhMmdDLEVBQWI7QUFDRCxLQUZELE1BRU87QUFDTEE7QUFDRDtBQUNGO0FBVjBCLENBQVosR0FXYixFQVhKOztBQWFBLElBQUlnUixrQkFBa0IsQ0FDcEJ6ckMsS0FEb0IsRUFFcEI0K0IsS0FGb0IsRUFHcEJ1QixNQUhvQixFQUlwQjVSLFFBSm9CLEVBS3BCa1csS0FMb0IsRUFNcEIxSyxVQU5vQixDQUF0Qjs7QUFTQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSXBsQixVQUFVODJCLGdCQUFnQjkyQyxNQUFoQixDQUF1QnFwQyxXQUF2QixDQUFkOztBQUVBLElBQUl6QixRQUFRNUQsb0JBQW9CLEVBQUVoQixTQUFTQSxPQUFYLEVBQW9CaGpCLFNBQVNBLE9BQTdCLEVBQXBCLENBQVo7O0FBRUE7Ozs7O0FBS0E7QUFDQSxJQUFJOEIsS0FBSixFQUFXO0FBQ1Q7QUFDQWhNLFdBQVNqQixnQkFBVCxDQUEwQixpQkFBMUIsRUFBNkMsWUFBWTtBQUN2RCxRQUFJZ0IsS0FBS0MsU0FBU3k1QixhQUFsQjtBQUNBLFFBQUkxNUIsTUFBTUEsR0FBR2toQyxNQUFiLEVBQXFCO0FBQ25CQyxjQUFRbmhDLEVBQVIsRUFBWSxPQUFaO0FBQ0Q7QUFDRixHQUxEO0FBTUQ7O0FBRUQsSUFBSW9oQyxVQUFVO0FBQ1p2d0IsWUFBVSxTQUFTQSxRQUFULENBQW1CN1EsRUFBbkIsRUFBdUJoVSxPQUF2QixFQUFnQ3NELEtBQWhDLEVBQXVDO0FBQy9DLFFBQUlBLE1BQU0rRSxHQUFOLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIsVUFBSStOLEtBQUssWUFBWTtBQUNuQmkvQixvQkFBWXJoQyxFQUFaLEVBQWdCaFUsT0FBaEIsRUFBeUJzRCxNQUFNK25CLE9BQS9CO0FBQ0QsT0FGRDtBQUdBalY7QUFDQTtBQUNBLFVBQUk0SixRQUFRRSxNQUFaLEVBQW9CO0FBQ2xCN2lCLG1CQUFXK1ksRUFBWCxFQUFlLENBQWY7QUFDRDtBQUNGLEtBVEQsTUFTTyxJQUFJOVMsTUFBTStFLEdBQU4sS0FBYyxVQUFkLElBQTRCMkwsR0FBR2hTLElBQUgsS0FBWSxNQUF4QyxJQUFrRGdTLEdBQUdoUyxJQUFILEtBQVksVUFBbEUsRUFBOEU7QUFDbkZnUyxTQUFHMjVCLFdBQUgsR0FBaUIzdEMsUUFBUXFuQyxTQUF6QjtBQUNBLFVBQUksQ0FBQ3JuQyxRQUFRcW5DLFNBQVIsQ0FBa0J2VSxJQUF2QixFQUE2QjtBQUMzQixZQUFJLENBQUMzUyxTQUFMLEVBQWdCO0FBQ2RuTSxhQUFHaEIsZ0JBQUgsQ0FBb0Isa0JBQXBCLEVBQXdDc2lDLGtCQUF4QztBQUNBdGhDLGFBQUdoQixnQkFBSCxDQUFvQixnQkFBcEIsRUFBc0N1aUMsZ0JBQXRDO0FBQ0Q7QUFDRDtBQUNBLFlBQUl0MUIsS0FBSixFQUFXO0FBQ1RqTSxhQUFHa2hDLE1BQUgsR0FBWSxJQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0F4Qlc7QUF5QlpoTyxvQkFBa0IsU0FBU0EsZ0JBQVQsQ0FBMkJsekIsRUFBM0IsRUFBK0JoVSxPQUEvQixFQUF3Q3NELEtBQXhDLEVBQStDO0FBQy9ELFFBQUlBLE1BQU0rRSxHQUFOLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUJndEMsa0JBQVlyaEMsRUFBWixFQUFnQmhVLE9BQWhCLEVBQXlCc0QsTUFBTStuQixPQUEvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSW1xQixZQUFZeGhDLEdBQUdzc0IsUUFBSCxHQUNadGdDLFFBQVFhLEtBQVIsQ0FBY29NLElBQWQsQ0FBbUIsVUFBVWtJLENBQVYsRUFBYTtBQUFFLGVBQU9zZ0Msb0JBQW9CdGdDLENBQXBCLEVBQXVCbkIsR0FBRy9LLE9BQTFCLENBQVA7QUFBNEMsT0FBOUUsQ0FEWSxHQUVaakosUUFBUWEsS0FBUixLQUFrQmIsUUFBUXl6QixRQUExQixJQUFzQ2dpQixvQkFBb0J6MUMsUUFBUWEsS0FBNUIsRUFBbUNtVCxHQUFHL0ssT0FBdEMsQ0FGMUM7QUFHQSxVQUFJdXNDLFNBQUosRUFBZTtBQUNiTCxnQkFBUW5oQyxFQUFSLEVBQVksUUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQXZDVyxDQUFkOztBQTBDQSxTQUFTcWhDLFdBQVQsQ0FBc0JyaEMsRUFBdEIsRUFBMEJoVSxPQUExQixFQUFtQytpQixFQUFuQyxFQUF1QztBQUNyQyxNQUFJbGlCLFFBQVFiLFFBQVFhLEtBQXBCO0FBQ0EsTUFBSTYwQyxhQUFhMWhDLEdBQUdzc0IsUUFBcEI7QUFDQSxNQUFJb1YsY0FBYyxDQUFDaDNDLE1BQU1tSCxPQUFOLENBQWNoRixLQUFkLENBQW5CLEVBQXlDO0FBQ3ZDaEUsWUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QyxnQ0FBaUMzQixRQUFRd3lCLFVBQXpDLEdBQXVELE1BQXZELEdBQ0Esa0RBREEsR0FDc0Q3eEIsT0FBTzNCLFNBQVAsQ0FBaUJxRixRQUFqQixDQUEwQjNHLElBQTFCLENBQStCbUQsS0FBL0IsRUFBc0NzRixLQUF0QyxDQUE0QyxDQUE1QyxFQUErQyxDQUFDLENBQWhELENBRmYsRUFHdkM0YyxFQUh1QyxDQUF6QztBQUtBO0FBQ0Q7QUFDRCxNQUFJb2QsUUFBSixFQUFjd1YsTUFBZDtBQUNBLE9BQUssSUFBSS8yQyxJQUFJLENBQVIsRUFBVzJlLElBQUl2SixHQUFHL0ssT0FBSCxDQUFXL0ssTUFBL0IsRUFBdUNVLElBQUkyZSxDQUEzQyxFQUE4QzNlLEdBQTlDLEVBQW1EO0FBQ2pEKzJDLGFBQVMzaEMsR0FBRy9LLE9BQUgsQ0FBV3JLLENBQVgsQ0FBVDtBQUNBLFFBQUk4MkMsVUFBSixFQUFnQjtBQUNkdlYsaUJBQVcxaEIsYUFBYTVkLEtBQWIsRUFBb0IrMEMsU0FBU0QsTUFBVCxDQUFwQixJQUF3QyxDQUFDLENBQXBEO0FBQ0EsVUFBSUEsT0FBT3hWLFFBQVAsS0FBb0JBLFFBQXhCLEVBQWtDO0FBQ2hDd1YsZUFBT3hWLFFBQVAsR0FBa0JBLFFBQWxCO0FBQ0Q7QUFDRixLQUxELE1BS087QUFDTCxVQUFJN2hCLFdBQVdzM0IsU0FBU0QsTUFBVCxDQUFYLEVBQTZCOTBDLEtBQTdCLENBQUosRUFBeUM7QUFDdkMsWUFBSW1ULEdBQUc2aEMsYUFBSCxLQUFxQmozQyxDQUF6QixFQUE0QjtBQUMxQm9WLGFBQUc2aEMsYUFBSCxHQUFtQmozQyxDQUFuQjtBQUNEO0FBQ0Q7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxNQUFJLENBQUM4MkMsVUFBTCxFQUFpQjtBQUNmMWhDLE9BQUc2aEMsYUFBSCxHQUFtQixDQUFDLENBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTSixtQkFBVCxDQUE4QjUwQyxLQUE5QixFQUFxQ29JLE9BQXJDLEVBQThDO0FBQzVDLE9BQUssSUFBSXJLLElBQUksQ0FBUixFQUFXMmUsSUFBSXRVLFFBQVEvSyxNQUE1QixFQUFvQ1UsSUFBSTJlLENBQXhDLEVBQTJDM2UsR0FBM0MsRUFBZ0Q7QUFDOUMsUUFBSTBmLFdBQVdzM0IsU0FBUzNzQyxRQUFRckssQ0FBUixDQUFULENBQVgsRUFBaUNpQyxLQUFqQyxDQUFKLEVBQTZDO0FBQzNDLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTKzBDLFFBQVQsQ0FBbUJELE1BQW5CLEVBQTJCO0FBQ3pCLFNBQU8sWUFBWUEsTUFBWixHQUNIQSxPQUFPeEksTUFESixHQUVId0ksT0FBTzkwQyxLQUZYO0FBR0Q7O0FBRUQsU0FBU3kwQyxrQkFBVCxDQUE2Qmg0QyxDQUE3QixFQUFnQztBQUM5QkEsSUFBRXVLLE1BQUYsQ0FBUzBsQyxTQUFULEdBQXFCLElBQXJCO0FBQ0Q7O0FBRUQsU0FBU2dJLGdCQUFULENBQTJCajRDLENBQTNCLEVBQThCO0FBQzVCQSxJQUFFdUssTUFBRixDQUFTMGxDLFNBQVQsR0FBcUIsS0FBckI7QUFDQTRILFVBQVE3M0MsRUFBRXVLLE1BQVYsRUFBa0IsT0FBbEI7QUFDRDs7QUFFRCxTQUFTc3RDLE9BQVQsQ0FBa0JuaEMsRUFBbEIsRUFBc0JoUyxJQUF0QixFQUE0QjtBQUMxQixNQUFJMUUsSUFBSTJXLFNBQVM2aEMsV0FBVCxDQUFxQixZQUFyQixDQUFSO0FBQ0F4NEMsSUFBRXk0QyxTQUFGLENBQVkvekMsSUFBWixFQUFrQixJQUFsQixFQUF3QixJQUF4QjtBQUNBZ1MsS0FBR2dpQyxhQUFILENBQWlCMTRDLENBQWpCO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxTQUFTMjRDLFVBQVQsQ0FBcUIzeUMsS0FBckIsRUFBNEI7QUFDMUIsU0FBT0EsTUFBTW1vQixpQkFBTixLQUE0QixDQUFDbm9CLE1BQU1mLElBQVAsSUFBZSxDQUFDZSxNQUFNZixJQUFOLENBQVdnaEMsVUFBdkQsSUFDSDBTLFdBQVczeUMsTUFBTW1vQixpQkFBTixDQUF3QndFLE1BQW5DLENBREcsR0FFSDNzQixLQUZKO0FBR0Q7O0FBRUQsSUFBSTh3QyxPQUFPO0FBQ1Q1N0IsUUFBTSxTQUFTQSxJQUFULENBQWV4RSxFQUFmLEVBQW1CNVIsR0FBbkIsRUFBd0JrQixLQUF4QixFQUErQjtBQUNuQyxRQUFJekMsUUFBUXVCLElBQUl2QixLQUFoQjs7QUFFQXlDLFlBQVEyeUMsV0FBVzN5QyxLQUFYLENBQVI7QUFDQSxRQUFJaWdDLGFBQWFqZ0MsTUFBTWYsSUFBTixJQUFjZSxNQUFNZixJQUFOLENBQVdnaEMsVUFBMUM7QUFDQSxRQUFJMlMsa0JBQWtCbGlDLEdBQUdtaUMsa0JBQUgsR0FDcEJuaUMsR0FBR2k2QixLQUFILENBQVNtSSxPQUFULEtBQXFCLE1BQXJCLEdBQThCLEVBQTlCLEdBQW1DcGlDLEdBQUdpNkIsS0FBSCxDQUFTbUksT0FEOUM7QUFFQSxRQUFJdjFDLFNBQVMwaUMsVUFBVCxJQUF1QixDQUFDdGpCLEtBQTVCLEVBQW1DO0FBQ2pDM2MsWUFBTWYsSUFBTixDQUFXNnhDLElBQVgsR0FBa0IsSUFBbEI7QUFDQTNCLFlBQU1udkMsS0FBTixFQUFhLFlBQVk7QUFDdkIwUSxXQUFHaTZCLEtBQUgsQ0FBU21JLE9BQVQsR0FBbUJGLGVBQW5CO0FBQ0QsT0FGRDtBQUdELEtBTEQsTUFLTztBQUNMbGlDLFNBQUdpNkIsS0FBSCxDQUFTbUksT0FBVCxHQUFtQnYxQyxRQUFRcTFDLGVBQVIsR0FBMEIsTUFBN0M7QUFDRDtBQUNGLEdBaEJROztBQWtCVGx5QixVQUFRLFNBQVNBLE1BQVQsQ0FBaUJoUSxFQUFqQixFQUFxQjVSLEdBQXJCLEVBQTBCa0IsS0FBMUIsRUFBaUM7QUFDdkMsUUFBSXpDLFFBQVF1QixJQUFJdkIsS0FBaEI7QUFDQSxRQUFJNHlCLFdBQVdyeEIsSUFBSXF4QixRQUFuQjs7QUFFQTtBQUNBLFFBQUk1eUIsVUFBVTR5QixRQUFkLEVBQXdCO0FBQUU7QUFBUTtBQUNsQ253QixZQUFRMnlDLFdBQVczeUMsS0FBWCxDQUFSO0FBQ0EsUUFBSWlnQyxhQUFhamdDLE1BQU1mLElBQU4sSUFBY2UsTUFBTWYsSUFBTixDQUFXZ2hDLFVBQTFDO0FBQ0EsUUFBSUEsY0FBYyxDQUFDdGpCLEtBQW5CLEVBQTBCO0FBQ3hCM2MsWUFBTWYsSUFBTixDQUFXNnhDLElBQVgsR0FBa0IsSUFBbEI7QUFDQSxVQUFJdnpDLEtBQUosRUFBVztBQUNUNHhDLGNBQU1udkMsS0FBTixFQUFhLFlBQVk7QUFDdkIwUSxhQUFHaTZCLEtBQUgsQ0FBU21JLE9BQVQsR0FBbUJwaUMsR0FBR21pQyxrQkFBdEI7QUFDRCxTQUZEO0FBR0QsT0FKRCxNQUlPO0FBQ0wzQixjQUFNbHhDLEtBQU4sRUFBYSxZQUFZO0FBQ3ZCMFEsYUFBR2k2QixLQUFILENBQVNtSSxPQUFULEdBQW1CLE1BQW5CO0FBQ0QsU0FGRDtBQUdEO0FBQ0YsS0FYRCxNQVdPO0FBQ0xwaUMsU0FBR2k2QixLQUFILENBQVNtSSxPQUFULEdBQW1CdjFDLFFBQVFtVCxHQUFHbWlDLGtCQUFYLEdBQWdDLE1BQW5EO0FBQ0Q7QUFDRixHQXhDUTs7QUEwQ1RFLFVBQVEsU0FBU0EsTUFBVCxDQUNOcmlDLEVBRE0sRUFFTmhVLE9BRk0sRUFHTnNELEtBSE0sRUFJTkksUUFKTSxFQUtOZ2pDLFNBTE0sRUFNTjtBQUNBLFFBQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUNkMXlCLFNBQUdpNkIsS0FBSCxDQUFTbUksT0FBVCxHQUFtQnBpQyxHQUFHbWlDLGtCQUF0QjtBQUNEO0FBQ0Y7QUFwRFEsQ0FBWDs7QUF1REEsSUFBSUcscUJBQXFCO0FBQ3ZCdGYsU0FBT29lLE9BRGdCO0FBRXZCaEIsUUFBTUE7QUFGaUIsQ0FBekI7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJbUMsa0JBQWtCO0FBQ3BCdDJDLFFBQU1nQyxNQURjO0FBRXBCa3hDLFVBQVE1cUMsT0FGWTtBQUdwQnFuQyxPQUFLcm5DLE9BSGU7QUFJcEI2UyxRQUFNblosTUFKYztBQUtwQkQsUUFBTUMsTUFMYztBQU1wQjZ0QyxjQUFZN3RDLE1BTlE7QUFPcEJndUMsY0FBWWh1QyxNQVBRO0FBUXBCOHRDLGdCQUFjOXRDLE1BUk07QUFTcEJpdUMsZ0JBQWNqdUMsTUFUTTtBQVVwQit0QyxvQkFBa0IvdEMsTUFWRTtBQVdwQmt1QyxvQkFBa0JsdUMsTUFYRTtBQVlwQjR3QyxlQUFhNXdDLE1BWk87QUFhcEI4d0MscUJBQW1COXdDLE1BYkM7QUFjcEI2d0MsaUJBQWU3d0MsTUFkSztBQWVwQnF4QyxZQUFVLENBQUNkLE1BQUQsRUFBU3Z3QyxNQUFULEVBQWlCdEIsTUFBakI7QUFmVSxDQUF0Qjs7QUFrQkE7QUFDQTtBQUNBLFNBQVM2MUMsWUFBVCxDQUF1Qmx6QyxLQUF2QixFQUE4QjtBQUM1QixNQUFJbXpDLGNBQWNuekMsU0FBU0EsTUFBTWdvQixnQkFBakM7QUFDQSxNQUFJbXJCLGVBQWVBLFlBQVk5MUIsSUFBWixDQUFpQjFYLE9BQWpCLENBQXlCaW1CLFFBQTVDLEVBQXNEO0FBQ3BELFdBQU9zbkIsYUFBYS9vQix1QkFBdUJncEIsWUFBWXAwQyxRQUFuQyxDQUFiLENBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPaUIsS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU296QyxxQkFBVCxDQUFnQ0MsSUFBaEMsRUFBc0M7QUFDcEMsTUFBSXAwQyxPQUFPLEVBQVg7QUFDQSxNQUFJMEcsVUFBVTB0QyxLQUFLNXJDLFFBQW5CO0FBQ0E7QUFDQSxPQUFLLElBQUk1RixHQUFULElBQWdCOEQsUUFBUTBkLFNBQXhCLEVBQW1DO0FBQ2pDcGtCLFNBQUs0QyxHQUFMLElBQVl3eEMsS0FBS3h4QyxHQUFMLENBQVo7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJMG9CLFlBQVk1a0IsUUFBUTZrQixnQkFBeEI7QUFDQSxPQUFLLElBQUk4b0IsS0FBVCxJQUFrQi9vQixTQUFsQixFQUE2QjtBQUMzQnRyQixTQUFLMGEsU0FBUzI1QixLQUFULENBQUwsSUFBd0Ivb0IsVUFBVStvQixLQUFWLENBQXhCO0FBQ0Q7QUFDRCxTQUFPcjBDLElBQVA7QUFDRDs7QUFFRCxTQUFTczBDLFdBQVQsQ0FBc0IxMEMsQ0FBdEIsRUFBeUIyMEMsUUFBekIsRUFBbUM7QUFDakMsU0FBTyxrQkFBaUJ2c0MsSUFBakIsQ0FBc0J1c0MsU0FBU3p1QyxHQUEvQixJQUNIbEcsRUFBRSxZQUFGLENBREcsR0FFSDtBQUZKO0FBR0Q7O0FBRUQsU0FBUzQwQyxtQkFBVCxDQUE4Qnp6QyxLQUE5QixFQUFxQztBQUNuQyxTQUFRQSxRQUFRQSxNQUFNaEIsTUFBdEIsRUFBK0I7QUFDN0IsUUFBSWdCLE1BQU1mLElBQU4sQ0FBV2doQyxVQUFmLEVBQTJCO0FBQ3pCLGFBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTeVQsV0FBVCxDQUFzQnh6QyxLQUF0QixFQUE2Qnl6QyxRQUE3QixFQUF1QztBQUNyQyxTQUFPQSxTQUFTOXhDLEdBQVQsS0FBaUIzQixNQUFNMkIsR0FBdkIsSUFBOEI4eEMsU0FBUzV1QyxHQUFULEtBQWlCN0UsTUFBTTZFLEdBQTVEO0FBQ0Q7O0FBRUQsSUFBSTZ1QyxhQUFhO0FBQ2ZqM0MsUUFBTSxZQURTO0FBRWY4QixTQUFPdzBDLGVBRlE7QUFHZnJuQixZQUFVLElBSEs7O0FBS2ZodEIsVUFBUSxTQUFTQSxNQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUMxQixRQUFJd0csU0FBUyxJQUFiOztBQUVBLFFBQUl0RyxXQUFXLEtBQUtxSCxNQUFMLENBQVk1SSxPQUEzQjtBQUNBLFFBQUksQ0FBQ3VCLFFBQUwsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQ7QUFDQUEsZUFBV0EsU0FBU2dFLE1BQVQsQ0FBZ0IsVUFBVWxDLENBQVYsRUFBYTtBQUFFLGFBQU9BLEVBQUVrRSxHQUFUO0FBQWUsS0FBOUMsQ0FBWDtBQUNBO0FBQ0EsUUFBSSxDQUFDaEcsU0FBU25FLE1BQWQsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRDtBQUNBLFFBQUlyQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzdDLFNBQVNuRSxNQUFULEdBQWtCLENBQS9ELEVBQWtFO0FBQ2hFeUQsV0FDRSw0REFDQSwrQkFGRixFQUdFLEtBQUtxQixPQUhQO0FBS0Q7O0FBRUQsUUFBSW9ZLE9BQU8sS0FBS0EsSUFBaEI7O0FBRUE7QUFDQSxRQUFJdmUsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFDQWtXLElBREEsSUFDUUEsU0FBUyxRQURqQixJQUM2QkEsU0FBUyxRQUQxQyxFQUNvRDtBQUNsRHpaLFdBQ0UsZ0NBQWdDeVosSUFEbEMsRUFFRSxLQUFLcFksT0FGUDtBQUlEOztBQUVELFFBQUk4ekMsV0FBV3owQyxTQUFTLENBQVQsQ0FBZjs7QUFFQTtBQUNBO0FBQ0EsUUFBSTAwQyxvQkFBb0IsS0FBS2owQyxNQUF6QixDQUFKLEVBQXNDO0FBQ3BDLGFBQU9nMEMsUUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJdHpDLFFBQVFnekMsYUFBYU0sUUFBYixDQUFaO0FBQ0E7QUFDQSxRQUFJLENBQUN0ekMsS0FBTCxFQUFZO0FBQ1YsYUFBT3N6QyxRQUFQO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLSyxRQUFULEVBQW1CO0FBQ2pCLGFBQU9OLFlBQVkxMEMsQ0FBWixFQUFlMjBDLFFBQWYsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFFBQUl0ekIsS0FBSyxrQkFBbUIsS0FBS3VOLElBQXhCLEdBQWdDLEdBQXpDO0FBQ0F2dEIsVUFBTTJCLEdBQU4sR0FBWTNCLE1BQU0yQixHQUFOLElBQWEsSUFBYixHQUNScWUsS0FBS2hnQixNQUFNNkUsR0FESCxHQUVSd1UsWUFBWXJaLE1BQU0yQixHQUFsQixJQUNHbEQsT0FBT3VCLE1BQU0yQixHQUFiLEVBQWtCMkMsT0FBbEIsQ0FBMEIwYixFQUExQixNQUFrQyxDQUFsQyxHQUFzQ2hnQixNQUFNMkIsR0FBNUMsR0FBa0RxZSxLQUFLaGdCLE1BQU0yQixHQURoRSxHQUVFM0IsTUFBTTJCLEdBSlo7O0FBTUEsUUFBSTVDLE9BQU8sQ0FBQ2lCLE1BQU1qQixJQUFOLEtBQWVpQixNQUFNakIsSUFBTixHQUFhLEVBQTVCLENBQUQsRUFBa0NnaEMsVUFBbEMsR0FBK0NtVCxzQkFBc0IsSUFBdEIsQ0FBMUQ7QUFDQSxRQUFJVSxjQUFjLEtBQUtubkIsTUFBdkI7QUFDQSxRQUFJZ25CLFdBQVdULGFBQWFZLFdBQWIsQ0FBZjs7QUFFQTtBQUNBO0FBQ0EsUUFBSTV6QyxNQUFNakIsSUFBTixDQUFXeWxCLFVBQVgsSUFBeUJ4a0IsTUFBTWpCLElBQU4sQ0FBV3lsQixVQUFYLENBQXNCL2EsSUFBdEIsQ0FBMkIsVUFBVXNxQixDQUFWLEVBQWE7QUFBRSxhQUFPQSxFQUFFdDNCLElBQUYsS0FBVyxNQUFsQjtBQUEyQixLQUFyRSxDQUE3QixFQUFxRztBQUNuR3VELFlBQU1qQixJQUFOLENBQVc2eEMsSUFBWCxHQUFrQixJQUFsQjtBQUNEOztBQUVELFFBQUk2QyxZQUFZQSxTQUFTMTBDLElBQXJCLElBQTZCLENBQUN5MEMsWUFBWXh6QyxLQUFaLEVBQW1CeXpDLFFBQW5CLENBQWxDLEVBQWdFO0FBQzlEO0FBQ0E7QUFDQSxVQUFJbFAsVUFBVWtQLGFBQWFBLFNBQVMxMEMsSUFBVCxDQUFjZ2hDLFVBQWQsR0FBMkIzNUIsT0FBTyxFQUFQLEVBQVdySCxJQUFYLENBQXhDLENBQWQ7QUFDQTtBQUNBLFVBQUk2WSxTQUFTLFFBQWIsRUFBdUI7QUFDckI7QUFDQSxhQUFLKzdCLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQXBxQix1QkFBZWdiLE9BQWYsRUFBd0IsWUFBeEIsRUFBc0MsWUFBWTtBQUNoRHAvQixpQkFBT3d1QyxRQUFQLEdBQWtCLEtBQWxCO0FBQ0F4dUMsaUJBQU80bkIsWUFBUDtBQUNELFNBSEQ7QUFJQSxlQUFPc21CLFlBQVkxMEMsQ0FBWixFQUFlMjBDLFFBQWYsQ0FBUDtBQUNELE9BUkQsTUFRTyxJQUFJMTdCLFNBQVMsUUFBYixFQUF1QjtBQUM1QixZQUFJaThCLFlBQUo7QUFDQSxZQUFJdkMsZUFBZSxZQUFZO0FBQUV1QztBQUFpQixTQUFsRDtBQUNBdHFCLHVCQUFleHFCLElBQWYsRUFBcUIsWUFBckIsRUFBbUN1eUMsWUFBbkM7QUFDQS9uQix1QkFBZXhxQixJQUFmLEVBQXFCLGdCQUFyQixFQUF1Q3V5QyxZQUF2QztBQUNBL25CLHVCQUFlZ2IsT0FBZixFQUF3QixZQUF4QixFQUFzQyxVQUFVeU0sS0FBVixFQUFpQjtBQUFFNkMseUJBQWU3QyxLQUFmO0FBQXVCLFNBQWhGO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPc0MsUUFBUDtBQUNEO0FBdkdjLENBQWpCOztBQTBHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUkvMEMsUUFBUTZILE9BQU87QUFDakJ2QixPQUFLcEcsTUFEWTtBQUVqQnExQyxhQUFXcjFDO0FBRk0sQ0FBUCxFQUdUczBDLGVBSFMsQ0FBWjs7QUFLQSxPQUFPeDBDLE1BQU1xWixJQUFiOztBQUVBLElBQUltOEIsa0JBQWtCO0FBQ3BCeDFDLFNBQU9BLEtBRGE7O0FBR3BCRyxVQUFRLFNBQVNBLE1BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQzFCLFFBQUlrRyxNQUFNLEtBQUtBLEdBQUwsSUFBWSxLQUFLdkYsTUFBTCxDQUFZUCxJQUFaLENBQWlCOEYsR0FBN0IsSUFBb0MsTUFBOUM7QUFDQSxRQUFJcEMsTUFBTXRGLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0EsUUFBSThxQyxlQUFlLEtBQUtBLFlBQUwsR0FBb0IsS0FBS24xQyxRQUE1QztBQUNBLFFBQUlvMUMsY0FBYyxLQUFLL3RDLE1BQUwsQ0FBWTVJLE9BQVosSUFBdUIsRUFBekM7QUFDQSxRQUFJdUIsV0FBVyxLQUFLQSxRQUFMLEdBQWdCLEVBQS9CO0FBQ0EsUUFBSXExQyxpQkFBaUJoQixzQkFBc0IsSUFBdEIsQ0FBckI7O0FBRUEsU0FBSyxJQUFJOTNDLElBQUksQ0FBYixFQUFnQkEsSUFBSTY0QyxZQUFZdjVDLE1BQWhDLEVBQXdDVSxHQUF4QyxFQUE2QztBQUMzQyxVQUFJdUYsSUFBSXN6QyxZQUFZNzRDLENBQVosQ0FBUjtBQUNBLFVBQUl1RixFQUFFa0UsR0FBTixFQUFXO0FBQ1QsWUFBSWxFLEVBQUVnQixHQUFGLElBQVMsSUFBVCxJQUFpQmxELE9BQU9rQyxFQUFFZ0IsR0FBVCxFQUFjMkMsT0FBZCxDQUFzQixTQUF0QixNQUFxQyxDQUExRCxFQUE2RDtBQUMzRHpGLG1CQUFTeEQsSUFBVCxDQUFjc0YsQ0FBZDtBQUNBOEIsY0FBSTlCLEVBQUVnQixHQUFOLElBQWFoQixDQUFiLENBQ0MsQ0FBQ0EsRUFBRTVCLElBQUYsS0FBVzRCLEVBQUU1QixJQUFGLEdBQVMsRUFBcEIsQ0FBRCxFQUEwQmdoQyxVQUExQixHQUF1Q21VLGNBQXZDO0FBQ0YsU0FKRCxNQUlPLElBQUk3NkMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaEQsY0FBSTBLLE9BQU96TCxFQUFFbW5CLGdCQUFiO0FBQ0EsY0FBSXJyQixPQUFPMlAsT0FBUUEsS0FBSytRLElBQUwsQ0FBVTFYLE9BQVYsQ0FBa0JoSixJQUFsQixJQUEwQjJQLEtBQUt2SCxHQUEvQixJQUFzQyxFQUE5QyxHQUFvRGxFLEVBQUVrRSxHQUFqRTtBQUNBMUcsZUFBTSxpREFBaUQxQixJQUFqRCxHQUF3RCxHQUE5RDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJdTNDLFlBQUosRUFBa0I7QUFDaEIsVUFBSUcsT0FBTyxFQUFYO0FBQ0EsVUFBSUMsVUFBVSxFQUFkO0FBQ0EsV0FBSyxJQUFJcnBCLE1BQU0sQ0FBZixFQUFrQkEsTUFBTWlwQixhQUFhdDVDLE1BQXJDLEVBQTZDcXdCLEtBQTdDLEVBQW9EO0FBQ2xELFlBQUlzcEIsTUFBTUwsYUFBYWpwQixHQUFiLENBQVY7QUFDQXNwQixZQUFJdDFDLElBQUosQ0FBU2doQyxVQUFULEdBQXNCbVUsY0FBdEI7QUFDQUcsWUFBSXQxQyxJQUFKLENBQVN1MUMsR0FBVCxHQUFlRCxJQUFJenNCLEdBQUosQ0FBUXRXLHFCQUFSLEVBQWY7QUFDQSxZQUFJN08sSUFBSTR4QyxJQUFJMXlDLEdBQVIsQ0FBSixFQUFrQjtBQUNoQnd5QyxlQUFLOTRDLElBQUwsQ0FBVWc1QyxHQUFWO0FBQ0QsU0FGRCxNQUVPO0FBQ0xELGtCQUFRLzRDLElBQVIsQ0FBYWc1QyxHQUFiO0FBQ0Q7QUFDRjtBQUNELFdBQUtGLElBQUwsR0FBWXgxQyxFQUFFa0csR0FBRixFQUFPLElBQVAsRUFBYXN2QyxJQUFiLENBQVo7QUFDQSxXQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDRDs7QUFFRCxXQUFPejFDLEVBQUVrRyxHQUFGLEVBQU8sSUFBUCxFQUFhaEcsUUFBYixDQUFQO0FBQ0QsR0E1Q21COztBQThDcEIwMUMsZ0JBQWMsU0FBU0EsWUFBVCxHQUF5QjtBQUNyQztBQUNBLFNBQUs1bkIsU0FBTCxDQUNFLEtBQUtGLE1BRFAsRUFFRSxLQUFLMG5CLElBRlAsRUFHRSxLQUhGLEVBR1M7QUFDUCxRQUpGLENBSU87QUFKUDtBQU1BLFNBQUsxbkIsTUFBTCxHQUFjLEtBQUswbkIsSUFBbkI7QUFDRCxHQXZEbUI7O0FBeURwQnRnQyxXQUFTLFNBQVNBLE9BQVQsR0FBb0I7QUFDM0IsUUFBSWhWLFdBQVcsS0FBS20xQyxZQUFwQjtBQUNBLFFBQUlGLFlBQVksS0FBS0EsU0FBTCxJQUFtQixDQUFDLEtBQUtyM0MsSUFBTCxJQUFhLEdBQWQsSUFBcUIsT0FBeEQ7QUFDQSxRQUFJLENBQUNvQyxTQUFTbkUsTUFBVixJQUFvQixDQUFDLEtBQUs4NUMsT0FBTCxDQUFhMzFDLFNBQVMsQ0FBVCxFQUFZK29CLEdBQXpCLEVBQThCa3NCLFNBQTlCLENBQXpCLEVBQW1FO0FBQ2pFO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBajFDLGFBQVNrRCxPQUFULENBQWlCMHlDLGNBQWpCO0FBQ0E1MUMsYUFBU2tELE9BQVQsQ0FBaUIyeUMsY0FBakI7QUFDQTcxQyxhQUFTa0QsT0FBVCxDQUFpQjR5QyxnQkFBakI7O0FBRUE7QUFDQSxRQUFJQyxPQUFPbmtDLFNBQVNta0MsSUFBcEI7QUFDQSxRQUFJQyxJQUFJRCxLQUFLRSxZQUFiLENBZjJCLENBZUE7O0FBRTNCajJDLGFBQVNrRCxPQUFULENBQWlCLFVBQVVwQixDQUFWLEVBQWE7QUFDNUIsVUFBSUEsRUFBRTVCLElBQUYsQ0FBT2cyQyxLQUFYLEVBQWtCO0FBQ2hCLFlBQUl2a0MsS0FBSzdQLEVBQUVpbkIsR0FBWDtBQUNBLFlBQUltbkIsSUFBSXYrQixHQUFHaTZCLEtBQVg7QUFDQWlELDJCQUFtQmw5QixFQUFuQixFQUF1QnNqQyxTQUF2QjtBQUNBL0UsVUFBRWlHLFNBQUYsR0FBY2pHLEVBQUVrRyxlQUFGLEdBQW9CbEcsRUFBRW1HLGtCQUFGLEdBQXVCLEVBQXpEO0FBQ0Exa0MsV0FBR2hCLGdCQUFILENBQW9CdzlCLGtCQUFwQixFQUF3Q3g4QixHQUFHMmtDLE9BQUgsR0FBYSxTQUFTdmlDLEVBQVQsQ0FBYTlZLENBQWIsRUFBZ0I7QUFDbkUsY0FBSSxDQUFDQSxDQUFELElBQU0sYUFBYWlOLElBQWIsQ0FBa0JqTixFQUFFczdDLFlBQXBCLENBQVYsRUFBNkM7QUFDM0M1a0MsZUFBRys0QixtQkFBSCxDQUF1QnlELGtCQUF2QixFQUEyQ3A2QixFQUEzQztBQUNBcEMsZUFBRzJrQyxPQUFILEdBQWEsSUFBYjtBQUNBeEgsa0NBQXNCbjlCLEVBQXRCLEVBQTBCc2pDLFNBQTFCO0FBQ0Q7QUFDRixTQU5EO0FBT0Q7QUFDRixLQWREO0FBZUQsR0F6Rm1COztBQTJGcEI3dkIsV0FBUztBQUNQdXdCLGFBQVMsU0FBU0EsT0FBVCxDQUFrQmhrQyxFQUFsQixFQUFzQnNqQyxTQUF0QixFQUFpQztBQUN4QztBQUNBLFVBQUksQ0FBQ2xILGFBQUwsRUFBb0I7QUFDbEIsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxVQUFJLEtBQUt5SSxRQUFMLElBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLGVBQU8sS0FBS0EsUUFBWjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlDLFFBQVE5a0MsR0FBRytrQyxTQUFILEVBQVo7QUFDQSxVQUFJL2tDLEdBQUdrMEIsa0JBQVAsRUFBMkI7QUFDekJsMEIsV0FBR2swQixrQkFBSCxDQUFzQjNpQyxPQUF0QixDQUE4QixVQUFVeWlDLEdBQVYsRUFBZTtBQUFFd0gsc0JBQVlzSixLQUFaLEVBQW1COVEsR0FBbkI7QUFBMEIsU0FBekU7QUFDRDtBQUNEc0gsZUFBU3dKLEtBQVQsRUFBZ0J4QixTQUFoQjtBQUNBd0IsWUFBTTdLLEtBQU4sQ0FBWW1JLE9BQVosR0FBc0IsTUFBdEI7QUFDQSxXQUFLcm1CLEdBQUwsQ0FBU2dSLFdBQVQsQ0FBcUIrWCxLQUFyQjtBQUNBLFVBQUlodkIsT0FBT3VuQixrQkFBa0J5SCxLQUFsQixDQUFYO0FBQ0EsV0FBSy9vQixHQUFMLENBQVMrUSxXQUFULENBQXFCZ1ksS0FBckI7QUFDQSxhQUFRLEtBQUtELFFBQUwsR0FBZ0IvdUIsS0FBS3FvQixZQUE3QjtBQUNEO0FBeEJNO0FBM0ZXLENBQXRCOztBQXVIQSxTQUFTOEYsY0FBVCxDQUF5Qjl6QyxDQUF6QixFQUE0QjtBQUMxQjtBQUNBLE1BQUlBLEVBQUVpbkIsR0FBRixDQUFNdXRCLE9BQVYsRUFBbUI7QUFDakJ4MEMsTUFBRWluQixHQUFGLENBQU11dEIsT0FBTjtBQUNEO0FBQ0Q7QUFDQSxNQUFJeDBDLEVBQUVpbkIsR0FBRixDQUFNd25CLFFBQVYsRUFBb0I7QUFDbEJ6dUMsTUFBRWluQixHQUFGLENBQU13bkIsUUFBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3NGLGNBQVQsQ0FBeUIvekMsQ0FBekIsRUFBNEI7QUFDMUJBLElBQUU1QixJQUFGLENBQU95MkMsTUFBUCxHQUFnQjcwQyxFQUFFaW5CLEdBQUYsQ0FBTXRXLHFCQUFOLEVBQWhCO0FBQ0Q7O0FBRUQsU0FBU3FqQyxnQkFBVCxDQUEyQmgwQyxDQUEzQixFQUE4QjtBQUM1QixNQUFJODBDLFNBQVM5MEMsRUFBRTVCLElBQUYsQ0FBT3UxQyxHQUFwQjtBQUNBLE1BQUlrQixTQUFTNzBDLEVBQUU1QixJQUFGLENBQU95MkMsTUFBcEI7QUFDQSxNQUFJRSxLQUFLRCxPQUFPamtDLElBQVAsR0FBY2drQyxPQUFPaGtDLElBQTlCO0FBQ0EsTUFBSW1rQyxLQUFLRixPQUFPaGtDLEdBQVAsR0FBYStqQyxPQUFPL2pDLEdBQTdCO0FBQ0EsTUFBSWlrQyxNQUFNQyxFQUFWLEVBQWM7QUFDWmgxQyxNQUFFNUIsSUFBRixDQUFPZzJDLEtBQVAsR0FBZSxJQUFmO0FBQ0EsUUFBSWhHLElBQUlwdUMsRUFBRWluQixHQUFGLENBQU02aUIsS0FBZDtBQUNBc0UsTUFBRWlHLFNBQUYsR0FBY2pHLEVBQUVrRyxlQUFGLEdBQW9CLGVBQWVTLEVBQWYsR0FBb0IsS0FBcEIsR0FBNEJDLEVBQTVCLEdBQWlDLEtBQW5FO0FBQ0E1RyxNQUFFbUcsa0JBQUYsR0FBdUIsSUFBdkI7QUFDRDtBQUNGOztBQUVELElBQUlVLHFCQUFxQjtBQUN2QmxDLGNBQVlBLFVBRFc7QUFFdkJLLG1CQUFpQkE7QUFGTSxDQUF6Qjs7QUFLQTs7QUFFQTtBQUNBbHZCLE1BQU12a0IsTUFBTixDQUFhc2IsV0FBYixHQUEyQkEsV0FBM0I7QUFDQWlKLE1BQU12a0IsTUFBTixDQUFha2IsYUFBYixHQUE2QkEsYUFBN0I7QUFDQXFKLE1BQU12a0IsTUFBTixDQUFhb2IsZUFBYixHQUErQkEsZUFBL0I7QUFDQW1KLE1BQU12a0IsTUFBTixDQUFhbWIsZ0JBQWIsR0FBZ0NBLGdCQUFoQzs7QUFFQTtBQUNBclYsT0FBT3llLE1BQU1wZixPQUFOLENBQWMrZSxVQUFyQixFQUFpQ3N1QixrQkFBakM7QUFDQTFzQyxPQUFPeWUsTUFBTXBmLE9BQU4sQ0FBYy9GLFVBQXJCLEVBQWlDazJDLGtCQUFqQzs7QUFFQTtBQUNBL3dCLE1BQU1ycEIsU0FBTixDQUFnQm14QixTQUFoQixHQUE0QjVrQixZQUFZdzZCLEtBQVosR0FBb0J2bUMsSUFBaEQ7O0FBRUE7QUFDQTZvQixNQUFNcnBCLFNBQU4sQ0FBZ0JxM0IsTUFBaEIsR0FBeUIsVUFDdkJyaUIsRUFEdUIsRUFFdkI0YixTQUZ1QixFQUd2QjtBQUNBNWIsT0FBS0EsTUFBTXpJLFNBQU4sR0FBa0J6RyxNQUFNa1AsRUFBTixDQUFsQixHQUE4QnBRLFNBQW5DO0FBQ0EsU0FBT2d0QixlQUFlLElBQWYsRUFBcUI1YyxFQUFyQixFQUF5QjRiLFNBQXpCLENBQVA7QUFDRCxDQU5EOztBQVFBO0FBQ0E7QUFDQXZ5QixXQUFXLFlBQVk7QUFDckIsTUFBSXlHLE9BQU84YSxRQUFYLEVBQXFCO0FBQ25CLFFBQUlBLFFBQUosRUFBYztBQUNaQSxlQUFTN2UsSUFBVCxDQUFjLE1BQWQsRUFBc0Jzb0IsS0FBdEI7QUFDRCxLQUZELE1BRU8sSUFBSXhyQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q21iLFFBQTdDLEVBQXVEO0FBQzVEemUsY0FBUUEsUUFBUWtvQixJQUFSLEdBQWUsTUFBZixHQUF3QixLQUFoQyxFQUNFLCtFQUNBLHVDQUZGO0FBSUQ7QUFDRjtBQUNELE1BQUlqdEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFDQXBCLE9BQU82YSxhQUFQLEtBQXlCLEtBRHpCLElBRUFwVCxTQUZBLElBRWEsT0FBTzNKLE9BQVAsS0FBbUIsV0FGcEMsRUFFaUQ7QUFDL0NBLFlBQVFBLFFBQVFrb0IsSUFBUixHQUFlLE1BQWYsR0FBd0IsS0FBaEMsRUFDRSwrQ0FDQSx1RUFEQSxHQUVBLDBEQUhGO0FBS0Q7QUFDRixDQXBCRCxFQW9CRyxDQXBCSDs7QUFzQkE7O0FBRUE7QUFDQSxTQUFTdXZCLFlBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDQyxPQUFoQyxFQUF5QztBQUN2QyxNQUFJQyxNQUFNdmxDLFNBQVN1akIsYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0FnaUIsTUFBSUMsU0FBSixHQUFnQixjQUFjSCxPQUFkLEdBQXdCLEtBQXhDO0FBQ0EsU0FBT0UsSUFBSUMsU0FBSixDQUFjM3hDLE9BQWQsQ0FBc0J5eEMsT0FBdEIsSUFBaUMsQ0FBeEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsSUFBSUcsdUJBQXVCbnVDLFlBQVk4dEMsYUFBYSxJQUFiLEVBQW1CLE9BQW5CLENBQVosR0FBMEMsS0FBckU7O0FBRUE7O0FBRUEsSUFBSU0sYUFBYXY5QixRQUNmLDhEQUNBLGtDQUZlLENBQWpCOztBQUtBO0FBQ0E7QUFDQSxJQUFJdzlCLG1CQUFtQng5QixRQUNyQix5REFEcUIsQ0FBdkI7O0FBSUE7QUFDQTtBQUNBLElBQUl5OUIsbUJBQW1CejlCLFFBQ3JCLHdFQUNBLGtFQURBLEdBRUEsdUVBRkEsR0FHQSwyRUFIQSxHQUlBLGdCQUxxQixDQUF2Qjs7QUFRQTs7QUFFQSxJQUFJMDlCLE9BQUo7O0FBRUEsU0FBU24xQyxNQUFULENBQWlCbzFDLElBQWpCLEVBQXVCO0FBQ3JCRCxZQUFVQSxXQUFXN2xDLFNBQVN1akIsYUFBVCxDQUF1QixLQUF2QixDQUFyQjtBQUNBc2lCLFVBQVFMLFNBQVIsR0FBb0JNLElBQXBCO0FBQ0EsU0FBT0QsUUFBUTVZLFdBQWY7QUFDRDs7QUFFRDs7OztBQUlBOzs7Ozs7O0FBT0E7QUFDQSxJQUFJOFksdUJBQXVCLGdCQUEzQjtBQUNBLElBQUlDLG1CQUFtQixPQUF2QjtBQUNBLElBQUlDLG1CQUFtQjtBQUNyQjtBQUNBLGFBQWF6cEMsTUFGUTtBQUdyQjtBQUNBLGFBQWFBLE1BSlE7QUFLckI7QUFDQSxpQkFBaUJBLE1BTkksQ0FBdkI7QUFRQSxJQUFJMHBDLFlBQVksSUFBSWpzQyxNQUFKLENBQ2QsVUFBVThyQyxxQkFBcUJ2cEMsTUFBL0IsR0FDQSxVQURBLEdBQ2F3cEMsaUJBQWlCeHBDLE1BRDlCLEdBQ3VDLEdBRHZDLEdBRUEsU0FGQSxHQUVZeXBDLGlCQUFpQnQwQyxJQUFqQixDQUFzQixHQUF0QixDQUZaLEdBRXlDLEtBSDNCLENBQWhCOztBQU1BO0FBQ0E7QUFDQSxJQUFJdzBDLFNBQVMsdUJBQWI7QUFDQSxJQUFJQyxlQUFlLFNBQVNELE1BQVQsR0FBa0IsT0FBbEIsR0FBNEJBLE1BQTVCLEdBQXFDLEdBQXhEO0FBQ0EsSUFBSUUsZUFBZSxJQUFJcHNDLE1BQUosQ0FBVyxPQUFPbXNDLFlBQWxCLENBQW5CO0FBQ0EsSUFBSUUsZ0JBQWdCLFlBQXBCO0FBQ0EsSUFBSXR2QixTQUFTLElBQUkvYyxNQUFKLENBQVcsVUFBVW1zQyxZQUFWLEdBQXlCLFFBQXBDLENBQWI7QUFDQSxJQUFJRyxVQUFVLG9CQUFkO0FBQ0EsSUFBSUMsVUFBVSxPQUFkO0FBQ0EsSUFBSUMscUJBQXFCLE9BQXpCOztBQUVBLElBQUlDLDRCQUE0QixLQUFoQztBQUNBLElBQUlqMkMsT0FBSixDQUFZLFFBQVosRUFBc0IsVUFBVTZKLENBQVYsRUFBYXFzQyxDQUFiLEVBQWdCO0FBQ3BDRCw4QkFBNEJDLE1BQU0sRUFBbEM7QUFDRCxDQUZEOztBQUlBO0FBQ0EsSUFBSUMscUJBQXFCeitCLFFBQVEsdUJBQVIsRUFBaUMsSUFBakMsQ0FBekI7QUFDQSxJQUFJMCtCLFVBQVUsRUFBZDs7QUFFQSxJQUFJQyxjQUFjO0FBQ2hCLFVBQVEsR0FEUTtBQUVoQixVQUFRLEdBRlE7QUFHaEIsWUFBVSxHQUhNO0FBSWhCLFdBQVMsR0FKTztBQUtoQixXQUFTO0FBTE8sQ0FBbEI7QUFPQSxJQUFJQyxjQUFjLHVCQUFsQjtBQUNBLElBQUlDLDBCQUEwQiwyQkFBOUI7O0FBRUEsU0FBU0MsVUFBVCxDQUFxQnI2QyxLQUFyQixFQUE0QjY0QyxvQkFBNUIsRUFBa0Q7QUFDaEQsTUFBSXRwQyxLQUFLc3BDLHVCQUF1QnVCLHVCQUF2QixHQUFpREQsV0FBMUQ7QUFDQSxTQUFPbjZDLE1BQU02RCxPQUFOLENBQWMwTCxFQUFkLEVBQWtCLFVBQVVNLEtBQVYsRUFBaUI7QUFBRSxXQUFPcXFDLFlBQVlycUMsS0FBWixDQUFQO0FBQTRCLEdBQWpFLENBQVA7QUFDRDs7QUFFRCxTQUFTeXFDLFNBQVQsQ0FBb0JwQixJQUFwQixFQUEwQjl3QyxPQUExQixFQUFtQztBQUNqQyxNQUFJNEMsUUFBUSxFQUFaO0FBQ0EsTUFBSXV2QyxhQUFhbnlDLFFBQVFteUMsVUFBekI7QUFDQSxNQUFJQyxnQkFBZ0JweUMsUUFBUTB3QyxVQUFSLElBQXNCMzdCLEVBQTFDO0FBQ0EsTUFBSXM5QixzQkFBc0JyeUMsUUFBUTJ3QyxnQkFBUixJQUE0QjU3QixFQUF0RDtBQUNBLE1BQUl0ZCxRQUFRLENBQVo7QUFDQSxNQUFJOHNCLElBQUosRUFBVSt0QixPQUFWO0FBQ0EsU0FBT3hCLElBQVAsRUFBYTtBQUNYdnNCLFdBQU91c0IsSUFBUDtBQUNBO0FBQ0EsUUFBSSxDQUFDd0IsT0FBRCxJQUFZLENBQUNWLG1CQUFtQlUsT0FBbkIsQ0FBakIsRUFBOEM7QUFDNUMsVUFBSUMsVUFBVXpCLEtBQUtqeUMsT0FBTCxDQUFhLEdBQWIsQ0FBZDtBQUNBLFVBQUkwekMsWUFBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNBLFlBQUlmLFFBQVFsd0MsSUFBUixDQUFhd3ZDLElBQWIsQ0FBSixFQUF3QjtBQUN0QixjQUFJMEIsYUFBYTFCLEtBQUtqeUMsT0FBTCxDQUFhLEtBQWIsQ0FBakI7O0FBRUEsY0FBSTJ6QyxjQUFjLENBQWxCLEVBQXFCO0FBQ25CQyxvQkFBUUQsYUFBYSxDQUFyQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFlBQUlmLG1CQUFtQm53QyxJQUFuQixDQUF3Qnd2QyxJQUF4QixDQUFKLEVBQW1DO0FBQ2pDLGNBQUk0QixpQkFBaUI1QixLQUFLanlDLE9BQUwsQ0FBYSxJQUFiLENBQXJCOztBQUVBLGNBQUk2ekMsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCRCxvQkFBUUMsaUJBQWlCLENBQXpCO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0EsWUFBSUMsZUFBZTdCLEtBQUtycEMsS0FBTCxDQUFXOHBDLE9BQVgsQ0FBbkI7QUFDQSxZQUFJb0IsWUFBSixFQUFrQjtBQUNoQkYsa0JBQVFFLGFBQWEsQ0FBYixFQUFnQjE5QyxNQUF4QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJMjlDLGNBQWM5QixLQUFLcnBDLEtBQUwsQ0FBV3VhLE1BQVgsQ0FBbEI7QUFDQSxZQUFJNHdCLFdBQUosRUFBaUI7QUFDZixjQUFJQyxXQUFXcDdDLEtBQWY7QUFDQWc3QyxrQkFBUUcsWUFBWSxDQUFaLEVBQWUzOUMsTUFBdkI7QUFDQTY5QyxzQkFBWUYsWUFBWSxDQUFaLENBQVosRUFBNEJDLFFBQTVCLEVBQXNDcDdDLEtBQXRDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLFlBQUlzN0MsZ0JBQWdCQyxlQUFwQjtBQUNBLFlBQUlELGFBQUosRUFBbUI7QUFDakJFLHlCQUFlRixhQUFmO0FBQ0E7QUFDRDtBQUNGOztBQUVELFVBQUk3d0IsT0FBUSxLQUFLLENBQWpCO0FBQUEsVUFBcUJneEIsU0FBVSxLQUFLLENBQXBDO0FBQUEsVUFBd0N6dEMsT0FBUSxLQUFLLENBQXJEO0FBQ0EsVUFBSThzQyxXQUFXLENBQWYsRUFBa0I7QUFDaEJXLGlCQUFTcEMsS0FBSzV6QyxLQUFMLENBQVdxMUMsT0FBWCxDQUFUO0FBQ0EsZUFDRSxDQUFDdndCLE9BQU8xZ0IsSUFBUCxDQUFZNHhDLE1BQVosQ0FBRCxJQUNBLENBQUM3QixhQUFhL3ZDLElBQWIsQ0FBa0I0eEMsTUFBbEIsQ0FERCxJQUVBLENBQUMxQixRQUFRbHdDLElBQVIsQ0FBYTR4QyxNQUFiLENBRkQsSUFHQSxDQUFDekIsbUJBQW1CbndDLElBQW5CLENBQXdCNHhDLE1BQXhCLENBSkgsRUFLRTtBQUNBO0FBQ0F6dEMsaUJBQU95dEMsT0FBT3IwQyxPQUFQLENBQWUsR0FBZixFQUFvQixDQUFwQixDQUFQO0FBQ0EsY0FBSTRHLE9BQU8sQ0FBWCxFQUFjO0FBQUU7QUFBTztBQUN2QjhzQyxxQkFBVzlzQyxJQUFYO0FBQ0F5dEMsbUJBQVNwQyxLQUFLNXpDLEtBQUwsQ0FBV3ExQyxPQUFYLENBQVQ7QUFDRDtBQUNEcndCLGVBQU80dUIsS0FBS3hPLFNBQUwsQ0FBZSxDQUFmLEVBQWtCaVEsT0FBbEIsQ0FBUDtBQUNBRSxnQkFBUUYsT0FBUjtBQUNEOztBQUVELFVBQUlBLFVBQVUsQ0FBZCxFQUFpQjtBQUNmcndCLGVBQU80dUIsSUFBUDtBQUNBQSxlQUFPLEVBQVA7QUFDRDs7QUFFRCxVQUFJOXdDLFFBQVFtekMsS0FBUixJQUFpQmp4QixJQUFyQixFQUEyQjtBQUN6QmxpQixnQkFBUW16QyxLQUFSLENBQWNqeEIsSUFBZDtBQUNEO0FBQ0YsS0ExRUQsTUEwRU87QUFDTCxVQUFJa3hCLGFBQWFkLFFBQVFoL0IsV0FBUixFQUFqQjtBQUNBLFVBQUkrL0IsZUFBZXhCLFFBQVF1QixVQUFSLE1BQXdCdkIsUUFBUXVCLFVBQVIsSUFBc0IsSUFBSW51QyxNQUFKLENBQVcsb0JBQW9CbXVDLFVBQXBCLEdBQWlDLFNBQTVDLEVBQXVELEdBQXZELENBQTlDLENBQW5CO0FBQ0EsVUFBSUUsZUFBZSxDQUFuQjtBQUNBLFVBQUlDLE9BQU96QyxLQUFLcjFDLE9BQUwsQ0FBYTQzQyxZQUFiLEVBQTJCLFVBQVVHLEdBQVYsRUFBZXR4QixJQUFmLEVBQXFCRixNQUFyQixFQUE2QjtBQUNqRXN4Qix1QkFBZXR4QixPQUFPL3NCLE1BQXRCO0FBQ0EsWUFBSSxDQUFDMjhDLG1CQUFtQndCLFVBQW5CLENBQUQsSUFBbUNBLGVBQWUsVUFBdEQsRUFBa0U7QUFDaEVseEIsaUJBQU9BLEtBQ0p6bUIsT0FESSxDQUNJLG9CQURKLEVBQzBCLElBRDFCLEVBRUpBLE9BRkksQ0FFSSwyQkFGSixFQUVpQyxJQUZqQyxDQUFQO0FBR0Q7QUFDRCxZQUFJdUUsUUFBUW16QyxLQUFaLEVBQW1CO0FBQ2pCbnpDLGtCQUFRbXpDLEtBQVIsQ0FBY2p4QixJQUFkO0FBQ0Q7QUFDRCxlQUFPLEVBQVA7QUFDRCxPQVhVLENBQVg7QUFZQXpxQixlQUFTcTVDLEtBQUs3N0MsTUFBTCxHQUFjcytDLEtBQUt0K0MsTUFBNUI7QUFDQTY3QyxhQUFPeUMsSUFBUDtBQUNBVCxrQkFBWU0sVUFBWixFQUF3QjM3QyxRQUFRNjdDLFlBQWhDLEVBQThDNzdDLEtBQTlDO0FBQ0Q7O0FBRUQsUUFBSXE1QyxTQUFTdnNCLElBQWIsRUFBbUI7QUFDakJ2a0IsY0FBUW16QyxLQUFSLElBQWlCbnpDLFFBQVFtekMsS0FBUixDQUFjckMsSUFBZCxDQUFqQjtBQUNBLFVBQUlsOUMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQzJHLE1BQU0zTixNQUFoRCxJQUEwRCtLLFFBQVF0SCxJQUF0RSxFQUE0RTtBQUMxRXNILGdCQUFRdEgsSUFBUixDQUFjLDZDQUE2Q280QyxJQUE3QyxHQUFvRCxJQUFsRTtBQUNEO0FBQ0Q7QUFDRDtBQUNGOztBQUVEO0FBQ0FnQzs7QUFFQSxXQUFTTCxPQUFULENBQWtCdGhDLENBQWxCLEVBQXFCO0FBQ25CMVosYUFBUzBaLENBQVQ7QUFDQTIvQixXQUFPQSxLQUFLeE8sU0FBTCxDQUFlbnhCLENBQWYsQ0FBUDtBQUNEOztBQUVELFdBQVM2aEMsYUFBVCxHQUEwQjtBQUN4QixRQUFJditCLFFBQVFxOEIsS0FBS3JwQyxLQUFMLENBQVc0cEMsWUFBWCxDQUFaO0FBQ0EsUUFBSTU4QixLQUFKLEVBQVc7QUFDVCxVQUFJaE4sUUFBUTtBQUNWMnZCLGlCQUFTM2lCLE1BQU0sQ0FBTixDQURDO0FBRVZsVSxlQUFPLEVBRkc7QUFHVmtVLGVBQU9oZDtBQUhHLE9BQVo7QUFLQWc3QyxjQUFRaCtCLE1BQU0sQ0FBTixFQUFTeGYsTUFBakI7QUFDQSxVQUFJNlMsR0FBSixFQUFTMnRCLElBQVQ7QUFDQSxhQUFPLEVBQUUzdEIsTUFBTWdwQyxLQUFLcnBDLEtBQUwsQ0FBVzZwQyxhQUFYLENBQVIsTUFBdUM3YixPQUFPcWIsS0FBS3JwQyxLQUFMLENBQVd5cEMsU0FBWCxDQUE5QyxDQUFQLEVBQTZFO0FBQzNFdUIsZ0JBQVFoZCxLQUFLLENBQUwsRUFBUXhnQyxNQUFoQjtBQUNBd1MsY0FBTWxILEtBQU4sQ0FBWTNLLElBQVosQ0FBaUI2L0IsSUFBakI7QUFDRDtBQUNELFVBQUkzdEIsR0FBSixFQUFTO0FBQ1BMLGNBQU1nc0MsVUFBTixHQUFtQjNyQyxJQUFJLENBQUosQ0FBbkI7QUFDQTJxQyxnQkFBUTNxQyxJQUFJLENBQUosRUFBTzdTLE1BQWY7QUFDQXdTLGNBQU1LLEdBQU4sR0FBWXJRLEtBQVo7QUFDQSxlQUFPZ1EsS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTd3JDLGNBQVQsQ0FBeUJ4ckMsS0FBekIsRUFBZ0M7QUFDOUIsUUFBSTJ2QixVQUFVM3ZCLE1BQU0ydkIsT0FBcEI7QUFDQSxRQUFJcWMsYUFBYWhzQyxNQUFNZ3NDLFVBQXZCOztBQUVBLFFBQUl0QixVQUFKLEVBQWdCO0FBQ2QsVUFBSUcsWUFBWSxHQUFaLElBQW1CMUIsaUJBQWlCeFosT0FBakIsQ0FBdkIsRUFBa0Q7QUFDaEQwYixvQkFBWVIsT0FBWjtBQUNEO0FBQ0QsVUFBSUQsb0JBQW9CamIsT0FBcEIsS0FBZ0NrYixZQUFZbGIsT0FBaEQsRUFBeUQ7QUFDdkQwYixvQkFBWTFiLE9BQVo7QUFDRDtBQUNGOztBQUVELFFBQUlzYyxRQUFRdEIsY0FBY2hiLE9BQWQsS0FBMEJBLFlBQVksTUFBWixJQUFzQmtiLFlBQVksTUFBNUQsSUFBc0UsQ0FBQyxDQUFDbUIsVUFBcEY7O0FBRUEsUUFBSW4vQixJQUFJN00sTUFBTWxILEtBQU4sQ0FBWXRMLE1BQXBCO0FBQ0EsUUFBSXNMLFFBQVEsSUFBSTlLLEtBQUosQ0FBVTZlLENBQVYsQ0FBWjtBQUNBLFNBQUssSUFBSTNlLElBQUksQ0FBYixFQUFnQkEsSUFBSTJlLENBQXBCLEVBQXVCM2UsR0FBdkIsRUFBNEI7QUFDMUIsVUFBSUgsT0FBT2lTLE1BQU1sSCxLQUFOLENBQVk1SyxDQUFaLENBQVg7QUFDQTtBQUNBLFVBQUkrN0MsNkJBQTZCbDhDLEtBQUssQ0FBTCxFQUFRcUosT0FBUixDQUFnQixJQUFoQixNQUEwQixDQUFDLENBQTVELEVBQStEO0FBQzdELFlBQUlySixLQUFLLENBQUwsTUFBWSxFQUFoQixFQUFvQjtBQUFFLGlCQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUFpQjtBQUN2QyxZQUFJQSxLQUFLLENBQUwsTUFBWSxFQUFoQixFQUFvQjtBQUFFLGlCQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUFpQjtBQUN2QyxZQUFJQSxLQUFLLENBQUwsTUFBWSxFQUFoQixFQUFvQjtBQUFFLGlCQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUFpQjtBQUN4QztBQUNELFVBQUlvQyxRQUFRcEMsS0FBSyxDQUFMLEtBQVdBLEtBQUssQ0FBTCxDQUFYLElBQXNCQSxLQUFLLENBQUwsQ0FBdEIsSUFBaUMsRUFBN0M7QUFDQStLLFlBQU01SyxDQUFOLElBQVc7QUFDVHFCLGNBQU14QixLQUFLLENBQUwsQ0FERztBQUVUb0MsZUFBT3E2QyxXQUNMcjZDLEtBREssRUFFTG9JLFFBQVF5d0Msb0JBRkg7QUFGRSxPQUFYO0FBT0Q7O0FBRUQsUUFBSSxDQUFDaUQsS0FBTCxFQUFZO0FBQ1Y5d0MsWUFBTWhOLElBQU4sQ0FBVyxFQUFFd0osS0FBS2c0QixPQUFQLEVBQWdCdWMsZUFBZXZjLFFBQVE5akIsV0FBUixFQUEvQixFQUFzRC9TLE9BQU9BLEtBQTdELEVBQVg7QUFDQSt4QyxnQkFBVWxiLE9BQVY7QUFDRDs7QUFFRCxRQUFJcDNCLFFBQVF5VSxLQUFaLEVBQW1CO0FBQ2pCelUsY0FBUXlVLEtBQVIsQ0FBYzJpQixPQUFkLEVBQXVCNzJCLEtBQXZCLEVBQThCbXpDLEtBQTlCLEVBQXFDanNDLE1BQU1nTixLQUEzQyxFQUFrRGhOLE1BQU1LLEdBQXhEO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTZ3JDLFdBQVQsQ0FBc0IxYixPQUF0QixFQUErQjNpQixLQUEvQixFQUFzQzNNLEdBQXRDLEVBQTJDO0FBQ3pDLFFBQUkrbUMsR0FBSixFQUFTK0UsaUJBQVQ7QUFDQSxRQUFJbi9CLFNBQVMsSUFBYixFQUFtQjtBQUFFQSxjQUFRaGQsS0FBUjtBQUFnQjtBQUNyQyxRQUFJcVEsT0FBTyxJQUFYLEVBQWlCO0FBQUVBLFlBQU1yUSxLQUFOO0FBQWM7O0FBRWpDLFFBQUkyL0IsT0FBSixFQUFhO0FBQ1h3YywwQkFBb0J4YyxRQUFROWpCLFdBQVIsRUFBcEI7QUFDRDs7QUFFRDtBQUNBLFFBQUk4akIsT0FBSixFQUFhO0FBQ1gsV0FBS3lYLE1BQU1qc0MsTUFBTTNOLE1BQU4sR0FBZSxDQUExQixFQUE2QjQ1QyxPQUFPLENBQXBDLEVBQXVDQSxLQUF2QyxFQUE4QztBQUM1QyxZQUFJanNDLE1BQU1pc0MsR0FBTixFQUFXOEUsYUFBWCxLQUE2QkMsaUJBQWpDLEVBQW9EO0FBQ2xEO0FBQ0Q7QUFDRjtBQUNGLEtBTkQsTUFNTztBQUNMO0FBQ0EvRSxZQUFNLENBQU47QUFDRDs7QUFFRCxRQUFJQSxPQUFPLENBQVgsRUFBYztBQUNaO0FBQ0EsV0FBSyxJQUFJbDVDLElBQUlpTixNQUFNM04sTUFBTixHQUFlLENBQTVCLEVBQStCVSxLQUFLazVDLEdBQXBDLEVBQXlDbDVDLEdBQXpDLEVBQThDO0FBQzVDLFlBQUkvQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixLQUNDdEcsSUFBSWs1QyxHQUFKLElBQVcsQ0FBQ3pYLE9BRGIsS0FFQXAzQixRQUFRdEgsSUFGWixFQUVrQjtBQUNoQnNILGtCQUFRdEgsSUFBUixDQUNHLFVBQVdrSyxNQUFNak4sQ0FBTixFQUFTeUosR0FBcEIsR0FBMkIsNEJBRDlCO0FBR0Q7QUFDRCxZQUFJWSxRQUFROEgsR0FBWixFQUFpQjtBQUNmOUgsa0JBQVE4SCxHQUFSLENBQVlsRixNQUFNak4sQ0FBTixFQUFTeUosR0FBckIsRUFBMEJxVixLQUExQixFQUFpQzNNLEdBQWpDO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBbEYsWUFBTTNOLE1BQU4sR0FBZTQ1QyxHQUFmO0FBQ0F5RCxnQkFBVXpELE9BQU9qc0MsTUFBTWlzQyxNQUFNLENBQVosRUFBZXp2QyxHQUFoQztBQUNELEtBbEJELE1Ba0JPLElBQUl3MEMsc0JBQXNCLElBQTFCLEVBQWdDO0FBQ3JDLFVBQUk1ekMsUUFBUXlVLEtBQVosRUFBbUI7QUFDakJ6VSxnQkFBUXlVLEtBQVIsQ0FBYzJpQixPQUFkLEVBQXVCLEVBQXZCLEVBQTJCLElBQTNCLEVBQWlDM2lCLEtBQWpDLEVBQXdDM00sR0FBeEM7QUFDRDtBQUNGLEtBSk0sTUFJQSxJQUFJOHJDLHNCQUFzQixHQUExQixFQUErQjtBQUNwQyxVQUFJNXpDLFFBQVF5VSxLQUFaLEVBQW1CO0FBQ2pCelUsZ0JBQVF5VSxLQUFSLENBQWMyaUIsT0FBZCxFQUF1QixFQUF2QixFQUEyQixLQUEzQixFQUFrQzNpQixLQUFsQyxFQUF5QzNNLEdBQXpDO0FBQ0Q7QUFDRCxVQUFJOUgsUUFBUThILEdBQVosRUFBaUI7QUFDZjlILGdCQUFROEgsR0FBUixDQUFZc3ZCLE9BQVosRUFBcUIzaUIsS0FBckIsRUFBNEIzTSxHQUE1QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEOztBQUVBLElBQUkrckMsZUFBZSx1QkFBbkI7QUFDQSxJQUFJQyxnQkFBZ0Isd0JBQXBCOztBQUVBLElBQUlDLGFBQWFsZ0MsT0FBTyxVQUFVbWdDLFVBQVYsRUFBc0I7QUFDNUMsTUFBSUMsT0FBT0QsV0FBVyxDQUFYLEVBQWN2NEMsT0FBZCxDQUFzQnE0QyxhQUF0QixFQUFxQyxNQUFyQyxDQUFYO0FBQ0EsTUFBSUksUUFBUUYsV0FBVyxDQUFYLEVBQWN2NEMsT0FBZCxDQUFzQnE0QyxhQUF0QixFQUFxQyxNQUFyQyxDQUFaO0FBQ0EsU0FBTyxJQUFJN3VDLE1BQUosQ0FBV2d2QyxPQUFPLGVBQVAsR0FBeUJDLEtBQXBDLEVBQTJDLEdBQTNDLENBQVA7QUFDRCxDQUpnQixDQUFqQjs7QUFNQSxTQUFTQyxTQUFULENBQ0VqeUIsSUFERixFQUVFOHhCLFVBRkYsRUFHRTtBQUNBLE1BQUlJLFFBQVFKLGFBQWFELFdBQVdDLFVBQVgsQ0FBYixHQUFzQ0gsWUFBbEQ7QUFDQSxNQUFJLENBQUNPLE1BQU05eUMsSUFBTixDQUFXNGdCLElBQVgsQ0FBTCxFQUF1QjtBQUNyQjtBQUNEO0FBQ0QsTUFBSWhkLFNBQVMsRUFBYjtBQUNBLE1BQUltdkMsWUFBWUQsTUFBTUMsU0FBTixHQUFrQixDQUFsQztBQUNBLE1BQUk1c0MsS0FBSixFQUFXaFEsS0FBWDtBQUNBLFNBQVFnUSxRQUFRMnNDLE1BQU0vdUMsSUFBTixDQUFXNmMsSUFBWCxDQUFoQixFQUFtQztBQUNqQ3pxQixZQUFRZ1EsTUFBTWhRLEtBQWQ7QUFDQTtBQUNBLFFBQUlBLFFBQVE0OEMsU0FBWixFQUF1QjtBQUNyQm52QyxhQUFPdFAsSUFBUCxDQUFZbVIsS0FBS0MsU0FBTCxDQUFla2IsS0FBS2hsQixLQUFMLENBQVdtM0MsU0FBWCxFQUFzQjU4QyxLQUF0QixDQUFmLENBQVo7QUFDRDtBQUNEO0FBQ0EsUUFBSTZuQyxNQUFNRCxhQUFhNTNCLE1BQU0sQ0FBTixFQUFTckwsSUFBVCxFQUFiLENBQVY7QUFDQThJLFdBQU90UCxJQUFQLENBQWEsUUFBUTBwQyxHQUFSLEdBQWMsR0FBM0I7QUFDQStVLGdCQUFZNThDLFFBQVFnUSxNQUFNLENBQU4sRUFBU3hTLE1BQTdCO0FBQ0Q7QUFDRCxNQUFJby9DLFlBQVlueUIsS0FBS2p0QixNQUFyQixFQUE2QjtBQUMzQmlRLFdBQU90UCxJQUFQLENBQVltUixLQUFLQyxTQUFMLENBQWVrYixLQUFLaGxCLEtBQUwsQ0FBV20zQyxTQUFYLENBQWYsQ0FBWjtBQUNEO0FBQ0QsU0FBT252QyxPQUFPdkksSUFBUCxDQUFZLEdBQVosQ0FBUDtBQUNEOztBQUVEOztBQUVBLElBQUkyM0MsT0FBTyxXQUFYO0FBQ0EsSUFBSUMsUUFBUSxXQUFaO0FBQ0EsSUFBSUMsYUFBYSwwQkFBakI7QUFDQSxJQUFJQyxnQkFBZ0IsNENBQXBCOztBQUVBLElBQUlDLFFBQVEsUUFBWjtBQUNBLElBQUlDLFNBQVMsYUFBYjtBQUNBLElBQUlDLGFBQWEsVUFBakI7O0FBRUEsSUFBSUMsbUJBQW1CaGhDLE9BQU9uWSxNQUFQLENBQXZCOztBQUVBO0FBQ0EsSUFBSW81QyxNQUFKO0FBQ0EsSUFBSWQsVUFBSjtBQUNBLElBQUllLFVBQUo7QUFDQSxJQUFJQyxhQUFKO0FBQ0EsSUFBSUMsY0FBSjtBQUNBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsbUJBQUo7QUFDQSxJQUFJQyx1QkFBSjs7QUFFQTs7O0FBR0EsU0FBUzN3QyxLQUFULENBQ0VuTSxRQURGLEVBRUUwSCxPQUZGLEVBR0U7QUFDQTgwQyxXQUFTOTBDLFFBQVF0SCxJQUFSLElBQWdCd25DLFFBQXpCO0FBQ0FrViw0QkFBMEJwMUMsUUFBUWlXLGVBQVIsSUFBMkJsQixFQUFyRDtBQUNBb2dDLHdCQUFzQm4xQyxRQUFRbVcsV0FBUixJQUF1QnBCLEVBQTdDO0FBQ0FtZ0MscUJBQW1CbDFDLFFBQVE4MkIsUUFBUixJQUFvQi9oQixFQUF2QztBQUNBaWdDLGtCQUFnQjdVLG9CQUFvQm5nQyxRQUFRa1YsT0FBNUIsRUFBcUMsa0JBQXJDLENBQWhCO0FBQ0E2L0IsZUFBYTVVLG9CQUFvQm5nQyxRQUFRa1YsT0FBNUIsRUFBcUMsZUFBckMsQ0FBYjtBQUNBKy9CLG1CQUFpQjlVLG9CQUFvQm5nQyxRQUFRa1YsT0FBNUIsRUFBcUMsbUJBQXJDLENBQWpCO0FBQ0E4K0IsZUFBYWgwQyxRQUFRZzBDLFVBQXJCOztBQUVBLE1BQUlweEMsUUFBUSxFQUFaO0FBQ0EsTUFBSXl5QyxxQkFBcUJyMUMsUUFBUXExQyxrQkFBUixLQUErQixLQUF4RDtBQUNBLE1BQUlDLElBQUo7QUFDQSxNQUFJQyxhQUFKO0FBQ0EsTUFBSUMsU0FBUyxLQUFiO0FBQ0EsTUFBSWhjLFFBQVEsS0FBWjtBQUNBLE1BQUlpYyxTQUFTLEtBQWI7O0FBRUEsV0FBU0MsUUFBVCxDQUFtQjc3QixHQUFuQixFQUF3QjtBQUN0QixRQUFJLENBQUM0N0IsTUFBTCxFQUFhO0FBQ1hBLGVBQVMsSUFBVDtBQUNBWCxhQUFPajdCLEdBQVA7QUFDRDtBQUNGOztBQUVELFdBQVM4N0IsTUFBVCxDQUFpQkMsT0FBakIsRUFBMEI7QUFDeEI7QUFDQSxRQUFJQSxRQUFRaGMsR0FBWixFQUFpQjtBQUNmNGIsZUFBUyxLQUFUO0FBQ0Q7QUFDRCxRQUFJTixpQkFBaUJVLFFBQVF4MkMsR0FBekIsQ0FBSixFQUFtQztBQUNqQ282QixjQUFRLEtBQVI7QUFDRDtBQUNGOztBQUVEMFksWUFBVTU1QyxRQUFWLEVBQW9CO0FBQ2xCSSxVQUFNbzhDLE1BRFk7QUFFbEIzQyxnQkFBWW55QyxRQUFRbXlDLFVBRkY7QUFHbEJ6QixnQkFBWTF3QyxRQUFRMHdDLFVBSEY7QUFJbEJDLHNCQUFrQjN3QyxRQUFRMndDLGdCQUpSO0FBS2xCRiwwQkFBc0J6d0MsUUFBUXl3QyxvQkFMWjtBQU1sQmg4QixXQUFPLFNBQVNBLEtBQVQsQ0FBZ0JyVixHQUFoQixFQUFxQm1CLEtBQXJCLEVBQTRCbXpDLEtBQTVCLEVBQW1DO0FBQ3hDO0FBQ0E7QUFDQSxVQUFJcHhCLEtBQU1pekIsaUJBQWlCQSxjQUFjanpCLEVBQWhDLElBQXVDOHlCLHdCQUF3QmgyQyxHQUF4QixDQUFoRDs7QUFFQTtBQUNBO0FBQ0EsVUFBSTJYLFFBQVF1TCxPQUFPLEtBQW5CLEVBQTBCO0FBQ3hCL2hCLGdCQUFRczFDLGNBQWN0MUMsS0FBZCxDQUFSO0FBQ0Q7O0FBRUQsVUFBSXExQyxVQUFVO0FBQ1o3OEMsY0FBTSxDQURNO0FBRVpxRyxhQUFLQSxHQUZPO0FBR1pnaUMsbUJBQVc3Z0MsS0FIQztBQUlaNGdDLGtCQUFVMlUsYUFBYXYxQyxLQUFiLENBSkU7QUFLWmxILGdCQUFRazhDLGFBTEk7QUFNWm44QyxrQkFBVTtBQU5FLE9BQWQ7QUFRQSxVQUFJa3BCLEVBQUosRUFBUTtBQUNOc3pCLGdCQUFRdHpCLEVBQVIsR0FBYUEsRUFBYjtBQUNEOztBQUVELFVBQUl5ekIsZUFBZUgsT0FBZixLQUEyQixDQUFDdCtCLG1CQUFoQyxFQUFxRDtBQUNuRHMrQixnQkFBUUksU0FBUixHQUFvQixJQUFwQjtBQUNBcGlELGdCQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzY0QyxPQUN2Qyx1RUFDQSxzRUFEQSxHQUVBLEdBRkEsR0FFTTExQyxHQUZOLEdBRVksR0FGWixHQUVrQiwrQkFIcUIsQ0FBekM7QUFLRDs7QUFFRDtBQUNBLFdBQUssSUFBSXpKLElBQUksQ0FBYixFQUFnQkEsSUFBSXEvQyxjQUFjLy9DLE1BQWxDLEVBQTBDVSxHQUExQyxFQUErQztBQUM3Q3EvQyxzQkFBY3IvQyxDQUFkLEVBQWlCaWdELE9BQWpCLEVBQTBCNTFDLE9BQTFCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDdzFDLE1BQUwsRUFBYTtBQUNYUyxtQkFBV0wsT0FBWDtBQUNBLFlBQUlBLFFBQVFoYyxHQUFaLEVBQWlCO0FBQ2Y0YixtQkFBUyxJQUFUO0FBQ0Q7QUFDRjtBQUNELFVBQUlOLGlCQUFpQlUsUUFBUXgyQyxHQUF6QixDQUFKLEVBQW1DO0FBQ2pDbzZCLGdCQUFRLElBQVI7QUFDRDtBQUNELFVBQUlnYyxNQUFKLEVBQVk7QUFDVlUsd0JBQWdCTixPQUFoQjtBQUNELE9BRkQsTUFFTztBQUNMTyxtQkFBV1AsT0FBWDtBQUNBUSxrQkFBVVIsT0FBVjtBQUNBUyxvQkFBWVQsT0FBWjtBQUNBVSxtQkFBV1YsT0FBWDs7QUFFQTtBQUNBO0FBQ0FBLGdCQUFRVyxLQUFSLEdBQWdCLENBQUNYLFFBQVExNUMsR0FBVCxJQUFnQixDQUFDcUUsTUFBTXRMLE1BQXZDOztBQUVBdWhELG1CQUFXWixPQUFYO0FBQ0FhLG9CQUFZYixPQUFaO0FBQ0FjLHlCQUFpQmQsT0FBakI7QUFDQSxhQUFLLElBQUl0d0IsTUFBTSxDQUFmLEVBQWtCQSxNQUFNeXZCLFdBQVc5L0MsTUFBbkMsRUFBMkNxd0IsS0FBM0MsRUFBa0Q7QUFDaER5dkIscUJBQVd6dkIsR0FBWCxFQUFnQnN3QixPQUFoQixFQUF5QjUxQyxPQUF6QjtBQUNEO0FBQ0QyMkMscUJBQWFmLE9BQWI7QUFDRDs7QUFFRCxlQUFTZ0Isb0JBQVQsQ0FBK0I3ckMsRUFBL0IsRUFBbUM7QUFDakMsWUFBSW5YLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGNBQUk4TyxHQUFHM0wsR0FBSCxLQUFXLE1BQVgsSUFBcUIyTCxHQUFHM0wsR0FBSCxLQUFXLFVBQXBDLEVBQWdEO0FBQzlDczJDLHFCQUNFLGlCQUFrQjNxQyxHQUFHM0wsR0FBckIsR0FBNEIsNkNBQTVCLEdBQ0EseUJBRkY7QUFJRDtBQUNELGNBQUkyTCxHQUFHbzJCLFFBQUgsQ0FBWTkzQixjQUFaLENBQTJCLE9BQTNCLENBQUosRUFBeUM7QUFDdkNxc0MscUJBQ0UsaUVBQ0EsK0JBRkY7QUFJRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFJLENBQUNKLElBQUwsRUFBVztBQUNUQSxlQUFPTSxPQUFQO0FBQ0FnQiw2QkFBcUJ0QixJQUFyQjtBQUNELE9BSEQsTUFHTyxJQUFJLENBQUMxeUMsTUFBTTNOLE1BQVgsRUFBbUI7QUFDeEI7QUFDQSxZQUFJcWdELEtBQUt1QixFQUFMLEtBQVlqQixRQUFRa0IsTUFBUixJQUFrQmxCLFFBQVFtQixJQUF0QyxDQUFKLEVBQWlEO0FBQy9DSCwrQkFBcUJoQixPQUFyQjtBQUNBb0IseUJBQWUxQixJQUFmLEVBQXFCO0FBQ25CaFcsaUJBQUtzVyxRQUFRa0IsTUFETTtBQUVuQkcsbUJBQU9yQjtBQUZZLFdBQXJCO0FBSUQsU0FORCxNQU1PLElBQUloaUQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaER5NUMsbUJBQ0UsaUVBQ0EsOENBREEsR0FFQSxzQ0FIRjtBQUtEO0FBQ0Y7QUFDRCxVQUFJSCxpQkFBaUIsQ0FBQ0ssUUFBUUksU0FBOUIsRUFBeUM7QUFDdkMsWUFBSUosUUFBUWtCLE1BQVIsSUFBa0JsQixRQUFRbUIsSUFBOUIsRUFBb0M7QUFDbENHLDhCQUFvQnRCLE9BQXBCLEVBQTZCTCxhQUE3QjtBQUNELFNBRkQsTUFFTyxJQUFJSyxRQUFRdUIsU0FBWixFQUF1QjtBQUFFO0FBQzlCNUIsd0JBQWNnQixLQUFkLEdBQXNCLEtBQXRCO0FBQ0EsY0FBSXYvQyxPQUFPNCtDLFFBQVF3QixVQUFSLElBQXNCLFdBQWpDLENBQTZDLENBQUM3QixjQUFjanRCLFdBQWQsS0FBOEJpdEIsY0FBY2p0QixXQUFkLEdBQTRCLEVBQTFELENBQUQsRUFBZ0V0eEIsSUFBaEUsSUFBd0U0K0MsT0FBeEU7QUFDOUMsU0FITSxNQUdBO0FBQ0xMLHdCQUFjbjhDLFFBQWQsQ0FBdUJ4RCxJQUF2QixDQUE0QmdnRCxPQUE1QjtBQUNBQSxrQkFBUXY4QyxNQUFSLEdBQWlCazhDLGFBQWpCO0FBQ0Q7QUFDRjtBQUNELFVBQUksQ0FBQzdCLEtBQUwsRUFBWTtBQUNWNkIsd0JBQWdCSyxPQUFoQjtBQUNBaHpDLGNBQU1oTixJQUFOLENBQVdnZ0QsT0FBWDtBQUNELE9BSEQsTUFHTztBQUNMRCxlQUFPQyxPQUFQO0FBQ0Q7QUFDRDtBQUNBLFdBQUssSUFBSXlCLE1BQU0sQ0FBZixFQUFrQkEsTUFBTXBDLGVBQWVoZ0QsTUFBdkMsRUFBK0NvaUQsS0FBL0MsRUFBc0Q7QUFDcERwQyx1QkFBZW9DLEdBQWYsRUFBb0J6QixPQUFwQixFQUE2QjUxQyxPQUE3QjtBQUNEO0FBQ0YsS0FuSWlCOztBQXFJbEI4SCxTQUFLLFNBQVNBLEdBQVQsR0FBZ0I7QUFDbkI7QUFDQSxVQUFJOHRDLFVBQVVoekMsTUFBTUEsTUFBTTNOLE1BQU4sR0FBZSxDQUFyQixDQUFkO0FBQ0EsVUFBSXFpRCxXQUFXMUIsUUFBUXg4QyxRQUFSLENBQWlCdzhDLFFBQVF4OEMsUUFBUixDQUFpQm5FLE1BQWpCLEdBQTBCLENBQTNDLENBQWY7QUFDQSxVQUFJcWlELFlBQVlBLFNBQVN2K0MsSUFBVCxLQUFrQixDQUE5QixJQUFtQ3UrQyxTQUFTcDFCLElBQVQsS0FBa0IsR0FBckQsSUFBNEQsQ0FBQ3NYLEtBQWpFLEVBQXdFO0FBQ3RFb2MsZ0JBQVF4OEMsUUFBUixDQUFpQnlKLEdBQWpCO0FBQ0Q7QUFDRDtBQUNBRCxZQUFNM04sTUFBTixJQUFnQixDQUFoQjtBQUNBc2dELHNCQUFnQjN5QyxNQUFNQSxNQUFNM04sTUFBTixHQUFlLENBQXJCLENBQWhCO0FBQ0EwZ0QsYUFBT0MsT0FBUDtBQUNELEtBaEppQjs7QUFrSmxCekMsV0FBTyxTQUFTQSxLQUFULENBQWdCanhCLElBQWhCLEVBQXNCO0FBQzNCLFVBQUksQ0FBQ3F6QixhQUFMLEVBQW9CO0FBQ2xCLFlBQUkzaEQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsY0FBSWltQixTQUFTNXBCLFFBQWIsRUFBdUI7QUFDckJvOUMscUJBQ0Usb0VBREY7QUFHRCxXQUpELE1BSU8sSUFBS3h6QixPQUFPQSxLQUFLOWxCLElBQUwsRUFBWixFQUEwQjtBQUMvQnM1QyxxQkFDRyxZQUFZeHpCLElBQVosR0FBbUIsMENBRHRCO0FBR0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsVUFBSW5MLFFBQ0F3K0IsY0FBY24yQyxHQUFkLEtBQXNCLFVBRHRCLElBRUFtMkMsY0FBY3BVLFFBQWQsQ0FBdUJ5TSxXQUF2QixLQUF1QzFyQixJQUYzQyxFQUVpRDtBQUMvQztBQUNEO0FBQ0QsVUFBSTlvQixXQUFXbThDLGNBQWNuOEMsUUFBN0I7QUFDQThvQixhQUFPc1gsU0FBU3RYLEtBQUs5bEIsSUFBTCxFQUFULEdBQ0h5NEMsaUJBQWlCM3lCLElBQWpCO0FBQ0Y7QUFGSyxRQUdIbXpCLHNCQUFzQmo4QyxTQUFTbkUsTUFBL0IsR0FBd0MsR0FBeEMsR0FBOEMsRUFIbEQ7QUFJQSxVQUFJaXRCLElBQUosRUFBVTtBQUNSLFlBQUlxSCxVQUFKO0FBQ0EsWUFBSSxDQUFDaXNCLE1BQUQsSUFBV3R6QixTQUFTLEdBQXBCLEtBQTRCcUgsYUFBYTRxQixVQUFVanlCLElBQVYsRUFBZ0I4eEIsVUFBaEIsQ0FBekMsQ0FBSixFQUEyRTtBQUN6RTU2QyxtQkFBU3hELElBQVQsQ0FBYztBQUNabUQsa0JBQU0sQ0FETTtBQUVad3dCLHdCQUFZQSxVQUZBO0FBR1pySCxrQkFBTUE7QUFITSxXQUFkO0FBS0QsU0FORCxNQU1PLElBQUlBLFNBQVMsR0FBVCxJQUFnQixDQUFDOW9CLFNBQVNuRSxNQUExQixJQUFvQ21FLFNBQVNBLFNBQVNuRSxNQUFULEdBQWtCLENBQTNCLEVBQThCaXRCLElBQTlCLEtBQXVDLEdBQS9FLEVBQW9GO0FBQ3pGOW9CLG1CQUFTeEQsSUFBVCxDQUFjO0FBQ1ptRCxrQkFBTSxDQURNO0FBRVptcEIsa0JBQU1BO0FBRk0sV0FBZDtBQUlEO0FBQ0Y7QUFDRjtBQTVMaUIsR0FBcEI7QUE4TEEsU0FBT296QixJQUFQO0FBQ0Q7O0FBRUQsU0FBU1csVUFBVCxDQUFxQmxyQyxFQUFyQixFQUF5QjtBQUN2QixNQUFJazJCLGlCQUFpQmwyQixFQUFqQixFQUFxQixPQUFyQixLQUFpQyxJQUFyQyxFQUEyQztBQUN6Q0EsT0FBRzZ1QixHQUFILEdBQVMsSUFBVDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3NjLGVBQVQsQ0FBMEJuckMsRUFBMUIsRUFBOEI7QUFDNUIsTUFBSXVKLElBQUl2SixHQUFHcTJCLFNBQUgsQ0FBYW5zQyxNQUFyQjtBQUNBLE1BQUlxZixDQUFKLEVBQU87QUFDTCxRQUFJL1QsUUFBUXdLLEdBQUd4SyxLQUFILEdBQVcsSUFBSTlLLEtBQUosQ0FBVTZlLENBQVYsQ0FBdkI7QUFDQSxTQUFLLElBQUkzZSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyZSxDQUFwQixFQUF1QjNlLEdBQXZCLEVBQTRCO0FBQzFCNEssWUFBTTVLLENBQU4sSUFBVztBQUNUcUIsY0FBTStULEdBQUdxMkIsU0FBSCxDQUFhenJDLENBQWIsRUFBZ0JxQixJQURiO0FBRVRZLGVBQU9tUCxLQUFLQyxTQUFMLENBQWUrRCxHQUFHcTJCLFNBQUgsQ0FBYXpyQyxDQUFiLEVBQWdCaUMsS0FBL0I7QUFGRSxPQUFYO0FBSUQ7QUFDRixHQVJELE1BUU8sSUFBSSxDQUFDbVQsR0FBRzZ1QixHQUFSLEVBQWE7QUFDbEI7QUFDQTd1QixPQUFHd3JDLEtBQUgsR0FBVyxJQUFYO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRCxVQUFULENBQXFCdnJDLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQUl1MEIsTUFBTXdCLGVBQWUvMUIsRUFBZixFQUFtQixLQUFuQixDQUFWO0FBQ0EsTUFBSXUwQixHQUFKLEVBQVM7QUFDUCxRQUFJMXJDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDOE8sR0FBRzNMLEdBQUgsS0FBVyxVQUF4RCxFQUFvRTtBQUNsRTAxQyxhQUFPLHFFQUFQO0FBQ0Q7QUFDRC9wQyxPQUFHN08sR0FBSCxHQUFTb2pDLEdBQVQ7QUFDRDtBQUNGOztBQUVELFNBQVNrWCxVQUFULENBQXFCenJDLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQUk1UixNQUFNMm5DLGVBQWUvMUIsRUFBZixFQUFtQixLQUFuQixDQUFWO0FBQ0EsTUFBSTVSLEdBQUosRUFBUztBQUNQNFIsT0FBRzVSLEdBQUgsR0FBU0EsR0FBVDtBQUNBNFIsT0FBR3V0QixRQUFILEdBQWNpZixXQUFXeHNDLEVBQVgsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU29yQyxVQUFULENBQXFCcHJDLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQUl1MEIsR0FBSjtBQUNBLE1BQUtBLE1BQU0yQixpQkFBaUJsMkIsRUFBakIsRUFBcUIsT0FBckIsQ0FBWCxFQUEyQztBQUN6QyxRQUFJeXNDLFVBQVVsWSxJQUFJNzNCLEtBQUosQ0FBVStzQyxVQUFWLENBQWQ7QUFDQSxRQUFJLENBQUNnRCxPQUFMLEVBQWM7QUFDWjVqRCxjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzY0QyxPQUN0QywrQkFBK0J4VixHQURPLENBQXpDO0FBR0E7QUFDRDtBQUNEdjBCLE9BQUcwc0MsR0FBSCxHQUFTRCxRQUFRLENBQVIsRUFBV3A3QyxJQUFYLEVBQVQ7QUFDQSxRQUFJOEgsUUFBUXN6QyxRQUFRLENBQVIsRUFBV3A3QyxJQUFYLEVBQVo7QUFDQSxRQUFJczdDLGdCQUFnQnh6QyxNQUFNdUQsS0FBTixDQUFZZ3RDLGFBQVosQ0FBcEI7QUFDQSxRQUFJaUQsYUFBSixFQUFtQjtBQUNqQjNzQyxTQUFHN0csS0FBSCxHQUFXd3pDLGNBQWMsQ0FBZCxFQUFpQnQ3QyxJQUFqQixFQUFYO0FBQ0EyTyxTQUFHNHNDLFNBQUgsR0FBZUQsY0FBYyxDQUFkLEVBQWlCdDdDLElBQWpCLEVBQWY7QUFDQSxVQUFJczdDLGNBQWMsQ0FBZCxDQUFKLEVBQXNCO0FBQ3BCM3NDLFdBQUc2c0MsU0FBSCxHQUFlRixjQUFjLENBQWQsRUFBaUJ0N0MsSUFBakIsRUFBZjtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0wyTyxTQUFHN0csS0FBSCxHQUFXQSxLQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNreUMsU0FBVCxDQUFvQnJyQyxFQUFwQixFQUF3QjtBQUN0QixNQUFJdTBCLE1BQU0yQixpQkFBaUJsMkIsRUFBakIsRUFBcUIsTUFBckIsQ0FBVjtBQUNBLE1BQUl1MEIsR0FBSixFQUFTO0FBQ1B2MEIsT0FBRzhyQyxFQUFILEdBQVF2WCxHQUFSO0FBQ0EwWCxtQkFBZWpzQyxFQUFmLEVBQW1CO0FBQ2pCdTBCLFdBQUtBLEdBRFk7QUFFakIyWCxhQUFPbHNDO0FBRlUsS0FBbkI7QUFJRCxHQU5ELE1BTU87QUFDTCxRQUFJazJCLGlCQUFpQmwyQixFQUFqQixFQUFxQixRQUFyQixLQUFrQyxJQUF0QyxFQUE0QztBQUMxQ0EsU0FBR2dzQyxJQUFILEdBQVUsSUFBVjtBQUNEO0FBQ0QsUUFBSUQsU0FBUzdWLGlCQUFpQmwyQixFQUFqQixFQUFxQixXQUFyQixDQUFiO0FBQ0EsUUFBSStyQyxNQUFKLEVBQVk7QUFDVi9yQyxTQUFHK3JDLE1BQUgsR0FBWUEsTUFBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTSSxtQkFBVCxDQUE4Qm5zQyxFQUE5QixFQUFrQzFSLE1BQWxDLEVBQTBDO0FBQ3hDLE1BQUkyVixPQUFPNm9DLGdCQUFnQngrQyxPQUFPRCxRQUF2QixDQUFYO0FBQ0EsTUFBSTRWLFFBQVFBLEtBQUs2bkMsRUFBakIsRUFBcUI7QUFDbkJHLG1CQUFlaG9DLElBQWYsRUFBcUI7QUFDbkJzd0IsV0FBS3YwQixHQUFHK3JDLE1BRFc7QUFFbkJHLGFBQU9sc0M7QUFGWSxLQUFyQjtBQUlELEdBTEQsTUFLTyxJQUFJblgsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaEQ2NEMsV0FDRSxRQUFRL3BDLEdBQUcrckMsTUFBSCxHQUFhLGNBQWMvckMsR0FBRytyQyxNQUFqQixHQUEwQixHQUF2QyxHQUE4QyxNQUF0RCxJQUFnRSxHQUFoRSxHQUNBLG1CQURBLEdBQ3VCL3JDLEdBQUczTCxHQUQxQixHQUNpQywrQkFGbkM7QUFJRDtBQUNGOztBQUVELFNBQVN5NEMsZUFBVCxDQUEwQnorQyxRQUExQixFQUFvQztBQUNsQyxNQUFJekQsSUFBSXlELFNBQVNuRSxNQUFqQjtBQUNBLFNBQU9VLEdBQVAsRUFBWTtBQUNWLFFBQUl5RCxTQUFTekQsQ0FBVCxFQUFZb0QsSUFBWixLQUFxQixDQUF6QixFQUE0QjtBQUMxQixhQUFPSyxTQUFTekQsQ0FBVCxDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSS9CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDN0MsU0FBU3pELENBQVQsRUFBWXVzQixJQUFaLEtBQXFCLEdBQWxFLEVBQXVFO0FBQ3JFNHlCLGVBQ0UsWUFBYTE3QyxTQUFTekQsQ0FBVCxFQUFZdXNCLElBQVosQ0FBaUI5bEIsSUFBakIsRUFBYixHQUF3QyxrQ0FBeEMsR0FDQSxrQkFGRjtBQUlEO0FBQ0RoRCxlQUFTeUosR0FBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTbTBDLGNBQVQsQ0FBeUJqc0MsRUFBekIsRUFBNkJ2UyxTQUE3QixFQUF3QztBQUN0QyxNQUFJLENBQUN1UyxHQUFHK3NDLFlBQVIsRUFBc0I7QUFDcEIvc0MsT0FBRytzQyxZQUFILEdBQWtCLEVBQWxCO0FBQ0Q7QUFDRC9zQyxLQUFHK3NDLFlBQUgsQ0FBZ0JsaUQsSUFBaEIsQ0FBcUI0QyxTQUFyQjtBQUNEOztBQUVELFNBQVM2OUMsV0FBVCxDQUFzQnRyQyxFQUF0QixFQUEwQjtBQUN4QixNQUFJc1ksVUFBVTRkLGlCQUFpQmwyQixFQUFqQixFQUFxQixRQUFyQixDQUFkO0FBQ0EsTUFBSXNZLFdBQVcsSUFBZixFQUFxQjtBQUNuQnRZLE9BQUdyVSxJQUFILEdBQVUsSUFBVjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUysvQyxXQUFULENBQXNCMXJDLEVBQXRCLEVBQTBCO0FBQ3hCLE1BQUlBLEdBQUczTCxHQUFILEtBQVcsTUFBZixFQUF1QjtBQUNyQjJMLE9BQUdndEMsUUFBSCxHQUFjalgsZUFBZS8xQixFQUFmLEVBQW1CLE1BQW5CLENBQWQ7QUFDQSxRQUFJblgsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUM4TyxHQUFHN08sR0FBaEQsRUFBcUQ7QUFDbkQ0NEMsYUFDRSxzRUFDQSxrREFEQSxHQUVBLDRDQUhGO0FBS0Q7QUFDRixHQVRELE1BU087QUFDTCxRQUFJc0MsYUFBYXRXLGVBQWUvMUIsRUFBZixFQUFtQixNQUFuQixDQUFqQjtBQUNBLFFBQUlxc0MsVUFBSixFQUFnQjtBQUNkcnNDLFNBQUdxc0MsVUFBSCxHQUFnQkEsZUFBZSxJQUFmLEdBQXNCLFdBQXRCLEdBQW9DQSxVQUFwRDtBQUNEO0FBQ0QsUUFBSXJzQyxHQUFHM0wsR0FBSCxLQUFXLFVBQWYsRUFBMkI7QUFDekIyTCxTQUFHb3NDLFNBQUgsR0FBZWxXLGlCQUFpQmwyQixFQUFqQixFQUFxQixPQUFyQixDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVMyckMsZ0JBQVQsQ0FBMkIzckMsRUFBM0IsRUFBK0I7QUFDN0IsTUFBSWhVLE9BQUo7QUFDQSxNQUFLQSxVQUFVK3BDLGVBQWUvMUIsRUFBZixFQUFtQixJQUFuQixDQUFmLEVBQTBDO0FBQ3hDQSxPQUFHMVMsU0FBSCxHQUFldEIsT0FBZjtBQUNEO0FBQ0QsTUFBSWtxQyxpQkFBaUJsMkIsRUFBakIsRUFBcUIsaUJBQXJCLEtBQTJDLElBQS9DLEVBQXFEO0FBQ25EQSxPQUFHMmpCLGNBQUgsR0FBb0IsSUFBcEI7QUFDRDtBQUNGOztBQUVELFNBQVNpb0IsWUFBVCxDQUF1QjVyQyxFQUF2QixFQUEyQjtBQUN6QixNQUFJc0ksT0FBT3RJLEdBQUdxMkIsU0FBZDtBQUNBLE1BQUl6ckMsQ0FBSixFQUFPMmUsQ0FBUCxFQUFVdGQsSUFBVixFQUFnQnNuQyxPQUFoQixFQUF5QjFtQyxLQUF6QixFQUFnQ3dtQyxTQUFoQyxFQUEyQzRaLE1BQTNDO0FBQ0EsT0FBS3JpRCxJQUFJLENBQUosRUFBTzJlLElBQUlqQixLQUFLcGUsTUFBckIsRUFBNkJVLElBQUkyZSxDQUFqQyxFQUFvQzNlLEdBQXBDLEVBQXlDO0FBQ3ZDcUIsV0FBT3NuQyxVQUFVanJCLEtBQUsxZCxDQUFMLEVBQVFxQixJQUF6QjtBQUNBWSxZQUFReWIsS0FBSzFkLENBQUwsRUFBUWlDLEtBQWhCO0FBQ0EsUUFBSTI4QyxNQUFNanpDLElBQU4sQ0FBV3RLLElBQVgsQ0FBSixFQUFzQjtBQUNwQjtBQUNBK1QsU0FBR2t0QyxXQUFILEdBQWlCLElBQWpCO0FBQ0E7QUFDQTdaLGtCQUFZOFosZUFBZWxoRCxJQUFmLENBQVo7QUFDQSxVQUFJb25DLFNBQUosRUFBZTtBQUNicG5DLGVBQU9BLEtBQUt5RSxPQUFMLENBQWFtNUMsVUFBYixFQUF5QixFQUF6QixDQUFQO0FBQ0Q7QUFDRCxVQUFJRCxPQUFPcnpDLElBQVAsQ0FBWXRLLElBQVosQ0FBSixFQUF1QjtBQUFFO0FBQ3ZCQSxlQUFPQSxLQUFLeUUsT0FBTCxDQUFhazVDLE1BQWIsRUFBcUIsRUFBckIsQ0FBUDtBQUNBLzhDLGdCQUFReW5DLGFBQWF6bkMsS0FBYixDQUFSO0FBQ0FvZ0QsaUJBQVMsS0FBVDtBQUNBLFlBQUk1WixTQUFKLEVBQWU7QUFDYixjQUFJQSxVQUFVdGUsSUFBZCxFQUFvQjtBQUNsQms0QixxQkFBUyxJQUFUO0FBQ0FoaEQsbUJBQU9nZCxTQUFTaGQsSUFBVCxDQUFQO0FBQ0EsZ0JBQUlBLFNBQVMsV0FBYixFQUEwQjtBQUFFQSxxQkFBTyxXQUFQO0FBQXFCO0FBQ2xEO0FBQ0QsY0FBSW9uQyxVQUFVK1osS0FBZCxFQUFxQjtBQUNuQm5oRCxtQkFBT2dkLFNBQVNoZCxJQUFULENBQVA7QUFDRDtBQUNGO0FBQ0QsWUFBSWdoRCxVQUFVN0Msb0JBQW9CcHFDLEdBQUczTCxHQUF2QixFQUE0QjJMLEdBQUdvMkIsUUFBSCxDQUFZcG9DLElBQXhDLEVBQThDL0IsSUFBOUMsQ0FBZCxFQUFtRTtBQUNqRW9wQyxrQkFBUXIxQixFQUFSLEVBQVkvVCxJQUFaLEVBQWtCWSxLQUFsQjtBQUNELFNBRkQsTUFFTztBQUNMeW9DLGtCQUFRdDFCLEVBQVIsRUFBWS9ULElBQVosRUFBa0JZLEtBQWxCO0FBQ0Q7QUFDRixPQW5CRCxNQW1CTyxJQUFJMDhDLEtBQUtoekMsSUFBTCxDQUFVdEssSUFBVixDQUFKLEVBQXFCO0FBQUU7QUFDNUJBLGVBQU9BLEtBQUt5RSxPQUFMLENBQWE2NEMsSUFBYixFQUFtQixFQUFuQixDQUFQO0FBQ0E5VCxtQkFBV3oxQixFQUFYLEVBQWUvVCxJQUFmLEVBQXFCWSxLQUFyQixFQUE0QndtQyxTQUE1QjtBQUNELE9BSE0sTUFHQTtBQUFFO0FBQ1BwbkMsZUFBT0EsS0FBS3lFLE9BQUwsQ0FBYTg0QyxLQUFiLEVBQW9CLEVBQXBCLENBQVA7QUFDQTtBQUNBLFlBQUk2RCxXQUFXcGhELEtBQUt5USxLQUFMLENBQVdpdEMsS0FBWCxDQUFmO0FBQ0EsWUFBSW5VLE1BQU02WCxZQUFZQSxTQUFTLENBQVQsQ0FBdEI7QUFDQSxZQUFJN1gsR0FBSixFQUFTO0FBQ1B2cEMsaUJBQU9BLEtBQUtrRyxLQUFMLENBQVcsQ0FBWCxFQUFjLEVBQUVxakMsSUFBSXRyQyxNQUFKLEdBQWEsQ0FBZixDQUFkLENBQVA7QUFDRDtBQUNEcXJDLHFCQUFhdjFCLEVBQWIsRUFBaUIvVCxJQUFqQixFQUF1QnNuQyxPQUF2QixFQUFnQzFtQyxLQUFoQyxFQUF1QzJvQyxHQUF2QyxFQUE0Q25DLFNBQTVDO0FBQ0EsWUFBSXhxQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q2pGLFNBQVMsT0FBdEQsRUFBK0Q7QUFDN0RxaEQsNkJBQW1CdHRDLEVBQW5CLEVBQXVCblQsS0FBdkI7QUFDRDtBQUNGO0FBQ0YsS0EzQ0QsTUEyQ087QUFDTDtBQUNBLFVBQUloRSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxZQUFJc3RCLGFBQWE0cUIsVUFBVXY4QyxLQUFWLEVBQWlCbzhDLFVBQWpCLENBQWpCO0FBQ0EsWUFBSXpxQixVQUFKLEVBQWdCO0FBQ2R1ckIsaUJBQ0U5OUMsT0FBTyxLQUFQLEdBQWVZLEtBQWYsR0FBdUIsTUFBdkIsR0FDQSxvREFEQSxHQUVBLDBEQUZBLEdBR0EsdURBSkY7QUFNRDtBQUNGO0FBQ0R5b0MsY0FBUXQxQixFQUFSLEVBQVkvVCxJQUFaLEVBQWtCK1AsS0FBS0MsU0FBTCxDQUFlcFAsS0FBZixDQUFsQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTMi9DLFVBQVQsQ0FBcUJ4c0MsRUFBckIsRUFBeUI7QUFDdkIsTUFBSTFSLFNBQVMwUixFQUFiO0FBQ0EsU0FBTzFSLE1BQVAsRUFBZTtBQUNiLFFBQUlBLE9BQU9vK0MsR0FBUCxLQUFlOThDLFNBQW5CLEVBQThCO0FBQzVCLGFBQU8sSUFBUDtBQUNEO0FBQ0R0QixhQUFTQSxPQUFPQSxNQUFoQjtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBUzYrQyxjQUFULENBQXlCbGhELElBQXpCLEVBQStCO0FBQzdCLE1BQUl5USxRQUFRelEsS0FBS3lRLEtBQUwsQ0FBV210QyxVQUFYLENBQVo7QUFDQSxNQUFJbnRDLEtBQUosRUFBVztBQUNULFFBQUlpTixNQUFNLEVBQVY7QUFDQWpOLFVBQU1uTCxPQUFOLENBQWMsVUFBVWdKLENBQVYsRUFBYTtBQUFFb1AsVUFBSXBQLEVBQUVwSSxLQUFGLENBQVEsQ0FBUixDQUFKLElBQWtCLElBQWxCO0FBQXlCLEtBQXREO0FBQ0EsV0FBT3dYLEdBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNvaEMsWUFBVCxDQUF1QnYxQyxLQUF2QixFQUE4QjtBQUM1QixNQUFJdkQsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJckgsSUFBSSxDQUFSLEVBQVcyZSxJQUFJL1QsTUFBTXRMLE1BQTFCLEVBQWtDVSxJQUFJMmUsQ0FBdEMsRUFBeUMzZSxHQUF6QyxFQUE4QztBQUM1QyxRQUFJL0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNlLElBQUl1RCxNQUFNNUssQ0FBTixFQUFTcUIsSUFBYixDQUF6QyxJQUErRCxDQUFDK2YsSUFBcEUsRUFBMEU7QUFDeEUrOUIsYUFBTywwQkFBMEJ2MEMsTUFBTTVLLENBQU4sRUFBU3FCLElBQTFDO0FBQ0Q7QUFDRGdHLFFBQUl1RCxNQUFNNUssQ0FBTixFQUFTcUIsSUFBYixJQUFxQnVKLE1BQU01SyxDQUFOLEVBQVNpQyxLQUE5QjtBQUNEO0FBQ0QsU0FBT29GLEdBQVA7QUFDRDs7QUFFRCxTQUFTKzRDLGNBQVQsQ0FBeUJockMsRUFBekIsRUFBNkI7QUFDM0IsU0FDRUEsR0FBRzNMLEdBQUgsS0FBVyxPQUFYLElBQ0MyTCxHQUFHM0wsR0FBSCxLQUFXLFFBQVgsS0FDQyxDQUFDMkwsR0FBR28yQixRQUFILENBQVlwb0MsSUFBYixJQUNBZ1MsR0FBR28yQixRQUFILENBQVlwb0MsSUFBWixLQUFxQixpQkFGdEIsQ0FGSDtBQU9EOztBQUVELElBQUl1L0MsVUFBVSxjQUFkO0FBQ0EsSUFBSUMsYUFBYSxTQUFqQjs7QUFFQTtBQUNBLFNBQVMxQyxhQUFULENBQXdCdDFDLEtBQXhCLEVBQStCO0FBQzdCLE1BQUlwRSxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUl4RyxJQUFJLENBQWIsRUFBZ0JBLElBQUk0SyxNQUFNdEwsTUFBMUIsRUFBa0NVLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUk4L0IsT0FBT2wxQixNQUFNNUssQ0FBTixDQUFYO0FBQ0EsUUFBSSxDQUFDMmlELFFBQVFoM0MsSUFBUixDQUFhbTBCLEtBQUt6K0IsSUFBbEIsQ0FBTCxFQUE4QjtBQUM1QnkrQixXQUFLeitCLElBQUwsR0FBWXkrQixLQUFLeitCLElBQUwsQ0FBVXlFLE9BQVYsQ0FBa0I4OEMsVUFBbEIsRUFBOEIsRUFBOUIsQ0FBWjtBQUNBcDhDLFVBQUl2RyxJQUFKLENBQVM2L0IsSUFBVDtBQUNEO0FBQ0Y7QUFDRCxTQUFPdDVCLEdBQVA7QUFDRDs7QUFFRCxTQUFTazhDLGtCQUFULENBQTZCdHRDLEVBQTdCLEVBQWlDblQsS0FBakMsRUFBd0M7QUFDdEMsTUFBSTRnRCxNQUFNenRDLEVBQVY7QUFDQSxTQUFPeXRDLEdBQVAsRUFBWTtBQUNWLFFBQUlBLElBQUlmLEdBQUosSUFBV2UsSUFBSXQwQyxLQUFKLEtBQWN0TSxLQUE3QixFQUFvQztBQUNsQ2s5QyxhQUNFLE1BQU8vcEMsR0FBRzNMLEdBQVYsR0FBaUIsYUFBakIsR0FBaUN4SCxLQUFqQyxHQUF5QyxPQUF6QyxHQUNBLCtEQURBLEdBRUEsaUVBRkEsR0FHQSxvRUFIQSxHQUlBLG1GQUxGO0FBT0Q7QUFDRDRnRCxVQUFNQSxJQUFJbi9DLE1BQVY7QUFDRDtBQUNGOztBQUVEOztBQUVBLElBQUlvL0MsV0FBSjtBQUNBLElBQUlDLHFCQUFKOztBQUVBLElBQUlDLHNCQUFzQjlrQyxPQUFPK2tDLGVBQVAsQ0FBMUI7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsU0FBU0MsUUFBVCxDQUFtQnZELElBQW5CLEVBQXlCdDFDLE9BQXpCLEVBQWtDO0FBQ2hDLE1BQUksQ0FBQ3MxQyxJQUFMLEVBQVc7QUFBRTtBQUFRO0FBQ3JCbUQsZ0JBQWNFLG9CQUFvQjM0QyxRQUFRb1YsVUFBUixJQUFzQixFQUExQyxDQUFkO0FBQ0FzakMsMEJBQXdCMTRDLFFBQVErVixhQUFSLElBQXlCaEIsRUFBakQ7QUFDQTtBQUNBK2pDLGVBQWF4RCxJQUFiO0FBQ0E7QUFDQXlELGtCQUFnQnpELElBQWhCLEVBQXNCLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBU3NELGVBQVQsQ0FBMEI3N0MsSUFBMUIsRUFBZ0M7QUFDOUIsU0FBT29XLFFBQ0wsNkRBQ0NwVyxPQUFPLE1BQU1BLElBQWIsR0FBb0IsRUFEckIsQ0FESyxDQUFQO0FBSUQ7O0FBRUQsU0FBUys3QyxZQUFULENBQXVCaDJCLElBQXZCLEVBQTZCO0FBQzNCQSxPQUFLazJCLE1BQUwsR0FBY3Q0QyxTQUFTb2lCLElBQVQsQ0FBZDtBQUNBLE1BQUlBLEtBQUsvcEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQ0UsQ0FBQzIvQyxzQkFBc0I1MUIsS0FBSzFqQixHQUEzQixDQUFELElBQ0EwakIsS0FBSzFqQixHQUFMLEtBQWEsTUFEYixJQUVBMGpCLEtBQUtxZSxRQUFMLENBQWMsaUJBQWQsS0FBb0MsSUFIdEMsRUFJRTtBQUNBO0FBQ0Q7QUFDRCxTQUFLLElBQUl4ckMsSUFBSSxDQUFSLEVBQVcyZSxJQUFJd08sS0FBSzFwQixRQUFMLENBQWNuRSxNQUFsQyxFQUEwQ1UsSUFBSTJlLENBQTlDLEVBQWlEM2UsR0FBakQsRUFBc0Q7QUFDcEQsVUFBSTRFLFFBQVF1b0IsS0FBSzFwQixRQUFMLENBQWN6RCxDQUFkLENBQVo7QUFDQW1qRCxtQkFBYXYrQyxLQUFiO0FBQ0EsVUFBSSxDQUFDQSxNQUFNeStDLE1BQVgsRUFBbUI7QUFDakJsMkIsYUFBS2syQixNQUFMLEdBQWMsS0FBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQVNELGVBQVQsQ0FBMEJqMkIsSUFBMUIsRUFBZ0M4TixPQUFoQyxFQUF5QztBQUN2QyxNQUFJOU4sS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsUUFBSStwQixLQUFLazJCLE1BQUwsSUFBZWwyQixLQUFLcHNCLElBQXhCLEVBQThCO0FBQzVCb3NCLFdBQUttMkIsV0FBTCxHQUFtQnJvQixPQUFuQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBSTlOLEtBQUtrMkIsTUFBTCxJQUFlbDJCLEtBQUsxcEIsUUFBTCxDQUFjbkUsTUFBN0IsSUFBdUMsRUFDekM2dEIsS0FBSzFwQixRQUFMLENBQWNuRSxNQUFkLEtBQXlCLENBQXpCLElBQ0E2dEIsS0FBSzFwQixRQUFMLENBQWMsQ0FBZCxFQUFpQkwsSUFBakIsS0FBMEIsQ0FGZSxDQUEzQyxFQUdHO0FBQ0QrcEIsV0FBS28yQixVQUFMLEdBQWtCLElBQWxCO0FBQ0E7QUFDRCxLQU5ELE1BTU87QUFDTHAyQixXQUFLbzJCLFVBQUwsR0FBa0IsS0FBbEI7QUFDRDtBQUNELFFBQUlwMkIsS0FBSzFwQixRQUFULEVBQW1CO0FBQ2pCLFdBQUssSUFBSXpELElBQUksQ0FBUixFQUFXMmUsSUFBSXdPLEtBQUsxcEIsUUFBTCxDQUFjbkUsTUFBbEMsRUFBMENVLElBQUkyZSxDQUE5QyxFQUFpRDNlLEdBQWpELEVBQXNEO0FBQ3BEb2pELHdCQUFnQmoyQixLQUFLMXBCLFFBQUwsQ0FBY3pELENBQWQsQ0FBaEIsRUFBa0NpN0IsV0FBVyxDQUFDLENBQUM5TixLQUFLMjBCLEdBQXBEO0FBQ0Q7QUFDRjtBQUNELFFBQUkzMEIsS0FBS2cxQixZQUFULEVBQXVCO0FBQ3JCcUIsa0NBQTRCcjJCLEtBQUtnMUIsWUFBakMsRUFBK0NsbkIsT0FBL0M7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU3VvQiwyQkFBVCxDQUFzQ0MsZUFBdEMsRUFBdUR4b0IsT0FBdkQsRUFBZ0U7QUFDOUQsT0FBSyxJQUFJajdCLElBQUksQ0FBUixFQUFXTixNQUFNK2pELGdCQUFnQm5rRCxNQUF0QyxFQUE4Q1UsSUFBSU4sR0FBbEQsRUFBdURNLEdBQXZELEVBQTREO0FBQzFEb2pELG9CQUFnQkssZ0JBQWdCempELENBQWhCLEVBQW1Cc2hELEtBQW5DLEVBQTBDcm1CLE9BQTFDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbHdCLFFBQVQsQ0FBbUJvaUIsSUFBbkIsRUFBeUI7QUFDdkIsTUFBSUEsS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFBRTtBQUNyQixXQUFPLEtBQVA7QUFDRDtBQUNELE1BQUkrcEIsS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFBRTtBQUNyQixXQUFPLElBQVA7QUFDRDtBQUNELFNBQU8sQ0FBQyxFQUFFK3BCLEtBQUs4VyxHQUFMLElBQ1IsQ0FBQzlXLEtBQUttMUIsV0FBTixJQUFxQjtBQUNyQixHQUFDbjFCLEtBQUsrekIsRUFETixJQUNZLENBQUMvekIsS0FBSzIwQixHQURsQixJQUN5QjtBQUN6QixHQUFDbGtDLGFBQWF1UCxLQUFLMWpCLEdBQWxCLENBRkQsSUFFMkI7QUFDM0JzNUMsd0JBQXNCNTFCLEtBQUsxakIsR0FBM0IsQ0FIQSxJQUdtQztBQUNuQyxHQUFDaTZDLDJCQUEyQnYyQixJQUEzQixDQUpELElBS0FwckIsT0FBT3FGLElBQVAsQ0FBWStsQixJQUFaLEVBQWtCcmtCLEtBQWxCLENBQXdCZzZDLFdBQXhCLENBTk0sQ0FBUjtBQVFEOztBQUVELFNBQVNZLDBCQUFULENBQXFDdjJCLElBQXJDLEVBQTJDO0FBQ3pDLFNBQU9BLEtBQUt6cEIsTUFBWixFQUFvQjtBQUNsQnlwQixXQUFPQSxLQUFLenBCLE1BQVo7QUFDQSxRQUFJeXBCLEtBQUsxakIsR0FBTCxLQUFhLFVBQWpCLEVBQTZCO0FBQzNCLGFBQU8sS0FBUDtBQUNEO0FBQ0QsUUFBSTBqQixLQUFLMjBCLEdBQVQsRUFBYztBQUNaLGFBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJNkIsVUFBVSw4Q0FBZDtBQUNBLElBQUlDLGVBQWUsOEZBQW5COztBQUVBO0FBQ0EsSUFBSXpqQyxXQUFXO0FBQ2IwakMsT0FBSyxFQURRO0FBRWJDLE9BQUssQ0FGUTtBQUdialEsU0FBTyxFQUhNO0FBSWJrUSxTQUFPLEVBSk07QUFLYkMsTUFBSSxFQUxTO0FBTWI1dEMsUUFBTSxFQU5PO0FBT2I2dEMsU0FBTyxFQVBNO0FBUWJDLFFBQU0sRUFSTztBQVNiLFlBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQVRHLENBQWY7O0FBWUE7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsV0FBVyxVQUFVdGhELFNBQVYsRUFBcUI7QUFBRSxTQUFRLFFBQVFBLFNBQVIsR0FBb0IsZUFBNUI7QUFBK0MsQ0FBckY7O0FBRUEsSUFBSXVoRCxlQUFlO0FBQ2pCQyxRQUFNLDJCQURXO0FBRWpCQyxXQUFTLDBCQUZRO0FBR2pCQyxRQUFNSixTQUFTLHdDQUFULENBSFc7QUFJakJLLFFBQU1MLFNBQVMsaUJBQVQsQ0FKVztBQUtqQnI5QyxTQUFPcTlDLFNBQVMsa0JBQVQsQ0FMVTtBQU1qQk0sT0FBS04sU0FBUyxnQkFBVCxDQU5ZO0FBT2pCbjhDLFFBQU1tOEMsU0FBUyxpQkFBVCxDQVBXO0FBUWpCL3RDLFFBQU0rdEMsU0FBUywyQ0FBVCxDQVJXO0FBU2pCTyxVQUFRUCxTQUFTLDJDQUFULENBVFM7QUFVakJGLFNBQU9FLFNBQVMsMkNBQVQ7QUFWVSxDQUFuQjs7QUFhQSxTQUFTUSxXQUFULENBQXNCNVosTUFBdEIsRUFBOEJDLE1BQTlCLEVBQXNDO0FBQ3BDLE1BQUl4a0MsTUFBTXdrQyxTQUFTLFlBQVQsR0FBd0IsTUFBbEM7QUFDQSxPQUFLLElBQUkzcEMsSUFBVCxJQUFpQjBwQyxNQUFqQixFQUF5QjtBQUN2QnZrQyxXQUFPLE9BQU9uRixJQUFQLEdBQWMsS0FBZCxHQUF1QnVqRCxXQUFXdmpELElBQVgsRUFBaUIwcEMsT0FBTzFwQyxJQUFQLENBQWpCLENBQXZCLEdBQXlELEdBQWhFO0FBQ0Q7QUFDRCxTQUFPbUYsSUFBSWUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsSUFBbUIsR0FBMUI7QUFDRDs7QUFFRCxTQUFTcTlDLFVBQVQsQ0FDRXZqRCxJQURGLEVBRUVtSixPQUZGLEVBR0U7QUFDQSxNQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaLFdBQU8sY0FBUDtBQUNEOztBQUVELE1BQUkxSyxNQUFNbUgsT0FBTixDQUFjdUQsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFdBQVEsTUFBT0EsUUFBUW5ELEdBQVIsQ0FBWSxVQUFVbUQsT0FBVixFQUFtQjtBQUFFLGFBQU9vNkMsV0FBV3ZqRCxJQUFYLEVBQWlCbUosT0FBakIsQ0FBUDtBQUFtQyxLQUFwRSxFQUFzRXhELElBQXRFLENBQTJFLEdBQTNFLENBQVAsR0FBMEYsR0FBbEc7QUFDRDs7QUFFRCxNQUFJNjlDLGVBQWVqQixhQUFhajRDLElBQWIsQ0FBa0JuQixRQUFRdkksS0FBMUIsQ0FBbkI7QUFDQSxNQUFJNmlELHVCQUF1Qm5CLFFBQVFoNEMsSUFBUixDQUFhbkIsUUFBUXZJLEtBQXJCLENBQTNCOztBQUVBLE1BQUksQ0FBQ3VJLFFBQVFpK0IsU0FBYixFQUF3QjtBQUN0QixXQUFPb2MsZ0JBQWdCQyxvQkFBaEIsR0FDSHQ2QyxRQUFRdkksS0FETCxHQUVGLHNCQUF1QnVJLFFBQVF2SSxLQUEvQixHQUF3QyxHQUY3QyxDQURzQixDQUc0QjtBQUNuRCxHQUpELE1BSU87QUFDTCxRQUFJMHJDLE9BQU8sRUFBWDtBQUNBLFFBQUlvWCxrQkFBa0IsRUFBdEI7QUFDQSxRQUFJMzlDLE9BQU8sRUFBWDtBQUNBLFNBQUssSUFBSWIsR0FBVCxJQUFnQmlFLFFBQVFpK0IsU0FBeEIsRUFBbUM7QUFDakMsVUFBSTJiLGFBQWE3OUMsR0FBYixDQUFKLEVBQXVCO0FBQ3JCdytDLDJCQUFtQlgsYUFBYTc5QyxHQUFiLENBQW5CO0FBQ0E7QUFDQSxZQUFJNFosU0FBUzVaLEdBQVQsQ0FBSixFQUFtQjtBQUNqQmEsZUFBS25ILElBQUwsQ0FBVXNHLEdBQVY7QUFDRDtBQUNGLE9BTkQsTUFNTztBQUNMYSxhQUFLbkgsSUFBTCxDQUFVc0csR0FBVjtBQUNEO0FBQ0Y7QUFDRCxRQUFJYSxLQUFLOUgsTUFBVCxFQUFpQjtBQUNmcXVDLGNBQVFxWCxhQUFhNTlDLElBQWIsQ0FBUjtBQUNEO0FBQ0Q7QUFDQSxRQUFJMjlDLGVBQUosRUFBcUI7QUFDbkJwWCxjQUFRb1gsZUFBUjtBQUNEO0FBQ0QsUUFBSUUsY0FBY0osZUFDZHI2QyxRQUFRdkksS0FBUixHQUFnQixVQURGLEdBRWQ2aUQsdUJBQ0csTUFBT3Q2QyxRQUFRdkksS0FBZixHQUF3QixXQUQzQixHQUVFdUksUUFBUXZJLEtBSmQ7QUFLQSxXQUFRLHNCQUFzQjByQyxJQUF0QixHQUE2QnNYLFdBQTdCLEdBQTJDLEdBQW5EO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRCxZQUFULENBQXVCNTlDLElBQXZCLEVBQTZCO0FBQzNCLFNBQVEsK0JBQWdDQSxLQUFLQyxHQUFMLENBQVM2OUMsYUFBVCxFQUF3QmwrQyxJQUF4QixDQUE2QixJQUE3QixDQUFoQyxHQUFzRSxlQUE5RTtBQUNEOztBQUVELFNBQVNrK0MsYUFBVCxDQUF3QjMrQyxHQUF4QixFQUE2QjtBQUMzQixNQUFJNCtDLFNBQVNDLFNBQVM3K0MsR0FBVCxFQUFjLEVBQWQsQ0FBYjtBQUNBLE1BQUk0K0MsTUFBSixFQUFZO0FBQ1YsV0FBUSxzQkFBc0JBLE1BQTlCO0FBQ0Q7QUFDRCxNQUFJNTJDLFFBQVE0UixTQUFTNVosR0FBVCxDQUFaO0FBQ0EsU0FBUSx1QkFBd0I2SyxLQUFLQyxTQUFMLENBQWU5SyxHQUFmLENBQXhCLElBQWdEZ0ksUUFBUSxNQUFNNkMsS0FBS0MsU0FBTCxDQUFlOUMsS0FBZixDQUFkLEdBQXNDLEVBQXRGLElBQTRGLEdBQXBHO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBUzgyQyxNQUFULENBQWlCandDLEVBQWpCLEVBQXFCNVQsR0FBckIsRUFBMEI7QUFDeEI0VCxLQUFHa3dDLFFBQUgsR0FBYyxVQUFVM1gsSUFBVixFQUFnQjtBQUM1QixXQUFRLFFBQVFBLElBQVIsR0FBZSxJQUFmLEdBQXVCdjRCLEdBQUczTCxHQUExQixHQUFpQyxJQUFqQyxHQUF5Q2pJLElBQUlTLEtBQTdDLElBQXVEVCxJQUFJaW5DLFNBQUosSUFBaUJqbkMsSUFBSWluQyxTQUFKLENBQWN0ZSxJQUEvQixHQUFzQyxPQUF0QyxHQUFnRCxFQUF2RyxJQUE2RyxHQUFySDtBQUNELEdBRkQ7QUFHRDs7QUFFRDs7QUFFQSxJQUFJbzdCLGlCQUFpQjtBQUNuQjNyQyxRQUFNeXJDLE1BRGE7QUFFbkJHLFNBQU81a0Q7QUFGWSxDQUFyQjs7QUFLQTs7QUFFQTtBQUNBLElBQUk2a0QsTUFBSjtBQUNBLElBQUlDLFlBQUo7QUFDQSxJQUFJQyxVQUFKO0FBQ0EsSUFBSUMsb0JBQUo7QUFDQSxJQUFJQyx1QkFBSjtBQUNBLElBQUk3c0IsZUFBSjtBQUNBLElBQUk4c0IsU0FBSjtBQUNBLElBQUlDLGNBQUo7O0FBRUEsU0FBU0MsUUFBVCxDQUNFQyxHQURGLEVBRUU1N0MsT0FGRixFQUdFO0FBQ0E7QUFDQSxNQUFJNjdDLHNCQUFzQmx0QixlQUExQjtBQUNBLE1BQUltdEIseUJBQXlCbnRCLGtCQUFrQixFQUEvQztBQUNBLE1BQUlvdEIsZ0JBQWdCTixTQUFwQjtBQUNBQSxjQUFZLENBQVo7QUFDQUMsbUJBQWlCMTdDLE9BQWpCO0FBQ0FvN0MsV0FBU3A3QyxRQUFRdEgsSUFBUixJQUFnQnduQyxRQUF6QjtBQUNBbWIsaUJBQWVsYixvQkFBb0JuZ0MsUUFBUWtWLE9BQTVCLEVBQXFDLGVBQXJDLENBQWY7QUFDQW9tQyxlQUFhbmIsb0JBQW9CbmdDLFFBQVFrVixPQUE1QixFQUFxQyxTQUFyQyxDQUFiO0FBQ0FxbUMseUJBQXVCdjdDLFFBQVErZSxVQUFSLElBQXNCLEVBQTdDO0FBQ0F5OEIsNEJBQTBCeDdDLFFBQVErVixhQUFSLElBQXlCaEIsRUFBbkQ7QUFDQSxNQUFJdXVCLE9BQU9zWSxNQUFNSSxXQUFXSixHQUFYLENBQU4sR0FBd0IsV0FBbkM7QUFDQWp0QixvQkFBa0JrdEIsbUJBQWxCO0FBQ0FKLGNBQVlNLGFBQVo7QUFDQSxTQUFPO0FBQ0w5aUQsWUFBUyx1QkFBdUJxcUMsSUFBdkIsR0FBOEIsR0FEbEM7QUFFTDNVLHFCQUFpQm10QjtBQUZaLEdBQVA7QUFJRDs7QUFFRCxTQUFTRSxVQUFULENBQXFCanhDLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQUlBLEdBQUdtdUMsVUFBSCxJQUFpQixDQUFDbnVDLEdBQUdreEMsZUFBekIsRUFBMEM7QUFDeEMsV0FBT0MsVUFBVW54QyxFQUFWLENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSUEsR0FBR3JVLElBQUgsSUFBVyxDQUFDcVUsR0FBR294QyxhQUFuQixFQUFrQztBQUN2QyxXQUFPQyxRQUFRcnhDLEVBQVIsQ0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJQSxHQUFHMHNDLEdBQUgsSUFBVSxDQUFDMXNDLEdBQUdzeEMsWUFBbEIsRUFBZ0M7QUFDckMsV0FBT0MsT0FBT3Z4QyxFQUFQLENBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSUEsR0FBRzhyQyxFQUFILElBQVMsQ0FBQzlyQyxHQUFHd3hDLFdBQWpCLEVBQThCO0FBQ25DLFdBQU9DLE1BQU16eEMsRUFBTixDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlBLEdBQUczTCxHQUFILEtBQVcsVUFBWCxJQUF5QixDQUFDMkwsR0FBR3FzQyxVQUFqQyxFQUE2QztBQUNsRCxXQUFPcUYsWUFBWTF4QyxFQUFaLEtBQW1CLFFBQTFCO0FBQ0QsR0FGTSxNQUVBLElBQUlBLEdBQUczTCxHQUFILEtBQVcsTUFBZixFQUF1QjtBQUM1QixXQUFPczlDLFFBQVEzeEMsRUFBUixDQUFQO0FBQ0QsR0FGTSxNQUVBO0FBQ0w7QUFDQSxRQUFJdTRCLElBQUo7QUFDQSxRQUFJdjRCLEdBQUcxUyxTQUFQLEVBQWtCO0FBQ2hCaXJDLGFBQU9xWixhQUFhNXhDLEdBQUcxUyxTQUFoQixFQUEyQjBTLEVBQTNCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJelIsT0FBT3lSLEdBQUd3ckMsS0FBSCxHQUFXNTdDLFNBQVgsR0FBdUJpaUQsUUFBUTd4QyxFQUFSLENBQWxDOztBQUVBLFVBQUkzUixXQUFXMlIsR0FBRzJqQixjQUFILEdBQW9CLElBQXBCLEdBQTJCK3RCLFlBQVkxeEMsRUFBWixFQUFnQixJQUFoQixDQUExQztBQUNBdTRCLGFBQU8sU0FBVXY0QixHQUFHM0wsR0FBYixHQUFvQixHQUFwQixJQUEyQjlGLE9BQVEsTUFBTUEsSUFBZCxHQUFzQixFQUFqRCxLQUF3REYsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUF0RixJQUE0RixHQUFuRztBQUNEO0FBQ0Q7QUFDQSxTQUFLLElBQUl6RCxJQUFJLENBQWIsRUFBZ0JBLElBQUkwbEQsYUFBYXBtRCxNQUFqQyxFQUF5Q1UsR0FBekMsRUFBOEM7QUFDNUMydEMsYUFBTytYLGFBQWExbEQsQ0FBYixFQUFnQm9WLEVBQWhCLEVBQW9CdTRCLElBQXBCLENBQVA7QUFDRDtBQUNELFdBQU9BLElBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBUzRZLFNBQVQsQ0FBb0JueEMsRUFBcEIsRUFBd0I7QUFDdEJBLEtBQUdreEMsZUFBSCxHQUFxQixJQUFyQjtBQUNBdHRCLGtCQUFnQi80QixJQUFoQixDQUFzQix1QkFBd0JvbUQsV0FBV2p4QyxFQUFYLENBQXhCLEdBQTBDLEdBQWhFO0FBQ0EsU0FBUSxTQUFTNGpCLGdCQUFnQjE1QixNQUFoQixHQUF5QixDQUFsQyxLQUF3QzhWLEdBQUdrdUMsV0FBSCxHQUFpQixPQUFqQixHQUEyQixFQUFuRSxJQUF5RSxHQUFqRjtBQUNEOztBQUVEO0FBQ0EsU0FBU21ELE9BQVQsQ0FBa0JyeEMsRUFBbEIsRUFBc0I7QUFDcEJBLEtBQUdveEMsYUFBSCxHQUFtQixJQUFuQjtBQUNBLE1BQUlweEMsR0FBRzhyQyxFQUFILElBQVMsQ0FBQzlyQyxHQUFHd3hDLFdBQWpCLEVBQThCO0FBQzVCLFdBQU9DLE1BQU16eEMsRUFBTixDQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUlBLEdBQUdrdUMsV0FBUCxFQUFvQjtBQUN6QixRQUFJLzhDLE1BQU0sRUFBVjtBQUNBLFFBQUk3QyxTQUFTMFIsR0FBRzFSLE1BQWhCO0FBQ0EsV0FBT0EsTUFBUCxFQUFlO0FBQ2IsVUFBSUEsT0FBT28rQyxHQUFYLEVBQWdCO0FBQ2R2N0MsY0FBTTdDLE9BQU82QyxHQUFiO0FBQ0E7QUFDRDtBQUNEN0MsZUFBU0EsT0FBT0EsTUFBaEI7QUFDRDtBQUNELFFBQUksQ0FBQzZDLEdBQUwsRUFBVTtBQUNSdEksY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNtL0MsT0FDdkMsc0RBRHVDLENBQXpDO0FBR0EsYUFBT1ksV0FBV2p4QyxFQUFYLENBQVA7QUFDRDtBQUNELFdBQVEsUUFBU2l4QyxXQUFXanhDLEVBQVgsQ0FBVCxHQUEyQixHQUEzQixHQUFrQzB3QyxXQUFsQyxJQUFrRHYvQyxNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBdEUsSUFBNEUsR0FBcEY7QUFDRCxHQWpCTSxNQWlCQTtBQUNMLFdBQU9nZ0QsVUFBVW54QyxFQUFWLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN5eEMsS0FBVCxDQUFnQnp4QyxFQUFoQixFQUFvQjtBQUNsQkEsS0FBR3d4QyxXQUFILEdBQWlCLElBQWpCLENBRGtCLENBQ0s7QUFDdkIsU0FBT00sZ0JBQWdCOXhDLEdBQUcrc0MsWUFBSCxDQUFnQjU2QyxLQUFoQixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzIvQyxlQUFULENBQTBCQyxVQUExQixFQUFzQztBQUNwQyxNQUFJLENBQUNBLFdBQVc3bkQsTUFBaEIsRUFBd0I7QUFDdEIsV0FBTyxNQUFQO0FBQ0Q7O0FBRUQsTUFBSXVELFlBQVlza0QsV0FBV3JnRCxLQUFYLEVBQWhCO0FBQ0EsTUFBSWpFLFVBQVU4bUMsR0FBZCxFQUFtQjtBQUNqQixXQUFRLE1BQU85bUMsVUFBVThtQyxHQUFqQixHQUF3QixJQUF4QixHQUFnQ3lkLGNBQWN2a0QsVUFBVXkrQyxLQUF4QixDQUFoQyxHQUFrRSxHQUFsRSxHQUF5RTRGLGdCQUFnQkMsVUFBaEIsQ0FBakY7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFRLEtBQU1DLGNBQWN2a0QsVUFBVXkrQyxLQUF4QixDQUFkO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFTOEYsYUFBVCxDQUF3Qmh5QyxFQUF4QixFQUE0QjtBQUMxQixXQUFPQSxHQUFHclUsSUFBSCxHQUFVMGxELFFBQVFyeEMsRUFBUixDQUFWLEdBQXdCaXhDLFdBQVdqeEMsRUFBWCxDQUEvQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3V4QyxNQUFULENBQWlCdnhDLEVBQWpCLEVBQXFCO0FBQ25CLE1BQUl1MEIsTUFBTXYwQixHQUFHMHNDLEdBQWI7QUFDQSxNQUFJdnpDLFFBQVE2RyxHQUFHN0csS0FBZjtBQUNBLE1BQUl5ekMsWUFBWTVzQyxHQUFHNHNDLFNBQUgsR0FBZ0IsTUFBTzVzQyxHQUFHNHNDLFNBQTFCLEdBQXdDLEVBQXhEO0FBQ0EsTUFBSUMsWUFBWTdzQyxHQUFHNnNDLFNBQUgsR0FBZ0IsTUFBTzdzQyxHQUFHNnNDLFNBQTFCLEdBQXdDLEVBQXhEOztBQUVBLE1BQ0Voa0QsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFDQStnRCxlQUFlanlDLEVBQWYsQ0FEQSxJQUNzQkEsR0FBRzNMLEdBQUgsS0FBVyxNQURqQyxJQUMyQzJMLEdBQUczTCxHQUFILEtBQVcsVUFEdEQsSUFDb0UsQ0FBQzJMLEdBQUc3TyxHQUYxRSxFQUdFO0FBQ0FrL0MsV0FDRSxNQUFPcndDLEdBQUczTCxHQUFWLEdBQWlCLFdBQWpCLEdBQStCOEUsS0FBL0IsR0FBdUMsTUFBdkMsR0FBZ0RvN0IsR0FBaEQsR0FBc0QscUNBQXRELEdBQ0EsbUNBREEsR0FFQSwwREFIRixFQUlFLElBSkYsQ0FJTztBQUpQO0FBTUQ7O0FBRUR2MEIsS0FBR3N4QyxZQUFILEdBQWtCLElBQWxCLENBbEJtQixDQWtCSztBQUN4QixTQUFPLFNBQVMvYyxHQUFULEdBQWUsSUFBZixHQUNMLFdBREssR0FDU3A3QixLQURULEdBQ2lCeXpDLFNBRGpCLEdBQzZCQyxTQUQ3QixHQUN5QyxJQUR6QyxHQUVILFNBRkcsR0FFVW9FLFdBQVdqeEMsRUFBWCxDQUZWLEdBR0wsSUFIRjtBQUlEOztBQUVELFNBQVM2eEMsT0FBVCxDQUFrQjd4QyxFQUFsQixFQUFzQjtBQUNwQixNQUFJelIsT0FBTyxHQUFYOztBQUVBO0FBQ0E7QUFDQSxNQUFJd2xCLE9BQU9tK0IsY0FBY2x5QyxFQUFkLENBQVg7QUFDQSxNQUFJK1QsSUFBSixFQUFVO0FBQUV4bEIsWUFBUXdsQixPQUFPLEdBQWY7QUFBcUI7O0FBRWpDO0FBQ0EsTUFBSS9ULEdBQUc3TyxHQUFQLEVBQVk7QUFDVjVDLFlBQVEsU0FBVXlSLEdBQUc3TyxHQUFiLEdBQW9CLEdBQTVCO0FBQ0Q7QUFDRDtBQUNBLE1BQUk2TyxHQUFHNVIsR0FBUCxFQUFZO0FBQ1ZHLFlBQVEsU0FBVXlSLEdBQUc1UixHQUFiLEdBQW9CLEdBQTVCO0FBQ0Q7QUFDRCxNQUFJNFIsR0FBR3V0QixRQUFQLEVBQWlCO0FBQ2ZoL0IsWUFBUSxnQkFBUjtBQUNEO0FBQ0Q7QUFDQSxNQUFJeVIsR0FBRzZ1QixHQUFQLEVBQVk7QUFDVnRnQyxZQUFRLFdBQVI7QUFDRDtBQUNEO0FBQ0EsTUFBSXlSLEdBQUcxUyxTQUFQLEVBQWtCO0FBQ2hCaUIsWUFBUSxXQUFZeVIsR0FBRzNMLEdBQWYsR0FBc0IsS0FBOUI7QUFDRDtBQUNEO0FBQ0EsT0FBSyxJQUFJekosSUFBSSxDQUFiLEVBQWdCQSxJQUFJMmxELFdBQVdybUQsTUFBL0IsRUFBdUNVLEdBQXZDLEVBQTRDO0FBQzFDMkQsWUFBUWdpRCxXQUFXM2xELENBQVgsRUFBY29WLEVBQWQsQ0FBUjtBQUNEO0FBQ0Q7QUFDQSxNQUFJQSxHQUFHeEssS0FBUCxFQUFjO0FBQ1pqSCxZQUFRLFlBQWE0akQsU0FBU255QyxHQUFHeEssS0FBWixDQUFiLEdBQW1DLElBQTNDO0FBQ0Q7QUFDRDtBQUNBLE1BQUl3SyxHQUFHalMsS0FBUCxFQUFjO0FBQ1pRLFlBQVEsZUFBZ0I0akQsU0FBU255QyxHQUFHalMsS0FBWixDQUFoQixHQUFzQyxJQUE5QztBQUNEO0FBQ0Q7QUFDQSxNQUFJaVMsR0FBRzIxQixNQUFQLEVBQWU7QUFDYnBuQyxZQUFTZ2hELFlBQVl2dkMsR0FBRzIxQixNQUFmLENBQUQsR0FBMkIsR0FBbkM7QUFDRDtBQUNELE1BQUkzMUIsR0FBRzYxQixZQUFQLEVBQXFCO0FBQ25CdG5DLFlBQVNnaEQsWUFBWXZ2QyxHQUFHNjFCLFlBQWYsRUFBNkIsSUFBN0IsQ0FBRCxHQUF1QyxHQUEvQztBQUNEO0FBQ0Q7QUFDQSxNQUFJNzFCLEdBQUdxc0MsVUFBUCxFQUFtQjtBQUNqQjk5QyxZQUFRLFVBQVd5UixHQUFHcXNDLFVBQWQsR0FBNEIsR0FBcEM7QUFDRDtBQUNEO0FBQ0EsTUFBSXJzQyxHQUFHdWQsV0FBUCxFQUFvQjtBQUNsQmh2QixZQUFTNmpELGVBQWVweUMsR0FBR3VkLFdBQWxCLENBQUQsR0FBbUMsR0FBM0M7QUFDRDtBQUNEO0FBQ0EsTUFBSXZkLEdBQUdnakIsS0FBUCxFQUFjO0FBQ1p6MEIsWUFBUSxrQkFBbUJ5UixHQUFHZ2pCLEtBQUgsQ0FBU24yQixLQUE1QixHQUFxQyxZQUFyQyxHQUFxRG1ULEdBQUdnakIsS0FBSCxDQUFTeUIsUUFBOUQsR0FBMEUsY0FBMUUsR0FBNEZ6a0IsR0FBR2dqQixLQUFILENBQVN4RSxVQUFyRyxHQUFtSCxJQUEzSDtBQUNEO0FBQ0Q7QUFDQSxNQUFJeGUsR0FBRzJqQixjQUFQLEVBQXVCO0FBQ3JCLFFBQUlBLGlCQUFpQjB1QixrQkFBa0JyeUMsRUFBbEIsQ0FBckI7QUFDQSxRQUFJMmpCLGNBQUosRUFBb0I7QUFDbEJwMUIsY0FBUW8xQixpQkFBaUIsR0FBekI7QUFDRDtBQUNGO0FBQ0RwMUIsU0FBT0EsS0FBS21DLE9BQUwsQ0FBYSxJQUFiLEVBQW1CLEVBQW5CLElBQXlCLEdBQWhDO0FBQ0E7QUFDQSxNQUFJc1AsR0FBR2t3QyxRQUFQLEVBQWlCO0FBQ2YzaEQsV0FBT3lSLEdBQUdrd0MsUUFBSCxDQUFZM2hELElBQVosQ0FBUDtBQUNEO0FBQ0QsU0FBT0EsSUFBUDtBQUNEOztBQUVELFNBQVMyakQsYUFBVCxDQUF3Qmx5QyxFQUF4QixFQUE0QjtBQUMxQixNQUFJK1QsT0FBTy9ULEdBQUdnVSxVQUFkO0FBQ0EsTUFBSSxDQUFDRCxJQUFMLEVBQVc7QUFBRTtBQUFRO0FBQ3JCLE1BQUkzaUIsTUFBTSxjQUFWO0FBQ0EsTUFBSWtoRCxhQUFhLEtBQWpCO0FBQ0EsTUFBSTFuRCxDQUFKLEVBQU8yZSxDQUFQLEVBQVVuZCxHQUFWLEVBQWVtbUQsV0FBZjtBQUNBLE9BQUszbkQsSUFBSSxDQUFKLEVBQU8yZSxJQUFJd0ssS0FBSzdwQixNQUFyQixFQUE2QlUsSUFBSTJlLENBQWpDLEVBQW9DM2UsR0FBcEMsRUFBeUM7QUFDdkN3QixVQUFNMm5CLEtBQUtucEIsQ0FBTCxDQUFOO0FBQ0EybkQsa0JBQWMsSUFBZDtBQUNBLFFBQUlDLE1BQU1oQyxxQkFBcUJwa0QsSUFBSUgsSUFBekIsS0FBa0Nra0QsZUFBZS9qRCxJQUFJSCxJQUFuQixDQUE1QztBQUNBLFFBQUl1bUQsR0FBSixFQUFTO0FBQ1A7QUFDQTtBQUNBRCxvQkFBYyxDQUFDLENBQUNDLElBQUl4eUMsRUFBSixFQUFRNVQsR0FBUixFQUFhaWtELE1BQWIsQ0FBaEI7QUFDRDtBQUNELFFBQUlrQyxXQUFKLEVBQWlCO0FBQ2ZELG1CQUFhLElBQWI7QUFDQWxoRCxhQUFPLGFBQWNoRixJQUFJSCxJQUFsQixHQUEwQixlQUExQixHQUE2Q0csSUFBSW1uQyxPQUFqRCxHQUE0RCxJQUE1RCxJQUFvRW5uQyxJQUFJUyxLQUFKLEdBQWEsYUFBY1QsSUFBSVMsS0FBbEIsR0FBMkIsZUFBM0IsR0FBOENtUCxLQUFLQyxTQUFMLENBQWU3UCxJQUFJUyxLQUFuQixDQUEzRCxHQUF5RixFQUE3SixLQUFvS1QsSUFBSW9wQyxHQUFKLEdBQVcsWUFBYXBwQyxJQUFJb3BDLEdBQWpCLEdBQXdCLElBQW5DLEdBQTJDLEVBQS9NLEtBQXNOcHBDLElBQUlpbkMsU0FBSixHQUFpQixnQkFBaUJyM0IsS0FBS0MsU0FBTCxDQUFlN1AsSUFBSWluQyxTQUFuQixDQUFsQyxHQUFvRSxFQUExUixJQUFnUyxJQUF2UztBQUNEO0FBQ0Y7QUFDRCxNQUFJaWYsVUFBSixFQUFnQjtBQUNkLFdBQU9saEQsSUFBSWUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsSUFBbUIsR0FBMUI7QUFDRDtBQUNGOztBQUVELFNBQVNrZ0QsaUJBQVQsQ0FBNEJyeUMsRUFBNUIsRUFBZ0M7QUFDOUIsTUFBSTZ3QyxNQUFNN3dDLEdBQUczUixRQUFILENBQVksQ0FBWixDQUFWO0FBQ0EsTUFBSXhGLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLEtBQ0Y4TyxHQUFHM1IsUUFBSCxDQUFZbkUsTUFBWixHQUFxQixDQUFyQixJQUEwQjJtRCxJQUFJN2lELElBQUosS0FBYSxDQURyQyxDQUFKLEVBRUc7QUFDRHFpRCxXQUFPLGlFQUFQO0FBQ0Q7QUFDRCxNQUFJUSxJQUFJN2lELElBQUosS0FBYSxDQUFqQixFQUFvQjtBQUNsQixRQUFJeWtELGtCQUFrQjdCLFNBQVNDLEdBQVQsRUFBY0YsY0FBZCxDQUF0QjtBQUNBLFdBQVEsdUNBQXdDOEIsZ0JBQWdCdmtELE1BQXhELEdBQWtFLHFCQUFsRSxHQUEyRnVrRCxnQkFBZ0I3dUIsZUFBaEIsQ0FBZ0MzeEIsR0FBaEMsQ0FBb0MsVUFBVXNtQyxJQUFWLEVBQWdCO0FBQUUsYUFBUSxnQkFBZ0JBLElBQWhCLEdBQXVCLEdBQS9CO0FBQXNDLEtBQTVGLEVBQThGM21DLElBQTlGLENBQW1HLEdBQW5HLENBQTNGLEdBQXNNLElBQTlNO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTd2dELGNBQVQsQ0FBeUJ6M0IsS0FBekIsRUFBZ0M7QUFDOUIsU0FBUSxxQkFBc0JodUIsT0FBT3FGLElBQVAsQ0FBWTJvQixLQUFaLEVBQW1CMW9CLEdBQW5CLENBQXVCLFVBQVVkLEdBQVYsRUFBZTtBQUFFLFdBQU91aEQsY0FBY3ZoRCxHQUFkLEVBQW1Cd3BCLE1BQU14cEIsR0FBTixDQUFuQixDQUFQO0FBQXdDLEdBQWhGLEVBQWtGUyxJQUFsRixDQUF1RixHQUF2RixDQUF0QixHQUFxSCxJQUE3SDtBQUNEOztBQUVELFNBQVM4Z0QsYUFBVCxDQUF3QnZoRCxHQUF4QixFQUE2QjZPLEVBQTdCLEVBQWlDO0FBQy9CLFNBQU8sTUFBTTdPLEdBQU4sR0FBWSxZQUFaLEdBQTRCbEQsT0FBTytSLEdBQUdvMkIsUUFBSCxDQUFZdWMsS0FBbkIsQ0FBNUIsR0FBeUQsSUFBekQsR0FDTCxTQURLLElBQ1EzeUMsR0FBRzNMLEdBQUgsS0FBVyxVQUFYLEdBQ1RxOUMsWUFBWTF4QyxFQUFaLEtBQW1CLFFBRFYsR0FFVGl4QyxXQUFXanhDLEVBQVgsQ0FIQyxJQUdpQixJQUh4QjtBQUlEOztBQUVELFNBQVMweEMsV0FBVCxDQUFzQjF4QyxFQUF0QixFQUEwQjR5QyxTQUExQixFQUFxQztBQUNuQyxNQUFJdmtELFdBQVcyUixHQUFHM1IsUUFBbEI7QUFDQSxNQUFJQSxTQUFTbkUsTUFBYixFQUFxQjtBQUNuQixRQUFJMm9ELE9BQU94a0QsU0FBUyxDQUFULENBQVg7QUFDQTtBQUNBLFFBQUlBLFNBQVNuRSxNQUFULEtBQW9CLENBQXBCLElBQ0Eyb0QsS0FBS25HLEdBREwsSUFFQW1HLEtBQUt4K0MsR0FBTCxLQUFhLFVBRmIsSUFHQXcrQyxLQUFLeCtDLEdBQUwsS0FBYSxNQUhqQixFQUd5QjtBQUN2QixhQUFPNDhDLFdBQVc0QixJQUFYLENBQVA7QUFDRDtBQUNELFFBQUlqdUIsb0JBQW9CZ3VCLFlBQVlFLHFCQUFxQnprRCxRQUFyQixDQUFaLEdBQTZDLENBQXJFO0FBQ0EsV0FBUSxNQUFPQSxTQUFTNEQsR0FBVCxDQUFhOGdELE9BQWIsRUFBc0JuaEQsSUFBdEIsQ0FBMkIsR0FBM0IsQ0FBUCxHQUEwQyxHQUExQyxJQUFpRGd6QixvQkFBcUIsTUFBTUEsaUJBQTNCLEdBQWdELEVBQWpHLENBQVI7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2t1QixvQkFBVCxDQUErQnprRCxRQUEvQixFQUF5QztBQUN2QyxNQUFJK0MsTUFBTSxDQUFWO0FBQ0EsT0FBSyxJQUFJeEcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUQsU0FBU25FLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QyxRQUFJb1YsS0FBSzNSLFNBQVN6RCxDQUFULENBQVQ7QUFDQSxRQUFJb1YsR0FBR2hTLElBQUgsS0FBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsUUFBSWdsRCxtQkFBbUJoekMsRUFBbkIsS0FDQ0EsR0FBRytzQyxZQUFILElBQW1CL3NDLEdBQUcrc0MsWUFBSCxDQUFnQjl6QyxJQUFoQixDQUFxQixVQUFVOUksQ0FBVixFQUFhO0FBQUUsYUFBTzZpRCxtQkFBbUI3aUQsRUFBRSs3QyxLQUFyQixDQUFQO0FBQXFDLEtBQXpFLENBRHhCLEVBQ3FHO0FBQ25HOTZDLFlBQU0sQ0FBTjtBQUNBO0FBQ0Q7QUFDRCxRQUFJNmdELGVBQWVqeUMsRUFBZixLQUNDQSxHQUFHK3NDLFlBQUgsSUFBbUIvc0MsR0FBRytzQyxZQUFILENBQWdCOXpDLElBQWhCLENBQXFCLFVBQVU5SSxDQUFWLEVBQWE7QUFBRSxhQUFPOGhELGVBQWU5aEQsRUFBRSs3QyxLQUFqQixDQUFQO0FBQWlDLEtBQXJFLENBRHhCLEVBQ2lHO0FBQy9GOTZDLFlBQU0sQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzRoRCxrQkFBVCxDQUE2Qmh6QyxFQUE3QixFQUFpQztBQUMvQixTQUFPQSxHQUFHMHNDLEdBQUgsS0FBVzk4QyxTQUFYLElBQXdCb1EsR0FBRzNMLEdBQUgsS0FBVyxVQUFuQyxJQUFpRDJMLEdBQUczTCxHQUFILEtBQVcsTUFBbkU7QUFDRDs7QUFFRCxTQUFTNDlDLGNBQVQsQ0FBeUJqeUMsRUFBekIsRUFBNkI7QUFDM0IsU0FBTyxDQUFDeXdDLHdCQUF3Qnp3QyxHQUFHM0wsR0FBM0IsQ0FBUjtBQUNEOztBQUVELFNBQVMwK0MsT0FBVCxDQUFrQmg3QixJQUFsQixFQUF3QjtBQUN0QixNQUFJQSxLQUFLL3BCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixXQUFPaWpELFdBQVdsNUIsSUFBWCxDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT2s3QixRQUFRbDdCLElBQVIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2s3QixPQUFULENBQWtCOTdCLElBQWxCLEVBQXdCO0FBQ3RCLFNBQVEsU0FBU0EsS0FBS25wQixJQUFMLEtBQWMsQ0FBZCxHQUNibXBCLEtBQUtxSCxVQURRLENBQ0c7QUFESCxJQUViMDBCLHlCQUF5QmwzQyxLQUFLQyxTQUFMLENBQWVrYixLQUFLQSxJQUFwQixDQUF6QixDQUZJLElBRW1ELEdBRjNEO0FBR0Q7O0FBRUQsU0FBU3c2QixPQUFULENBQWtCM3hDLEVBQWxCLEVBQXNCO0FBQ3BCLE1BQUlndEMsV0FBV2h0QyxHQUFHZ3RDLFFBQUgsSUFBZSxXQUE5QjtBQUNBLE1BQUkzK0MsV0FBV3FqRCxZQUFZMXhDLEVBQVosQ0FBZjtBQUNBLE1BQUk1TyxNQUFNLFFBQVE0N0MsUUFBUixJQUFvQjMrQyxXQUFZLE1BQU1BLFFBQWxCLEdBQThCLEVBQWxELENBQVY7QUFDQSxNQUFJbUgsUUFBUXdLLEdBQUd4SyxLQUFILElBQWEsTUFBT3dLLEdBQUd4SyxLQUFILENBQVN2RCxHQUFULENBQWEsVUFBVW9CLENBQVYsRUFBYTtBQUFFLFdBQVM0VixTQUFTNVYsRUFBRXBILElBQVgsQ0FBRCxHQUFxQixHQUFyQixHQUE0Qm9ILEVBQUV4RyxLQUF0QztBQUFnRCxHQUE1RSxFQUE4RStFLElBQTlFLENBQW1GLEdBQW5GLENBQVAsR0FBa0csR0FBM0g7QUFDQSxNQUFJdWhELFVBQVVuekMsR0FBR28yQixRQUFILENBQVksUUFBWixDQUFkO0FBQ0EsTUFBSSxDQUFDNWdDLFNBQVMyOUMsT0FBVixLQUFzQixDQUFDOWtELFFBQTNCLEVBQXFDO0FBQ25DK0MsV0FBTyxPQUFQO0FBQ0Q7QUFDRCxNQUFJb0UsS0FBSixFQUFXO0FBQ1RwRSxXQUFPLE1BQU1vRSxLQUFiO0FBQ0Q7QUFDRCxNQUFJMjlDLE9BQUosRUFBYTtBQUNYL2hELFdBQU8sQ0FBQ29FLFFBQVEsRUFBUixHQUFhLE9BQWQsSUFBeUIsR0FBekIsR0FBK0IyOUMsT0FBdEM7QUFDRDtBQUNELFNBQU8vaEQsTUFBTSxHQUFiO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTd2dELFlBQVQsQ0FBdUJ3QixhQUF2QixFQUFzQ3B6QyxFQUF0QyxFQUEwQztBQUN4QyxNQUFJM1IsV0FBVzJSLEdBQUcyakIsY0FBSCxHQUFvQixJQUFwQixHQUEyQit0QixZQUFZMXhDLEVBQVosRUFBZ0IsSUFBaEIsQ0FBMUM7QUFDQSxTQUFRLFFBQVFvekMsYUFBUixHQUF3QixHQUF4QixHQUErQnZCLFFBQVE3eEMsRUFBUixDQUEvQixJQUErQzNSLFdBQVksTUFBTUEsUUFBbEIsR0FBOEIsRUFBN0UsSUFBbUYsR0FBM0Y7QUFDRDs7QUFFRCxTQUFTOGpELFFBQVQsQ0FBbUJwa0QsS0FBbkIsRUFBMEI7QUFDeEIsTUFBSXFELE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSXhHLElBQUksQ0FBYixFQUFnQkEsSUFBSW1ELE1BQU03RCxNQUExQixFQUFrQ1UsR0FBbEMsRUFBdUM7QUFDckMsUUFBSW1xQixPQUFPaG5CLE1BQU1uRCxDQUFOLENBQVg7QUFDQXdHLFdBQU8sT0FBUTJqQixLQUFLOW9CLElBQWIsR0FBcUIsS0FBckIsR0FBOEJpbkQseUJBQXlCbitCLEtBQUtsb0IsS0FBOUIsQ0FBOUIsR0FBc0UsR0FBN0U7QUFDRDtBQUNELFNBQU91RSxJQUFJZSxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTK2dELHdCQUFULENBQW1DLzdCLElBQW5DLEVBQXlDO0FBQ3ZDLFNBQU9BLEtBQ0p6bUIsT0FESSxDQUNJLFNBREosRUFDZSxTQURmLEVBRUpBLE9BRkksQ0FFSSxTQUZKLEVBRWUsU0FGZixDQUFQO0FBR0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLElBQUkyaUQsc0JBQXNCLElBQUluNUMsTUFBSixDQUFXLFFBQVEsQ0FDM0MsNEVBQ0EscUVBREEsR0FFQSxzREFIMkMsRUFJM0M1SSxLQUoyQyxDQUlyQyxHQUpxQyxFQUloQ00sSUFKZ0MsQ0FJM0IsU0FKMkIsQ0FBUixHQUlOLEtBSkwsQ0FBMUI7O0FBTUE7QUFDQSxJQUFJMGhELG1CQUFtQixJQUFJcDVDLE1BQUosQ0FBVyxRQUNoQyxvQkFEd0MsQ0FFeEM1SSxLQUZ3QyxDQUVsQyxHQUZrQyxFQUU3Qk0sSUFGNkIsQ0FFeEIsdUJBRndCLENBQVIsR0FFVyxtQkFGdEIsQ0FBdkI7O0FBSUE7QUFDQSxJQUFJMmhELFVBQVUsa0JBQWQ7O0FBRUE7QUFDQSxJQUFJQyxnQkFBZ0IsZ0dBQXBCOztBQUVBO0FBQ0EsU0FBU0MsWUFBVCxDQUF1QjVDLEdBQXZCLEVBQTRCO0FBQzFCLE1BQUk2QyxTQUFTLEVBQWI7QUFDQSxNQUFJN0MsR0FBSixFQUFTO0FBQ1A4QyxjQUFVOUMsR0FBVixFQUFlNkMsTUFBZjtBQUNEO0FBQ0QsU0FBT0EsTUFBUDtBQUNEOztBQUVELFNBQVNDLFNBQVQsQ0FBb0I1N0IsSUFBcEIsRUFBMEIyN0IsTUFBMUIsRUFBa0M7QUFDaEMsTUFBSTM3QixLQUFLL3BCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixTQUFLLElBQUkvQixJQUFULElBQWlCOHJCLEtBQUtxZSxRQUF0QixFQUFnQztBQUM5QixVQUFJb1QsTUFBTWp6QyxJQUFOLENBQVd0SyxJQUFYLENBQUosRUFBc0I7QUFDcEIsWUFBSVksUUFBUWtyQixLQUFLcWUsUUFBTCxDQUFjbnFDLElBQWQsQ0FBWjtBQUNBLFlBQUlZLEtBQUosRUFBVztBQUNULGNBQUlaLFNBQVMsT0FBYixFQUFzQjtBQUNwQjJuRCxxQkFBUzc3QixJQUFULEVBQWdCLGFBQWFsckIsS0FBYixHQUFxQixJQUFyQyxFQUE0QzZtRCxNQUE1QztBQUNELFdBRkQsTUFFTyxJQUFJbkssS0FBS2h6QyxJQUFMLENBQVV0SyxJQUFWLENBQUosRUFBcUI7QUFDMUI0bkQsdUJBQVdobkQsS0FBWCxFQUFtQlosT0FBTyxLQUFQLEdBQWVZLEtBQWYsR0FBdUIsSUFBMUMsRUFBaUQ2bUQsTUFBakQ7QUFDRCxXQUZNLE1BRUE7QUFDTEksNEJBQWdCam5ELEtBQWhCLEVBQXdCWixPQUFPLEtBQVAsR0FBZVksS0FBZixHQUF1QixJQUEvQyxFQUFzRDZtRCxNQUF0RDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsUUFBSTM3QixLQUFLMXBCLFFBQVQsRUFBbUI7QUFDakIsV0FBSyxJQUFJekQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbXRCLEtBQUsxcEIsUUFBTCxDQUFjbkUsTUFBbEMsRUFBMENVLEdBQTFDLEVBQStDO0FBQzdDK29ELGtCQUFVNTdCLEtBQUsxcEIsUUFBTCxDQUFjekQsQ0FBZCxDQUFWLEVBQTRCOG9ELE1BQTVCO0FBQ0Q7QUFDRjtBQUNGLEdBcEJELE1Bb0JPLElBQUkzN0IsS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDMUI4bEQsb0JBQWdCLzdCLEtBQUt5RyxVQUFyQixFQUFpQ3pHLEtBQUtaLElBQXRDLEVBQTRDdThCLE1BQTVDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRyxVQUFULENBQXFCdGYsR0FBckIsRUFBMEJwZCxJQUExQixFQUFnQ3U4QixNQUFoQyxFQUF3QztBQUN0QyxNQUFJSyxlQUFleGYsSUFBSTdqQyxPQUFKLENBQVk4aUQsYUFBWixFQUEyQixFQUEzQixFQUErQjkyQyxLQUEvQixDQUFxQzQyQyxnQkFBckMsQ0FBbkI7QUFDQSxNQUFJUyxZQUFKLEVBQWtCO0FBQ2hCTCxXQUFPN29ELElBQVAsQ0FDRSw2REFDQSxJQURBLEdBQ1FrcEQsYUFBYSxDQUFiLENBRFIsR0FDMkIsbUJBRDNCLEdBQ2tENThCLEtBQUs5bEIsSUFBTCxFQUZwRDtBQUlEO0FBQ0R5aUQsa0JBQWdCdmYsR0FBaEIsRUFBcUJwZCxJQUFyQixFQUEyQnU4QixNQUEzQjtBQUNEOztBQUVELFNBQVNFLFFBQVQsQ0FBbUI3N0IsSUFBbkIsRUFBeUJaLElBQXpCLEVBQStCdThCLE1BQS9CLEVBQXVDO0FBQ3JDSSxrQkFBZ0IvN0IsS0FBSzIwQixHQUFMLElBQVksRUFBNUIsRUFBZ0N2MUIsSUFBaEMsRUFBc0N1OEIsTUFBdEM7QUFDQU0sa0JBQWdCajhCLEtBQUs1ZSxLQUFyQixFQUE0QixhQUE1QixFQUEyQ2dlLElBQTNDLEVBQWlEdThCLE1BQWpEO0FBQ0FNLGtCQUFnQmo4QixLQUFLNjBCLFNBQXJCLEVBQWdDLGdCQUFoQyxFQUFrRHoxQixJQUFsRCxFQUF3RHU4QixNQUF4RDtBQUNBTSxrQkFBZ0JqOEIsS0FBSzgwQixTQUFyQixFQUFnQyxnQkFBaEMsRUFBa0QxMUIsSUFBbEQsRUFBd0R1OEIsTUFBeEQ7QUFDRDs7QUFFRCxTQUFTTSxlQUFULENBQTBCQyxLQUExQixFQUFpQ2ptRCxJQUFqQyxFQUF1Q21wQixJQUF2QyxFQUE2Q3U4QixNQUE3QyxFQUFxRDtBQUNuRCxNQUFJLE9BQU9PLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsQ0FBQ1YsUUFBUWg5QyxJQUFSLENBQWEwOUMsS0FBYixDQUFsQyxFQUF1RDtBQUNyRFAsV0FBTzdvRCxJQUFQLENBQWEsYUFBYW1ELElBQWIsR0FBb0IsS0FBcEIsR0FBNEJpbUQsS0FBNUIsR0FBb0Msb0JBQXBDLEdBQTREOThCLEtBQUs5bEIsSUFBTCxFQUF6RTtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3lpRCxlQUFULENBQTBCdmYsR0FBMUIsRUFBK0JwZCxJQUEvQixFQUFxQ3U4QixNQUFyQyxFQUE2QztBQUMzQyxNQUFJO0FBQ0YsUUFBSVEsUUFBSixDQUFjLFlBQVkzZixHQUExQjtBQUNELEdBRkQsQ0FFRSxPQUFPanJDLENBQVAsRUFBVTtBQUNWLFFBQUl5cUQsZUFBZXhmLElBQUk3akMsT0FBSixDQUFZOGlELGFBQVosRUFBMkIsRUFBM0IsRUFBK0I5MkMsS0FBL0IsQ0FBcUMyMkMsbUJBQXJDLENBQW5CO0FBQ0EsUUFBSVUsWUFBSixFQUFrQjtBQUNoQkwsYUFBTzdvRCxJQUFQLENBQ0Usc0RBQ0EsSUFEQSxHQUNRa3BELGFBQWEsQ0FBYixDQURSLEdBQzJCLG1CQUQzQixHQUNrRDU4QixLQUFLOWxCLElBQUwsRUFGcEQ7QUFJRCxLQUxELE1BS087QUFDTHFpRCxhQUFPN29ELElBQVAsQ0FBYSx5QkFBMEJzc0IsS0FBSzlsQixJQUFMLEVBQXZDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBLFNBQVM4aUQsV0FBVCxDQUNFNW1ELFFBREYsRUFFRTBILE9BRkYsRUFHRTtBQUNBLE1BQUk0N0MsTUFBTW4zQyxNQUFNbk0sU0FBUzhELElBQVQsRUFBTixFQUF1QjRELE9BQXZCLENBQVY7QUFDQTY0QyxXQUFTK0MsR0FBVCxFQUFjNTdDLE9BQWQ7QUFDQSxNQUFJc2pDLE9BQU9xWSxTQUFTQyxHQUFULEVBQWM1N0MsT0FBZCxDQUFYO0FBQ0EsU0FBTztBQUNMNDdDLFNBQUtBLEdBREE7QUFFTDNpRCxZQUFRcXFDLEtBQUtycUMsTUFGUjtBQUdMMDFCLHFCQUFpQjJVLEtBQUszVTtBQUhqQixHQUFQO0FBS0Q7O0FBRUQsU0FBU3d3QixZQUFULENBQXVCN2IsSUFBdkIsRUFBNkJtYixNQUE3QixFQUFxQztBQUNuQyxNQUFJO0FBQ0YsV0FBTyxJQUFJUSxRQUFKLENBQWEzYixJQUFiLENBQVA7QUFDRCxHQUZELENBRUUsT0FBT2hyQixHQUFQLEVBQVk7QUFDWm1tQyxXQUFPN29ELElBQVAsQ0FBWSxFQUFFMGlCLEtBQUtBLEdBQVAsRUFBWWdyQixNQUFNQSxJQUFsQixFQUFaO0FBQ0EsV0FBTy9zQyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNm9ELGNBQVQsQ0FBeUJDLFdBQXpCLEVBQXNDO0FBQ3BDLE1BQUlDLHVCQUF1QjVuRCxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBM0I7O0FBRUEsV0FBU2tCLE9BQVQsQ0FDRXJNLFFBREYsRUFFRTBILE9BRkYsRUFHRTtBQUNBLFFBQUl1L0MsZUFBZTduRCxPQUFPK0wsTUFBUCxDQUFjNDdDLFdBQWQsQ0FBbkI7QUFDQSxRQUFJWixTQUFTLEVBQWI7QUFDQSxRQUFJZSxPQUFPLEVBQVg7QUFDQUQsaUJBQWE3bUQsSUFBYixHQUFvQixVQUFVbWhCLEdBQVYsRUFBZTRsQyxNQUFmLEVBQXVCO0FBQ3pDLE9BQUNBLFNBQVNELElBQVQsR0FBZ0JmLE1BQWpCLEVBQXlCN29ELElBQXpCLENBQThCaWtCLEdBQTlCO0FBQ0QsS0FGRDs7QUFJQSxRQUFJN1osT0FBSixFQUFhO0FBQ1g7QUFDQSxVQUFJQSxRQUFRa1YsT0FBWixFQUFxQjtBQUNuQnFxQyxxQkFBYXJxQyxPQUFiLEdBQXVCLENBQUNtcUMsWUFBWW5xQyxPQUFaLElBQXVCLEVBQXhCLEVBQTRCaGdCLE1BQTVCLENBQW1DOEssUUFBUWtWLE9BQTNDLENBQXZCO0FBQ0Q7QUFDRDtBQUNBLFVBQUlsVixRQUFRK2UsVUFBWixFQUF3QjtBQUN0QndnQyxxQkFBYXhnQyxVQUFiLEdBQTBCcGUsT0FDeEJqSixPQUFPK0wsTUFBUCxDQUFjNDdDLFlBQVl0Z0MsVUFBMUIsQ0FEd0IsRUFFeEIvZSxRQUFRK2UsVUFGZ0IsQ0FBMUI7QUFJRDtBQUNEO0FBQ0EsV0FBSyxJQUFJN2lCLEdBQVQsSUFBZ0I4RCxPQUFoQixFQUF5QjtBQUN2QixZQUFJOUQsUUFBUSxTQUFSLElBQXFCQSxRQUFRLFlBQWpDLEVBQStDO0FBQzdDcWpELHVCQUFhcmpELEdBQWIsSUFBb0I4RCxRQUFROUQsR0FBUixDQUFwQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJd2pELFdBQVdSLFlBQVk1bUQsUUFBWixFQUFzQmluRCxZQUF0QixDQUFmO0FBQ0EsUUFBSTNyRCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3dpRCxhQUFPN29ELElBQVAsQ0FBWUksS0FBWixDQUFrQnlvRCxNQUFsQixFQUEwQkQsYUFBYWtCLFNBQVM5RCxHQUF0QixDQUExQjtBQUNEO0FBQ0Q4RCxhQUFTakIsTUFBVCxHQUFrQkEsTUFBbEI7QUFDQWlCLGFBQVNGLElBQVQsR0FBZ0JBLElBQWhCO0FBQ0EsV0FBT0UsUUFBUDtBQUNEOztBQUVELFdBQVNDLGtCQUFULENBQ0VybkQsUUFERixFQUVFMEgsT0FGRixFQUdFOFosRUFIRixFQUlFO0FBQ0E5WixjQUFVQSxXQUFXLEVBQXJCOztBQUVBO0FBQ0EsUUFBSXBNLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0EsVUFBSTtBQUNGLFlBQUlnakQsUUFBSixDQUFhLFVBQWI7QUFDRCxPQUZELENBRUUsT0FBTzVxRCxDQUFQLEVBQVU7QUFDVixZQUFJQSxFQUFFK0csUUFBRixHQUFhcU0sS0FBYixDQUFtQixpQkFBbkIsQ0FBSixFQUEyQztBQUN6Qy9PLGVBQ0UsaUVBQ0EsdUVBREEsR0FFQSxrRUFGQSxHQUdBLGlFQUhBLEdBSUEsa0NBTEY7QUFPRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxRQUFJd0QsTUFBTThELFFBQVFnMEMsVUFBUixHQUNOaDdDLE9BQU9nSCxRQUFRZzBDLFVBQWYsSUFBNkIxN0MsUUFEdkIsR0FFTkEsUUFGSjtBQUdBLFFBQUlnbkQscUJBQXFCcGpELEdBQXJCLENBQUosRUFBK0I7QUFDN0IsYUFBT29qRCxxQkFBcUJwakQsR0FBckIsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsUUFBSXdqRCxXQUFXLzZDLFFBQVFyTSxRQUFSLEVBQWtCMEgsT0FBbEIsQ0FBZjs7QUFFQTtBQUNBLFFBQUlwTSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJeWpELFNBQVNqQixNQUFULElBQW1CaUIsU0FBU2pCLE1BQVQsQ0FBZ0J4cEQsTUFBdkMsRUFBK0M7QUFDN0N5RCxhQUNFLGtDQUFrQ0osUUFBbEMsR0FBNkMsTUFBN0MsR0FDQW9uRCxTQUFTakIsTUFBVCxDQUFnQnpoRCxHQUFoQixDQUFvQixVQUFVM0ksQ0FBVixFQUFhO0FBQUUsaUJBQVEsT0FBT0EsQ0FBZjtBQUFvQixTQUF2RCxFQUF5RHNJLElBQXpELENBQThELElBQTlELENBREEsR0FDc0UsSUFGeEUsRUFHRW1kLEVBSEY7QUFLRDtBQUNELFVBQUk0bEMsU0FBU0YsSUFBVCxJQUFpQkUsU0FBU0YsSUFBVCxDQUFjdnFELE1BQW5DLEVBQTJDO0FBQ3pDeXFELGlCQUFTRixJQUFULENBQWNsakQsT0FBZCxDQUFzQixVQUFVdWQsR0FBVixFQUFlO0FBQUUsaUJBQU9MLElBQUlLLEdBQUosRUFBU0MsRUFBVCxDQUFQO0FBQXNCLFNBQTdEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFFBQUkzZCxNQUFNLEVBQVY7QUFDQSxRQUFJeWpELGNBQWMsRUFBbEI7QUFDQXpqRCxRQUFJbEQsTUFBSixHQUFha21ELGFBQWFPLFNBQVN6bUQsTUFBdEIsRUFBOEIybUQsV0FBOUIsQ0FBYjtBQUNBLFFBQUl0ckMsSUFBSW9yQyxTQUFTL3dCLGVBQVQsQ0FBeUIxNUIsTUFBakM7QUFDQWtILFFBQUl3eUIsZUFBSixHQUFzQixJQUFJbDVCLEtBQUosQ0FBVTZlLENBQVYsQ0FBdEI7QUFDQSxTQUFLLElBQUkzZSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyZSxDQUFwQixFQUF1QjNlLEdBQXZCLEVBQTRCO0FBQzFCd0csVUFBSXd5QixlQUFKLENBQW9CaDVCLENBQXBCLElBQXlCd3BELGFBQWFPLFNBQVMvd0IsZUFBVCxDQUF5Qmg1QixDQUF6QixDQUFiLEVBQTBDaXFELFdBQTFDLENBQXpCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJaHNELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUksQ0FBQyxDQUFDeWpELFNBQVNqQixNQUFWLElBQW9CLENBQUNpQixTQUFTakIsTUFBVCxDQUFnQnhwRCxNQUF0QyxLQUFpRDJxRCxZQUFZM3FELE1BQWpFLEVBQXlFO0FBQ3ZFeUQsYUFDRSw0Q0FDQWtuRCxZQUFZNWlELEdBQVosQ0FBZ0IsVUFBVTdELEdBQVYsRUFBZTtBQUM3QixjQUFJbWYsTUFBTW5mLElBQUltZixHQUFkO0FBQ0EsY0FBSWdyQixPQUFPbnFDLElBQUltcUMsSUFBZjs7QUFFQSxpQkFBU2hyQixJQUFJbGQsUUFBSixFQUFELEdBQW1CLFNBQW5CLEdBQStCa29DLElBQS9CLEdBQXNDLElBQTlDO0FBQ0gsU0FMQyxFQUtDM21DLElBTEQsQ0FLTSxJQUxOLENBRkYsRUFRRW1kLEVBUkY7QUFVRDtBQUNGOztBQUVELFdBQVF3bEMscUJBQXFCcGpELEdBQXJCLElBQTRCQyxHQUFwQztBQUNEOztBQUVELFNBQU87QUFDTHdJLGFBQVNBLE9BREo7QUFFTGc3Qyx3QkFBb0JBO0FBRmYsR0FBUDtBQUlEOztBQUVEOztBQUVBLFNBQVNFLGFBQVQsQ0FBd0I5MEMsRUFBeEIsRUFBNEIvSyxPQUE1QixFQUFxQztBQUNuQyxNQUFJdEgsT0FBT3NILFFBQVF0SCxJQUFSLElBQWdCd25DLFFBQTNCO0FBQ0EsTUFBSTdKLGNBQWM0SyxpQkFBaUJsMkIsRUFBakIsRUFBcUIsT0FBckIsQ0FBbEI7QUFDQSxNQUFJblgsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNvNkIsV0FBN0MsRUFBMEQ7QUFDeEQsUUFBSTlNLGFBQWE0cUIsVUFBVTlkLFdBQVYsRUFBdUJyMkIsUUFBUWcwQyxVQUEvQixDQUFqQjtBQUNBLFFBQUl6cUIsVUFBSixFQUFnQjtBQUNkN3dCLFdBQ0UsYUFBYTI5QixXQUFiLEdBQTJCLE1BQTNCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLDZEQUpGO0FBTUQ7QUFDRjtBQUNELE1BQUlBLFdBQUosRUFBaUI7QUFDZnRyQixPQUFHc3JCLFdBQUgsR0FBaUJ0dkIsS0FBS0MsU0FBTCxDQUFlcXZCLFdBQWYsQ0FBakI7QUFDRDtBQUNELE1BQUl5cEIsZUFBZWhmLGVBQWUvMUIsRUFBZixFQUFtQixPQUFuQixFQUE0QixLQUE1QixDQUFrQyxlQUFsQyxDQUFuQjtBQUNBLE1BQUkrMEMsWUFBSixFQUFrQjtBQUNoQi8wQyxPQUFHKzBDLFlBQUgsR0FBa0JBLFlBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxTQUFULENBQW9CaDFDLEVBQXBCLEVBQXdCO0FBQ3RCLE1BQUl6UixPQUFPLEVBQVg7QUFDQSxNQUFJeVIsR0FBR3NyQixXQUFQLEVBQW9CO0FBQ2xCLzhCLFlBQVEsaUJBQWtCeVIsR0FBR3NyQixXQUFyQixHQUFvQyxHQUE1QztBQUNEO0FBQ0QsTUFBSXRyQixHQUFHKzBDLFlBQVAsRUFBcUI7QUFDbkJ4bUQsWUFBUSxXQUFZeVIsR0FBRyswQyxZQUFmLEdBQStCLEdBQXZDO0FBQ0Q7QUFDRCxTQUFPeG1ELElBQVA7QUFDRDs7QUFFRCxJQUFJMG1ELFVBQVU7QUFDWjVxQyxjQUFZLENBQUMsYUFBRCxDQURBO0FBRVp5cUMsaUJBQWVBLGFBRkg7QUFHWmpELFdBQVNtRDtBQUhHLENBQWQ7O0FBTUE7O0FBRUEsU0FBU0UsZUFBVCxDQUEwQmwxQyxFQUExQixFQUE4Qi9LLE9BQTlCLEVBQXVDO0FBQ3JDLE1BQUl0SCxPQUFPc0gsUUFBUXRILElBQVIsSUFBZ0J3bkMsUUFBM0I7QUFDQSxNQUFJZ0YsY0FBY2pFLGlCQUFpQmwyQixFQUFqQixFQUFxQixPQUFyQixDQUFsQjtBQUNBLE1BQUltNkIsV0FBSixFQUFpQjtBQUNmO0FBQ0EsUUFBSXR4QyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJc3RCLGFBQWE0cUIsVUFBVWpQLFdBQVYsRUFBdUJsbEMsUUFBUWcwQyxVQUEvQixDQUFqQjtBQUNBLFVBQUl6cUIsVUFBSixFQUFnQjtBQUNkN3dCLGFBQ0UsYUFBYXdzQyxXQUFiLEdBQTJCLE1BQTNCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLDZEQUpGO0FBTUQ7QUFDRjtBQUNEbjZCLE9BQUdtNkIsV0FBSCxHQUFpQm4rQixLQUFLQyxTQUFMLENBQWUyOUIsZUFBZU8sV0FBZixDQUFmLENBQWpCO0FBQ0Q7O0FBRUQsTUFBSWdiLGVBQWVwZixlQUFlLzFCLEVBQWYsRUFBbUIsT0FBbkIsRUFBNEIsS0FBNUIsQ0FBa0MsZUFBbEMsQ0FBbkI7QUFDQSxNQUFJbTFDLFlBQUosRUFBa0I7QUFDaEJuMUMsT0FBR20xQyxZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsU0FBVCxDQUFvQnAxQyxFQUFwQixFQUF3QjtBQUN0QixNQUFJelIsT0FBTyxFQUFYO0FBQ0EsTUFBSXlSLEdBQUdtNkIsV0FBUCxFQUFvQjtBQUNsQjVyQyxZQUFRLGlCQUFrQnlSLEdBQUdtNkIsV0FBckIsR0FBb0MsR0FBNUM7QUFDRDtBQUNELE1BQUluNkIsR0FBR20xQyxZQUFQLEVBQXFCO0FBQ25CNW1ELFlBQVEsWUFBYXlSLEdBQUdtMUMsWUFBaEIsR0FBZ0MsSUFBeEM7QUFDRDtBQUNELFNBQU81bUQsSUFBUDtBQUNEOztBQUVELElBQUk4bUQsVUFBVTtBQUNaaHJDLGNBQVksQ0FBQyxhQUFELENBREE7QUFFWnlxQyxpQkFBZUksZUFGSDtBQUdackQsV0FBU3VEO0FBSEcsQ0FBZDs7QUFNQSxJQUFJRSxZQUFZLENBQ2RMLE9BRGMsRUFFZEksT0FGYyxDQUFoQjs7QUFLQTs7QUFFQSxTQUFTbCtCLElBQVQsQ0FBZW5YLEVBQWYsRUFBbUI1VCxHQUFuQixFQUF3QjtBQUN0QixNQUFJQSxJQUFJUyxLQUFSLEVBQWU7QUFDYndvQyxZQUFRcjFCLEVBQVIsRUFBWSxhQUFaLEVBQTRCLFFBQVM1VCxJQUFJUyxLQUFiLEdBQXNCLEdBQWxEO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxTQUFTazVDLElBQVQsQ0FBZS9sQyxFQUFmLEVBQW1CNVQsR0FBbkIsRUFBd0I7QUFDdEIsTUFBSUEsSUFBSVMsS0FBUixFQUFlO0FBQ2J3b0MsWUFBUXIxQixFQUFSLEVBQVksV0FBWixFQUEwQixRQUFTNVQsSUFBSVMsS0FBYixHQUFzQixHQUFoRDtBQUNEO0FBQ0Y7O0FBRUQsSUFBSTBvRCxlQUFlO0FBQ2pCdnlCLFNBQU9BLEtBRFU7QUFFakI3TCxRQUFNQSxJQUZXO0FBR2pCNHVCLFFBQU1BO0FBSFcsQ0FBbkI7O0FBTUE7O0FBRUEsSUFBSXVPLGNBQWM7QUFDaEJsTixjQUFZLElBREk7QUFFaEJqOUIsV0FBU21yQyxTQUZPO0FBR2hCdGhDLGNBQVl1aEMsWUFISTtBQUloQnhwQixZQUFVQSxRQUpNO0FBS2hCNFosY0FBWUEsVUFMSTtBQU1oQnY2QixlQUFhQSxXQU5HO0FBT2hCdzZCLG9CQUFrQkEsZ0JBUEY7QUFRaEI1NkIsaUJBQWVBLGFBUkM7QUFTaEJFLG1CQUFpQkEsZUFURDtBQVVoQmIsY0FBWUgsY0FBY29yQyxTQUFkO0FBVkksQ0FBbEI7O0FBYUEsSUFBSUUsUUFBUW5CLGVBQWVDLFdBQWYsQ0FBWjtBQUNBLElBQUlNLHFCQUFxQlksTUFBTVosa0JBQS9COztBQUVBOztBQUVBLElBQUlhLGVBQWUzc0MsT0FBTyxVQUFVMEcsRUFBVixFQUFjO0FBQ3RDLE1BQUl4UCxLQUFLbFAsTUFBTTBlLEVBQU4sQ0FBVDtBQUNBLFNBQU94UCxNQUFNQSxHQUFHeWxDLFNBQWhCO0FBQ0QsQ0FIa0IsQ0FBbkI7O0FBS0EsSUFBSWlRLFFBQVFyaEMsTUFBTXJwQixTQUFOLENBQWdCcTNCLE1BQTVCO0FBQ0FoTyxNQUFNcnBCLFNBQU4sQ0FBZ0JxM0IsTUFBaEIsR0FBeUIsVUFDdkJyaUIsRUFEdUIsRUFFdkI0YixTQUZ1QixFQUd2QjtBQUNBNWIsT0FBS0EsTUFBTWxQLE1BQU1rUCxFQUFOLENBQVg7O0FBRUE7QUFDQSxNQUFJQSxPQUFPQyxTQUFTbWtDLElBQWhCLElBQXdCcGtDLE9BQU9DLFNBQVNXLGVBQTVDLEVBQTZEO0FBQzNEL1gsWUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QywwRUFEdUMsQ0FBekM7QUFHQSxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJc0gsVUFBVSxLQUFLOEIsUUFBbkI7QUFDQTtBQUNBLE1BQUksQ0FBQzlCLFFBQVEvRyxNQUFiLEVBQXFCO0FBQ25CLFFBQUlYLFdBQVcwSCxRQUFRMUgsUUFBdkI7QUFDQSxRQUFJQSxRQUFKLEVBQWM7QUFDWixVQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaEMsWUFBSUEsU0FBU3FLLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBM0IsRUFBZ0M7QUFDOUJySyxxQkFBV2tvRCxhQUFhbG9ELFFBQWIsQ0FBWDtBQUNBO0FBQ0EsY0FBSTFFLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDLENBQUMzRCxRQUE5QyxFQUF3RDtBQUN0REksaUJBQ0csNkNBQThDc0gsUUFBUTFILFFBRHpELEVBRUUsSUFGRjtBQUlEO0FBQ0Y7QUFDRixPQVhELE1BV08sSUFBSUEsU0FBU3VrQyxRQUFiLEVBQXVCO0FBQzVCdmtDLG1CQUFXQSxTQUFTazRDLFNBQXBCO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsWUFBSTU4QyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3ZELGVBQUssNkJBQTZCSixRQUFsQyxFQUE0QyxJQUE1QztBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRixLQXBCRCxNQW9CTyxJQUFJeVMsRUFBSixFQUFRO0FBQ2J6UyxpQkFBV29vRCxhQUFhMzFDLEVBQWIsQ0FBWDtBQUNEO0FBQ0QsUUFBSXpTLFFBQUosRUFBYztBQUNaO0FBQ0EsVUFBSTFFLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDcEIsT0FBTzJSLFdBQWhELElBQStEa1YsSUFBbkUsRUFBeUU7QUFDdkVBLGFBQUssU0FBTDtBQUNEOztBQUVELFVBQUl2b0IsTUFBTXdtRCxtQkFBbUJybkQsUUFBbkIsRUFBNkI7QUFDckNtNEMsOEJBQXNCQSxvQkFEZTtBQUVyQ3VELG9CQUFZaDBDLFFBQVFnMEM7QUFGaUIsT0FBN0IsRUFHUCxJQUhPLENBQVY7QUFJQSxVQUFJLzZDLFNBQVNFLElBQUlGLE1BQWpCO0FBQ0EsVUFBSTAxQixrQkFBa0J4MUIsSUFBSXcxQixlQUExQjtBQUNBM3VCLGNBQVEvRyxNQUFSLEdBQWlCQSxNQUFqQjtBQUNBK0csY0FBUTJ1QixlQUFSLEdBQTBCQSxlQUExQjs7QUFFQTtBQUNBLFVBQUkvNkIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNwQixPQUFPMlIsV0FBaEQsSUFBK0RrVixJQUFuRSxFQUF5RTtBQUN2RUEsYUFBSyxhQUFMO0FBQ0FDLGdCQUFVLEtBQUtrRyxLQUFOLEdBQWUsVUFBeEIsRUFBcUMsU0FBckMsRUFBZ0QsYUFBaEQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPNDRCLE1BQU1oc0QsSUFBTixDQUFXLElBQVgsRUFBaUJzVyxFQUFqQixFQUFxQjRiLFNBQXJCLENBQVA7QUFDRCxDQWhFRDs7QUFrRUE7Ozs7QUFJQSxTQUFTKzVCLFlBQVQsQ0FBdUIzMUMsRUFBdkIsRUFBMkI7QUFDekIsTUFBSUEsR0FBRzQxQyxTQUFQLEVBQWtCO0FBQ2hCLFdBQU81MUMsR0FBRzQxQyxTQUFWO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSUMsWUFBWTUxQyxTQUFTdWpCLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQXF5QixjQUFVOW9CLFdBQVYsQ0FBc0Ivc0IsR0FBRytrQyxTQUFILENBQWEsSUFBYixDQUF0QjtBQUNBLFdBQU84USxVQUFVcFEsU0FBakI7QUFDRDtBQUNGOztBQUVEcHhCLE1BQU16YSxPQUFOLEdBQWdCZzdDLGtCQUFoQjs7QUFFQSwrREFBZXZnQyxLQUFmLEU7Ozs7Ozs7QUN6bFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpREFBaUQsSUFBSTtBQUNwSSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FDM0JBLElBQUl1eUIsQ0FBSjs7QUFFQTtBQUNBQSxJQUFLLFlBQVc7QUFDZixRQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEtBQUlBLEtBQUtzTixTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUU0QixJQUFILEVBQVMsTUFBVCxDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFNeHNELENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxPQUFPa08sTUFBUCxLQUFrQixRQUFyQixFQUNDb3ZDLElBQUlwdkMsTUFBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTFPLE9BQU9DLE9BQVAsR0FBaUI2OUMsQ0FBakIsQzs7Ozs7Ozs7O0FDcEJBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxjQUFJNytCLEdBQUo7QUFDQSxjQUFJQSxHQUFKOztBQUVBLE1BQU1ndUMsUUFBUSxFQUFFeG9ELFVBQVUsMkJBQVosRUFBZDtBQUNBLE1BQU15b0QsTUFBTSxFQUFFem9ELFVBQVUsa1FBQVosRUFBWjtBQUNBLE1BQU0wb0QsTUFBTSxFQUFFMW9ELFVBQVUsa1FBQVosRUFBWjtBQUNBLE1BQU0yb0QsTUFBTSxFQUFFM29ELFVBQVUsa1FBQVosRUFBWjs7QUFFQSxNQUFNcUgsU0FBUyx3QkFBYztBQUM1QjBELFNBQVEsQ0FDUCxFQUFFdEksTUFBTSxHQUFSLEVBQWErSSxVQUFVLFFBQXZCLEVBRE8sRUFFUDtBQUNDL0ksUUFBTSxRQURQO0FBRUMxQyxhQUFXeW9ELEtBRlo7QUFHQ25qRCxRQUFNO0FBQ0x1akQsZUFBWTtBQURQLEdBSFA7QUFNQzluRCxZQUFVLENBQ1Q7QUFDQzJCLFNBQU0sRUFEUDtBQUVDMUMsY0FBVzBvRDtBQUZaLEdBRFMsRUFLVDtBQUNDaG1ELFNBQU0sS0FEUDtBQUVDMUMsY0FBVzJvRCxHQUZaO0FBR0NyakQsU0FBTTtBQUNMdWpELGdCQUFZO0FBRFA7QUFIUCxHQUxTLEVBWVQ7QUFDQ25tRCxTQUFNLEtBRFA7QUFFQzFDLGNBQVc0b0QsR0FGWjtBQUdDdGpELFNBQU07QUFDTHVqRCxnQkFBWTtBQURQO0FBSFAsR0FaUztBQU5YLEVBRk87QUFEb0IsQ0FBZCxDQUFmOztBQWlDQSxrQkFBUTtBQUNQdmhELE9BRE87QUFFUDFGLGFBQVk7QUFDWGtuRDtBQURXLEVBRkw7QUFLUDdvRCxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7OztBQUxKLENBQVIsRUFzQkc4MEIsTUF0QkgsQ0FzQlUsTUF0QlYsRTs7Ozs7O0FDOUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xEQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0EsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiJhcHAuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOTg5ZTAwYjllOTFkNWQ5MDQyOTEiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGZhY3RvcnkoZXhwb3J0cyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIG1vZCA9IHtcblx0XHRcdGV4cG9ydHM6IHt9XG5cdFx0fTtcblx0XHRmYWN0b3J5KG1vZC5leHBvcnRzKTtcblx0XHRnbG9iYWwuaW5kZXggPSBtb2QuZXhwb3J0cztcblx0fVxufSkodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSB7XG5cdFx0aW5zdGFsbChWdWUpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblx0XHRcdFx0JGJyZWFkY3J1bWJzOiB7XG5cdFx0XHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuJHJvdXRlLm1hdGNoZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0VnVlLmNvbXBvbmVudCgnYnJlYWRjcnVtYnMnLCB7XG5cdFx0XHRcdHRlbXBsYXRlOiBgXG5cdFx0XHRcdFx0PG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiIHYtaWY9XCIkYnJlYWRjcnVtYnMubGVuZ3RoXCI+XG5cdFx0XHRcdFx0XHQ8bGkgY2xhc3M9XCJicmVhZGNydW1iLWl0ZW1cIiB2LWlmPVwiY3J1bWIubWV0YS5icmVhZGNydW1iXCIgdi1mb3I9XCIoY3J1bWIsIGluZGV4KSBpbiAkYnJlYWRjcnVtYnNcIj5cblx0XHRcdFx0XHRcdFx0PHJvdXRlci1saW5rIHYtYmluZDp0bz1cInsgcGF0aDogY3J1bWIucGF0aCB9XCIgOnRhZz1cImluZGV4ICE9ICRicmVhZGNydW1icy5sZW5ndGggLSAxID8gJ2EnIDogJ3NwYW4nXCI+e3sgY3J1bWIubWV0YS5icmVhZGNydW1iIH19PC9yb3V0ZXItbGluaz5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0PC9vbD5cblx0XHRcdFx0YFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vfi92dWUtMi1icmVhZGNydW1icy9saWIvaW5kZXguanMiLCIvKipcbiAgKiB2dWUtcm91dGVyIHYyLjIuMVxuICAqIChjKSAyMDE3IEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gaW5qZWN0IGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rc1xuICAgIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICAgIGhvb2tzLmluaXQgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY2hpbGQ7XG4gICAgfTtcbiAgICBob29rcy5wcmVwYXRjaCA9IGZ1bmN0aW9uIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY2hpbGQ7XG4gICAgfTtcbiAgICBob29rcy5kZXN0cm95ID0gZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICBpZiAobWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPT09IHZub2RlLmNoaWxkKSB7XG4gICAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICB3YXJuKGZhbHNlLCAoXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBib29sZWFuLlwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbWZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeVxuKSB7XG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xuXG4gIGlmIChxdWVyeSkge1xuICAgIHZhciBwYXJzZWRRdWVyeTtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkUXVlcnkgPSBwYXJzZVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIGUubWVzc2FnZSk7XG4gICAgICBwYXJzZWRRdWVyeSA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmFRdWVyeSkge1xuICAgICAgcGFyc2VkUXVlcnlba2V5XSA9IGV4dHJhUXVlcnlba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFF1ZXJ5XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4dHJhUXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbDIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KS5qb2luKCcmJykgOiBudWxsO1xuICByZXR1cm4gcmVzID8gKFwiP1wiICsgcmVzKSA6ICcnXG59XG5cbi8qICAqL1xuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHZhciByb3V0ZSA9IHtcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuICAgIG1ldGE6IChyZWNvcmQgJiYgcmVjb3JkLm1ldGEpIHx8IHt9LFxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG4gICAgcXVlcnk6IGxvY2F0aW9uLnF1ZXJ5IHx8IHt9LFxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKHJlZikge1xuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XG4gIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgc3RyaW5naWZ5UXVlcnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gU3RyaW5nKGFba2V5XSkgPT09IFN0cmluZyhiW2tleV0pOyB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdyb3V0ZXItbGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyB8fCByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MgfHwgJ3JvdXRlci1saW5rLWFjdGl2ZSc7XG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSBsb2NhdGlvbi5wYXRoID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIDogcm91dGU7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHsgb25bZV0gPSBoYW5kbGVyOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGFnID09PSAnYScpIHtcbiAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXh0ZW5kID0gX1Z1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuJHJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuJHJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAodGhpcy4kb3B0aW9ucy5yb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItbGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnPycgfHwgcmVsYXRpdmUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLicpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZU1hcCAoXG4gIHJvdXRlcyxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZVBhdGgocGF0aCwgcGFyZW50KSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXG4gICAgLy8gSWYgdXNlcnMgbmF2aWdhdGUgdG8gdGhpcyByb3V0ZSBieSBuYW1lLCB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocm91dGUubmFtZSAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInXFxcIiksIFwiICtcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICBcImxpbmtzIGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXG4gICAgICAgID8gY2xlYW5QYXRoKChtYXRjaEFzICsgXCIvXCIgKyAoY2hpbGQucGF0aCkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKSkge1xuICAgICAgcm91dGUuYWxpYXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIGFsaWFzUm91dGUsIHBhcmVudCwgcmVjb3JkLnBhdGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiByb3V0ZS5hbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgYWxpYXNSb3V0ZSwgcGFyZW50LCByZWNvcmQucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChwYXRoLCBwYXJlbnQpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG52YXIgaW5kZXgkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpc2FycmF5ID0gaW5kZXgkMTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBpbmRleCA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxuaW5kZXgucGFyc2UgPSBwYXJzZV8xO1xuaW5kZXguY29tcGlsZSA9IGNvbXBpbGVfMTtcbmluZGV4LnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5pbmRleC50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG52YXIgcmVnZXhwQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4IChwYXRoKSB7XG4gIHZhciBoaXQgPSByZWdleHBDYWNoZVtwYXRoXTtcbiAgdmFyIGtleXMsIHJlZ2V4cDtcblxuICBpZiAoaGl0KSB7XG4gICAga2V5cyA9IGhpdC5rZXlzO1xuICAgIHJlZ2V4cCA9IGhpdC5yZWdleHA7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IFtdO1xuICAgIHJlZ2V4cCA9IGluZGV4KHBhdGgsIGtleXMpO1xuICAgIHJlZ2V4cENhY2hlW3BhdGhdID0geyBrZXlzOiBrZXlzLCByZWdleHA6IHJlZ2V4cCB9O1xuICB9XG5cbiAgcmV0dXJuIHsga2V5czoga2V5cywgcmVnZXhwOiByZWdleHAgfVxufVxuXG52YXIgcmVnZXhwQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcm91dGVNc2dcbikge1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gaW5kZXguY29tcGlsZShwYXRoKSk7XG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XG4gIC8vIG5hbWVkIHRhcmdldFxuICBpZiAobmV4dC5uYW1lIHx8IG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLy8gcmVsYXRpdmUgcGFyYW1zXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcbiAgICBuZXh0ID0gYXNzaWduKHt9LCBuZXh0KTtcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgcGFyYW1zID0gYXNzaWduKGFzc2lnbih7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Lm1hdGNoZWQpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgXCJyZWxhdGl2ZSBwYXJhbXMgbmF2aWdhdGlvbiByZXF1aXJlcyBhIGN1cnJlbnQgcm91dGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcbiAgdmFyIGJhc2VQYXRoID0gKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXG4gICAgOiAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KHBhcnNlZFBhdGgucXVlcnksIG5leHQucXVlcnkpO1xuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChyb3V0ZXMpIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IGdldFJvdXRlUmVnZXgocmVjb3JkLnBhdGgpLmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBwYXRoIGluIHBhdGhNYXApIHtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocGF0aCwgbG9jYXRpb24ucGFyYW1zLCBsb2NhdGlvbi5wYXRoKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocGF0aE1hcFtwYXRoXSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0IChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb25cbiAgKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24pKVxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuICAgICAgdmFyIHJhd1BhdGggPSByZXNvbHZlUmVjb3JkUGF0aChwYXRoLCByZWNvcmQpO1xuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xuICAgICAgLy8gMy4gcmVtYXRjaCB3aXRoIGV4aXN0aW5nIHF1ZXJ5IGFuZCBoYXNoXG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgcGF0aDogcmVzb2x2ZWRQYXRoLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKSk7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWFzIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hBc1xuICApIHtcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XG4gICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcbiAgICB9KTtcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xuICAgICAgdmFyIGFsaWFzZWRSZWNvcmQgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcbiAgICB9XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHBhdGhuYW1lXG4pIHtcbiAgdmFyIHJlZiA9IGdldFJvdXRlUmVnZXgocGF0aCk7XG4gIHZhciByZWdleHAgPSByZWYucmVnZXhwO1xuICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICB2YXIgbSA9IHBhdGhuYW1lLm1hdGNoKHJlZ2V4cCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7IHBhcmFtc1trZXkubmFtZV0gPSB2YWw7IH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICAgIGlmIChpc09iamVjdCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsKSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgY2Iocm91dGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBvbkFib3J0KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmNvbmZpcm1UcmFuc2l0aW9uID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb24gKHJvdXRlLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHsgb25BYm9ydCAmJiBvbkFib3J0KCk7IH07XG4gIGlmIChcbiAgICBpc1NhbWVSb3V0ZShyb3V0ZSwgY3VycmVudCkgJiZcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXG4gICAgcm91dGUubWF0Y2hlZC5sZW5ndGggPT09IGN1cnJlbnQubWF0Y2hlZC5sZW5ndGhcbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICByZXR1cm4gYWJvcnQoKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZSh0aGlzLmN1cnJlbnQubWF0Y2hlZCwgcm91dGUubWF0Y2hlZCk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0byA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gbmV4dCgnLycpIG9yIG5leHQoeyBwYXRoOiAnLycgfSkgLT4gcmVkaXJlY3RcbiAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkgPyB0aGlzJDEucmVwbGFjZSh0bykgOiB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXG4gICAgICAgIG5leHQodG8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkLCBwb3N0RW50ZXJDYnMsIGlzVmFsaWQpO1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgcnVuUXVldWUoZW50ZXJHdWFyZHMsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgICB9XG4gICAgICB0aGlzJDEucGVuZGluZyA9IG51bGw7XG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIGlmICh0aGlzJDEucm91dGVyLmFwcCkge1xuICAgICAgICB0aGlzJDEucm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWQsXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICByZXR1cm4gYmluZEVudGVyR3VhcmQoZ3VhcmQsIG1hdGNoLCBrZXksIGNicywgaXNWYWxpZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gYmluZEVudGVyR3VhcmQgKFxuICBndWFyZCxcbiAgbWF0Y2gsXG4gIGtleSxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgbmV4dChjYik7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9sbCAoXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxuICBpbnN0YW5jZXMsXG4gIGtleSxcbiAgaXNWYWxpZFxuKSB7XG4gIGlmIChpbnN0YW5jZXNba2V5XSkge1xuICAgIGNiKGluc3RhbmNlc1trZXldKTtcbiAgfSBlbHNlIGlmIChpc1ZhbGlkKCkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICB9LCAxNik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiBhbmQgZG9lc24ndCBoYXZlIFZ1ZSBvcHRpb25zIGF0dGFjaGVkLFxuICAgIC8vIGFzc3VtZSBpdCdzIGFuIGFzeW5jIGNvbXBvbmVudCByZXNvbHZlIGZ1bmN0aW9uLlxuICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgIC8vIHJlc29sdmVkLlxuICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmICFkZWYub3B0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgbWF0Y2guY29tcG9uZW50c1trZXldID0gcmVzb2x2ZWREZWY7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgd2FybihmYWxzZSwgKFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uKSk7XG4gICAgICAgICAgbmV4dChmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG5cbiAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgdGhpcyQxLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgdGhpcyQxLmN1cnJlbnQsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgdmFyIGkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGkgPj0gMCA/IGkgOiAwKSArICcjJyArIHBhdGhcbiAgKTtcbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10pO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGU7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7fSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgdGhpcy5iZWZvcmVIb29rcy5wdXNoKGZuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbikge1xuICB0aGlzLmFmdGVySG9va3MucHVzaChmbik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYikge1xuICB0aGlzLmhpc3Rvcnkub25SZWFkeShjYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJvdXRlLm1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgIH0pXG4gIH0pKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXG4gIHRvLFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbih0bywgY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudCwgYXBwZW5kKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzIuMi4xJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIi8qIVxuICogVnVlLmpzIHYyLjIuNVxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICByZXR1cm4gYSA9PT0gYlxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqL1xuICBfYXNzZXRUeXBlczogW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF0sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbGlmZWN5Y2xlIGhvb2tzLlxuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcbn07XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cbiAgICAgIGlmIChfcmVzb2x2ZSkgeyBfcmVzb2x2ZShjdHgpOyB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gXCI8QW5vbnltb3VzPlwiKSB7XG4gICAgICBzdHIgKz0gXCIgLSB1c2UgdGhlIFxcXCJuYW1lXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXCI7XG4gICAgfVxuICAgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDMpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6XCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5mbnMpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKCFvbGRIb29rKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgdmFyIG5hbWUsIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZuc1xuKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbZm5zW2ldWzBdXSA9IGZuc1tpXVsxXTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZCwgdm07XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc2V0IHNjaGVkdWxlciBiZWZvcmUgdXBkYXRlZCBob29rIGNhbGxlZFxuICB2YXIgb2xkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCB1cGRhdGVkIGhvb2tzXG4gIGluZGV4ID0gb2xkUXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHdhdGNoZXIgPSBvbGRRdWV1ZVtpbmRleF07XG4gICAgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID49IDAgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShNYXRoLm1heChpLCBpbmRleCkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0geyBrZXk6IDEsIHJlZjogMSwgc2xvdDogMSB9O1xuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Bba2V5XSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXlzW2ldKSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChkYXRhLm1vZGVsKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKHByb3BPcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgZGF0YTogZGF0YSxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY2Jcbikge1xuICBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICByZXMgPSBiYXNlQ3Rvci5leHRlbmQocmVzKTtcbiAgICAgIH1cbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAvLyBoYW5kbGUgcHJvbWlzZVxuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nICYmICFmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHMgKGRhdGEsIEN0b3IsIHRhZykge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wT3B0aW9ucykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcbiAgaWYgKGF0dHJzIHx8IHByb3BzIHx8IGRvbVByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBkb21Qcm9wcywga2V5LCBhbHRLZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGhhc2gpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKG9uW2V2ZW50XSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChhbHdheXNOb3JtYWxpemUpIHsgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFOyB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChkYXRhICYmIGRhdGEuX19vYl9fKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyAmJiAhY2hpbGQubnMpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS4kdm5vZGUgPSBudWxsOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IF90b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgaW5qZWN0ID0gdm0uJG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMykpIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwXTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faW5hY3RpdmUpIHtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi4yLjUnO1xuXG4vKiAgKi9cblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogY2hpbGQuY2xhc3NcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGlmICgoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pICYmIHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG5cbi8qXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKSkge1xuICAgICAgdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhYmFpbGVkKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJykpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJyk7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoIWRhdGEuc3RhdGljQ2xhc3MgJiYgIWRhdGEuY2xhc3MgJiZcbiAgICAgICghb2xkRGF0YSB8fCAoIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50XG4pIHtcbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKGVsLCBuYW1lKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInZhciAkJGV4cCA9IFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCAkJGlkeCA9IFwiICsgKG1vZGVsUnMuaWR4KSArIFwiO1wiICtcbiAgICAgIFwiaWYgKCFBcnJheS5pc0FycmF5KCQkZXhwKSl7XCIgK1xuICAgICAgICB2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudCArIFwifVwiICtcbiAgICAgIFwiZWxzZXskJGV4cC5zcGxpY2UoJCRpZHgsIDEsIFwiICsgYXNzaWdubWVudCArIFwiKX1cIlxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkYyl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIHZhbHVlICsgXCI9JCRjfVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob25bUkFOR0VfVE9LRU5dKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSxcbiAgY2FwdHVyZVxuKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGN1ciA9PSBudWxsID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtub3JtYWxpemUobmFtZSldID0gdmFsO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoIWRhdGEuc3RhdGljU3R5bGUgJiYgIWRhdGEuc3R5bGUgJiZcbiAgICAgICFvbGREYXRhLnN0YXRpY1N0eWxlICYmICFvbGREYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgdm5vZGUuZGF0YS5zdHlsZSA9IHN0eWxlLl9fb2JfXyA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKCFmbikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGludm9rZXJGbnMpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0JyB8fCBlbC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcbiAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG4gICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uc1tpXSksIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICByZXR1cm4gL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpXG4gICAgPyBoKCdrZWVwLWFsaXZlJylcbiAgICA6IG51bGxcbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkQ2hpbGQgJiYgb2xkQ2hpbGQuZGF0YSAmJiAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuZnVuY3Rpb24gc2hvdWxkRGVjb2RlIChjb250ZW50LCBlbmNvZGVkKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCI+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbn1cblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcbnZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbnZhciBzaW5nbGVBdHRyVmFsdWVzID0gW1xuICAvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcbiAgL1wiKFteXCJdKilcIisvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgc2luZ2xlIHF1b3Rlc1xuICAvJyhbXiddKiknKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcbiAgLyhbXlxcc1wiJz08PmBdKykvLnNvdXJjZVxuXTtcbnZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuICAnXlxcXFxzKicgKyBzaW5nbGVBdHRySWRlbnRpZmllci5zb3VyY2UgK1xuICAnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG4gICdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuKTtcblxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICAgIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUpIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3Mobm9kZS5pZkNvbmRpdGlvbnMsIGlzSW5Gb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MgKGNvbmRpdGlvbkJsb2NrcywgaXNJbkZvcikge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gY29uZGl0aW9uQmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbWFya1N0YXRpY1Jvb3RzKGNvbmRpdGlvbkJsb2Nrc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKGV2ZW50cywgbmF0aXZlKSB7XG4gIHZhciByZXMgPSBuYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDM7XG52YXIgdHJhbnNmb3JtcyQxO1xudmFyIGRhdGFHZW5GbnM7XG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzJDE7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDE7XG52YXIgc3RhdGljUmVuZGVyRm5zO1xudmFyIG9uY2VDb3VudDtcbnZhciBjdXJyZW50T3B0aW9ucztcblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICAvLyBzYXZlIHByZXZpb3VzIHN0YXRpY1JlbmRlckZucyBzbyBnZW5lcmF0ZSBjYWxscyBjYW4gYmUgbmVzdGVkXG4gIHZhciBwcmV2U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuICB2YXIgY3VycmVudFN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB2YXIgcHJldk9uY2VDb3VudCA9IG9uY2VDb3VudDtcbiAgb25jZUNvdW50ID0gMDtcbiAgY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICB3YXJuJDMgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRyYW5zZm9ybXMkMSA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICBkYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHBsYXRmb3JtRGlyZWN0aXZlcyQxID0gb3B0aW9ucy5kaXJlY3RpdmVzIHx8IHt9O1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCkgOiAnX2MoXCJkaXZcIiknO1xuICBzdGF0aWNSZW5kZXJGbnMgPSBwcmV2U3RhdGljUmVuZGVyRm5zO1xuICBvbmNlQ291bnQgPSBwcmV2T25jZUNvdW50O1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogY3VycmVudFN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbClcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEoZWwpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtcyQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gdHJhbnNmb3JtcyQxW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMyhcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbClcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwiLFwiICsgKG9uY2VDb3VudCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChlbCkge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpKVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKGNvbmRpdGlvbnMpIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gZWwub25jZSA/IGdlbk9uY2UoZWwpIDogZ2VuRWxlbWVudChlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKGVsKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG1heWJlQ29tcG9uZW50KGVsKSAmJiBlbC50YWcgIT09ICdzbG90JyAmJiBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLmtleVxuICApIHtcbiAgICB3YXJuJDMoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBkYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHBsYXRmb3JtRGlyZWN0aXZlcyQxW2Rpci5uYW1lXSB8fCBiYXNlRGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQzKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHdhcm4kMygnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgcmV0dXJuIFwiW1wiICsga2V5ICsgXCIsZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCkpICsgXCJ9XVwiXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChlbCwgY2hlY2tTa2lwKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsJDEpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcCA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuKSA6IDA7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZ2VuTm9kZSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoY2hpbGRyZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIG1heWJlQ29tcG9uZW50IChlbCkge1xuICByZXR1cm4gIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxKGVsLnRhZylcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKGNvbXBvbmVudE5hbWUsIGVsKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEoZWwpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG52YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgdmFyIGZ1bmN0aW9uQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBjb21waWxlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRpcHMgPSBbXTtcbiAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCQkMSkge1xuICAgICAgKHRpcCQkMSA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgfVxuICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgfVxuICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICByZXR1cm4gY29tcGlsZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHZhciBsID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLmxlbmd0aDtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zW2ldID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnN0YXRpY1JlbmRlckZuc1tpXSwgZm5HZW5FcnJvcnMpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0gPSByZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjb21waWxlVG9GdW5jdGlvbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIG51bGwsXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTFmYTY2ZWI4XFxcIn0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2hvbWUudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJEOlxcXFxzYW5kLWJveFxcXFxnaXRcXFxcdnVlLXJcXFxcc3JjXFxcXGhvbWUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gaG9tZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMWZhNjZlYjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xZmE2NmViOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ob21lLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFZ1ZVJvdXRlciBmcm9tICd2dWUtcm91dGVyJztcbmltcG9ydCBIb21lIGZyb20gJy4vaG9tZS52dWUnO1xuaW1wb3J0IFZ1ZUJyZWFkY3J1bWJzIGZyb20gJ3Z1ZS0yLWJyZWFkY3J1bWJzJztcblxuVnVlLnVzZShWdWVSb3V0ZXIpO1xuVnVlLnVzZShWdWVCcmVhZGNydW1icyk7XG5cbmNvbnN0IEZlZWRzID0geyB0ZW1wbGF0ZTogJzxkaXY+PHJvdXRlci12aWV3Lz48L2Rpdj4nIH07XG5jb25zdCBCaXogPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+Qml6PC9oMj48cD5Mb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gSXBzYSB2b2x1cHRhdGUgcXVpYSBxdWFzIGFzc3VtZW5kYSBiZWF0YWUgdmVybz8gT21uaXMsIHByYWVzZW50aXVtLiBNYWduaSBuZXNjaXVudCBhbGlhcyBlbGlnZW5kaSBzdXNjaXBpdCB2ZWwgZG9sb3IgYWNjdXNhbnRpdW0sIGl0YXF1ZSBwb3NzaW11cyBudWxsYSBtYWlvcmVzIG5vc3RydW0uPC9wPjwvZGl2PicgfTtcbmNvbnN0IEZvbyA9IHsgdGVtcGxhdGU6ICc8ZGl2PjxoMj5Gb288L2gyPjxwPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBJcHNhIHZvbHVwdGF0ZSBxdWlhIHF1YXMgYXNzdW1lbmRhIGJlYXRhZSB2ZXJvPyBPbW5pcywgcHJhZXNlbnRpdW0uIE1hZ25pIG5lc2NpdW50IGFsaWFzIGVsaWdlbmRpIHN1c2NpcGl0IHZlbCBkb2xvciBhY2N1c2FudGl1bSwgaXRhcXVlIHBvc3NpbXVzIG51bGxhIG1haW9yZXMgbm9zdHJ1bS48L3A+PC9kaXY+JyB9O1xuY29uc3QgQmFyID0geyB0ZW1wbGF0ZTogJzxkaXY+PGgyPkJhcjwvaDI+PHA+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIElwc2Egdm9sdXB0YXRlIHF1aWEgcXVhcyBhc3N1bWVuZGEgYmVhdGFlIHZlcm8/IE9tbmlzLCBwcmFlc2VudGl1bS4gTWFnbmkgbmVzY2l1bnQgYWxpYXMgZWxpZ2VuZGkgc3VzY2lwaXQgdmVsIGRvbG9yIGFjY3VzYW50aXVtLCBpdGFxdWUgcG9zc2ltdXMgbnVsbGEgbWFpb3JlcyBub3N0cnVtLjwvcD48L2Rpdj4nIH07XG5cbmNvbnN0IHJvdXRlciA9IG5ldyBWdWVSb3V0ZXIoe1xuXHRyb3V0ZXM6IFtcblx0XHR7IHBhdGg6ICcvJywgcmVkaXJlY3Q6ICcvZmVlZHMnIH0sXG5cdFx0e1xuXHRcdFx0cGF0aDogJy9mZWVkcycsXG5cdFx0XHRjb21wb25lbnQ6IEZlZWRzLFxuXHRcdFx0bWV0YToge1xuXHRcdFx0XHRicmVhZGNydW1iOiAnRmVlZHMnXG5cdFx0XHR9LFxuXHRcdFx0Y2hpbGRyZW46IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhdGg6ICcnLFxuXHRcdFx0XHRcdGNvbXBvbmVudDogQml6XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXRoOiAnZm9vJyxcblx0XHRcdFx0XHRjb21wb25lbnQ6IEZvbyxcblx0XHRcdFx0XHRtZXRhOiB7XG5cdFx0XHRcdFx0XHRicmVhZGNydW1iOiAnZm9vJ1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhdGg6ICdiYXInLFxuXHRcdFx0XHRcdGNvbXBvbmVudDogQmFyLFxuXHRcdFx0XHRcdG1ldGE6IHtcblx0XHRcdFx0XHRcdGJyZWFkY3J1bWI6ICdiYXInXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fVxuXHRdXG59KTtcblxubmV3IFZ1ZSh7XG5cdHJvdXRlcixcblx0Y29tcG9uZW50czoge1xuXHRcdEhvbWU6IEhvbWVcblx0fSxcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGlkPVwiYXBwXCIgY2xhc3M9XCJjb250YWluZXJcIj5cblx0XHRcdDx1bCBjbGFzcz1cIm5hdlwiPlxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJuYXYtaXRlbSAgZHJvcGRvd25cIj5cblx0XHRcdFx0XHQ8cm91dGVyLWxpbmsgdG89XCIvZmVlZHNcIiBjbGFzcz1cIm5hdi1saW5rIGRyb3Bkb3duLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiByb2xlPVwiYnV0dG9uXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5GZWVkczwvcm91dGVyLWxpbms+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj5cblx0XHRcdFx0PHJvdXRlci1saW5rIHRvPVwiL2ZlZWRzL2Zvb1wiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPkZvbzwvcm91dGVyLWxpbms+XG5cdFx0XHRcdDxyb3V0ZXItbGluayB0bz1cIi9mZWVkcy9iYXJcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIj5CYXI8L3JvdXRlci1saW5rPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0PC91bD5cblx0XHRcdDxicmVhZGNydW1icy8+XG5cdFx0XHQ8cm91dGVyLXZpZXcvPlxuXHRcdFx0PGhyPlxuXHRcdFx0PEhvbWUvPlxuXHRcdDwvZGl2PlxuXHRgXG59KS4kbW91bnQoJyNhcHAnKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwLmpzIiwiLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgc2NvcGVJZCxcbiAgY3NzTW9kdWxlc1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgLy8gaW5qZWN0IGNzc01vZHVsZXNcbiAgaWYgKGNzc01vZHVsZXMpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuY29tcHV0ZWQgfHwgbnVsbClcbiAgICBPYmplY3Qua2V5cyhjc3NNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBjc3NNb2R1bGVzW2tleV1cbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxuICAgIH0pXG4gICAgb3B0aW9ucy5jb21wdXRlZCA9IGNvbXB1dGVkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX3ZtLl9tKDApXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnaDMnLCBbX3ZtLl92KFwiSG9tZSBjb21wb25lbnRcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlbmlhbSBtb2xlc3RpYXMgYXBlcmlhbSBvZGl0IHNpdCBoYXJ1bSBxdWFtLCBsYWJvcnVtIG1hZ25hbS4gVmVyaXRhdGlzIGl0YXF1ZSB0ZW1wb3JpYnVzIHZpdGFlIGJlYXRhZSBxdWFtIGVhcXVlIHZvbHVwdGF0ZW0gYWxpYXMgZW5pbT8gTWF4aW1lLCBpdGFxdWUuIEV2ZW5pZXQuXCIpXSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTFmYTY2ZWI4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTFmYTY2ZWI4XCJ9IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaG9tZS52dWVcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==