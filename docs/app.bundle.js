/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", expecting an object, function or boolean.");
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery) {
  if (extraQuery === void 0) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery;
  } else {
    return extraQuery;
  }
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom) {
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  return (path || '/') + stringifyQuery(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact ? isSameRoute(current, compareTarget) : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  if (relative.charAt(0) === '/') {
    return relative;
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue;
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

/*  */

function createRouteMap(routes, oldPathMap, oldNameMap) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex(path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp };
}

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function normalizeLocation(raw, current, append) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : current && current.path || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = getRouteRegex(record.path).keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(path, params, pathname) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function () {
    onAbort && onAbort();
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || typeof to === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        typeof to === 'object' && to.replace ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () {
      return this$1.current === route;
    };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            return cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  return function boundRouteGuard() {
    return guard.apply(instance, arguments);
  };
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, "Failed to resolve async component " + key + ": " + reason);
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      };
    }
  });
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady(cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
 * vue-breadcrumbs v0.3.1
 * (c) 2016 Sam Turrell
 * Released under the MIT License.
 */
/*(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.VueBreadcrumbs = factory();
}(this, function () { 'use strict';

  function plugin(Vue) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	Vue.prototype.$breadcrumbs = function () {
		var crumbs = [];
		for (var i = 0; i < this.$route.matched.length; i++) {
		  if (this.$route.matched[i].meta && this.$route.matched[i].meta.breadcrumb) {
			crumbs.push(this.$route.matched[i]);
		  }
		}
		return crumbs;
	}

	Vue.component('breadcrumbs', {
	  template: '<ol class="breadcrumb" v-if="$breadcrumbs.length"> <li class="breadcrumb-item" v-for="(crumb, i) in $breadcrumbs"> <router-link :to=" { path: crumb.path }">{{ crumb.meta.breadcrumb }}</router-link> </li> </ol>'
	});
  }

  plugin.version = '0.3.1';

  return plugin;

}));*/

/* harmony default export */ __webpack_exports__["default"] = ({
	install(Vue, options) {
		Object.defineProperties(Vue.prototype, {
			$breadcrumbs: {
				get() {
					return this.$route.matched;
				}
			}
		});

		Vue.component('breadcrumbs', {
			template: `
				<ol class="breadcrumb" v-if="$breadcrumbs.length">
					<li class="breadcrumb-item" v-for="(crumb, i) in $breadcrumbs">
						<router-link :to=" { path: crumb.path }">
							{{ crumb.meta.breadcrumb }}
						</router-link>
					</li>
				</ol>`
		});
	}
});

/*export default {
	install(Vue, options) {
		Vue.prototype.$breadcrumbs = this.$root;

		Vue.component('breadcrumbs', {
			template: `<h2>{{ $breadcrumbs }}</h2>`
		})
	}
}*/

/*const MyPlugin = {
  install(Vue, options) {
    Vue.myAddedProperty = 'Example Property'
    Vue.myAddedMethod = function() {
   	  return Vue.myAddedProperty
    }
  }
};

export default MyPlugin;*/

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
 * Vue.js v2.2.5
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function () {
  return false;
};

/**
 * Return same value
 */
var identity = function (_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  };
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: ['component', 'directive', 'filter'],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return (/native code/.test(Ctor.toString())
  );
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) {
      console.error(err);
    };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        cb.call(ctx);
      }
      if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var formatLocation = function (str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return "\n(found in " + str + ")";
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$3) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = typeof value === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = typeof value === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = typeof value === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = typeof value === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1];
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn("Error in " + info + ":", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function () {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.componentOptions;
  })[0];
}

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // reset scheduler before updated hook called
  var oldQueue = queue.slice();
  resetSchedulerState();

  // call updated hooks
  index = oldQueue.length;
  while (index--) {
    watcher = oldQueue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);
  observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy(vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (!Ctor) {
    return;
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return;
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor, tag);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function () {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function resolveAsyncComponent(factory, baseCtor, cb) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function (res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function (reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved;
  }
}

function extractProps(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the delared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    var loop = function (i) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            defineReactive$$1(vm, key, source._provided[provideKey], function () {
              warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
            });
          } else {
            defineReactive$$1(vm, key, source._provided[provideKey]);
          }
          break;
        }
        source = source.$parent;
      }
    };

    for (var i = 0; i < keys.length; i++) loop(i);
  }
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern instanceof RegExp) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Vue$3.version = '2.2.5';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (parentNode = parentNode.parent) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  var res = '';
  if (!value) {
    return res;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if (stringified = stringifyClass(value[i])) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function sameVnode(a, b) {
  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important) {
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "var $$exp = " + modelRs.exp + ", $$idx = " + modelRs.idx + ";" + "if (!Array.isArray($$exp)){" + value + "=" + assignment + "}" + "else{$$exp.splice($$idx, 1, " + assignment + ")}";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + value + "=$$c}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number || type === 'number') {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, handler, once, capture) {
  if (once) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, handler, capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (modifiers && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return;
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm();
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (!fn) {
    return false;
  }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  return (/\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null
  );
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function () {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\">";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var decoder;

function decode(html) {
  decoder = decoder || document.createElement('div');
  decoder.innerHTML = html;
  return decoder.textContent;
}

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
// attr value double quotes
/"([^"]*)"+/.source,
// attr value, single quotes
/'([^']*)'+/.source,
// attr value, no quotes
/([^\s"'=<>`]+)/.source];
var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          continue;
        }
      }

      var text = void 0,
          rest$1 = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest$1 = html.slice(textEnd);
        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {
          // < in plain text, be forgiving and treat it as text
          next = rest$1.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest$1 = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var endTagLength = 0;
      var rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest.length;
      html = rest;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformGetTagNamespace = options.getTagNamespace || no;
  platformMustUseProp = options.mustUseProp || no;
  platformIsPreTag = options.isPreTag || no;
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
        }
        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      walkThroughConditionsBlocks(node.ifConditions, isInFor);
    }
  }
}

function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
    markStaticRoots(conditionBlocks[i].block, isInFor);
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, native) {
  var res = native ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  bind: bind$1,
  cloak: noop
};

/*  */

// configurable state
var warn$3;
var transforms$1;
var dataGenFns;
var platformDirectives$1;
var isPlatformReservedTag$1;
var staticRenderFns;
var onceCount;
var currentOptions;

function generate(ast, options) {
  // save previous staticRenderFns so generate calls can be nested
  var prevStaticRenderFns = staticRenderFns;
  var currentStaticRenderFns = staticRenderFns = [];
  var prevOnceCount = onceCount;
  onceCount = 0;
  currentOptions = options;
  warn$3 = options.warn || baseWarn;
  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
  dataGenFns = pluckModuleFunction(options.modules, 'genData');
  platformDirectives$1 = options.directives || {};
  isPlatformReservedTag$1 = options.isReservedTag || no;
  var code = ast ? genElement(ast) : '_c("div")';
  staticRenderFns = prevStaticRenderFns;
  onceCount = prevOnceCount;
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: currentStaticRenderFns
  };
}

function genElement(el) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el);
  } else if (el.for && !el.forProcessed) {
    return genFor(el);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el);
    } else {
      var data = el.plain ? undefined : genData(el);

      var children = el.inlineTemplate ? null : genChildren(el, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < transforms$1.length; i++) {
      code = transforms$1[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el) {
  el.staticProcessed = true;
  staticRenderFns.push("with(this){return " + genElement(el) + "}");
  return "_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && warn$3("v-once can only be used inside v-for that is keyed. ");
      return genElement(el);
    }
    return "_o(" + genElement(el) + "," + onceCount++ + (key ? "," + key : "") + ")";
  } else {
    return genStatic(el);
  }
}

function genIf(el) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice());
}

function genIfConditions(conditions) {
  if (!conditions.length) {
    return '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return el.once ? genOnce(el) : genElement(el);
  }
}

function genFor(el) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    warn$3("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genElement(el) + '})';
}

function genData(el) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < dataGenFns.length; i++) {
    data += dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  return data;
}

function genDirectives(el) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, warn$3);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
    warn$3('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, currentOptions);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key]);
  }).join(',') + "])";
}

function genScopedSlot(key, el) {
  return "[" + key + ",function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + "}]";
}

function genChildren(el, checkSkip) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return genElement(el$1);
    }
    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
    return "[" + children.map(genNode).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function maybeComponent(el) {
  return !isPlatformReservedTag$1(el.tag);
}

function genNode(node) {
  if (node.type === 1) {
    return genElement(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genSlot(el) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el) {
  var children = el.inlineTemplate ? null : genChildren(el, true);
  return "_c(" + componentName + "," + genData(el) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
  if (keywordMatch) {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

function makeFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompiler(baseOptions) {
  var functionCompileCache = Object.create(null);

  function compile(template, options) {
    var finalOptions = Object.create(baseOptions);
    var errors = [];
    var tips = [];
    finalOptions.warn = function (msg, tip$$1) {
      (tip$$1 ? tips : errors).push(msg);
    };

    if (options) {
      // merge custom modules
      if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
      }
      // copy other options
      for (var key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key];
        }
      }
    }

    var compiled = baseCompile(template, finalOptions);
    if (process.env.NODE_ENV !== 'production') {
      errors.push.apply(errors, detectErrors(compiled.ast));
    }
    compiled.errors = errors;
    compiled.tips = tips;
    return compiled;
  }

  function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (functionCompileCache[key]) {
      return functionCompileCache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = makeFunction(compiled.render, fnGenErrors);
    var l = compiled.staticRenderFns.length;
    res.staticRenderFns = new Array(l);
    for (var i = 0; i < l; i++) {
      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
    }

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return functionCompileCache[key] = res;
  }

  return {
    compile: compile,
    compileToFunctions: compileToFunctions
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData$1
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$2(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$2
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

/* harmony default export */ __webpack_exports__["default"] = (Vue$3);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(5)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(7)(
  /* script */
  null,
  /* template */
  __webpack_require__(8),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "D:\\sand-box\\git\\vue-r\\src\\home.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] home.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1fa66eb8", Component.options)
  } else {
    hotAPI.reload("data-v-1fa66eb8", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(3);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(1);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _home = __webpack_require__(4);

var _home2 = _interopRequireDefault(_home);

var _vue2Breadcrumbs = __webpack_require__(2);

var _vue2Breadcrumbs2 = _interopRequireDefault(_vue2Breadcrumbs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);
_vue2.default.use(_vue2Breadcrumbs2.default);

const Feeds = { template: '<div><h1>Feeds</h1> <router-view/></div>' };
const Foo = { template: '<div><h2>foo</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };
const Bar = { template: '<div><h2>Bar</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };

const router = new _vueRouter2.default({
  routes: [{ path: '/', redirect: '/feeds' }, {
    path: '/feeds',
    component: Feeds,
    meta: {
      breadcrumb: 'Feeds'
    },
    children: [{
      path: 'foo',
      component: Foo,
      meta: {
        breadcrumb: 'foo'
      }
    }, {
      path: 'bar',
      component: Bar,
      meta: {
        breadcrumb: 'bar'
      }
    }]
  }]
});

new _vue2.default({
  router,
  components: {
    Home: _home2.default
  },
  template: `
    <div id="app" class="container">
      <ul class="nav">
        <li class="nav-item  dropdown">
        	<router-link to="/feeds" class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Feeds</router-link>
        	<div class="dropdown-menu">
				<router-link to="/feeds/foo" class="dropdown-item">Foo</router-link>
				<router-link to="/feeds/bar" class="dropdown-item">Bar</router-link>
        	</div>
        </li>
      </ul>
      <breadcrumbs/>
      <router-view/>
      <hr>
      <Home/>
    </div>
  `
}).$mount('#app');

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('h3', [_vm._v("Home component")]), _vm._v(" "), _c('p', [_vm._v("Lorem ipsum dolor sit amet, consectetur adipisicing elit. Veniam molestias aperiam odit sit harum quam, laborum magnam. Veritatis itaque temporibus vitae beatae quam eaque voluptatem alias enim? Maxime, itaque. Eveniet.")])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-1fa66eb8", module.exports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmMzMTE3YTdlZTQyNGJlMDllZmUiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUyLWJyZWFkY3J1bWJzL2Rpc3QvdnVlLWJyZWFkY3J1bWJzLmpzIiwid2VicGFjazovLy8uLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vaG9tZS52dWUiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaG9tZS52dWU/Y2U2ZiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIndhcm4iLCJjb25zb2xlIiwiVmlldyIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiaCIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCIkdm5vZGUiLCJfaW5hY3RpdmUiLCIkcGFyZW50Iiwicm91dGVyVmlld0RlcHRoIiwibWF0Y2hlZCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJob29rcyIsImhvb2siLCJpbml0Iiwidm5vZGUiLCJpbnN0YW5jZXMiLCJjaGlsZCIsInByZXBhdGNoIiwib2xkVm5vZGUiLCJkZXN0cm95IiwidW5kZWZpbmVkIiwicmVzb2x2ZVByb3BzIiwiY29uZmlnIiwicGFyYW1zIiwicGF0aCIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJjb21tYVJFIiwiZW5jb2RlIiwic3RyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVRdWVyeSIsInF1ZXJ5IiwiZXh0cmFRdWVyeSIsInBhcnNlZFF1ZXJ5IiwicGFyc2VRdWVyeSIsIk5PREVfRU5WIiwia2V5IiwicmVzIiwidHJpbSIsInNwbGl0IiwiZm9yRWFjaCIsInBhcmFtIiwicGFydHMiLCJzaGlmdCIsInZhbCIsImpvaW4iLCJpc0FycmF5Iiwic3RyaW5naWZ5UXVlcnkiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwicmVzdWx0Iiwic2xpY2UiLCJ2YWwyIiwiZmlsdGVyIiwieCIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwibG9jYXRpb24iLCJyZWRpcmVjdGVkRnJvbSIsIm1ldGEiLCJoYXNoIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiZnJlZXplIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJpc0luY2x1ZGVkUm91dGUiLCJjdXJyZW50IiwidGFyZ2V0IiwiaW5kZXhPZiIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJ0byIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJldmVudCIsInRoaXMkMSIsInJvdXRlciIsIiRyb3V0ZXIiLCJyZXNvbHZlIiwiaHJlZiIsImNsYXNzZXMiLCJvcHRpb25zIiwibGlua0FjdGl2ZUNsYXNzIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJjbGFzcyIsImF0dHJzIiwiZmluZEFuY2hvciIsIiRzbG90cyIsImlzU3RhdGljIiwiZXh0ZW5kIiwiX1Z1ZSIsInV0aWwiLCJhRGF0YSIsImFBdHRycyIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwiYnV0dG9uIiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiaW5zdGFsbCIsIlZ1ZSIsImluc3RhbGxlZCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiJHJvb3QiLCJfcm91dGVyIiwiX3JvdXRlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCIkb3B0aW9ucyIsImRlZmluZVJlYWN0aXZlIiwiaGlzdG9yeSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsIndpbmRvdyIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiY3JlYXRlUm91dGVNYXAiLCJyb3V0ZXMiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhNYXAiLCJjcmVhdGUiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJtYXRjaEFzIiwibm9ybWFsaXplUGF0aCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc1JvdXRlIiwiaW5kZXgkMSIsImFyciIsImlzYXJyYXkiLCJpbmRleCIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJwYXJzZSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsInZhbHVlIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENhY2hlIiwiZ2V0Um91dGVSZWdleCIsImhpdCIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsInBhcmFtTmFtZXMiLCJfY3JlYXRlUm91dGUiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsImhhc093blByb3BlcnR5IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwYXRobmFtZSIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiZnJvbSIsImlzUG9wIiwiYXBwIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsIiRuZXh0VGljayIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJpc09iamVjdCIsInNlbGVjdG9yIiwiZWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJpc1ZhbGlkUG9zaXRpb24iLCJub3JtYWxpemVQb3NpdGlvbiIsInNjcm9sbFRvIiwieSIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc051bWJlciIsInYiLCJzdXBwb3J0c1B1c2hTdGF0ZSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIl9rZXkiLCJnZW5LZXkiLCJ0b0ZpeGVkIiwicHVzaFN0YXRlIiwidXJsIiwicmVwbGFjZVN0YXRlIiwicnVuUXVldWUiLCJmbiIsImNiIiwic3RlcCIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicGVuZGluZyIsInJlYWR5IiwicmVhZHlDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwibWF4IiwiTWF0aCIsImV4dHJhY3RHdWFyZHMiLCJyZWNvcmRzIiwiYmluZCIsInJldmVyc2UiLCJndWFyZHMiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJmbGF0dGVuIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiXyIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsInJlc29sdmVkRGVmIiwicmVqZWN0IiwicmVhc29uIiwidGhlbiIsImNhbGxlZCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJnZXRMb2NhdGlvbiIsIl9fcHJvdG9fXyIsImNvbnN0cnVjdG9yIiwiZ28iLCJuIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwic2VhcmNoIiwiSGFzaEhpc3RvcnkiLCJmYWxsYmFjayIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwicmVzb2x2ZWQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidXNlIiwiJGJyZWFkY3J1bWJzIiwidGVtcGxhdGUiLCJfdG9TdHJpbmciLCJ0b051bWJlciIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwicmVtb3ZlIiwiaXRlbSIsInNwbGljZSIsImhhc093biIsImlzUHJpbWl0aXZlIiwiY2FjaGVkIiwiY2FjaGVkRm4iLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjYXBpdGFsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJjdHgiLCJib3VuZEZuIiwibCIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJfZnJvbSIsIk9CSkVDVF9TVFJJTkciLCJpc1BsYWluT2JqZWN0IiwidG9PYmplY3QiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJzdGF0aWNLZXlzIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImxvb3NlSW5kZXhPZiIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2Fzc2V0VHlwZXMiLCJfbGlmZWN5Y2xlSG9va3MiLCJfbWF4VXBkYXRlQ291bnQiLCJlbXB0eU9iamVjdCIsImlzUmVzZXJ2ZWQiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJoYXNQcm90byIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZ2xvYmFsIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsImNhbGxiYWNrcyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsIlByb21pc2UiLCJwIiwibG9nRXJyb3IiLCJlcnIiLCJlcnJvciIsImNhdGNoIiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInF1ZXVlTmV4dFRpY2siLCJfcmVzb2x2ZSIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJmb3JtYXRMb2NhdGlvbiIsImluY2x1ZGVGaWxlIiwiX2lzVnVlIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJ1aWQkMSIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJ0b1ZhbCIsImZyb21WYWwiLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJtZXJnZUFzc2V0cyIsIndhdGNoIiwibWV0aG9kcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIlZ1ZSQzIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsImhhbmRsZUVycm9yIiwiaW5mbyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJjb21wb25lbnRJbnN0YW5jZSIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsIm5lc3RlZEluZGV4IiwibGFzdCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwidXNlciIsImV4cHJlc3Npb24iLCJvbGRRdWV1ZSIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5Iiwic3luYyIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJpbnNlcnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJleHRyYWN0UHJvcHMiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwiX2NvbnRleHQiLCJkIiwiY3JlYXRlRWxlbWVudCIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwiZmFjdG9yeSIsInJlcXVlc3RlZCIsInBlbmRpbmdDYWxsYmFja3MiLCJkb21Qcm9wcyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBseU5TIiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwidHJlZSIsIl9zdGF0aWNUcmVlcyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiaW5pdFJlbmRlciIsInJlbmRlckNvbnRleHQiLCJfYyIsIiRjcmVhdGVFbGVtZW50IiwicmVuZGVyTWl4aW4iLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJpbml0UHJvdmlkZSIsInByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsImluamVjdCIsInByb3ZpZGVLZXkiLCJ1aWQiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsImluaXRVc2UiLCJwbHVnaW4iLCJpbml0TWl4aW4kMSIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwicGF0dGVyblR5cGVzIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBydW5lQ2FjaGUiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJkZWxldGUiLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJnZW5DbGFzc0Zyb21EYXRhIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJpc1VuZGVmIiwiaXNEZWYiLCJpc1RydWUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImluUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwiYW5jZXN0b3IiLCJfc2NvcGVJZCIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsImVsbVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJiYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiaHlkcmF0ZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsImZpbHRlcnMiLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwibW9kZWxScyIsInBhcnNlTW9kZWwiLCJpZHgiLCJjaHIiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJzdHlsZSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZSIsInByZWZpeGVzIiwidGVzdEVsIiwidXBwZXIiLCJwcmVmaXhlZCIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiZGVmJCQxIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwibW9kZWwkMSIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwib3B0aW9uIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImNvbXAiLCJrZXkkMSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiYmVmb3JlVXBkYXRlIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiYm9keSIsImYiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJkeSIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJkZWNvZGVyIiwiaHRtbCIsInNpbmdsZUF0dHJJZGVudGlmaWVyIiwic2luZ2xlQXR0ckFzc2lnbiIsInNpbmdsZUF0dHJWYWx1ZXMiLCJhdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOIiwiZyIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJkZWNvZGVBdHRyIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QkMSIsImNoYXJzIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsImVuZFRhZ0xlbmd0aCIsInJlc3QiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsImxhc3RJbmRleCIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJndWFyZElFU1ZHQnVnIiwibWFrZUF0dHJzTWFwIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0tleSIsInBsYWluIiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwiaSQyIiwibGFzdE5vZGUiLCJjaGVja0luRm9yIiwiaW5NYXRjaCIsImZvciIsIml0ZXJhdG9yTWF0Y2giLCJpdGVyYXRvcjEiLCJpdGVyYXRvcjIiLCJmaW5kUHJldkVsZW1lbnQiLCJpZkNvbmRpdGlvbnMiLCJzbG90TmFtZSIsImlzUHJvcCIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsIndhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyIsImNvbmRpdGlvbkJsb2NrcyIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJyaWdodCIsImRvd24iLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJwcmV2ZW50Iiwic2VsZiIsImN0cmwiLCJhbHQiLCJtaWRkbGUiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsInBhcnNlSW50IiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwid2FybiQzIiwidHJhbnNmb3JtcyQxIiwiZGF0YUdlbkZucyIsInBsYXRmb3JtRGlyZWN0aXZlcyQxIiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEiLCJvbmNlQ291bnQiLCJjdXJyZW50T3B0aW9ucyIsImdlbmVyYXRlIiwiYXN0IiwicHJldlN0YXRpY1JlbmRlckZucyIsImN1cnJlbnRTdGF0aWNSZW5kZXJGbnMiLCJwcmV2T25jZUNvdW50IiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsIm1heWJlQ29tcG9uZW50IiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJzY29wZSIsImNoZWNrU2tpcCIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsImlkZW50UkUiLCJzdHJpcFN0cmluZ1JFIiwiZGV0ZWN0RXJyb3JzIiwiZXJyb3JzIiwiY2hlY2tOb2RlIiwiY2hlY2tGb3IiLCJjaGVja0V2ZW50IiwiY2hlY2tFeHByZXNzaW9uIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJGdW5jdGlvbiIsImJhc2VDb21waWxlIiwibWFrZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZXIiLCJiYXNlT3B0aW9ucyIsImZ1bmN0aW9uQ29tcGlsZUNhY2hlIiwiZmluYWxPcHRpb25zIiwidGlwcyIsInRpcCQkMSIsImNvbXBpbGVkIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwiZm5HZW5FcnJvcnMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSQxIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMiIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiZXZhbCIsIkZlZWRzIiwiRm9vIiwiQmFyIiwiYnJlYWRjcnVtYiIsIkhvbWUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xEQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0EsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiJhcHAuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYmMzMTE3YTdlZTQyNGJlMDllZmUiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gICogdnVlLXJvdXRlciB2Mi4yLjFcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4oKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpO1xuICB9XG59XG5cbnZhciBWaWV3ID0ge1xuICBuYW1lOiAncm91dGVyLXZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XG5cbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcbiAgICB2YXIgY2FjaGUgPSBwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSB8fCAocGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgPSB7fSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxuICAgIC8vIGhhcyBiZWVuIHRvZ2dsZWQgaW5hY3RpdmUgYnV0IGtlcHQtYWxpdmUuXG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LiR2bm9kZSAmJiBwYXJlbnQuJHZub2RlLmRhdGEucm91dGVyVmlldykge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5faW5hY3RpdmUpIHtcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGg7XG5cbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGgoY2FjaGVbbmFtZV0sIGRhdGEsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gcm91dGUubWF0Y2hlZFtkZXB0aF07XG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgY2FjaGVbbmFtZV0gPSBudWxsO1xuICAgICAgcmV0dXJuIGgoKVxuICAgIH1cblxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcblxuICAgIC8vIGluamVjdCBpbnN0YW5jZSByZWdpc3RyYXRpb24gaG9va3NcbiAgICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgICBob29rcy5pbml0ID0gZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNoaWxkO1xuICAgIH07XG4gICAgaG9va3MucHJlcGF0Y2ggPSBmdW5jdGlvbiAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNoaWxkO1xuICAgIH07XG4gICAgaG9va3MuZGVzdHJveSA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgaWYgKG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID09PSB2bm9kZS5jaGlsZCkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xuICAgIGRhdGEucHJvcHMgPSByZXNvbHZlUHJvcHMocm91dGUsIG1hdGNoZWQucHJvcHMgJiYgbWF0Y2hlZC5wcm9wc1tuYW1lXSk7XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcbiAgc3dpdGNoICh0eXBlb2YgY29uZmlnKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGNvbmZpZyhyb3V0ZSlcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcbiAgICBkZWZhdWx0OlxuICAgICAgd2FybihmYWxzZSwgKFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb21mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICBpZiAocXVlcnkpIHtcbiAgICB2YXIgcGFyc2VkUXVlcnk7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2VRdWVyeShxdWVyeSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgICAgcGFyc2VkUXVlcnkgPSB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICAgIHBhcnNlZFF1ZXJ5W2tleV0gPSBleHRyYVF1ZXJ5W2tleV07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRRdWVyeVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRyYVF1ZXJ5XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBsb2NhdGlvbi5xdWVyeSB8fCB7fSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24pLFxuICAgIG1hdGNoZWQ6IHJlY29yZCA/IGZvcm1hdE1hdGNoKHJlY29yZCkgOiBbXVxuICB9O1xuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcbiAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xuICBwYXRoOiAnLydcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRNYXRjaCAocmVjb3JkKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUgKHJlY29yZCkge1xuICAgIHJlcy51bnNoaWZ0KHJlY29yZCk7XG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoIChyZWYpIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSArIGhhc2hcbn1cblxuZnVuY3Rpb24gaXNTYW1lUm91dGUgKGEsIGIpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KVxuICAgIClcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KSAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcbiAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xuXG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFN0cmluZyhhW2tleV0pID09PSBTdHJpbmcoYltrZXldKTsgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAncm91dGVyLWxpbmsnLFxuICBwcm9wczoge1xuICAgIHRvOiB7XG4gICAgICB0eXBlOiB0b1R5cGVzLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2EnXG4gICAgfSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgfHwgcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzIHx8ICdyb3V0ZXItbGluay1hY3RpdmUnO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aCA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSA6IHJvdXRlO1xuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxuICAgICAgPyBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IF9WdWUudXRpbC5leHRlbmQ7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGd1YXJkRXZlbnQgKGUpIHtcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgaWYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcbiAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XG4gIH1cbiAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiAoY2hpbGQgPSBmaW5kQW5jaG9yKGNoaWxkLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLiRyb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLiRyb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKHRoaXMuJG9wdGlvbnMucm91dGVyKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyO1xuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLXZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcblxuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXG4gIHN0cmF0cy5iZWZvcmVSb3V0ZUVudGVyID0gc3RyYXRzLmJlZm9yZVJvdXRlTGVhdmUgPSBzdHJhdHMuY3JlYXRlZDtcbn1cblxuLyogICovXG5cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJz8nIHx8IHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4nKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhNYXAsXG4gIG9sZE5hbWVNYXBcbikge1xuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHJlY29yZCA9IHtcbiAgICBwYXRoOiBub3JtYWxpemVQYXRoKHBhdGgsIHBhcmVudCksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkIGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgIFwidGhpcyByb3V0ZSBhbmQgdXNlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIGZvciBuYW1lZCBcIiArXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJvdXRlLmFsaWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcykpIHtcbiAgICAgIHJvdXRlLmFsaWFzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgICB9O1xuICAgICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCBhbGlhc1JvdXRlLCBwYXJlbnQsIHJlY29yZC5wYXRoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogcm91dGUuYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIGFsaWFzUm91dGUsIHBhcmVudCwgcmVjb3JkLnBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50KSB7XG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gIGlmIChwYXRoWzBdID09PSAnLycpIHsgcmV0dXJuIHBhdGggfVxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcbn1cblxudmFyIGluZGV4JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNhcnJheSA9IGluZGV4JDE7XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgaW5kZXggPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cbmluZGV4LnBhcnNlID0gcGFyc2VfMTtcbmluZGV4LmNvbXBpbGUgPSBjb21waWxlXzE7XG5pbmRleC50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xuaW5kZXgudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxudmFyIHJlZ2V4cENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZ2V0Um91dGVSZWdleCAocGF0aCkge1xuICB2YXIgaGl0ID0gcmVnZXhwQ2FjaGVbcGF0aF07XG4gIHZhciBrZXlzLCByZWdleHA7XG5cbiAgaWYgKGhpdCkge1xuICAgIGtleXMgPSBoaXQua2V5cztcbiAgICByZWdleHAgPSBoaXQucmVnZXhwO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBbXTtcbiAgICByZWdleHAgPSBpbmRleChwYXRoLCBrZXlzKTtcbiAgICByZWdleHBDYWNoZVtwYXRoXSA9IHsga2V5czoga2V5cywgcmVnZXhwOiByZWdleHAgfTtcbiAgfVxuXG4gIHJldHVybiB7IGtleXM6IGtleXMsIHJlZ2V4cDogcmVnZXhwIH1cbn1cblxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IGluZGV4LmNvbXBpbGUocGF0aCkpO1xuICAgIHJldHVybiBmaWxsZXIocGFyYW1zIHx8IHt9LCB7IHByZXR0eTogdHJ1ZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShwYXJzZWRQYXRoLnF1ZXJ5LCBuZXh0LnF1ZXJ5KTtcbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAocm91dGVzKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xuICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gICAgY3JlYXRlUm91dGVNYXAocm91dGVzLCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSBnZXRSb3V0ZVJlZ2V4KHJlY29yZC5wYXRoKS5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiBwYXRoTWFwKSB7XG4gICAgICAgIGlmIChtYXRjaFJvdXRlKHBhdGgsIGxvY2F0aW9uLnBhcmFtcywgbG9jYXRpb24ucGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHBhdGhNYXBbcGF0aF0sIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3JpZ2luYWxSZWRpcmVjdChjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uKSlcbiAgICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xuXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG5cbiAgICB2YXIgcmUgPSByZWRpcmVjdDtcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xuICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuICAgIHF1ZXJ5ID0gcmUuaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykgPyByZS5xdWVyeSA6IHF1ZXJ5O1xuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuICAgICAgdmFyIHRhcmdldFJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgIC8vIDEuIHJlc29sdmUgcmVsYXRpdmUgcmVkaXJlY3RcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG4gICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICBwYXRobmFtZVxuKSB7XG4gIHZhciByZWYgPSBnZXRSb3V0ZVJlZ2V4KHBhdGgpO1xuICB2YXIgcmVnZXhwID0gcmVmLnJlZ2V4cDtcbiAgdmFyIGtleXMgPSByZWYua2V5cztcbiAgdmFyIG0gPSBwYXRobmFtZS5tYXRjaChyZWdleHApO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV07XG4gICAgaWYgKGtleSkgeyBwYXJhbXNba2V5Lm5hbWVdID0gdmFsOyB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVjb3JkUGF0aCAocGF0aCwgcmVjb3JkKSB7XG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxufVxuXG4vKiAgKi9cblxuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICBwb3NpdGlvblN0b3JlW2tleV0gPSB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gcG9zaXRpb25TdG9yZVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCkge1xuICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3BcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqLngpIHx8IGlzTnVtYmVyKG9iai55KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlciAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInXG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICB9XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgIGlmICghdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIGNiKHJvdXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgb25BYm9ydCk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7IG9uQWJvcnQgJiYgb25BYm9ydCgpOyB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xuICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpID8gdGhpcyQxLnJlcGxhY2UodG8pIDogdGhpcyQxLnB1c2godG8pO1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICBuZXh0KHRvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zdEVudGVyQ2JzID0gW107XG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY3VycmVudCA9PT0gcm91dGU7IH07XG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHJ1blF1ZXVlKGVudGVyR3VhcmRzLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBWdWUgb3B0aW9ucyBhdHRhY2hlZCxcbiAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgLy8gd2Ugd2FudCB0byBoYWx0IHRoZSBuYXZpZ2F0aW9uIHVudGlsIHRoZSBpbmNvbWluZyBjb21wb25lbnQgaGFzIGJlZW5cbiAgICAvLyByZXNvbHZlZC5cbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZGVmLm9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIG5leHQpIHtcbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHdhcm4oZmFsc2UsIChcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbikpO1xuICAgICAgICAgIG5leHQoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZmxhdE1hcENvbXBvbmVudHMgKFxuICBtYXRjaGVkLFxuICBmblxuKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxuICAgICAgbS5jb21wb25lbnRzW2tleV0sXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxuICAgICAgbSwga2V5XG4gICAgKTsgfSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIHRoaXMkMS5jdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIHRoaXMkMS5jdXJyZW50LCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgdGhpcyQxLmN1cnJlbnQsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG5cbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcbiAgICApO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpO1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc2xpY2UoaW5kZXggKyAxKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoIChwYXRoKSB7XG4gIHZhciBpID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBpID49IDAgPyBpIDogMCkgKyAnIycgKyBwYXRoXG4gICk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xuICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZToge30gfTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoZXIubWF0Y2gocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jdXJyZW50Um91dGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxuICAgIFwibm90IGluc3RhbGxlZC4gTWFrZSBzdXJlIHRvIGNhbGwgYFZ1ZS51c2UoVnVlUm91dGVyKWAgXCIgK1xuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcbiAgKTtcblxuICB0aGlzLmFwcHMucHVzaChhcHApO1xuXG4gIC8vIG1haW4gYXBwIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gIGlmICh0aGlzLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5hcHAgPSBhcHA7XG5cbiAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG5cbiAgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIVE1MNUhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSGFzaEhpc3RvcnkpIHtcbiAgICB2YXIgc2V0dXBIYXNoTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoaXN0b3J5LnNldHVwTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhcbiAgICAgIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCksXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lcixcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHRoaXMkMS5hcHBzLmZvckVhY2goZnVuY3Rpb24gKGFwcCkge1xuICAgICAgYXBwLl9yb3V0ZSA9IHJvdXRlO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uIGJlZm9yZUVhY2ggKGZuKSB7XG4gIHRoaXMuYmVmb3JlSG9va3MucHVzaChmbik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcbiAgdGhpcy5hZnRlckhvb2tzLnB1c2goZm4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnB1c2gobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxuICAgIDogdGhpcy5jdXJyZW50Um91dGU7XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbS5jb21wb25lbnRzW2tleV1cbiAgICB9KVxuICB9KSlcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxuICB0byxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24odG8sIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsIGFwcGVuZCk7XG4gIHZhciByb3V0ZSA9IHRoaXMubWF0Y2gobG9jYXRpb24sIGN1cnJlbnQpO1xuICB2YXIgZnVsbFBhdGggPSByb3V0ZS5yZWRpcmVjdGVkRnJvbSB8fCByb3V0ZS5mdWxsUGF0aDtcbiAgdmFyIGJhc2UgPSB0aGlzLmhpc3RvcnkuYmFzZTtcbiAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGJhc2UsIGZ1bGxQYXRoLCB0aGlzLm1vZGUpO1xuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICByb3V0ZTogcm91dGUsXG4gICAgaHJlZjogaHJlZixcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIG5vcm1hbGl6ZWRUbzogbG9jYXRpb24sXG4gICAgcmVzb2x2ZWQ6IHJvdXRlXG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgdGhpcy5tYXRjaGVyLmFkZFJvdXRlcyhyb3V0ZXMpO1xuICBpZiAodGhpcy5oaXN0b3J5LmN1cnJlbnQgIT09IFNUQVJUKSB7XG4gICAgdGhpcy5oaXN0b3J5LnRyYW5zaXRpb25Ubyh0aGlzLmhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlUm91dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhyZWYgKGJhc2UsIGZ1bGxQYXRoLCBtb2RlKSB7XG4gIHZhciBwYXRoID0gbW9kZSA9PT0gJ2hhc2gnID8gJyMnICsgZnVsbFBhdGggOiBmdWxsUGF0aDtcbiAgcmV0dXJuIGJhc2UgPyBjbGVhblBhdGgoYmFzZSArICcvJyArIHBhdGgpIDogcGF0aFxufVxuXG5WdWVSb3V0ZXIuaW5zdGFsbCA9IGluc3RhbGw7XG5WdWVSb3V0ZXIudmVyc2lvbiA9ICcyLjIuMSc7XG5cbmlmIChpbkJyb3dzZXIgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShWdWVSb3V0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWdWVSb3V0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCIvKiFcbiAqIHZ1ZS1icmVhZGNydW1icyB2MC4zLjFcbiAqIChjKSAyMDE2IFNhbSBUdXJyZWxsXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBnbG9iYWwuVnVlQnJlYWRjcnVtYnMgPSBmYWN0b3J5KCk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHBsdWdpbihWdWUpIHtcblx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFZ1ZS5wcm90b3R5cGUuJGJyZWFkY3J1bWJzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjcnVtYnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHJvdXRlLm1hdGNoZWQubGVuZ3RoOyBpKyspIHtcblx0XHQgIGlmICh0aGlzLiRyb3V0ZS5tYXRjaGVkW2ldLm1ldGEgJiYgdGhpcy4kcm91dGUubWF0Y2hlZFtpXS5tZXRhLmJyZWFkY3J1bWIpIHtcblx0XHRcdGNydW1icy5wdXNoKHRoaXMuJHJvdXRlLm1hdGNoZWRbaV0pO1xuXHRcdCAgfVxuXHRcdH1cblx0XHRyZXR1cm4gY3J1bWJzO1xuXHR9XG5cblx0VnVlLmNvbXBvbmVudCgnYnJlYWRjcnVtYnMnLCB7XG5cdCAgdGVtcGxhdGU6ICc8b2wgY2xhc3M9XCJicmVhZGNydW1iXCIgdi1pZj1cIiRicmVhZGNydW1icy5sZW5ndGhcIj4gPGxpIGNsYXNzPVwiYnJlYWRjcnVtYi1pdGVtXCIgdi1mb3I9XCIoY3J1bWIsIGkpIGluICRicmVhZGNydW1ic1wiPiA8cm91dGVyLWxpbmsgOnRvPVwiIHsgcGF0aDogY3J1bWIucGF0aCB9XCI+e3sgY3J1bWIubWV0YS5icmVhZGNydW1iIH19PC9yb3V0ZXItbGluaz4gPC9saT4gPC9vbD4nXG5cdH0pO1xuICB9XG5cbiAgcGx1Z2luLnZlcnNpb24gPSAnMC4zLjEnO1xuXG4gIHJldHVybiBwbHVnaW47XG5cbn0pKTsqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVnVlLnByb3RvdHlwZSwge1xuXHRcdFx0JGJyZWFkY3J1bWJzOiB7XG5cdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy4kcm91dGUubWF0Y2hlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRWdWUuY29tcG9uZW50KCdicmVhZGNydW1icycsIHtcblx0XHRcdHRlbXBsYXRlOiBgXG5cdFx0XHRcdDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIiB2LWlmPVwiJGJyZWFkY3J1bWJzLmxlbmd0aFwiPlxuXHRcdFx0XHRcdDxsaSBjbGFzcz1cImJyZWFkY3J1bWItaXRlbVwiIHYtZm9yPVwiKGNydW1iLCBpKSBpbiAkYnJlYWRjcnVtYnNcIj5cblx0XHRcdFx0XHRcdDxyb3V0ZXItbGluayA6dG89XCIgeyBwYXRoOiBjcnVtYi5wYXRoIH1cIj5cblx0XHRcdFx0XHRcdFx0e3sgY3J1bWIubWV0YS5icmVhZGNydW1iIH19XG5cdFx0XHRcdFx0XHQ8L3JvdXRlci1saW5rPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDwvb2w+YFxuXHRcdH0pXG5cdH1cbn1cblxuLypleHBvcnQgZGVmYXVsdCB7XG5cdGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG5cdFx0VnVlLnByb3RvdHlwZS4kYnJlYWRjcnVtYnMgPSB0aGlzLiRyb290O1xuXG5cdFx0VnVlLmNvbXBvbmVudCgnYnJlYWRjcnVtYnMnLCB7XG5cdFx0XHR0ZW1wbGF0ZTogYDxoMj57eyAkYnJlYWRjcnVtYnMgfX08L2gyPmBcblx0XHR9KVxuXHR9XG59Ki9cblxuLypjb25zdCBNeVBsdWdpbiA9IHtcbiAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICBWdWUubXlBZGRlZFByb3BlcnR5ID0gJ0V4YW1wbGUgUHJvcGVydHknXG4gICAgVnVlLm15QWRkZWRNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgIFx0ICByZXR1cm4gVnVlLm15QWRkZWRQcm9wZXJ0eVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTXlQbHVnaW47Ki9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3Z1ZTItYnJlYWRjcnVtYnMvZGlzdC92dWUtYnJlYWRjcnVtYnMuanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi4yLjVcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBjb25maWcgPSB7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG59O1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09IFwiPEFub255bW91cz5cIikge1xuICAgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiO1xuICAgIH1cbiAgICByZXR1cm4gKFwiXFxuKGZvdW5kIGluIFwiICsgc3RyICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIDogcmVzXG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgZXh0ZW5kc0Zyb20gPT09ICdmdW5jdGlvbidcbiAgICAgID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pXG4gICAgICA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSQzKSB7XG4gICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnbnVtYmVyJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQm9vbGVhbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnRnVuY3Rpb24nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFjdXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIW9sZCkge1xuICAgICAgaWYgKCFjdXIuZm5zKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmICghb2xkSG9vaykge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvbGRIb29rLmZucyAmJiBvbGRIb29rLm1lcmdlZCkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGMgPT0gbnVsbCB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgbGFzdC50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMudGV4dCAmJiBsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoYy50YWcgJiYgYy5rZXkgPT0gbnVsbCAmJiBuZXN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIGMuY29tcG9uZW50T3B0aW9uczsgfSlbMF1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIHZhciBuYW1lLCBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnNcbikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzW2Zuc1tpXVswXV0gPSBmbnNbaV1bMV07XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgcXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQsIHZtO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBzY2hlZHVsZXIgYmVmb3JlIHVwZGF0ZWQgaG9vayBjYWxsZWRcbiAgdmFyIG9sZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IG9sZFF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gb2xkUXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+PSAwICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoTWF0aC5tYXgoaSwgaW5kZXgpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoIUN0b3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGlmICghQ3Rvci5jaWQpIHtcbiAgICBpZiAoQ3Rvci5yZXNvbHZlZCkge1xuICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoQ3RvciwgYmFzZUN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaXQncyBvayB0byBxdWV1ZSB0aGlzIG9uIGV2ZXJ5IHJlbmRlciBiZWNhdXNlXG4gICAgICAgIC8vICRmb3JjZVVwZGF0ZSBpcyBidWZmZXJlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIUN0b3IpIHtcbiAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoZGF0YS5tb2RlbCkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yLCB0YWcpIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcE9wdGlvbnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIHZhciBkb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHM7XG4gIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWxhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5KSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgZG9tUHJvcHMsIGtleSwgYWx0S2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChoYXNoKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChvbltldmVudF0pIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIGluamVjdCA9IHZtLiRvcHRpb25zLmluamVjdDtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgLy8gaXNBcnJheSBoZXJlXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGluamVjdCk7XG4gICAgdmFyIGtleXMgPSBpc0FycmF5XG4gICAgICA/IGluamVjdFxuICAgICAgOiBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMi41JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5hdHRycyAmJiAhdm5vZGUuZGF0YS5hdHRycykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGF0dHJzLl9fb2JfXykge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoYXR0cnNba2V5XSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXG4gICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudFxuKSB7XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyB2YWx1ZSArIFwiPSQkY31cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG9uW1JBTkdFX1RPS0VOXSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UsXG4gIGNhcHR1cmVcbikge1xuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAocHJvcHMuX19vYl9fKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2VudGVyQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fbGVhdmVDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdExlYXZlRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmICghZm4pIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpbnZva2VyRm5zKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgICBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChldmVudHMsIG5hdGl2ZSkge1xuICB2YXIgcmVzID0gbmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMyk7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICB3YXJuJDMoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0pOyB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChrZXksIGVsKSB7XG4gIHJldHVybiBcIltcIiArIGtleSArIFwiLGZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwpKSArIFwifV1cIlxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBlbCQxLmZvciAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvbkNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0aXBzID0gW107XG4gICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXAkJDEpIHtcbiAgICAgICh0aXAkJDEgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgIH1cbiAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgcmV0dXJuIGNvbXBpbGVkXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICB2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0sIGZuR2VuRXJyb3JzKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldID0gcmVzKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBjb21waWxlLFxuICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY29tcGlsZVRvRnVuY3Rpb25zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQyXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICBudWxsLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xZmE2NmViOFxcXCJ9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9ob21lLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRDpcXFxcc2FuZC1ib3hcXFxcZ2l0XFxcXHZ1ZS1yXFxcXHNyY1xcXFxob21lLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGhvbWUudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTFmYTY2ZWI4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMWZhNjZlYjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaG9tZS52dWVcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL34vd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcic7XG5pbXBvcnQgSG9tZSBmcm9tICcuL2hvbWUudnVlJztcbmltcG9ydCBWdWVCcmVhZGNydW1icyBmcm9tICd2dWUyLWJyZWFkY3J1bWJzJztcblxuVnVlLnVzZShWdWVSb3V0ZXIpO1xuVnVlLnVzZShWdWVCcmVhZGNydW1icyk7XG5cbmNvbnN0IEZlZWRzID0geyB0ZW1wbGF0ZTogJzxkaXY+PGgxPkZlZWRzPC9oMT4gPHJvdXRlci12aWV3Lz48L2Rpdj4nIH07XG5jb25zdCBGb28gPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+Zm9vPC9oMj48cD5Mb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gSXBzYSB2b2x1cHRhdGUgcXVpYSBxdWFzIGFzc3VtZW5kYSBiZWF0YWUgdmVybz8gT21uaXMsIHByYWVzZW50aXVtLiBNYWduaSBuZXNjaXVudCBhbGlhcyBlbGlnZW5kaSBzdXNjaXBpdCB2ZWwgZG9sb3IgYWNjdXNhbnRpdW0sIGl0YXF1ZSBwb3NzaW11cyBudWxsYSBtYWlvcmVzIG5vc3RydW0uPC9wPjwvZGl2PicgfTtcbmNvbnN0IEJhciA9IHsgdGVtcGxhdGU6ICc8ZGl2PjxoMj5CYXI8L2gyPjxwPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBJcHNhIHZvbHVwdGF0ZSBxdWlhIHF1YXMgYXNzdW1lbmRhIGJlYXRhZSB2ZXJvPyBPbW5pcywgcHJhZXNlbnRpdW0uIE1hZ25pIG5lc2NpdW50IGFsaWFzIGVsaWdlbmRpIHN1c2NpcGl0IHZlbCBkb2xvciBhY2N1c2FudGl1bSwgaXRhcXVlIHBvc3NpbXVzIG51bGxhIG1haW9yZXMgbm9zdHJ1bS48L3A+PC9kaXY+JyB9O1xuXG5jb25zdCByb3V0ZXIgPSBuZXcgVnVlUm91dGVyKHtcbiAgcm91dGVzOiBbXG4gIFx0eyBwYXRoOiAnLycsIHJlZGlyZWN0OiAnL2ZlZWRzJyB9LFxuICAgIHtcbiAgICBcdHBhdGg6ICcvZmVlZHMnLFxuICAgIFx0Y29tcG9uZW50OiBGZWVkcyxcbiAgICBcdG1ldGE6IHtcblx0ICAgICAgYnJlYWRjcnVtYjogJ0ZlZWRzJ1xuXHQgICAgfSxcbiAgICBcdGNoaWxkcmVuOiBbXG4gICAgXHRcdHtcbiAgICBcdFx0XHRwYXRoOiAnZm9vJyxcbiAgICBcdFx0XHRjb21wb25lbnQ6IEZvbyxcblx0XHQgICAgXHRtZXRhOiB7XG5cdFx0XHQgICAgICBicmVhZGNydW1iOiAnZm9vJ1xuXHRcdFx0ICAgIH1cbiAgICBcdFx0fSxcbiAgICBcdFx0e1xuICAgIFx0XHRcdHBhdGg6ICdiYXInLFxuICAgIFx0XHRcdGNvbXBvbmVudDogQmFyLFxuXHRcdCAgICBcdG1ldGE6IHtcblx0XHRcdCAgICAgIGJyZWFkY3J1bWI6ICdiYXInXG5cdFx0XHQgICAgfVxuICAgIFx0XHR9XG4gICAgXHRdXG4gICAgfVxuICBdXG59KTtcblxubmV3IFZ1ZSh7XG4gIHJvdXRlcixcbiAgY29tcG9uZW50czoge1xuICAgIEhvbWU6IEhvbWVcbiAgfSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGlkPVwiYXBwXCIgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgIDx1bCBjbGFzcz1cIm5hdlwiPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSAgZHJvcGRvd25cIj5cbiAgICAgICAgXHQ8cm91dGVyLWxpbmsgdG89XCIvZmVlZHNcIiBjbGFzcz1cIm5hdi1saW5rIGRyb3Bkb3duLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiByb2xlPVwiYnV0dG9uXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5GZWVkczwvcm91dGVyLWxpbms+XG4gICAgICAgIFx0PGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj5cblx0XHRcdFx0PHJvdXRlci1saW5rIHRvPVwiL2ZlZWRzL2Zvb1wiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPkZvbzwvcm91dGVyLWxpbms+XG5cdFx0XHRcdDxyb3V0ZXItbGluayB0bz1cIi9mZWVkcy9iYXJcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIj5CYXI8L3JvdXRlci1saW5rPlxuICAgICAgICBcdDwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgPC91bD5cbiAgICAgIDxicmVhZGNydW1icy8+XG4gICAgICA8cm91dGVyLXZpZXcvPlxuICAgICAgPGhyPlxuICAgICAgPEhvbWUvPlxuICAgIDwvZGl2PlxuICBgXG59KS4kbW91bnQoJyNhcHAnKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwLmpzIiwiLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgc2NvcGVJZCxcbiAgY3NzTW9kdWxlc1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgLy8gaW5qZWN0IGNzc01vZHVsZXNcbiAgaWYgKGNzc01vZHVsZXMpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuY29tcHV0ZWQgfHwgbnVsbClcbiAgICBPYmplY3Qua2V5cyhjc3NNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBjc3NNb2R1bGVzW2tleV1cbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxuICAgIH0pXG4gICAgb3B0aW9ucy5jb21wdXRlZCA9IGNvbXB1dGVkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX3ZtLl9tKDApXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnaDMnLCBbX3ZtLl92KFwiSG9tZSBjb21wb25lbnRcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlbmlhbSBtb2xlc3RpYXMgYXBlcmlhbSBvZGl0IHNpdCBoYXJ1bSBxdWFtLCBsYWJvcnVtIG1hZ25hbS4gVmVyaXRhdGlzIGl0YXF1ZSB0ZW1wb3JpYnVzIHZpdGFlIGJlYXRhZSBxdWFtIGVhcXVlIHZvbHVwdGF0ZW0gYWxpYXMgZW5pbT8gTWF4aW1lLCBpdGFxdWUuIEV2ZW5pZXQuXCIpXSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTFmYTY2ZWI4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTFmYTY2ZWI4XCJ9IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaG9tZS52dWVcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==