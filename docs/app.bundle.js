/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports !== "undefined") {
		factory(exports);
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports);
		global.index = mod.exports;
	}
})(this, function (exports) {
	"use strict";

	(function (global, factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports !== "undefined") {
			factory(exports);
		} else {
			var mod = {
				exports: {}
			};
			factory(mod.exports);
			global.index = mod.exports;
		}
	})(undefined, function (exports) {
		'use strict';

		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = {
			install(Vue) {
				Object.defineProperties(Vue.prototype, {
					$breadcrumbs: {
						get() {
							return this.$route.matched;
						}
					}
				});

				Vue.component('breadcrumbs', {
					template: `<ol class="breadcrumb" v-if="$breadcrumbs.length"><li class="breadcrumb-item" v-if="crumb.meta.breadcrumb" v-for="(crumb, i) in $breadcrumbs"><router-link :to=" { path: crumb.path }">{{ crumb.meta.breadcrumb }}</router-link></li></ol>`
				});
			}
		};
	});
});

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", expecting an object, function or boolean.");
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery) {
  if (extraQuery === void 0) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery;
  } else {
    return extraQuery;
  }
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom) {
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  return (path || '/') + stringifyQuery(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact ? isSameRoute(current, compareTarget) : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  if (relative.charAt(0) === '/') {
    return relative;
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue;
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

/*  */

function createRouteMap(routes, oldPathMap, oldNameMap) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex(path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp };
}

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function normalizeLocation(raw, current, append) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : current && current.path || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = getRouteRegex(record.path).keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(path, params, pathname) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function () {
    onAbort && onAbort();
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || typeof to === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        typeof to === 'object' && to.replace ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () {
      return this$1.current === route;
    };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            return cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  return function boundRouteGuard() {
    return guard.apply(instance, arguments);
  };
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, "Failed to resolve async component " + key + ": " + reason);
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      };
    }
  });
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady(cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
 * Vue.js v2.2.5
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function () {
  return false;
};

/**
 * Return same value
 */
var identity = function (_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  };
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: ['component', 'directive', 'filter'],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return (/native code/.test(Ctor.toString())
  );
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) {
      console.error(err);
    };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        cb.call(ctx);
      }
      if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var formatLocation = function (str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return "\n(found in " + str + ")";
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$3) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = typeof value === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = typeof value === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = typeof value === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = typeof value === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1];
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn("Error in " + info + ":", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function () {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.componentOptions;
  })[0];
}

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // reset scheduler before updated hook called
  var oldQueue = queue.slice();
  resetSchedulerState();

  // call updated hooks
  index = oldQueue.length;
  while (index--) {
    watcher = oldQueue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);
  observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy(vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (!Ctor) {
    return;
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return;
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor, tag);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function () {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function resolveAsyncComponent(factory, baseCtor, cb) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function (res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function (reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved;
  }
}

function extractProps(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the delared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    var loop = function (i) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            defineReactive$$1(vm, key, source._provided[provideKey], function () {
              warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
            });
          } else {
            defineReactive$$1(vm, key, source._provided[provideKey]);
          }
          break;
        }
        source = source.$parent;
      }
    };

    for (var i = 0; i < keys.length; i++) loop(i);
  }
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern instanceof RegExp) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Vue$3.version = '2.2.5';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (parentNode = parentNode.parent) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  var res = '';
  if (!value) {
    return res;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if (stringified = stringifyClass(value[i])) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function sameVnode(a, b) {
  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important) {
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "var $$exp = " + modelRs.exp + ", $$idx = " + modelRs.idx + ";" + "if (!Array.isArray($$exp)){" + value + "=" + assignment + "}" + "else{$$exp.splice($$idx, 1, " + assignment + ")}";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + value + "=$$c}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number || type === 'number') {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, handler, once, capture) {
  if (once) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, handler, capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (modifiers && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return;
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm();
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (!fn) {
    return false;
  }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  return (/\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null
  );
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function () {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\">";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var decoder;

function decode(html) {
  decoder = decoder || document.createElement('div');
  decoder.innerHTML = html;
  return decoder.textContent;
}

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
// attr value double quotes
/"([^"]*)"+/.source,
// attr value, single quotes
/'([^']*)'+/.source,
// attr value, no quotes
/([^\s"'=<>`]+)/.source];
var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          continue;
        }
      }

      var text = void 0,
          rest$1 = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest$1 = html.slice(textEnd);
        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {
          // < in plain text, be forgiving and treat it as text
          next = rest$1.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest$1 = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var endTagLength = 0;
      var rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest.length;
      html = rest;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformGetTagNamespace = options.getTagNamespace || no;
  platformMustUseProp = options.mustUseProp || no;
  platformIsPreTag = options.isPreTag || no;
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
        }
        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      walkThroughConditionsBlocks(node.ifConditions, isInFor);
    }
  }
}

function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
    markStaticRoots(conditionBlocks[i].block, isInFor);
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, native) {
  var res = native ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  bind: bind$1,
  cloak: noop
};

/*  */

// configurable state
var warn$3;
var transforms$1;
var dataGenFns;
var platformDirectives$1;
var isPlatformReservedTag$1;
var staticRenderFns;
var onceCount;
var currentOptions;

function generate(ast, options) {
  // save previous staticRenderFns so generate calls can be nested
  var prevStaticRenderFns = staticRenderFns;
  var currentStaticRenderFns = staticRenderFns = [];
  var prevOnceCount = onceCount;
  onceCount = 0;
  currentOptions = options;
  warn$3 = options.warn || baseWarn;
  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
  dataGenFns = pluckModuleFunction(options.modules, 'genData');
  platformDirectives$1 = options.directives || {};
  isPlatformReservedTag$1 = options.isReservedTag || no;
  var code = ast ? genElement(ast) : '_c("div")';
  staticRenderFns = prevStaticRenderFns;
  onceCount = prevOnceCount;
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: currentStaticRenderFns
  };
}

function genElement(el) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el);
  } else if (el.for && !el.forProcessed) {
    return genFor(el);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el);
    } else {
      var data = el.plain ? undefined : genData(el);

      var children = el.inlineTemplate ? null : genChildren(el, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < transforms$1.length; i++) {
      code = transforms$1[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el) {
  el.staticProcessed = true;
  staticRenderFns.push("with(this){return " + genElement(el) + "}");
  return "_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && warn$3("v-once can only be used inside v-for that is keyed. ");
      return genElement(el);
    }
    return "_o(" + genElement(el) + "," + onceCount++ + (key ? "," + key : "") + ")";
  } else {
    return genStatic(el);
  }
}

function genIf(el) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice());
}

function genIfConditions(conditions) {
  if (!conditions.length) {
    return '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return el.once ? genOnce(el) : genElement(el);
  }
}

function genFor(el) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    warn$3("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genElement(el) + '})';
}

function genData(el) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < dataGenFns.length; i++) {
    data += dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  return data;
}

function genDirectives(el) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, warn$3);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
    warn$3('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, currentOptions);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key]);
  }).join(',') + "])";
}

function genScopedSlot(key, el) {
  return "[" + key + ",function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + "}]";
}

function genChildren(el, checkSkip) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return genElement(el$1);
    }
    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
    return "[" + children.map(genNode).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function maybeComponent(el) {
  return !isPlatformReservedTag$1(el.tag);
}

function genNode(node) {
  if (node.type === 1) {
    return genElement(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genSlot(el) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el) {
  var children = el.inlineTemplate ? null : genChildren(el, true);
  return "_c(" + componentName + "," + genData(el) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
  if (keywordMatch) {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

function makeFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompiler(baseOptions) {
  var functionCompileCache = Object.create(null);

  function compile(template, options) {
    var finalOptions = Object.create(baseOptions);
    var errors = [];
    var tips = [];
    finalOptions.warn = function (msg, tip$$1) {
      (tip$$1 ? tips : errors).push(msg);
    };

    if (options) {
      // merge custom modules
      if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
      }
      // copy other options
      for (var key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key];
        }
      }
    }

    var compiled = baseCompile(template, finalOptions);
    if (process.env.NODE_ENV !== 'production') {
      errors.push.apply(errors, detectErrors(compiled.ast));
    }
    compiled.errors = errors;
    compiled.tips = tips;
    return compiled;
  }

  function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (functionCompileCache[key]) {
      return functionCompileCache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = makeFunction(compiled.render, fnGenErrors);
    var l = compiled.staticRenderFns.length;
    res.staticRenderFns = new Array(l);
    for (var i = 0; i < l; i++) {
      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
    }

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return functionCompileCache[key] = res;
  }

  return {
    compile: compile,
    compileToFunctions: compileToFunctions
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData$1
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$2(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$2
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

/* harmony default export */ __webpack_exports__["default"] = (Vue$3);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(5)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(7)(
  /* script */
  null,
  /* template */
  __webpack_require__(8),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "D:\\sand-box\\git\\vue-r\\src\\home.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] home.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1fa66eb8", Component.options)
  } else {
    hotAPI.reload("data-v-1fa66eb8", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(3);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(2);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _home = __webpack_require__(4);

var _home2 = _interopRequireDefault(_home);

var _vue2Breadcrumbs = __webpack_require__(1);

var _vue2Breadcrumbs2 = _interopRequireDefault(_vue2Breadcrumbs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);
_vue2.default.use(_vue2Breadcrumbs2.default);

const Feeds = { template: '<div><router-view/></div>' };
const Biz = { template: '<div><h2>Biz</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };
const Foo = { template: '<div><h2>Foo</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };
const Bar = { template: '<div><h2>Bar</h2><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ipsa voluptate quia quas assumenda beatae vero? Omnis, praesentium. Magni nesciunt alias eligendi suscipit vel dolor accusantium, itaque possimus nulla maiores nostrum.</p></div>' };

const router = new _vueRouter2.default({
	routes: [{ path: '/', redirect: '/feeds' }, {
		path: '/feeds',
		component: Feeds,
		meta: {
			breadcrumb: 'Feeds'
		},
		children: [{
			path: '',
			component: Biz
		}, {
			path: 'foo',
			component: Foo,
			meta: {
				breadcrumb: 'foo'
			}
		}, {
			path: 'bar',
			component: Bar,
			meta: {
				breadcrumb: 'bar'
			}
		}]
	}]
});

new _vue2.default({
	router,
	components: {
		Home: _home2.default
	},
	template: `
		<div id="app" class="container">
			<ul class="nav">
				<li class="nav-item  dropdown">
					<router-link to="/feeds" class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Feeds</router-link>
					<div class="dropdown-menu">
				<router-link to="/feeds/foo" class="dropdown-item">Foo</router-link>
				<router-link to="/feeds/bar" class="dropdown-item">Bar</router-link>
					</div>
				</li>
			</ul>
			<breadcrumbs/>
			<router-view/>
			<hr>
			<Home/>
		</div>
	`
}).$mount('#app');

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('h3', [_vm._v("Home component")]), _vm._v(" "), _c('p', [_vm._v("Lorem ipsum dolor sit amet, consectetur adipisicing elit. Veniam molestias aperiam odit sit harum quam, laborum magnam. Veritatis itaque temporibus vitae beatae quam eaque voluptatem alias enim? Maxime, itaque. Eveniet.")])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-1fa66eb8", module.exports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTBlNjdlMzgxN2MxOTExYWJjNGQiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3Z1ZS0yLWJyZWFkY3J1bWJzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ob21lLnZ1ZSIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9ob21lLnZ1ZT9jZTZmIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJiaW5kaW5nIiwibmFtZSIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJnbG9iYWwiLCJmYWN0b3J5IiwiZGVmaW5lIiwibW9kIiwiaW5kZXgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVmYXVsdCIsImluc3RhbGwiLCJWdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiJGJyZWFkY3J1bWJzIiwiZ2V0IiwiJHJvdXRlIiwibWF0Y2hlZCIsImNvbXBvbmVudCIsInRlbXBsYXRlIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIndhcm4iLCJjb25zb2xlIiwiVmlldyIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJyZW5kZXIiLCJoIiwicmVmIiwiY2hpbGRyZW4iLCJwYXJlbnQiLCJkYXRhIiwicm91dGVyVmlldyIsInJvdXRlIiwiY2FjaGUiLCJfcm91dGVyVmlld0NhY2hlIiwiZGVwdGgiLCJpbmFjdGl2ZSIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJjb21wb25lbnRzIiwiaG9va3MiLCJob29rIiwiaW5pdCIsInZub2RlIiwiaW5zdGFuY2VzIiwiY2hpbGQiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiZGVzdHJveSIsInVuZGVmaW5lZCIsInJlc29sdmVQcm9wcyIsImNvbmZpZyIsInBhcmFtcyIsInBhdGgiLCJlbmNvZGVSZXNlcnZlUkUiLCJlbmNvZGVSZXNlcnZlUmVwbGFjZXIiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJwYXJzZWRRdWVyeSIsInBhcnNlUXVlcnkiLCJOT0RFX0VOViIsImtleSIsInJlcyIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJ2YWwiLCJqb2luIiwiaXNBcnJheSIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwia2V5cyIsIm1hcCIsInJlc3VsdCIsInNsaWNlIiwidmFsMiIsImZpbHRlciIsIngiLCJ0cmFpbGluZ1NsYXNoUkUiLCJjcmVhdGVSb3V0ZSIsInJlY29yZCIsImxvY2F0aW9uIiwicmVkaXJlY3RlZEZyb20iLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsIlNUQVJUIiwidW5zaGlmdCIsImlzU2FtZVJvdXRlIiwiYSIsImIiLCJpc09iamVjdEVxdWFsIiwiYUtleXMiLCJiS2V5cyIsImV2ZXJ5IiwiaXNJbmNsdWRlZFJvdXRlIiwiY3VycmVudCIsInRhcmdldCIsImluZGV4T2YiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwidG8iLCJyZXF1aXJlZCIsInRhZyIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsImFjdGl2ZUNsYXNzIiwiZXZlbnQiLCJ0aGlzJDEiLCJyb3V0ZXIiLCIkcm91dGVyIiwicmVzb2x2ZSIsImhyZWYiLCJjbGFzc2VzIiwib3B0aW9ucyIsImxpbmtBY3RpdmVDbGFzcyIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsImNsaWNrIiwiY2xhc3MiLCJhdHRycyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsImV4dGVuZCIsIl9WdWUiLCJ1dGlsIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImdldEF0dHJpYnV0ZSIsInRlc3QiLCJwcmV2ZW50RGVmYXVsdCIsImluc3RhbGxlZCIsIiRyb290IiwiX3JvdXRlciIsIl9yb3V0ZSIsIm1peGluIiwiYmVmb3JlQ3JlYXRlIiwiJG9wdGlvbnMiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImNyZWF0ZWQiLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJyZXNvbHZlUGF0aCIsInJlbGF0aXZlIiwiYmFzZSIsImNoYXJBdCIsInN0YWNrIiwicG9wIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyc2VQYXRoIiwiaGFzaEluZGV4IiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImNyZWF0ZVJvdXRlTWFwIiwicm91dGVzIiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTWFwIiwiY3JlYXRlIiwibmFtZU1hcCIsImFkZFJvdXRlUmVjb3JkIiwibWF0Y2hBcyIsIm5vcm1hbGl6ZVBhdGgiLCJyZWRpcmVjdCIsImJlZm9yZUVudGVyIiwic29tZSIsImNoaWxkTWF0Y2hBcyIsImFsaWFzIiwiYWxpYXNSb3V0ZSIsImluZGV4JDEiLCJhcnIiLCJpc2FycmF5IiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsInBhcnNlIiwiY29tcGlsZV8xIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb25fMSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cF8xIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsIlJlZ0V4cCIsInRva2VucyIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJleGVjIiwibSIsImVzY2FwZWQiLCJvZmZzZXQiLCJuZXh0IiwicHJlZml4IiwiY2FwdHVyZSIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsInN1YnN0ciIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInRvVXBwZXJDYXNlIiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsInByZXR0eSIsInRva2VuIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENhY2hlIiwiZ2V0Um91dGVSZWdleCIsImhpdCIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsInBhcmFtTmFtZXMiLCJfY3JlYXRlUm91dGUiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsImhhc093blByb3BlcnR5IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwYXRobmFtZSIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiZnJvbSIsImlzUG9wIiwiYXBwIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsIiRuZXh0VGljayIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJpc09iamVjdCIsInNlbGVjdG9yIiwiZWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJpc1ZhbGlkUG9zaXRpb24iLCJub3JtYWxpemVQb3NpdGlvbiIsInNjcm9sbFRvIiwieSIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc051bWJlciIsInYiLCJzdXBwb3J0c1B1c2hTdGF0ZSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIl9rZXkiLCJnZW5LZXkiLCJ0b0ZpeGVkIiwicHVzaFN0YXRlIiwidXJsIiwicmVwbGFjZVN0YXRlIiwicnVuUXVldWUiLCJmbiIsImNiIiwic3RlcCIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicGVuZGluZyIsInJlYWR5IiwicmVhZHlDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwibWF4IiwiTWF0aCIsImV4dHJhY3RHdWFyZHMiLCJyZWNvcmRzIiwiYmluZCIsInJldmVyc2UiLCJndWFyZHMiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJmbGF0dGVuIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiXyIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsInJlc29sdmVkRGVmIiwicmVqZWN0IiwicmVhc29uIiwidGhlbiIsImNhbGxlZCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJnZXRMb2NhdGlvbiIsIl9fcHJvdG9fXyIsImNvbnN0cnVjdG9yIiwiZ28iLCJuIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwic2VhcmNoIiwiSGFzaEhpc3RvcnkiLCJmYWxsYmFjayIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwicmVzb2x2ZWQiLCJ1c2UiLCJfdG9TdHJpbmciLCJ0b051bWJlciIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwicmVtb3ZlIiwiaXRlbSIsInNwbGljZSIsImhhc093biIsImlzUHJpbWl0aXZlIiwiY2FjaGVkIiwiY2FjaGVkRm4iLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjYXBpdGFsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJjdHgiLCJib3VuZEZuIiwibCIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJfZnJvbSIsIk9CSkVDVF9TVFJJTkciLCJpc1BsYWluT2JqZWN0IiwidG9PYmplY3QiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJzdGF0aWNLZXlzIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImxvb3NlSW5kZXhPZiIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2Fzc2V0VHlwZXMiLCJfbGlmZWN5Y2xlSG9va3MiLCJfbWF4VXBkYXRlQ291bnQiLCJlbXB0eU9iamVjdCIsImlzUmVzZXJ2ZWQiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJoYXNQcm90byIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsImNhbGxiYWNrcyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsIlByb21pc2UiLCJwIiwibG9nRXJyb3IiLCJlcnIiLCJlcnJvciIsImNhdGNoIiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInF1ZXVlTmV4dFRpY2siLCJfcmVzb2x2ZSIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJmb3JtYXRMb2NhdGlvbiIsImluY2x1ZGVGaWxlIiwiX2lzVnVlIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJ1aWQkMSIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJ0b1ZhbCIsImZyb21WYWwiLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJtZXJnZUFzc2V0cyIsIndhdGNoIiwibWV0aG9kcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIlZ1ZSQzIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsImhhbmRsZUVycm9yIiwiaW5mbyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJjb21wb25lbnRJbnN0YW5jZSIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsIm5lc3RlZEluZGV4IiwibGFzdCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwidXNlciIsImV4cHJlc3Npb24iLCJvbGRRdWV1ZSIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5Iiwic3luYyIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJpbnNlcnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJleHRyYWN0UHJvcHMiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwiX2NvbnRleHQiLCJkIiwiY3JlYXRlRWxlbWVudCIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwicmVxdWVzdGVkIiwicGVuZGluZ0NhbGxiYWNrcyIsImRvbVByb3BzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsImZyb21QYXJlbnQiLCJvdXJzIiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJ0cmVlIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZW5kZXJNaXhpbiIsInJlbmRlckVycm9yIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwiaW5qZWN0IiwicHJvdmlkZUtleSIsInVpZCIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiaW5pdFVzZSIsInBsdWdpbiIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJwYXR0ZXJuVHlwZXMiLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsImRlbGV0ZSIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsImdlbkNsYXNzRnJvbURhdGEiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsInNlbGVjdGVkIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaW5QcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJzdWJzdHJpbmciLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImR5bmFtaWNUeXBlIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplIiwicHJlZml4ZXMiLCJ0ZXN0RWwiLCJ1cHBlciIsInByZWZpeGVkIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiTnVtYmVyIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJtb2RlbCQxIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJnZXRWYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwiY29tcCIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJiZWZvcmVVcGRhdGUiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImR5IiwicGxhdGZvcm1Db21wb25lbnRzIiwic2hvdWxkRGVjb2RlIiwiY29udGVudCIsImVuY29kZWQiLCJkaXYiLCJpbm5lckhUTUwiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImRlY29kZXIiLCJodG1sIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImRlY29kZUF0dHIiLCJwYXJzZUhUTUwiLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCQxIiwiY2hhcnMiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiZW5kVGFnTGVuZ3RoIiwicmVzdCIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwibGFzdEluZGV4Iiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluVlByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZWxlbWVudCIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290Iiwid2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIiwiY29uZGl0aW9uQmxvY2tzIiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsInJpZ2h0IiwiZG93biIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInByZXZlbnQiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJ3YXJuJDMiLCJ0cmFuc2Zvcm1zJDEiLCJkYXRhR2VuRm5zIiwicGxhdGZvcm1EaXJlY3RpdmVzJDEiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSIsIm9uY2VDb3VudCIsImN1cnJlbnRPcHRpb25zIiwiZ2VuZXJhdGUiLCJhc3QiLCJwcmV2U3RhdGljUmVuZGVyRm5zIiwiY3VycmVudFN0YXRpY1JlbmRlckZucyIsInByZXZPbmNlQ291bnQiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwibWF5YmVDb21wb25lbnQiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiZ2VuU2NvcGVkU2xvdCIsInNjb3BlIiwiY2hlY2tTa2lwIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwiaWRlbnRSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIkZ1bmN0aW9uIiwiYmFzZUNvbXBpbGUiLCJtYWtlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlciIsImJhc2VPcHRpb25zIiwiZnVuY3Rpb25Db21waWxlQ2FjaGUiLCJmaW5hbE9wdGlvbnMiLCJ0aXBzIiwidGlwJCQxIiwiY29tcGlsZWQiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJmbkdlbkVycm9ycyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhJDEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQyIiwic3R5bGUkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsInJlZiQxIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJldmFsIiwiRmVlZHMiLCJCaXoiLCJGb28iLCJCYXIiLCJicmVhZGNydW1iIiwiSG9tZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQSxJQUFJQSxVQUFVQyxPQUFPQyxPQUFQLEdBQWlCLEVBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsVUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsU0FBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsVUFBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIO0FBQ0EsYUFBWTtBQUNULFFBQUk7QUFDQSxZQUFJLE9BQU9FLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDbENMLCtCQUFtQkssVUFBbkI7QUFDSCxTQUZELE1BRU87QUFDSEwsK0JBQW1CRSxnQkFBbkI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPSSxDQUFQLEVBQVU7QUFDUk4sMkJBQW1CRSxnQkFBbkI7QUFDSDtBQUNELFFBQUk7QUFDQSxZQUFJLE9BQU9LLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDcENOLGlDQUFxQk0sWUFBckI7QUFDSCxTQUZELE1BRU87QUFDSE4saUNBQXFCRyxtQkFBckI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPRSxDQUFQLEVBQVU7QUFDUkwsNkJBQXFCRyxtQkFBckI7QUFDSDtBQUNKLENBbkJBLEdBQUQ7QUFvQkEsU0FBU0ksVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDckIsUUFBSVQscUJBQXFCSyxVQUF6QixFQUFxQztBQUNqQztBQUNBLGVBQU9BLFdBQVdJLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNULHFCQUFxQkUsZ0JBQXJCLElBQXlDLENBQUNGLGdCQUEzQyxLQUFnRUssVUFBcEUsRUFBZ0Y7QUFDNUVMLDJCQUFtQkssVUFBbkI7QUFDQSxlQUFPQSxXQUFXSSxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9ULGlCQUFpQlMsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFNSCxDQUFOLEVBQVE7QUFDTixZQUFJO0FBQ0E7QUFDQSxtQkFBT04saUJBQWlCVSxJQUFqQixDQUFzQixJQUF0QixFQUE0QkQsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNILFNBSEQsQ0FHRSxPQUFNSCxDQUFOLEVBQVE7QUFDTjtBQUNBLG1CQUFPTixpQkFBaUJVLElBQWpCLENBQXNCLElBQXRCLEVBQTRCRCxHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0g7QUFDSjtBQUdKO0FBQ0QsU0FBU0UsZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDN0IsUUFBSVgsdUJBQXVCTSxZQUEzQixFQUF5QztBQUNyQztBQUNBLGVBQU9BLGFBQWFLLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNYLHVCQUF1QkcsbUJBQXZCLElBQThDLENBQUNILGtCQUFoRCxLQUF1RU0sWUFBM0UsRUFBeUY7QUFDckZOLDZCQUFxQk0sWUFBckI7QUFDQSxlQUFPQSxhQUFhSyxNQUFiLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9YLG1CQUFtQlcsTUFBbkIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFPTixDQUFQLEVBQVM7QUFDUCxZQUFJO0FBQ0E7QUFDQSxtQkFBT0wsbUJBQW1CUyxJQUFuQixDQUF3QixJQUF4QixFQUE4QkUsTUFBOUIsQ0FBUDtBQUNILFNBSEQsQ0FHRSxPQUFPTixDQUFQLEVBQVM7QUFDUDtBQUNBO0FBQ0EsbUJBQU9MLG1CQUFtQlMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSDtBQUNKO0FBSUo7QUFDRCxJQUFJQyxRQUFRLEVBQVo7QUFDQSxJQUFJQyxXQUFXLEtBQWY7QUFDQSxJQUFJQyxZQUFKO0FBQ0EsSUFBSUMsYUFBYSxDQUFDLENBQWxCOztBQUVBLFNBQVNDLGVBQVQsR0FBMkI7QUFDdkIsUUFBSSxDQUFDSCxRQUFELElBQWEsQ0FBQ0MsWUFBbEIsRUFBZ0M7QUFDNUI7QUFDSDtBQUNERCxlQUFXLEtBQVg7QUFDQSxRQUFJQyxhQUFhRyxNQUFqQixFQUF5QjtBQUNyQkwsZ0JBQVFFLGFBQWFJLE1BQWIsQ0FBb0JOLEtBQXBCLENBQVI7QUFDSCxLQUZELE1BRU87QUFDSEcscUJBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDRCxRQUFJSCxNQUFNSyxNQUFWLEVBQWtCO0FBQ2RFO0FBQ0g7QUFDSjs7QUFFRCxTQUFTQSxVQUFULEdBQXNCO0FBQ2xCLFFBQUlOLFFBQUosRUFBYztBQUNWO0FBQ0g7QUFDRCxRQUFJTyxVQUFVYixXQUFXUyxlQUFYLENBQWQ7QUFDQUgsZUFBVyxJQUFYOztBQUVBLFFBQUlRLE1BQU1ULE1BQU1LLE1BQWhCO0FBQ0EsV0FBTUksR0FBTixFQUFXO0FBQ1BQLHVCQUFlRixLQUFmO0FBQ0FBLGdCQUFRLEVBQVI7QUFDQSxlQUFPLEVBQUVHLFVBQUYsR0FBZU0sR0FBdEIsRUFBMkI7QUFDdkIsZ0JBQUlQLFlBQUosRUFBa0I7QUFDZEEsNkJBQWFDLFVBQWIsRUFBeUJPLEdBQXpCO0FBQ0g7QUFDSjtBQUNEUCxxQkFBYSxDQUFDLENBQWQ7QUFDQU0sY0FBTVQsTUFBTUssTUFBWjtBQUNIO0FBQ0RILG1CQUFlLElBQWY7QUFDQUQsZUFBVyxLQUFYO0FBQ0FILG9CQUFnQlUsT0FBaEI7QUFDSDs7QUFFRHhCLFFBQVEyQixRQUFSLEdBQW1CLFVBQVVmLEdBQVYsRUFBZTtBQUM5QixRQUFJZ0IsT0FBTyxJQUFJQyxLQUFKLENBQVVDLFVBQVVULE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLFFBQUlTLFVBQVVULE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsYUFBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUN2Q0gsaUJBQUtHLElBQUksQ0FBVCxJQUFjRCxVQUFVQyxDQUFWLENBQWQ7QUFDSDtBQUNKO0FBQ0RmLFVBQU1nQixJQUFOLENBQVcsSUFBSUMsSUFBSixDQUFTckIsR0FBVCxFQUFjZ0IsSUFBZCxDQUFYO0FBQ0EsUUFBSVosTUFBTUssTUFBTixLQUFpQixDQUFqQixJQUFzQixDQUFDSixRQUEzQixFQUFxQztBQUNqQ04sbUJBQVdZLFVBQVg7QUFDSDtBQUNKLENBWEQ7O0FBYUE7QUFDQSxTQUFTVSxJQUFULENBQWNyQixHQUFkLEVBQW1Cc0IsS0FBbkIsRUFBMEI7QUFDdEIsU0FBS3RCLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtzQixLQUFMLEdBQWFBLEtBQWI7QUFDSDtBQUNERCxLQUFLRSxTQUFMLENBQWVULEdBQWYsR0FBcUIsWUFBWTtBQUM3QixTQUFLZCxHQUFMLENBQVN3QixLQUFULENBQWUsSUFBZixFQUFxQixLQUFLRixLQUExQjtBQUNILENBRkQ7QUFHQWxDLFFBQVFxQyxLQUFSLEdBQWdCLFNBQWhCO0FBQ0FyQyxRQUFRc0MsT0FBUixHQUFrQixJQUFsQjtBQUNBdEMsUUFBUXVDLEdBQVIsR0FBYyxFQUFkO0FBQ0F2QyxRQUFRd0MsSUFBUixHQUFlLEVBQWY7QUFDQXhDLFFBQVF5QyxPQUFSLEdBQWtCLEVBQWxCLEMsQ0FBc0I7QUFDdEJ6QyxRQUFRMEMsUUFBUixHQUFtQixFQUFuQjs7QUFFQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCM0MsUUFBUTRDLEVBQVIsR0FBYUQsSUFBYjtBQUNBM0MsUUFBUTZDLFdBQVIsR0FBc0JGLElBQXRCO0FBQ0EzQyxRQUFROEMsSUFBUixHQUFlSCxJQUFmO0FBQ0EzQyxRQUFRK0MsR0FBUixHQUFjSixJQUFkO0FBQ0EzQyxRQUFRZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLFFBQVFpRCxrQkFBUixHQUE2Qk4sSUFBN0I7QUFDQTNDLFFBQVFrRCxJQUFSLEdBQWVQLElBQWY7O0FBRUEzQyxRQUFRbUQsT0FBUixHQUFrQixVQUFVQyxJQUFWLEVBQWdCO0FBQzlCLFVBQU0sSUFBSTlDLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sUUFBUXFELEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQXJELFFBQVFzRCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlqRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQU4sUUFBUXdELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25MQSxFQUFDLFVBQVVDLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLE1BQUksSUFBSixFQUFnRDtBQUMvQ0MsR0FBQSxpQ0FBTyxDQUFDLE9BQUQsQ0FBUCxvQ0FBb0JELE9BQXBCO0FBQUE7QUFBQTtBQUFBO0FBQ0EsR0FGRCxNQUVPLElBQUksT0FBT3hELE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDMUN3RCxXQUFReEQsT0FBUjtBQUNBLEdBRk0sTUFFQTtBQUNOLE9BQUkwRCxNQUFNO0FBQ1QxRCxhQUFTO0FBREEsSUFBVjtBQUdBd0QsV0FBUUUsSUFBSTFELE9BQVo7QUFDQXVELFVBQU9JLEtBQVAsR0FBZUQsSUFBSTFELE9BQW5CO0FBQ0E7QUFDRCxFQVpELGFBWVMsVUFBVUEsT0FBVixFQUFtQjtBQUMzQjs7QUFFQTRELFNBQU9DLGNBQVAsQ0FBc0I3RCxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUM1QzhELFVBQU87QUFEcUMsR0FBN0M7QUFHQTlELFVBQVErRCxPQUFSLEdBQWtCO0FBQ2pCQyxXQUFRQyxHQUFSLEVBQWE7QUFDWkwsV0FBT00sZ0JBQVAsQ0FBd0JELElBQUloQyxTQUE1QixFQUF1QztBQUN0Q2tDLG1CQUFjO0FBQ2JDLFlBQU07QUFDTCxjQUFPLEtBQUtDLE1BQUwsQ0FBWUMsT0FBbkI7QUFDQTtBQUhZO0FBRHdCLEtBQXZDOztBQVFBTCxRQUFJTSxTQUFKLENBQWMsYUFBZCxFQUE2QjtBQUM1QkMsZUFBVztBQURpQixLQUE3QjtBQUdBO0FBYmdCLEdBQWxCO0FBZUEsRUFqQ0Q7Ozs7Ozs7OytDQ0FBO0FBQUE7Ozs7O0FBS0E7O0FBRUEsU0FBU0MsTUFBVCxDQUFpQkMsU0FBakIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQ25DLE1BQUksQ0FBQ0QsU0FBTCxFQUFnQjtBQUNkLFVBQU0sSUFBSXRFLEtBQUosQ0FBVyxrQkFBa0J1RSxPQUE3QixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxJQUFULENBQWVGLFNBQWYsRUFBMEJDLE9BQTFCLEVBQW1DO0FBQ2pDLE1BQUksQ0FBQ0QsU0FBTCxFQUFnQjtBQUNkLFdBQU9HLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVFELElBQVIsQ0FBYyxrQkFBa0JELE9BQWhDLENBQWxDO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJRyxPQUFPO0FBQ1Q1QixRQUFNLGFBREc7QUFFVDZCLGNBQVksSUFGSDtBQUdUQyxTQUFPO0FBQ0w5QixVQUFNO0FBQ0orQixZQUFNQyxNQURGO0FBRUpuQixlQUFTO0FBRkw7QUFERCxHQUhFO0FBU1RvQixVQUFRLFNBQVNBLE1BQVQsQ0FBaUJDLENBQWpCLEVBQW9CQyxHQUFwQixFQUF5QjtBQUMvQixRQUFJTCxRQUFRSyxJQUFJTCxLQUFoQjtBQUNBLFFBQUlNLFdBQVdELElBQUlDLFFBQW5CO0FBQ0EsUUFBSUMsU0FBU0YsSUFBSUUsTUFBakI7QUFDQSxRQUFJQyxPQUFPSCxJQUFJRyxJQUFmOztBQUVBQSxTQUFLQyxVQUFMLEdBQWtCLElBQWxCOztBQUVBLFFBQUl2QyxPQUFPOEIsTUFBTTlCLElBQWpCO0FBQ0EsUUFBSXdDLFFBQVFILE9BQU9sQixNQUFuQjtBQUNBLFFBQUlzQixRQUFRSixPQUFPSyxnQkFBUCxLQUE0QkwsT0FBT0ssZ0JBQVAsR0FBMEIsRUFBdEQsQ0FBWjs7QUFFQTtBQUNBO0FBQ0EsUUFBSUMsUUFBUSxDQUFaO0FBQ0EsUUFBSUMsV0FBVyxLQUFmO0FBQ0EsV0FBT1AsTUFBUCxFQUFlO0FBQ2IsVUFBSUEsT0FBT1EsTUFBUCxJQUFpQlIsT0FBT1EsTUFBUCxDQUFjUCxJQUFkLENBQW1CQyxVQUF4QyxFQUFvRDtBQUNsREk7QUFDRDtBQUNELFVBQUlOLE9BQU9TLFNBQVgsRUFBc0I7QUFDcEJGLG1CQUFXLElBQVg7QUFDRDtBQUNEUCxlQUFTQSxPQUFPVSxPQUFoQjtBQUNEO0FBQ0RULFNBQUtVLGVBQUwsR0FBdUJMLEtBQXZCOztBQUVBO0FBQ0EsUUFBSUMsUUFBSixFQUFjO0FBQ1osYUFBT1YsRUFBRU8sTUFBTXpDLElBQU4sQ0FBRixFQUFlc0MsSUFBZixFQUFxQkYsUUFBckIsQ0FBUDtBQUNEOztBQUVELFFBQUloQixVQUFVb0IsTUFBTXBCLE9BQU4sQ0FBY3VCLEtBQWQsQ0FBZDtBQUNBO0FBQ0EsUUFBSSxDQUFDdkIsT0FBTCxFQUFjO0FBQ1pxQixZQUFNekMsSUFBTixJQUFjLElBQWQ7QUFDQSxhQUFPa0MsR0FBUDtBQUNEOztBQUVELFFBQUliLFlBQVlvQixNQUFNekMsSUFBTixJQUFjb0IsUUFBUTZCLFVBQVIsQ0FBbUJqRCxJQUFuQixDQUE5Qjs7QUFFQTtBQUNBLFFBQUlrRCxRQUFRWixLQUFLYSxJQUFMLEtBQWNiLEtBQUthLElBQUwsR0FBWSxFQUExQixDQUFaO0FBQ0FELFVBQU1FLElBQU4sR0FBYSxVQUFVQyxLQUFWLEVBQWlCO0FBQzVCakMsY0FBUWtDLFNBQVIsQ0FBa0J0RCxJQUFsQixJQUEwQnFELE1BQU1FLEtBQWhDO0FBQ0QsS0FGRDtBQUdBTCxVQUFNTSxRQUFOLEdBQWlCLFVBQVVDLFFBQVYsRUFBb0JKLEtBQXBCLEVBQTJCO0FBQzFDakMsY0FBUWtDLFNBQVIsQ0FBa0J0RCxJQUFsQixJQUEwQnFELE1BQU1FLEtBQWhDO0FBQ0QsS0FGRDtBQUdBTCxVQUFNUSxPQUFOLEdBQWdCLFVBQVVMLEtBQVYsRUFBaUI7QUFDL0IsVUFBSWpDLFFBQVFrQyxTQUFSLENBQWtCdEQsSUFBbEIsTUFBNEJxRCxNQUFNRSxLQUF0QyxFQUE2QztBQUMzQ25DLGdCQUFRa0MsU0FBUixDQUFrQnRELElBQWxCLElBQTBCMkQsU0FBMUI7QUFDRDtBQUNGLEtBSkQ7O0FBTUE7QUFDQXJCLFNBQUtSLEtBQUwsR0FBYThCLGFBQWFwQixLQUFiLEVBQW9CcEIsUUFBUVUsS0FBUixJQUFpQlYsUUFBUVUsS0FBUixDQUFjOUIsSUFBZCxDQUFyQyxDQUFiOztBQUVBLFdBQU9rQyxFQUFFYixTQUFGLEVBQWFpQixJQUFiLEVBQW1CRixRQUFuQixDQUFQO0FBQ0Q7QUFwRVEsQ0FBWDs7QUF1RUEsU0FBU3dCLFlBQVQsQ0FBdUJwQixLQUF2QixFQUE4QnFCLE1BQTlCLEVBQXNDO0FBQ3BDLFVBQVEsT0FBT0EsTUFBZjtBQUNFLFNBQUssV0FBTDtBQUNFO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsYUFBT0EsTUFBUDtBQUNGLFNBQUssVUFBTDtBQUNFLGFBQU9BLE9BQU9yQixLQUFQLENBQVA7QUFDRixTQUFLLFNBQUw7QUFDRSxhQUFPcUIsU0FBU3JCLE1BQU1zQixNQUFmLEdBQXdCSCxTQUEvQjtBQUNGO0FBQ0VqQyxXQUFLLEtBQUwsRUFBYSxnQkFBaUJjLE1BQU11QixJQUF2QixHQUErQixVQUEvQixHQUE2QyxPQUFPRixNQUFwRCxHQUE4RCw2Q0FBM0U7QUFWSjtBQVlEOztBQUVEOztBQUVBLElBQUlHLGtCQUFrQixVQUF0QjtBQUNBLElBQUlDLHdCQUF3QixVQUFVQyxDQUFWLEVBQWE7QUFBRSxTQUFPLE1BQU1BLEVBQUVDLFVBQUYsQ0FBYSxDQUFiLEVBQWdCQyxRQUFoQixDQUF5QixFQUF6QixDQUFiO0FBQTRDLENBQXZGO0FBQ0EsSUFBSUMsVUFBVSxNQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLFNBQVMsVUFBVUMsR0FBVixFQUFlO0FBQUUsU0FBT0MsbUJBQW1CRCxHQUFuQixFQUNsQ0UsT0FEa0MsQ0FDMUJULGVBRDBCLEVBQ1RDLHFCQURTLEVBRWxDUSxPQUZrQyxDQUUxQkosT0FGMEIsRUFFakIsR0FGaUIsQ0FBUDtBQUVILENBRjNCOztBQUlBLElBQUlLLFNBQVNDLGtCQUFiOztBQUVBLFNBQVNDLFlBQVQsQ0FDRUMsS0FERixFQUVFQyxVQUZGLEVBR0U7QUFDQSxNQUFLQSxlQUFlLEtBQUssQ0FBekIsRUFBNkJBLGFBQWEsRUFBYjs7QUFFN0IsTUFBSUQsS0FBSixFQUFXO0FBQ1QsUUFBSUUsV0FBSjtBQUNBLFFBQUk7QUFDRkEsb0JBQWNDLFdBQVdILEtBQVgsQ0FBZDtBQUNELEtBRkQsQ0FFRSxPQUFPeEgsQ0FBUCxFQUFVO0FBQ1ZULGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FBSyxLQUFMLEVBQVlyRSxFQUFFb0UsT0FBZCxDQUF6QztBQUNBc0Qsb0JBQWMsRUFBZDtBQUNEO0FBQ0QsU0FBSyxJQUFJRyxHQUFULElBQWdCSixVQUFoQixFQUE0QjtBQUMxQkMsa0JBQVlHLEdBQVosSUFBbUJKLFdBQVdJLEdBQVgsQ0FBbkI7QUFDRDtBQUNELFdBQU9ILFdBQVA7QUFDRCxHQVpELE1BWU87QUFDTCxXQUFPRCxVQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRSxVQUFULENBQXFCSCxLQUFyQixFQUE0QjtBQUMxQixNQUFJTSxNQUFNLEVBQVY7O0FBRUFOLFVBQVFBLE1BQU1PLElBQU4sR0FBYVgsT0FBYixDQUFxQixXQUFyQixFQUFrQyxFQUFsQyxDQUFSOztBQUVBLE1BQUksQ0FBQ0ksS0FBTCxFQUFZO0FBQ1YsV0FBT00sR0FBUDtBQUNEOztBQUVETixRQUFNUSxLQUFOLENBQVksR0FBWixFQUFpQkMsT0FBakIsQ0FBeUIsVUFBVUMsS0FBVixFQUFpQjtBQUN4QyxRQUFJQyxRQUFRRCxNQUFNZCxPQUFOLENBQWMsS0FBZCxFQUFxQixHQUFyQixFQUEwQlksS0FBMUIsQ0FBZ0MsR0FBaEMsQ0FBWjtBQUNBLFFBQUlILE1BQU1SLE9BQU9jLE1BQU1DLEtBQU4sRUFBUCxDQUFWO0FBQ0EsUUFBSUMsTUFBTUYsTUFBTXZILE1BQU4sR0FBZSxDQUFmLEdBQ055RyxPQUFPYyxNQUFNRyxJQUFOLENBQVcsR0FBWCxDQUFQLENBRE0sR0FFTixJQUZKOztBQUlBLFFBQUlSLElBQUlELEdBQUosTUFBYXZCLFNBQWpCLEVBQTRCO0FBQzFCd0IsVUFBSUQsR0FBSixJQUFXUSxHQUFYO0FBQ0QsS0FGRCxNQUVPLElBQUlqSCxNQUFNbUgsT0FBTixDQUFjVCxJQUFJRCxHQUFKLENBQWQsQ0FBSixFQUE2QjtBQUNsQ0MsVUFBSUQsR0FBSixFQUFTdEcsSUFBVCxDQUFjOEcsR0FBZDtBQUNELEtBRk0sTUFFQTtBQUNMUCxVQUFJRCxHQUFKLElBQVcsQ0FBQ0MsSUFBSUQsR0FBSixDQUFELEVBQVdRLEdBQVgsQ0FBWDtBQUNEO0FBQ0YsR0FkRDs7QUFnQkEsU0FBT1AsR0FBUDtBQUNEOztBQUVELFNBQVNVLGNBQVQsQ0FBeUJDLEdBQXpCLEVBQThCO0FBQzVCLE1BQUlYLE1BQU1XLE1BQU1wRixPQUFPcUYsSUFBUCxDQUFZRCxHQUFaLEVBQWlCRSxHQUFqQixDQUFxQixVQUFVZCxHQUFWLEVBQWU7QUFDbEQsUUFBSVEsTUFBTUksSUFBSVosR0FBSixDQUFWOztBQUVBLFFBQUlRLFFBQVEvQixTQUFaLEVBQXVCO0FBQ3JCLGFBQU8sRUFBUDtBQUNEOztBQUVELFFBQUkrQixRQUFRLElBQVosRUFBa0I7QUFDaEIsYUFBT3BCLE9BQU9ZLEdBQVAsQ0FBUDtBQUNEOztBQUVELFFBQUl6RyxNQUFNbUgsT0FBTixDQUFjRixHQUFkLENBQUosRUFBd0I7QUFDdEIsVUFBSU8sU0FBUyxFQUFiO0FBQ0FQLFVBQUlRLEtBQUosR0FBWVosT0FBWixDQUFvQixVQUFVYSxJQUFWLEVBQWdCO0FBQ2xDLFlBQUlBLFNBQVN4QyxTQUFiLEVBQXdCO0FBQ3RCO0FBQ0Q7QUFDRCxZQUFJd0MsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCRixpQkFBT3JILElBQVAsQ0FBWTBGLE9BQU9ZLEdBQVAsQ0FBWjtBQUNELFNBRkQsTUFFTztBQUNMZSxpQkFBT3JILElBQVAsQ0FBWTBGLE9BQU9ZLEdBQVAsSUFBYyxHQUFkLEdBQW9CWixPQUFPNkIsSUFBUCxDQUFoQztBQUNEO0FBQ0YsT0FURDtBQVVBLGFBQU9GLE9BQU9OLElBQVAsQ0FBWSxHQUFaLENBQVA7QUFDRDs7QUFFRCxXQUFPckIsT0FBT1ksR0FBUCxJQUFjLEdBQWQsR0FBb0JaLE9BQU9vQixHQUFQLENBQTNCO0FBQ0QsR0EzQmUsRUEyQmJVLE1BM0JhLENBMkJOLFVBQVVDLENBQVYsRUFBYTtBQUFFLFdBQU9BLEVBQUVwSSxNQUFGLEdBQVcsQ0FBbEI7QUFBc0IsR0EzQi9CLEVBMkJpQzBILElBM0JqQyxDQTJCc0MsR0EzQnRDLENBQU4sR0EyQm1ELElBM0I3RDtBQTRCQSxTQUFPUixNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBM0I7QUFDRDs7QUFFRDs7QUFFQSxJQUFJbUIsa0JBQWtCLE1BQXRCOztBQUVBLFNBQVNDLFdBQVQsQ0FDRUMsTUFERixFQUVFQyxRQUZGLEVBR0VDLGNBSEYsRUFJRTtBQUNBLE1BQUlsRSxRQUFRO0FBQ1Z4QyxVQUFNeUcsU0FBU3pHLElBQVQsSUFBa0J3RyxVQUFVQSxPQUFPeEcsSUFEL0I7QUFFVjJHLFVBQU9ILFVBQVVBLE9BQU9HLElBQWxCLElBQTJCLEVBRnZCO0FBR1Y1QyxVQUFNMEMsU0FBUzFDLElBQVQsSUFBaUIsR0FIYjtBQUlWNkMsVUFBTUgsU0FBU0csSUFBVCxJQUFpQixFQUpiO0FBS1YvQixXQUFPNEIsU0FBUzVCLEtBQVQsSUFBa0IsRUFMZjtBQU1WZixZQUFRMkMsU0FBUzNDLE1BQVQsSUFBbUIsRUFOakI7QUFPVitDLGNBQVVDLFlBQVlMLFFBQVosQ0FQQTtBQVFWckYsYUFBU29GLFNBQVNPLFlBQVlQLE1BQVosQ0FBVCxHQUErQjtBQVI5QixHQUFaO0FBVUEsTUFBSUUsY0FBSixFQUFvQjtBQUNsQmxFLFVBQU1rRSxjQUFOLEdBQXVCSSxZQUFZSixjQUFaLENBQXZCO0FBQ0Q7QUFDRCxTQUFPaEcsT0FBT3NHLE1BQVAsQ0FBY3hFLEtBQWQsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsSUFBSXlFLFFBQVFWLFlBQVksSUFBWixFQUFrQjtBQUM1QnhDLFFBQU07QUFEc0IsQ0FBbEIsQ0FBWjs7QUFJQSxTQUFTZ0QsV0FBVCxDQUFzQlAsTUFBdEIsRUFBOEI7QUFDNUIsTUFBSXJCLE1BQU0sRUFBVjtBQUNBLFNBQU9xQixNQUFQLEVBQWU7QUFDYnJCLFFBQUkrQixPQUFKLENBQVlWLE1BQVo7QUFDQUEsYUFBU0EsT0FBT25FLE1BQWhCO0FBQ0Q7QUFDRCxTQUFPOEMsR0FBUDtBQUNEOztBQUVELFNBQVMyQixXQUFULENBQXNCM0UsR0FBdEIsRUFBMkI7QUFDekIsTUFBSTRCLE9BQU81QixJQUFJNEIsSUFBZjtBQUNBLE1BQUljLFFBQVExQyxJQUFJMEMsS0FBaEIsQ0FBdUIsSUFBS0EsVUFBVSxLQUFLLENBQXBCLEVBQXdCQSxRQUFRLEVBQVI7QUFDL0MsTUFBSStCLE9BQU96RSxJQUFJeUUsSUFBZixDQUFxQixJQUFLQSxTQUFTLEtBQUssQ0FBbkIsRUFBdUJBLE9BQU8sRUFBUDs7QUFFNUMsU0FBTyxDQUFDN0MsUUFBUSxHQUFULElBQWdCOEIsZUFBZWhCLEtBQWYsQ0FBaEIsR0FBd0MrQixJQUEvQztBQUNEOztBQUVELFNBQVNPLFdBQVQsQ0FBc0JDLENBQXRCLEVBQXlCQyxDQUF6QixFQUE0QjtBQUMxQixNQUFJQSxNQUFNSixLQUFWLEVBQWlCO0FBQ2YsV0FBT0csTUFBTUMsQ0FBYjtBQUNELEdBRkQsTUFFTyxJQUFJLENBQUNBLENBQUwsRUFBUTtBQUNiLFdBQU8sS0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJRCxFQUFFckQsSUFBRixJQUFVc0QsRUFBRXRELElBQWhCLEVBQXNCO0FBQzNCLFdBQ0VxRCxFQUFFckQsSUFBRixDQUFPVSxPQUFQLENBQWU2QixlQUFmLEVBQWdDLEVBQWhDLE1BQXdDZSxFQUFFdEQsSUFBRixDQUFPVSxPQUFQLENBQWU2QixlQUFmLEVBQWdDLEVBQWhDLENBQXhDLElBQ0FjLEVBQUVSLElBQUYsS0FBV1MsRUFBRVQsSUFEYixJQUVBVSxjQUFjRixFQUFFdkMsS0FBaEIsRUFBdUJ3QyxFQUFFeEMsS0FBekIsQ0FIRjtBQUtELEdBTk0sTUFNQSxJQUFJdUMsRUFBRXBILElBQUYsSUFBVXFILEVBQUVySCxJQUFoQixFQUFzQjtBQUMzQixXQUNFb0gsRUFBRXBILElBQUYsS0FBV3FILEVBQUVySCxJQUFiLElBQ0FvSCxFQUFFUixJQUFGLEtBQVdTLEVBQUVULElBRGIsSUFFQVUsY0FBY0YsRUFBRXZDLEtBQWhCLEVBQXVCd0MsRUFBRXhDLEtBQXpCLENBRkEsSUFHQXlDLGNBQWNGLEVBQUV0RCxNQUFoQixFQUF3QnVELEVBQUV2RCxNQUExQixDQUpGO0FBTUQsR0FQTSxNQU9BO0FBQ0wsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTd0QsYUFBVCxDQUF3QkYsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCO0FBQzVCLE1BQUtELE1BQU0sS0FBSyxDQUFoQixFQUFvQkEsSUFBSSxFQUFKO0FBQ3BCLE1BQUtDLE1BQU0sS0FBSyxDQUFoQixFQUFvQkEsSUFBSSxFQUFKOztBQUVwQixNQUFJRSxRQUFRN0csT0FBT3FGLElBQVAsQ0FBWXFCLENBQVosQ0FBWjtBQUNBLE1BQUlJLFFBQVE5RyxPQUFPcUYsSUFBUCxDQUFZc0IsQ0FBWixDQUFaO0FBQ0EsTUFBSUUsTUFBTXRKLE1BQU4sS0FBaUJ1SixNQUFNdkosTUFBM0IsRUFBbUM7QUFDakMsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFPc0osTUFBTUUsS0FBTixDQUFZLFVBQVV2QyxHQUFWLEVBQWU7QUFBRSxXQUFPbEQsT0FBT29GLEVBQUVsQyxHQUFGLENBQVAsTUFBbUJsRCxPQUFPcUYsRUFBRW5DLEdBQUYsQ0FBUCxDQUExQjtBQUEyQyxHQUF4RSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3dDLGVBQVQsQ0FBMEJDLE9BQTFCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QyxTQUNFRCxRQUFRNUQsSUFBUixDQUFhVSxPQUFiLENBQXFCNkIsZUFBckIsRUFBc0MsR0FBdEMsRUFBMkN1QixPQUEzQyxDQUNFRCxPQUFPN0QsSUFBUCxDQUFZVSxPQUFaLENBQW9CNkIsZUFBcEIsRUFBcUMsR0FBckMsQ0FERixNQUVNLENBRk4sS0FHQyxDQUFDc0IsT0FBT2hCLElBQVIsSUFBZ0JlLFFBQVFmLElBQVIsS0FBaUJnQixPQUFPaEIsSUFIekMsS0FJQWtCLGNBQWNILFFBQVE5QyxLQUF0QixFQUE2QitDLE9BQU8vQyxLQUFwQyxDQUxGO0FBT0Q7O0FBRUQsU0FBU2lELGFBQVQsQ0FBd0JILE9BQXhCLEVBQWlDQyxNQUFqQyxFQUF5QztBQUN2QyxPQUFLLElBQUkxQyxHQUFULElBQWdCMEMsTUFBaEIsRUFBd0I7QUFDdEIsUUFBSSxFQUFFMUMsT0FBT3lDLE9BQVQsQ0FBSixFQUF1QjtBQUNyQixhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxJQUFJSSxVQUFVLENBQUMvRixNQUFELEVBQVN0QixNQUFULENBQWQ7QUFDQSxJQUFJc0gsYUFBYSxDQUFDaEcsTUFBRCxFQUFTdkQsS0FBVCxDQUFqQjs7QUFFQSxJQUFJd0osT0FBTztBQUNUakksUUFBTSxhQURHO0FBRVQ4QixTQUFPO0FBQ0xvRyxRQUFJO0FBQ0ZuRyxZQUFNZ0csT0FESjtBQUVGSSxnQkFBVTtBQUZSLEtBREM7QUFLTEMsU0FBSztBQUNIckcsWUFBTUMsTUFESDtBQUVIbkIsZUFBUztBQUZOLEtBTEE7QUFTTHdILFdBQU9DLE9BVEY7QUFVTEMsWUFBUUQsT0FWSDtBQVdMN0QsYUFBUzZELE9BWEo7QUFZTEUsaUJBQWF4RyxNQVpSO0FBYUx5RyxXQUFPO0FBQ0wxRyxZQUFNaUcsVUFERDtBQUVMbkgsZUFBUztBQUZKO0FBYkYsR0FGRTtBQW9CVG9CLFVBQVEsU0FBU0EsTUFBVCxDQUFpQkMsQ0FBakIsRUFBb0I7QUFDMUIsUUFBSXdHLFNBQVMsSUFBYjs7QUFFQSxRQUFJQyxTQUFTLEtBQUtDLE9BQWxCO0FBQ0EsUUFBSWpCLFVBQVUsS0FBS3hHLE1BQW5CO0FBQ0EsUUFBSWdCLE1BQU13RyxPQUFPRSxPQUFQLENBQWUsS0FBS1gsRUFBcEIsRUFBd0JQLE9BQXhCLEVBQWlDLEtBQUtZLE1BQXRDLENBQVY7QUFDQSxRQUFJOUIsV0FBV3RFLElBQUlzRSxRQUFuQjtBQUNBLFFBQUlqRSxRQUFRTCxJQUFJSyxLQUFoQjtBQUNBLFFBQUlzRyxPQUFPM0csSUFBSTJHLElBQWY7QUFDQSxRQUFJQyxVQUFVLEVBQWQ7QUFDQSxRQUFJUCxjQUFjLEtBQUtBLFdBQUwsSUFBb0JHLE9BQU9LLE9BQVAsQ0FBZUMsZUFBbkMsSUFBc0Qsb0JBQXhFO0FBQ0EsUUFBSUMsZ0JBQWdCekMsU0FBUzFDLElBQVQsR0FBZ0J3QyxZQUFZLElBQVosRUFBa0JFLFFBQWxCLENBQWhCLEdBQThDakUsS0FBbEU7QUFDQXVHLFlBQVFQLFdBQVIsSUFBdUIsS0FBS0gsS0FBTCxHQUNuQmxCLFlBQVlRLE9BQVosRUFBcUJ1QixhQUFyQixDQURtQixHQUVuQnhCLGdCQUFnQkMsT0FBaEIsRUFBeUJ1QixhQUF6QixDQUZKOztBQUlBLFFBQUlDLFVBQVUsVUFBVTlMLENBQVYsRUFBYTtBQUN6QixVQUFJK0wsV0FBVy9MLENBQVgsQ0FBSixFQUFtQjtBQUNqQixZQUFJcUwsT0FBT2pFLE9BQVgsRUFBb0I7QUFDbEJrRSxpQkFBT2xFLE9BQVAsQ0FBZWdDLFFBQWY7QUFDRCxTQUZELE1BRU87QUFDTGtDLGlCQUFPL0osSUFBUCxDQUFZNkgsUUFBWjtBQUNEO0FBQ0Y7QUFDRixLQVJEOztBQVVBLFFBQUlqSCxLQUFLLEVBQUU2SixPQUFPRCxVQUFULEVBQVQ7QUFDQSxRQUFJM0ssTUFBTW1ILE9BQU4sQ0FBYyxLQUFLNkMsS0FBbkIsQ0FBSixFQUErQjtBQUM3QixXQUFLQSxLQUFMLENBQVduRCxPQUFYLENBQW1CLFVBQVVqSSxDQUFWLEVBQWE7QUFBRW1DLFdBQUduQyxDQUFILElBQVE4TCxPQUFSO0FBQWtCLE9BQXBEO0FBQ0QsS0FGRCxNQUVPO0FBQ0wzSixTQUFHLEtBQUtpSixLQUFSLElBQWlCVSxPQUFqQjtBQUNEOztBQUVELFFBQUk3RyxPQUFPO0FBQ1RnSCxhQUFPUDtBQURFLEtBQVg7O0FBSUEsUUFBSSxLQUFLWCxHQUFMLEtBQWEsR0FBakIsRUFBc0I7QUFDcEI5RixXQUFLOUMsRUFBTCxHQUFVQSxFQUFWO0FBQ0E4QyxXQUFLaUgsS0FBTCxHQUFhLEVBQUVULE1BQU1BLElBQVIsRUFBYjtBQUNELEtBSEQsTUFHTztBQUNMO0FBQ0EsVUFBSTFCLElBQUlvQyxXQUFXLEtBQUtDLE1BQUwsQ0FBWTVJLE9BQXZCLENBQVI7QUFDQSxVQUFJdUcsQ0FBSixFQUFPO0FBQ0w7QUFDQUEsVUFBRXNDLFFBQUYsR0FBYSxLQUFiO0FBQ0EsWUFBSUMsU0FBU0MsS0FBS0MsSUFBTCxDQUFVRixNQUF2QjtBQUNBLFlBQUlHLFFBQVExQyxFQUFFOUUsSUFBRixHQUFTcUgsT0FBTyxFQUFQLEVBQVd2QyxFQUFFOUUsSUFBYixDQUFyQjtBQUNBd0gsY0FBTXRLLEVBQU4sR0FBV0EsRUFBWDtBQUNBLFlBQUl1SyxTQUFTM0MsRUFBRTlFLElBQUYsQ0FBT2lILEtBQVAsR0FBZUksT0FBTyxFQUFQLEVBQVd2QyxFQUFFOUUsSUFBRixDQUFPaUgsS0FBbEIsQ0FBNUI7QUFDQVEsZUFBT2pCLElBQVAsR0FBY0EsSUFBZDtBQUNELE9BUkQsTUFRTztBQUNMO0FBQ0F4RyxhQUFLOUMsRUFBTCxHQUFVQSxFQUFWO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPMEMsRUFBRSxLQUFLa0csR0FBUCxFQUFZOUYsSUFBWixFQUFrQixLQUFLbUgsTUFBTCxDQUFZNUksT0FBOUIsQ0FBUDtBQUNEO0FBOUVRLENBQVg7O0FBaUZBLFNBQVN1SSxVQUFULENBQXFCL0wsQ0FBckIsRUFBd0I7QUFDdEI7QUFDQSxNQUFJQSxFQUFFMk0sT0FBRixJQUFhM00sRUFBRTRNLE9BQWYsSUFBMEI1TSxFQUFFNk0sUUFBaEMsRUFBMEM7QUFBRTtBQUFRO0FBQ3BEO0FBQ0EsTUFBSTdNLEVBQUU4TSxnQkFBTixFQUF3QjtBQUFFO0FBQVE7QUFDbEM7QUFDQSxNQUFJOU0sRUFBRStNLE1BQUYsS0FBYXpHLFNBQWIsSUFBMEJ0RyxFQUFFK00sTUFBRixLQUFhLENBQTNDLEVBQThDO0FBQUU7QUFBUTtBQUN4RDtBQUNBLE1BQUkvTSxFQUFFdUssTUFBRixJQUFZdkssRUFBRXVLLE1BQUYsQ0FBU3lDLFlBQXpCLEVBQXVDO0FBQ3JDLFFBQUl6QyxTQUFTdkssRUFBRXVLLE1BQUYsQ0FBU3lDLFlBQVQsQ0FBc0IsUUFBdEIsQ0FBYjtBQUNBLFFBQUksY0FBY0MsSUFBZCxDQUFtQjFDLE1BQW5CLENBQUosRUFBZ0M7QUFBRTtBQUFRO0FBQzNDO0FBQ0Q7QUFDQSxNQUFJdkssRUFBRWtOLGNBQU4sRUFBc0I7QUFDcEJsTixNQUFFa04sY0FBRjtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU2YsVUFBVCxDQUFxQnBILFFBQXJCLEVBQStCO0FBQzdCLE1BQUlBLFFBQUosRUFBYztBQUNaLFFBQUltQixLQUFKO0FBQ0EsU0FBSyxJQUFJNUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUQsU0FBU25FLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QzRFLGNBQVFuQixTQUFTekQsQ0FBVCxDQUFSO0FBQ0EsVUFBSTRFLE1BQU02RSxHQUFOLEtBQWMsR0FBbEIsRUFBdUI7QUFDckIsZUFBTzdFLEtBQVA7QUFDRDtBQUNELFVBQUlBLE1BQU1uQixRQUFOLEtBQW1CbUIsUUFBUWlHLFdBQVdqRyxNQUFNbkIsUUFBakIsQ0FBM0IsQ0FBSixFQUE0RDtBQUMxRCxlQUFPbUIsS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELElBQUlxRyxJQUFKOztBQUVBLFNBQVM5SSxPQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNyQixNQUFJRCxRQUFRMEosU0FBWixFQUF1QjtBQUFFO0FBQVE7QUFDakMxSixVQUFRMEosU0FBUixHQUFvQixJQUFwQjs7QUFFQVosU0FBTzdJLEdBQVA7O0FBRUFMLFNBQU9DLGNBQVAsQ0FBc0JJLElBQUloQyxTQUExQixFQUFxQyxTQUFyQyxFQUFnRDtBQUM5Q21DLFNBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUFFLGFBQU8sS0FBS3VKLEtBQUwsQ0FBV0MsT0FBbEI7QUFBMkI7QUFESixHQUFoRDs7QUFJQWhLLFNBQU9DLGNBQVAsQ0FBc0JJLElBQUloQyxTQUExQixFQUFxQyxRQUFyQyxFQUErQztBQUM3Q21DLFNBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUFFLGFBQU8sS0FBS3VKLEtBQUwsQ0FBV0UsTUFBbEI7QUFBMEI7QUFESixHQUEvQzs7QUFJQTVKLE1BQUk2SixLQUFKLENBQVU7QUFDUkMsa0JBQWMsU0FBU0EsWUFBVCxHQUF5QjtBQUNyQyxVQUFJLEtBQUtDLFFBQUwsQ0FBY25DLE1BQWxCLEVBQTBCO0FBQ3hCLGFBQUsrQixPQUFMLEdBQWUsS0FBS0ksUUFBTCxDQUFjbkMsTUFBN0I7QUFDQSxhQUFLK0IsT0FBTCxDQUFhdEgsSUFBYixDQUFrQixJQUFsQjtBQUNBckMsWUFBSThJLElBQUosQ0FBU2tCLGNBQVQsQ0FBd0IsSUFBeEIsRUFBOEIsUUFBOUIsRUFBd0MsS0FBS0wsT0FBTCxDQUFhTSxPQUFiLENBQXFCckQsT0FBN0Q7QUFDRDtBQUNGO0FBUE8sR0FBVjs7QUFVQTVHLE1BQUlNLFNBQUosQ0FBYyxhQUFkLEVBQTZCTyxJQUE3QjtBQUNBYixNQUFJTSxTQUFKLENBQWMsYUFBZCxFQUE2QjRHLElBQTdCOztBQUVBLE1BQUlnRCxTQUFTbEssSUFBSThDLE1BQUosQ0FBV3FILHFCQUF4QjtBQUNBO0FBQ0FELFNBQU9FLGdCQUFQLEdBQTBCRixPQUFPRyxnQkFBUCxHQUEwQkgsT0FBT0ksT0FBM0Q7QUFDRDs7QUFFRDs7QUFFQSxJQUFJQyxZQUFZLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEM7O0FBRUE7O0FBRUEsU0FBU0MsV0FBVCxDQUNFQyxRQURGLEVBRUVDLElBRkYsRUFHRW5ELE1BSEYsRUFJRTtBQUNBLE1BQUlrRCxTQUFTRSxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQTNCLEVBQWdDO0FBQzlCLFdBQU9GLFFBQVA7QUFDRDs7QUFFRCxNQUFJQSxTQUFTRSxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZCLElBQThCRixTQUFTRSxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXpELEVBQThEO0FBQzVELFdBQU9ELE9BQU9ELFFBQWQ7QUFDRDs7QUFFRCxNQUFJRyxRQUFRRixLQUFLckcsS0FBTCxDQUFXLEdBQVgsQ0FBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJLENBQUNrRCxNQUFELElBQVcsQ0FBQ3FELE1BQU1BLE1BQU0zTixNQUFOLEdBQWUsQ0FBckIsQ0FBaEIsRUFBeUM7QUFDdkMyTixVQUFNQyxHQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJQyxXQUFXTCxTQUFTaEgsT0FBVCxDQUFpQixLQUFqQixFQUF3QixFQUF4QixFQUE0QlksS0FBNUIsQ0FBa0MsR0FBbEMsQ0FBZjtBQUNBLE9BQUssSUFBSTFHLElBQUksQ0FBYixFQUFnQkEsSUFBSW1OLFNBQVM3TixNQUE3QixFQUFxQ1UsR0FBckMsRUFBMEM7QUFDeEMsUUFBSW9OLFVBQVVELFNBQVNuTixDQUFULENBQWQ7QUFDQSxRQUFJb04sWUFBWSxHQUFoQixFQUFxQjtBQUNuQjtBQUNELEtBRkQsTUFFTyxJQUFJQSxZQUFZLElBQWhCLEVBQXNCO0FBQzNCSCxZQUFNQyxHQUFOO0FBQ0QsS0FGTSxNQUVBO0FBQ0xELFlBQU1oTixJQUFOLENBQVdtTixPQUFYO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLE1BQUlILE1BQU0sQ0FBTixNQUFhLEVBQWpCLEVBQXFCO0FBQ25CQSxVQUFNMUUsT0FBTixDQUFjLEVBQWQ7QUFDRDs7QUFFRCxTQUFPMEUsTUFBTWpHLElBQU4sQ0FBVyxHQUFYLENBQVA7QUFDRDs7QUFFRCxTQUFTcUcsU0FBVCxDQUFvQmpJLElBQXBCLEVBQTBCO0FBQ3hCLE1BQUk2QyxPQUFPLEVBQVg7QUFDQSxNQUFJL0IsUUFBUSxFQUFaOztBQUVBLE1BQUlvSCxZQUFZbEksS0FBSzhELE9BQUwsQ0FBYSxHQUFiLENBQWhCO0FBQ0EsTUFBSW9FLGFBQWEsQ0FBakIsRUFBb0I7QUFDbEJyRixXQUFPN0MsS0FBS21DLEtBQUwsQ0FBVytGLFNBQVgsQ0FBUDtBQUNBbEksV0FBT0EsS0FBS21DLEtBQUwsQ0FBVyxDQUFYLEVBQWMrRixTQUFkLENBQVA7QUFDRDs7QUFFRCxNQUFJQyxhQUFhbkksS0FBSzhELE9BQUwsQ0FBYSxHQUFiLENBQWpCO0FBQ0EsTUFBSXFFLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkJySCxZQUFRZCxLQUFLbUMsS0FBTCxDQUFXZ0csYUFBYSxDQUF4QixDQUFSO0FBQ0FuSSxXQUFPQSxLQUFLbUMsS0FBTCxDQUFXLENBQVgsRUFBY2dHLFVBQWQsQ0FBUDtBQUNEOztBQUVELFNBQU87QUFDTG5JLFVBQU1BLElBREQ7QUFFTGMsV0FBT0EsS0FGRjtBQUdMK0IsVUFBTUE7QUFIRCxHQUFQO0FBS0Q7O0FBRUQsU0FBU3VGLFNBQVQsQ0FBb0JwSSxJQUFwQixFQUEwQjtBQUN4QixTQUFPQSxLQUFLVSxPQUFMLENBQWEsT0FBYixFQUFzQixHQUF0QixDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBUzJILGNBQVQsQ0FDRUMsTUFERixFQUVFQyxVQUZGLEVBR0VDLFVBSEYsRUFJRTtBQUNBLE1BQUlDLFVBQVVGLGNBQWM1TCxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBNUI7QUFDQSxNQUFJQyxVQUFVSCxjQUFjN0wsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQTVCOztBQUVBSixTQUFPL0csT0FBUCxDQUFlLFVBQVU5QyxLQUFWLEVBQWlCO0FBQzlCbUssbUJBQWVILE9BQWYsRUFBd0JFLE9BQXhCLEVBQWlDbEssS0FBakM7QUFDRCxHQUZEOztBQUlBLFNBQU87QUFDTGdLLGFBQVNBLE9BREo7QUFFTEUsYUFBU0E7QUFGSixHQUFQO0FBSUQ7O0FBRUQsU0FBU0MsY0FBVCxDQUNFSCxPQURGLEVBRUVFLE9BRkYsRUFHRWxLLEtBSEYsRUFJRUgsTUFKRixFQUtFdUssT0FMRixFQU1FO0FBQ0EsTUFBSTdJLE9BQU92QixNQUFNdUIsSUFBakI7QUFDQSxNQUFJL0QsT0FBT3dDLE1BQU14QyxJQUFqQjtBQUNBLE1BQUlwRCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzFELFdBQU93QyxRQUFRLElBQWYsRUFBcUIsZ0RBQXJCO0FBQ0F4QyxXQUNFLE9BQU9pQixNQUFNbkIsU0FBYixLQUEyQixRQUQ3QixFQUVFLDBDQUEyQ1csT0FBTytCLFFBQVEvRCxJQUFmLENBQTNDLEdBQW1FLGVBQW5FLEdBQ0EsNkNBSEY7QUFLRDs7QUFFRCxNQUFJd0csU0FBUztBQUNYekMsVUFBTThJLGNBQWM5SSxJQUFkLEVBQW9CMUIsTUFBcEIsQ0FESztBQUVYWSxnQkFBWVQsTUFBTVMsVUFBTixJQUFvQixFQUFFcEMsU0FBUzJCLE1BQU1uQixTQUFqQixFQUZyQjtBQUdYaUMsZUFBVyxFQUhBO0FBSVh0RCxVQUFNQSxJQUpLO0FBS1hxQyxZQUFRQSxNQUxHO0FBTVh1SyxhQUFTQSxPQU5FO0FBT1hFLGNBQVV0SyxNQUFNc0ssUUFQTDtBQVFYQyxpQkFBYXZLLE1BQU11SyxXQVJSO0FBU1hwRyxVQUFNbkUsTUFBTW1FLElBQU4sSUFBYyxFQVRUO0FBVVg3RSxXQUFPVSxNQUFNVixLQUFOLElBQWUsSUFBZixHQUNILEVBREcsR0FFSFUsTUFBTVMsVUFBTixHQUNFVCxNQUFNVixLQURSLEdBRUUsRUFBRWpCLFNBQVMyQixNQUFNVixLQUFqQjtBQWRLLEdBQWI7O0FBaUJBLE1BQUlVLE1BQU1KLFFBQVYsRUFBb0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBSXhGLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUl6QyxNQUFNeEMsSUFBTixJQUFjd0MsTUFBTUosUUFBTixDQUFlNEssSUFBZixDQUFvQixVQUFVekosS0FBVixFQUFpQjtBQUFFLGVBQU8sU0FBUStHLElBQVIsQ0FBYS9HLE1BQU1RLElBQW5CO0FBQVA7QUFBa0MsT0FBekUsQ0FBbEIsRUFBOEY7QUFDNUZyQyxhQUNFLEtBREYsRUFFRSxrQkFBbUJjLE1BQU14QyxJQUF6QixHQUFpQywrQkFBakMsR0FDQSxxREFEQSxHQUN5RHdDLE1BQU14QyxJQUQvRCxHQUN1RSxRQUR2RSxHQUVBLHFFQUZBLEdBR0EsbUVBSEEsR0FJQSxnQkFORjtBQVFEO0FBQ0Y7QUFDRHdDLFVBQU1KLFFBQU4sQ0FBZWtELE9BQWYsQ0FBdUIsVUFBVS9CLEtBQVYsRUFBaUI7QUFDdEMsVUFBSTBKLGVBQWVMLFVBQ2ZULFVBQVdTLFVBQVUsR0FBVixHQUFpQnJKLE1BQU1RLElBQWxDLENBRGUsR0FFZkosU0FGSjtBQUdBZ0oscUJBQWVILE9BQWYsRUFBd0JFLE9BQXhCLEVBQWlDbkosS0FBakMsRUFBd0NpRCxNQUF4QyxFQUFnRHlHLFlBQWhEO0FBQ0QsS0FMRDtBQU1EOztBQUVELE1BQUl6SyxNQUFNMEssS0FBTixLQUFnQnZKLFNBQXBCLEVBQStCO0FBQzdCLFFBQUlsRixNQUFNbUgsT0FBTixDQUFjcEQsTUFBTTBLLEtBQXBCLENBQUosRUFBZ0M7QUFDOUIxSyxZQUFNMEssS0FBTixDQUFZNUgsT0FBWixDQUFvQixVQUFVNEgsS0FBVixFQUFpQjtBQUNuQyxZQUFJQyxhQUFhO0FBQ2ZwSixnQkFBTW1KLEtBRFM7QUFFZjlLLG9CQUFVSSxNQUFNSjtBQUZELFNBQWpCO0FBSUF1Syx1QkFBZUgsT0FBZixFQUF3QkUsT0FBeEIsRUFBaUNTLFVBQWpDLEVBQTZDOUssTUFBN0MsRUFBcURtRSxPQUFPekMsSUFBNUQ7QUFDRCxPQU5EO0FBT0QsS0FSRCxNQVFPO0FBQ0wsVUFBSW9KLGFBQWE7QUFDZnBKLGNBQU12QixNQUFNMEssS0FERztBQUVmOUssa0JBQVVJLE1BQU1KO0FBRkQsT0FBakI7QUFJQXVLLHFCQUFlSCxPQUFmLEVBQXdCRSxPQUF4QixFQUFpQ1MsVUFBakMsRUFBNkM5SyxNQUE3QyxFQUFxRG1FLE9BQU96QyxJQUE1RDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDeUksUUFBUWhHLE9BQU96QyxJQUFmLENBQUwsRUFBMkI7QUFDekJ5SSxZQUFRaEcsT0FBT3pDLElBQWYsSUFBdUJ5QyxNQUF2QjtBQUNEOztBQUVELE1BQUl4RyxJQUFKLEVBQVU7QUFDUixRQUFJLENBQUMwTSxRQUFRMU0sSUFBUixDQUFMLEVBQW9CO0FBQ2xCME0sY0FBUTFNLElBQVIsSUFBZ0J3RyxNQUFoQjtBQUNELEtBRkQsTUFFTyxJQUFJNUosUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQzJILE9BQTlDLEVBQXVEO0FBQzVEbEwsV0FDRSxLQURGLEVBRUUsd0NBQ0EsWUFEQSxHQUNlMUIsSUFEZixHQUNzQixjQUR0QixHQUN3Q3dHLE9BQU96QyxJQUQvQyxHQUN1RCxNQUh6RDtBQUtEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTOEksYUFBVCxDQUF3QjlJLElBQXhCLEVBQThCMUIsTUFBOUIsRUFBc0M7QUFDcEMwQixTQUFPQSxLQUFLVSxPQUFMLENBQWEsS0FBYixFQUFvQixFQUFwQixDQUFQO0FBQ0EsTUFBSVYsS0FBSyxDQUFMLE1BQVksR0FBaEIsRUFBcUI7QUFBRSxXQUFPQSxJQUFQO0FBQWE7QUFDcEMsTUFBSTFCLFVBQVUsSUFBZCxFQUFvQjtBQUFFLFdBQU8wQixJQUFQO0FBQWE7QUFDbkMsU0FBT29JLFVBQVk5SixPQUFPMEIsSUFBUixHQUFnQixHQUFoQixHQUFzQkEsSUFBakMsQ0FBUDtBQUNEOztBQUVELElBQUlxSixVQUFVM08sTUFBTW1ILE9BQU4sSUFBaUIsVUFBVXlILEdBQVYsRUFBZTtBQUM1QyxTQUFPM00sT0FBTzNCLFNBQVAsQ0FBaUJxRixRQUFqQixDQUEwQjNHLElBQTFCLENBQStCNFAsR0FBL0IsS0FBdUMsZ0JBQTlDO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJQyxVQUFVRixPQUFkOztBQUVBOzs7QUFHQSxJQUFJM00sUUFBUThNLFlBQVo7QUFDQSxJQUFJQyxVQUFVQyxLQUFkO0FBQ0EsSUFBSUMsWUFBWUMsT0FBaEI7QUFDQSxJQUFJQyxxQkFBcUJDLGdCQUF6QjtBQUNBLElBQUlDLG1CQUFtQkMsY0FBdkI7O0FBRUE7Ozs7O0FBS0EsSUFBSUMsY0FBYyxJQUFJQyxNQUFKLENBQVc7QUFDM0I7QUFDQTtBQUNBLFNBSDJCO0FBSTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQVYyQixFQVczQnRJLElBWDJCLENBV3RCLEdBWHNCLENBQVgsRUFXTCxHQVhLLENBQWxCOztBQWFBOzs7Ozs7O0FBT0EsU0FBUzhILEtBQVQsQ0FBZ0JsSixHQUFoQixFQUFxQnlFLE9BQXJCLEVBQThCO0FBQzVCLE1BQUlrRixTQUFTLEVBQWI7QUFDQSxNQUFJaEosTUFBTSxDQUFWO0FBQ0EsTUFBSXpFLFFBQVEsQ0FBWjtBQUNBLE1BQUlzRCxPQUFPLEVBQVg7QUFDQSxNQUFJb0ssbUJBQW1CbkYsV0FBV0EsUUFBUW9GLFNBQW5CLElBQWdDLEdBQXZEO0FBQ0EsTUFBSWpKLEdBQUo7O0FBRUEsU0FBTyxDQUFDQSxNQUFNNkksWUFBWUssSUFBWixDQUFpQjlKLEdBQWpCLENBQVAsS0FBaUMsSUFBeEMsRUFBOEM7QUFDNUMsUUFBSStKLElBQUluSixJQUFJLENBQUosQ0FBUjtBQUNBLFFBQUlvSixVQUFVcEosSUFBSSxDQUFKLENBQWQ7QUFDQSxRQUFJcUosU0FBU3JKLElBQUkxRSxLQUFqQjtBQUNBc0QsWUFBUVEsSUFBSTJCLEtBQUosQ0FBVXpGLEtBQVYsRUFBaUIrTixNQUFqQixDQUFSO0FBQ0EvTixZQUFRK04sU0FBU0YsRUFBRXJRLE1BQW5COztBQUVBO0FBQ0EsUUFBSXNRLE9BQUosRUFBYTtBQUNYeEssY0FBUXdLLFFBQVEsQ0FBUixDQUFSO0FBQ0E7QUFDRDs7QUFFRCxRQUFJRSxPQUFPbEssSUFBSTlELEtBQUosQ0FBWDtBQUNBLFFBQUlpTyxTQUFTdkosSUFBSSxDQUFKLENBQWI7QUFDQSxRQUFJbkYsT0FBT21GLElBQUksQ0FBSixDQUFYO0FBQ0EsUUFBSXdKLFVBQVV4SixJQUFJLENBQUosQ0FBZDtBQUNBLFFBQUl5SixRQUFRekosSUFBSSxDQUFKLENBQVo7QUFDQSxRQUFJMEosV0FBVzFKLElBQUksQ0FBSixDQUFmO0FBQ0EsUUFBSTJKLFdBQVczSixJQUFJLENBQUosQ0FBZjs7QUFFQTtBQUNBLFFBQUlwQixJQUFKLEVBQVU7QUFDUm1LLGFBQU90UCxJQUFQLENBQVltRixJQUFaO0FBQ0FBLGFBQU8sRUFBUDtBQUNEOztBQUVELFFBQUlnTCxVQUFVTCxVQUFVLElBQVYsSUFBa0JELFFBQVEsSUFBMUIsSUFBa0NBLFNBQVNDLE1BQXpEO0FBQ0EsUUFBSU0sU0FBU0gsYUFBYSxHQUFiLElBQW9CQSxhQUFhLEdBQTlDO0FBQ0EsUUFBSUksV0FBV0osYUFBYSxHQUFiLElBQW9CQSxhQUFhLEdBQWhEO0FBQ0EsUUFBSVQsWUFBWWpKLElBQUksQ0FBSixLQUFVZ0osZ0JBQTFCO0FBQ0EsUUFBSWUsVUFBVVAsV0FBV0MsS0FBekI7O0FBRUFWLFdBQU90UCxJQUFQLENBQVk7QUFDVm9CLFlBQU1BLFFBQVFrRixLQURKO0FBRVZ3SixjQUFRQSxVQUFVLEVBRlI7QUFHVk4saUJBQVdBLFNBSEQ7QUFJVmEsZ0JBQVVBLFFBSkE7QUFLVkQsY0FBUUEsTUFMRTtBQU1WRCxlQUFTQSxPQU5DO0FBT1ZELGdCQUFVLENBQUMsQ0FBQ0EsUUFQRjtBQVFWSSxlQUFTQSxVQUFVQyxZQUFZRCxPQUFaLENBQVYsR0FBa0NKLFdBQVcsSUFBWCxHQUFrQixPQUFPTSxhQUFhaEIsU0FBYixDQUFQLEdBQWlDO0FBUnBGLEtBQVo7QUFVRDs7QUFFRDtBQUNBLE1BQUkzTixRQUFROEQsSUFBSXRHLE1BQWhCLEVBQXdCO0FBQ3RCOEYsWUFBUVEsSUFBSThLLE1BQUosQ0FBVzVPLEtBQVgsQ0FBUjtBQUNEOztBQUVEO0FBQ0EsTUFBSXNELElBQUosRUFBVTtBQUNSbUssV0FBT3RQLElBQVAsQ0FBWW1GLElBQVo7QUFDRDs7QUFFRCxTQUFPbUssTUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU1AsT0FBVCxDQUFrQnBKLEdBQWxCLEVBQXVCeUUsT0FBdkIsRUFBZ0M7QUFDOUIsU0FBTzZFLGlCQUFpQkosTUFBTWxKLEdBQU4sRUFBV3lFLE9BQVgsQ0FBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTc0csd0JBQVQsQ0FBbUMvSyxHQUFuQyxFQUF3QztBQUN0QyxTQUFPZ0wsVUFBVWhMLEdBQVYsRUFBZUUsT0FBZixDQUF1QixTQUF2QixFQUFrQyxVQUFVUCxDQUFWLEVBQWE7QUFDcEQsV0FBTyxNQUFNQSxFQUFFQyxVQUFGLENBQWEsQ0FBYixFQUFnQkMsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkJvTCxXQUE3QixFQUFiO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNDLGNBQVQsQ0FBeUJsTCxHQUF6QixFQUE4QjtBQUM1QixTQUFPZ0wsVUFBVWhMLEdBQVYsRUFBZUUsT0FBZixDQUF1QixPQUF2QixFQUFnQyxVQUFVUCxDQUFWLEVBQWE7QUFDbEQsV0FBTyxNQUFNQSxFQUFFQyxVQUFGLENBQWEsQ0FBYixFQUFnQkMsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkJvTCxXQUE3QixFQUFiO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O0FBRUQ7OztBQUdBLFNBQVMzQixnQkFBVCxDQUEyQkssTUFBM0IsRUFBbUM7QUFDakM7QUFDQSxNQUFJd0IsVUFBVSxJQUFJalIsS0FBSixDQUFVeVAsT0FBT2pRLE1BQWpCLENBQWQ7O0FBRUE7QUFDQSxPQUFLLElBQUlVLElBQUksQ0FBYixFQUFnQkEsSUFBSXVQLE9BQU9qUSxNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsUUFBSSxPQUFPdVAsT0FBT3ZQLENBQVAsQ0FBUCxLQUFxQixRQUF6QixFQUFtQztBQUNqQytRLGNBQVEvUSxDQUFSLElBQWEsSUFBSXNQLE1BQUosQ0FBVyxTQUFTQyxPQUFPdlAsQ0FBUCxFQUFVdVEsT0FBbkIsR0FBNkIsSUFBeEMsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxVQUFVcEosR0FBVixFQUFlNkosSUFBZixFQUFxQjtBQUMxQixRQUFJNUwsT0FBTyxFQUFYO0FBQ0EsUUFBSXpCLE9BQU93RCxPQUFPLEVBQWxCO0FBQ0EsUUFBSWtELFVBQVUyRyxRQUFRLEVBQXRCO0FBQ0EsUUFBSXJMLFNBQVMwRSxRQUFRNEcsTUFBUixHQUFpQk4sd0JBQWpCLEdBQTRDOUssa0JBQXpEOztBQUVBLFNBQUssSUFBSTdGLElBQUksQ0FBYixFQUFnQkEsSUFBSXVQLE9BQU9qUSxNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsVUFBSWtSLFFBQVEzQixPQUFPdlAsQ0FBUCxDQUFaOztBQUVBLFVBQUksT0FBT2tSLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0I5TCxnQkFBUThMLEtBQVI7O0FBRUE7QUFDRDs7QUFFRCxVQUFJalAsUUFBUTBCLEtBQUt1TixNQUFNN1AsSUFBWCxDQUFaO0FBQ0EsVUFBSStMLE9BQUo7O0FBRUEsVUFBSW5MLFNBQVMsSUFBYixFQUFtQjtBQUNqQixZQUFJaVAsTUFBTVosUUFBVixFQUFvQjtBQUNsQjtBQUNBLGNBQUlZLE1BQU1kLE9BQVYsRUFBbUI7QUFDakJoTCxvQkFBUThMLE1BQU1uQixNQUFkO0FBQ0Q7O0FBRUQ7QUFDRCxTQVBELE1BT087QUFDTCxnQkFBTSxJQUFJb0IsU0FBSixDQUFjLGVBQWVELE1BQU03UCxJQUFyQixHQUE0QixpQkFBMUMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXNOLFFBQVExTSxLQUFSLENBQUosRUFBb0I7QUFDbEIsWUFBSSxDQUFDaVAsTUFBTWIsTUFBWCxFQUFtQjtBQUNqQixnQkFBTSxJQUFJYyxTQUFKLENBQWMsZUFBZUQsTUFBTTdQLElBQXJCLEdBQTRCLGlDQUE1QixHQUFnRStQLEtBQUtDLFNBQUwsQ0FBZXBQLEtBQWYsQ0FBaEUsR0FBd0YsR0FBdEcsQ0FBTjtBQUNEOztBQUVELFlBQUlBLE1BQU0zQyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGNBQUk0UixNQUFNWixRQUFWLEVBQW9CO0FBQ2xCO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsa0JBQU0sSUFBSWEsU0FBSixDQUFjLGVBQWVELE1BQU03UCxJQUFyQixHQUE0QixtQkFBMUMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsYUFBSyxJQUFJaVEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJclAsTUFBTTNDLE1BQTFCLEVBQWtDZ1MsR0FBbEMsRUFBdUM7QUFDckNsRSxvQkFBVXpILE9BQU8xRCxNQUFNcVAsQ0FBTixDQUFQLENBQVY7O0FBRUEsY0FBSSxDQUFDUCxRQUFRL1EsQ0FBUixFQUFXMkwsSUFBWCxDQUFnQnlCLE9BQWhCLENBQUwsRUFBK0I7QUFDN0Isa0JBQU0sSUFBSStELFNBQUosQ0FBYyxtQkFBbUJELE1BQU03UCxJQUF6QixHQUFnQyxjQUFoQyxHQUFpRDZQLE1BQU1YLE9BQXZELEdBQWlFLG1CQUFqRSxHQUF1RmEsS0FBS0MsU0FBTCxDQUFlakUsT0FBZixDQUF2RixHQUFpSCxHQUEvSCxDQUFOO0FBQ0Q7O0FBRURoSSxrQkFBUSxDQUFDa00sTUFBTSxDQUFOLEdBQVVKLE1BQU1uQixNQUFoQixHQUF5Qm1CLE1BQU16QixTQUFoQyxJQUE2Q3JDLE9BQXJEO0FBQ0Q7O0FBRUQ7QUFDRDs7QUFFREEsZ0JBQVU4RCxNQUFNZixRQUFOLEdBQWlCVyxlQUFlN08sS0FBZixDQUFqQixHQUF5QzBELE9BQU8xRCxLQUFQLENBQW5EOztBQUVBLFVBQUksQ0FBQzhPLFFBQVEvUSxDQUFSLEVBQVcyTCxJQUFYLENBQWdCeUIsT0FBaEIsQ0FBTCxFQUErQjtBQUM3QixjQUFNLElBQUkrRCxTQUFKLENBQWMsZUFBZUQsTUFBTTdQLElBQXJCLEdBQTRCLGNBQTVCLEdBQTZDNlAsTUFBTVgsT0FBbkQsR0FBNkQsbUJBQTdELEdBQW1GbkQsT0FBbkYsR0FBNkYsR0FBM0csQ0FBTjtBQUNEOztBQUVEaEksY0FBUThMLE1BQU1uQixNQUFOLEdBQWUzQyxPQUF2QjtBQUNEOztBQUVELFdBQU9oSSxJQUFQO0FBQ0QsR0FuRUQ7QUFvRUQ7O0FBRUQ7Ozs7OztBQU1BLFNBQVNxTCxZQUFULENBQXVCN0ssR0FBdkIsRUFBNEI7QUFDMUIsU0FBT0EsSUFBSUUsT0FBSixDQUFZLDRCQUFaLEVBQTBDLE1BQTFDLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBUzBLLFdBQVQsQ0FBc0JQLEtBQXRCLEVBQTZCO0FBQzNCLFNBQU9BLE1BQU1uSyxPQUFOLENBQWMsZUFBZCxFQUErQixNQUEvQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTeUwsVUFBVCxDQUFxQkMsRUFBckIsRUFBeUJwSyxJQUF6QixFQUErQjtBQUM3Qm9LLEtBQUdwSyxJQUFILEdBQVVBLElBQVY7QUFDQSxTQUFPb0ssRUFBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTQyxLQUFULENBQWdCcEgsT0FBaEIsRUFBeUI7QUFDdkIsU0FBT0EsUUFBUXFILFNBQVIsR0FBb0IsRUFBcEIsR0FBeUIsR0FBaEM7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNDLGNBQVQsQ0FBeUJ2TSxJQUF6QixFQUErQmdDLElBQS9CLEVBQXFDO0FBQ25DO0FBQ0EsTUFBSXdLLFNBQVN4TSxLQUFLeU0sTUFBTCxDQUFZQyxLQUFaLENBQWtCLFdBQWxCLENBQWI7O0FBRUEsTUFBSUYsTUFBSixFQUFZO0FBQ1YsU0FBSyxJQUFJNVIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNFIsT0FBT3RTLE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0Q29ILFdBQUtuSCxJQUFMLENBQVU7QUFDUm9CLGNBQU1yQixDQURFO0FBRVIrUCxnQkFBUSxJQUZBO0FBR1JOLG1CQUFXLElBSEg7QUFJUmEsa0JBQVUsS0FKRjtBQUtSRCxnQkFBUSxLQUxBO0FBTVJELGlCQUFTLEtBTkQ7QUFPUkQsa0JBQVUsS0FQRjtBQVFSSSxpQkFBUztBQVJELE9BQVY7QUFVRDtBQUNGOztBQUVELFNBQU9nQixXQUFXbk0sSUFBWCxFQUFpQmdDLElBQWpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTMkssYUFBVCxDQUF3QjNNLElBQXhCLEVBQThCZ0MsSUFBOUIsRUFBb0NpRCxPQUFwQyxFQUE2QztBQUMzQyxNQUFJeEQsUUFBUSxFQUFaOztBQUVBLE9BQUssSUFBSTdHLElBQUksQ0FBYixFQUFnQkEsSUFBSW9GLEtBQUs5RixNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcEM2RyxVQUFNNUcsSUFBTixDQUFXMk8sYUFBYXhKLEtBQUtwRixDQUFMLENBQWIsRUFBc0JvSCxJQUF0QixFQUE0QmlELE9BQTVCLEVBQXFDd0gsTUFBaEQ7QUFDRDs7QUFFRCxNQUFJRyxTQUFTLElBQUkxQyxNQUFKLENBQVcsUUFBUXpJLE1BQU1HLElBQU4sQ0FBVyxHQUFYLENBQVIsR0FBMEIsR0FBckMsRUFBMEN5SyxNQUFNcEgsT0FBTixDQUExQyxDQUFiOztBQUVBLFNBQU9rSCxXQUFXUyxNQUFYLEVBQW1CNUssSUFBbkIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVM2SyxjQUFULENBQXlCN00sSUFBekIsRUFBK0JnQyxJQUEvQixFQUFxQ2lELE9BQXJDLEVBQThDO0FBQzVDLFNBQU8rRSxlQUFlTixNQUFNMUosSUFBTixFQUFZaUYsT0FBWixDQUFmLEVBQXFDakQsSUFBckMsRUFBMkNpRCxPQUEzQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBUytFLGNBQVQsQ0FBeUJHLE1BQXpCLEVBQWlDbkksSUFBakMsRUFBdUNpRCxPQUF2QyxFQUFnRDtBQUM5QyxNQUFJLENBQUNzRSxRQUFRdkgsSUFBUixDQUFMLEVBQW9CO0FBQ2xCaUQsY0FBVSxzQkFBd0JqRCxRQUFRaUQsT0FBMUM7QUFDQWpELFdBQU8sRUFBUDtBQUNEOztBQUVEaUQsWUFBVUEsV0FBVyxFQUFyQjs7QUFFQSxNQUFJNkgsU0FBUzdILFFBQVE2SCxNQUFyQjtBQUNBLE1BQUlDLE1BQU05SCxRQUFROEgsR0FBUixLQUFnQixLQUExQjtBQUNBLE1BQUl0TyxRQUFRLEVBQVo7O0FBRUE7QUFDQSxPQUFLLElBQUk3RCxJQUFJLENBQWIsRUFBZ0JBLElBQUl1UCxPQUFPalEsTUFBM0IsRUFBbUNVLEdBQW5DLEVBQXdDO0FBQ3RDLFFBQUlrUixRQUFRM0IsT0FBT3ZQLENBQVAsQ0FBWjs7QUFFQSxRQUFJLE9BQU9rUixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCck4sZUFBUzRNLGFBQWFTLEtBQWIsQ0FBVDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUluQixTQUFTVSxhQUFhUyxNQUFNbkIsTUFBbkIsQ0FBYjtBQUNBLFVBQUlDLFVBQVUsUUFBUWtCLE1BQU1YLE9BQWQsR0FBd0IsR0FBdEM7O0FBRUFuSixXQUFLbkgsSUFBTCxDQUFVaVIsS0FBVjs7QUFFQSxVQUFJQSxNQUFNYixNQUFWLEVBQWtCO0FBQ2hCTCxtQkFBVyxRQUFRRCxNQUFSLEdBQWlCQyxPQUFqQixHQUEyQixJQUF0QztBQUNEOztBQUVELFVBQUlrQixNQUFNWixRQUFWLEVBQW9CO0FBQ2xCLFlBQUksQ0FBQ1ksTUFBTWQsT0FBWCxFQUFvQjtBQUNsQkosb0JBQVUsUUFBUUQsTUFBUixHQUFpQixHQUFqQixHQUF1QkMsT0FBdkIsR0FBaUMsS0FBM0M7QUFDRCxTQUZELE1BRU87QUFDTEEsb0JBQVVELFNBQVMsR0FBVCxHQUFlQyxPQUFmLEdBQXlCLElBQW5DO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTEEsa0JBQVVELFNBQVMsR0FBVCxHQUFlQyxPQUFmLEdBQXlCLEdBQW5DO0FBQ0Q7O0FBRURuTSxlQUFTbU0sT0FBVDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSVAsWUFBWWdCLGFBQWFwRyxRQUFRb0YsU0FBUixJQUFxQixHQUFsQyxDQUFoQjtBQUNBLE1BQUkyQyxvQkFBb0J2TyxNQUFNMEQsS0FBTixDQUFZLENBQUNrSSxVQUFVblEsTUFBdkIsTUFBbUNtUSxTQUEzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUksQ0FBQ3lDLE1BQUwsRUFBYTtBQUNYck8sWUFBUSxDQUFDdU8sb0JBQW9Cdk8sTUFBTTBELEtBQU4sQ0FBWSxDQUFaLEVBQWUsQ0FBQ2tJLFVBQVVuUSxNQUExQixDQUFwQixHQUF3RHVFLEtBQXpELElBQWtFLEtBQWxFLEdBQTBFNEwsU0FBMUUsR0FBc0YsU0FBOUY7QUFDRDs7QUFFRCxNQUFJMEMsR0FBSixFQUFTO0FBQ1B0TyxhQUFTLEdBQVQ7QUFDRCxHQUZELE1BRU87QUFDTDtBQUNBO0FBQ0FBLGFBQVNxTyxVQUFVRSxpQkFBVixHQUE4QixFQUE5QixHQUFtQyxRQUFRM0MsU0FBUixHQUFvQixLQUFoRTtBQUNEOztBQUVELFNBQU84QixXQUFXLElBQUlqQyxNQUFKLENBQVcsTUFBTXpMLEtBQWpCLEVBQXdCNE4sTUFBTXBILE9BQU4sQ0FBeEIsQ0FBWCxFQUFvRGpELElBQXBELENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU3dILFlBQVQsQ0FBdUJ4SixJQUF2QixFQUE2QmdDLElBQTdCLEVBQW1DaUQsT0FBbkMsRUFBNEM7QUFDMUMsTUFBSSxDQUFDc0UsUUFBUXZILElBQVIsQ0FBTCxFQUFvQjtBQUNsQmlELGNBQVUsc0JBQXdCakQsUUFBUWlELE9BQTFDO0FBQ0FqRCxXQUFPLEVBQVA7QUFDRDs7QUFFRGlELFlBQVVBLFdBQVcsRUFBckI7O0FBRUEsTUFBSWpGLGdCQUFnQmtLLE1BQXBCLEVBQTRCO0FBQzFCLFdBQU9xQyxlQUFldk0sSUFBZixFQUFxQixxQkFBdUJnQyxJQUE1QyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSXVILFFBQVF2SixJQUFSLENBQUosRUFBbUI7QUFDakIsV0FBTzJNLGVBQWMscUJBQXVCM00sSUFBckMsRUFBNEMscUJBQXVCZ0MsSUFBbkUsRUFBMEVpRCxPQUExRSxDQUFQO0FBQ0Q7O0FBRUQsU0FBTzRILGdCQUFlLHFCQUF1QjdNLElBQXRDLEVBQTZDLHFCQUF1QmdDLElBQXBFLEVBQTJFaUQsT0FBM0UsQ0FBUDtBQUNEOztBQUVEdkksTUFBTWdOLEtBQU4sR0FBY0QsT0FBZDtBQUNBL00sTUFBTWtOLE9BQU4sR0FBZ0JELFNBQWhCO0FBQ0FqTixNQUFNb04sZ0JBQU4sR0FBeUJELGtCQUF6QjtBQUNBbk4sTUFBTXNOLGNBQU4sR0FBdUJELGdCQUF2Qjs7QUFFQTs7QUFFQSxJQUFJa0QsY0FBY3RRLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFsQjs7QUFFQSxTQUFTd0UsYUFBVCxDQUF3QmxOLElBQXhCLEVBQThCO0FBQzVCLE1BQUltTixNQUFNRixZQUFZak4sSUFBWixDQUFWO0FBQ0EsTUFBSWdDLElBQUosRUFBVTRLLE1BQVY7O0FBRUEsTUFBSU8sR0FBSixFQUFTO0FBQ1BuTCxXQUFPbUwsSUFBSW5MLElBQVg7QUFDQTRLLGFBQVNPLElBQUlQLE1BQWI7QUFDRCxHQUhELE1BR087QUFDTDVLLFdBQU8sRUFBUDtBQUNBNEssYUFBU2xRLE1BQU1zRCxJQUFOLEVBQVlnQyxJQUFaLENBQVQ7QUFDQWlMLGdCQUFZak4sSUFBWixJQUFvQixFQUFFZ0MsTUFBTUEsSUFBUixFQUFjNEssUUFBUUEsTUFBdEIsRUFBcEI7QUFDRDs7QUFFRCxTQUFPLEVBQUU1SyxNQUFNQSxJQUFSLEVBQWM0SyxRQUFRQSxNQUF0QixFQUFQO0FBQ0Q7O0FBRUQsSUFBSVEscUJBQXFCelEsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQXpCOztBQUVBLFNBQVMyRSxVQUFULENBQ0VyTixJQURGLEVBRUVELE1BRkYsRUFHRXVOLFFBSEYsRUFJRTtBQUNBLE1BQUk7QUFDRixRQUFJQyxTQUNGSCxtQkFBbUJwTixJQUFuQixNQUNDb04sbUJBQW1CcE4sSUFBbkIsSUFBMkJ0RCxNQUFNa04sT0FBTixDQUFjNUosSUFBZCxDQUQ1QixDQURGO0FBR0EsV0FBT3VOLE9BQU94TixVQUFVLEVBQWpCLEVBQXFCLEVBQUU4TCxRQUFRLElBQVYsRUFBckIsQ0FBUDtBQUNELEdBTEQsQ0FLRSxPQUFPdlMsQ0FBUCxFQUFVO0FBQ1YsUUFBSVQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN2RCxXQUFLLEtBQUwsRUFBYSx1QkFBdUIyUCxRQUF2QixHQUFrQyxJQUFsQyxHQUEwQ2hVLEVBQUVvRSxPQUF6RDtBQUNEO0FBQ0QsV0FBTyxFQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxTQUFTOFAsaUJBQVQsQ0FDRUMsR0FERixFQUVFN0osT0FGRixFQUdFWSxNQUhGLEVBSUU7QUFDQSxNQUFJa0csT0FBTyxPQUFPK0MsR0FBUCxLQUFlLFFBQWYsR0FBMEIsRUFBRXpOLE1BQU15TixHQUFSLEVBQTFCLEdBQTBDQSxHQUFyRDtBQUNBO0FBQ0EsTUFBSS9DLEtBQUt6TyxJQUFMLElBQWF5TyxLQUFLZ0QsV0FBdEIsRUFBbUM7QUFDakMsV0FBT2hELElBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUksQ0FBQ0EsS0FBSzFLLElBQU4sSUFBYzBLLEtBQUszSyxNQUFuQixJQUE2QjZELE9BQWpDLEVBQTBDO0FBQ3hDOEcsV0FBT2lELE9BQU8sRUFBUCxFQUFXakQsSUFBWCxDQUFQO0FBQ0FBLFNBQUtnRCxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsUUFBSTNOLFNBQVM0TixPQUFPQSxPQUFPLEVBQVAsRUFBVy9KLFFBQVE3RCxNQUFuQixDQUFQLEVBQW1DMkssS0FBSzNLLE1BQXhDLENBQWI7QUFDQSxRQUFJNkQsUUFBUTNILElBQVosRUFBa0I7QUFDaEJ5TyxXQUFLek8sSUFBTCxHQUFZMkgsUUFBUTNILElBQXBCO0FBQ0F5TyxXQUFLM0ssTUFBTCxHQUFjQSxNQUFkO0FBQ0QsS0FIRCxNQUdPLElBQUk2RCxRQUFRdkcsT0FBWixFQUFxQjtBQUMxQixVQUFJdVEsVUFBVWhLLFFBQVF2RyxPQUFSLENBQWdCdUcsUUFBUXZHLE9BQVIsQ0FBZ0JuRCxNQUFoQixHQUF5QixDQUF6QyxFQUE0QzhGLElBQTFEO0FBQ0EwSyxXQUFLMUssSUFBTCxHQUFZcU4sV0FBV08sT0FBWCxFQUFvQjdOLE1BQXBCLEVBQTZCLFVBQVc2RCxRQUFRNUQsSUFBaEQsQ0FBWjtBQUNELEtBSE0sTUFHQSxJQUFJbkgsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaER2RCxXQUFLLEtBQUwsRUFBWSxzREFBWjtBQUNEO0FBQ0QsV0FBTytNLElBQVA7QUFDRDs7QUFFRCxNQUFJbUQsYUFBYTVGLFVBQVV5QyxLQUFLMUssSUFBTCxJQUFhLEVBQXZCLENBQWpCO0FBQ0EsTUFBSThOLFdBQVlsSyxXQUFXQSxRQUFRNUQsSUFBcEIsSUFBNkIsR0FBNUM7QUFDQSxNQUFJQSxPQUFPNk4sV0FBVzdOLElBQVgsR0FDUHlILFlBQVlvRyxXQUFXN04sSUFBdkIsRUFBNkI4TixRQUE3QixFQUF1Q3RKLFVBQVVrRyxLQUFLbEcsTUFBdEQsQ0FETyxHQUVOWixXQUFXQSxRQUFRNUQsSUFBcEIsSUFBNkIsR0FGakM7QUFHQSxNQUFJYyxRQUFRRCxhQUFhZ04sV0FBVy9NLEtBQXhCLEVBQStCNEosS0FBSzVKLEtBQXBDLENBQVo7QUFDQSxNQUFJK0IsT0FBTzZILEtBQUs3SCxJQUFMLElBQWFnTCxXQUFXaEwsSUFBbkM7QUFDQSxNQUFJQSxRQUFRQSxLQUFLK0UsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBL0IsRUFBb0M7QUFDbEMvRSxXQUFPLE1BQU1BLElBQWI7QUFDRDs7QUFFRCxTQUFPO0FBQ0w2SyxpQkFBYSxJQURSO0FBRUwxTixVQUFNQSxJQUZEO0FBR0xjLFdBQU9BLEtBSEY7QUFJTCtCLFVBQU1BO0FBSkQsR0FBUDtBQU1EOztBQUVELFNBQVM4SyxNQUFULENBQWlCdEssQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCO0FBQ3JCLE9BQUssSUFBSW5DLEdBQVQsSUFBZ0JtQyxDQUFoQixFQUFtQjtBQUNqQkQsTUFBRWxDLEdBQUYsSUFBU21DLEVBQUVuQyxHQUFGLENBQVQ7QUFDRDtBQUNELFNBQU9rQyxDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBUzBLLGFBQVQsQ0FBd0J6RixNQUF4QixFQUFnQztBQUM5QixNQUFJbEssTUFBTWlLLGVBQWVDLE1BQWYsQ0FBVjtBQUNBLE1BQUlHLFVBQVVySyxJQUFJcUssT0FBbEI7QUFDQSxNQUFJRSxVQUFVdkssSUFBSXVLLE9BQWxCOztBQUVBLFdBQVNxRixTQUFULENBQW9CMUYsTUFBcEIsRUFBNEI7QUFDMUJELG1CQUFlQyxNQUFmLEVBQXVCRyxPQUF2QixFQUFnQ0UsT0FBaEM7QUFDRDs7QUFFRCxXQUFTK0QsS0FBVCxDQUNFZSxHQURGLEVBRUVRLFlBRkYsRUFHRXRMLGNBSEYsRUFJRTtBQUNBLFFBQUlELFdBQVc4SyxrQkFBa0JDLEdBQWxCLEVBQXVCUSxZQUF2QixDQUFmO0FBQ0EsUUFBSWhTLE9BQU95RyxTQUFTekcsSUFBcEI7O0FBRUEsUUFBSUEsSUFBSixFQUFVO0FBQ1IsVUFBSXdHLFNBQVNrRyxRQUFRMU0sSUFBUixDQUFiO0FBQ0EsVUFBSXBELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDdkQsYUFBSzhFLE1BQUwsRUFBYyxzQkFBc0J4RyxJQUF0QixHQUE2QixrQkFBM0M7QUFDRDtBQUNELFVBQUlpUyxhQUFhaEIsY0FBY3pLLE9BQU96QyxJQUFyQixFQUEyQmdDLElBQTNCLENBQ2RLLE1BRGMsQ0FDUCxVQUFVbEIsR0FBVixFQUFlO0FBQUUsZUFBTyxDQUFDQSxJQUFJK0osUUFBWjtBQUF1QixPQURqQyxFQUVkakosR0FGYyxDQUVWLFVBQVVkLEdBQVYsRUFBZTtBQUFFLGVBQU9BLElBQUlsRixJQUFYO0FBQWtCLE9BRnpCLENBQWpCOztBQUlBLFVBQUksT0FBT3lHLFNBQVMzQyxNQUFoQixLQUEyQixRQUEvQixFQUF5QztBQUN2QzJDLGlCQUFTM0MsTUFBVCxHQUFrQixFQUFsQjtBQUNEOztBQUVELFVBQUlrTyxnQkFBZ0IsT0FBT0EsYUFBYWxPLE1BQXBCLEtBQStCLFFBQW5ELEVBQTZEO0FBQzNELGFBQUssSUFBSW9CLEdBQVQsSUFBZ0I4TSxhQUFhbE8sTUFBN0IsRUFBcUM7QUFDbkMsY0FBSSxFQUFFb0IsT0FBT3VCLFNBQVMzQyxNQUFsQixLQUE2Qm1PLFdBQVdwSyxPQUFYLENBQW1CM0MsR0FBbkIsSUFBMEIsQ0FBQyxDQUE1RCxFQUErRDtBQUM3RHVCLHFCQUFTM0MsTUFBVCxDQUFnQm9CLEdBQWhCLElBQXVCOE0sYUFBYWxPLE1BQWIsQ0FBb0JvQixHQUFwQixDQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFJc0IsTUFBSixFQUFZO0FBQ1ZDLGlCQUFTMUMsSUFBVCxHQUFnQnFOLFdBQVc1SyxPQUFPekMsSUFBbEIsRUFBd0IwQyxTQUFTM0MsTUFBakMsRUFBMEMsbUJBQW1COUQsSUFBbkIsR0FBMEIsSUFBcEUsQ0FBaEI7QUFDQSxlQUFPa1MsYUFBYTFMLE1BQWIsRUFBcUJDLFFBQXJCLEVBQStCQyxjQUEvQixDQUFQO0FBQ0Q7QUFDRixLQXpCRCxNQXlCTyxJQUFJRCxTQUFTMUMsSUFBYixFQUFtQjtBQUN4QjBDLGVBQVMzQyxNQUFULEdBQWtCLEVBQWxCO0FBQ0EsV0FBSyxJQUFJQyxJQUFULElBQWlCeUksT0FBakIsRUFBMEI7QUFDeEIsWUFBSTJGLFdBQVdwTyxJQUFYLEVBQWlCMEMsU0FBUzNDLE1BQTFCLEVBQWtDMkMsU0FBUzFDLElBQTNDLENBQUosRUFBc0Q7QUFDcEQsaUJBQU9tTyxhQUFhMUYsUUFBUXpJLElBQVIsQ0FBYixFQUE0QjBDLFFBQTVCLEVBQXNDQyxjQUF0QyxDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7QUFDQSxXQUFPd0wsYUFBYSxJQUFiLEVBQW1CekwsUUFBbkIsQ0FBUDtBQUNEOztBQUVELFdBQVNxRyxRQUFULENBQ0V0RyxNQURGLEVBRUVDLFFBRkYsRUFHRTtBQUNBLFFBQUkyTCxtQkFBbUI1TCxPQUFPc0csUUFBOUI7QUFDQSxRQUFJQSxXQUFXLE9BQU9zRixnQkFBUCxLQUE0QixVQUE1QixHQUNUQSxpQkFBaUI3TCxZQUFZQyxNQUFaLEVBQW9CQyxRQUFwQixDQUFqQixDQURTLEdBRVQyTCxnQkFGTjs7QUFJQSxRQUFJLE9BQU90RixRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDQSxpQkFBVyxFQUFFL0ksTUFBTStJLFFBQVIsRUFBWDtBQUNEOztBQUVELFFBQUksQ0FBQ0EsUUFBRCxJQUFhLE9BQU9BLFFBQVAsS0FBb0IsUUFBckMsRUFBK0M7QUFDN0NsUSxjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLEtBRHVDLEVBQy9CLDhCQUErQnFPLEtBQUtDLFNBQUwsQ0FBZWxELFFBQWYsQ0FEQSxDQUF6QztBQUdBLGFBQU9vRixhQUFhLElBQWIsRUFBbUJ6TCxRQUFuQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSTBKLEtBQUtyRCxRQUFUO0FBQ0EsUUFBSTlNLE9BQU9tUSxHQUFHblEsSUFBZDtBQUNBLFFBQUkrRCxPQUFPb00sR0FBR3BNLElBQWQ7QUFDQSxRQUFJYyxRQUFRNEIsU0FBUzVCLEtBQXJCO0FBQ0EsUUFBSStCLE9BQU9ILFNBQVNHLElBQXBCO0FBQ0EsUUFBSTlDLFNBQVMyQyxTQUFTM0MsTUFBdEI7QUFDQWUsWUFBUXNMLEdBQUdrQyxjQUFILENBQWtCLE9BQWxCLElBQTZCbEMsR0FBR3RMLEtBQWhDLEdBQXdDQSxLQUFoRDtBQUNBK0IsV0FBT3VKLEdBQUdrQyxjQUFILENBQWtCLE1BQWxCLElBQTRCbEMsR0FBR3ZKLElBQS9CLEdBQXNDQSxJQUE3QztBQUNBOUMsYUFBU3FNLEdBQUdrQyxjQUFILENBQWtCLFFBQWxCLElBQThCbEMsR0FBR3JNLE1BQWpDLEdBQTBDQSxNQUFuRDs7QUFFQSxRQUFJOUQsSUFBSixFQUFVO0FBQ1I7QUFDQSxVQUFJc1MsZUFBZTVGLFFBQVExTSxJQUFSLENBQW5CO0FBQ0EsVUFBSXBELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMUQsZUFBTytRLFlBQVAsRUFBc0Isb0NBQW9DdFMsSUFBcEMsR0FBMkMsZUFBakU7QUFDRDtBQUNELGFBQU95USxNQUFNO0FBQ1hnQixxQkFBYSxJQURGO0FBRVh6UixjQUFNQSxJQUZLO0FBR1g2RSxlQUFPQSxLQUhJO0FBSVgrQixjQUFNQSxJQUpLO0FBS1g5QyxnQkFBUUE7QUFMRyxPQUFOLEVBTUpILFNBTkksRUFNTzhDLFFBTlAsQ0FBUDtBQU9ELEtBYkQsTUFhTyxJQUFJMUMsSUFBSixFQUFVO0FBQ2Y7QUFDQSxVQUFJNE4sVUFBVVksa0JBQWtCeE8sSUFBbEIsRUFBd0J5QyxNQUF4QixDQUFkO0FBQ0E7QUFDQSxVQUFJZ00sZUFBZXBCLFdBQVdPLE9BQVgsRUFBb0I3TixNQUFwQixFQUE2QixnQ0FBZ0M2TixPQUFoQyxHQUEwQyxJQUF2RSxDQUFuQjtBQUNBO0FBQ0EsYUFBT2xCLE1BQU07QUFDWGdCLHFCQUFhLElBREY7QUFFWDFOLGNBQU15TyxZQUZLO0FBR1gzTixlQUFPQSxLQUhJO0FBSVgrQixjQUFNQTtBQUpLLE9BQU4sRUFLSmpELFNBTEksRUFLTzhDLFFBTFAsQ0FBUDtBQU1ELEtBWk0sTUFZQTtBQUNML0UsV0FBSyxLQUFMLEVBQWEsOEJBQStCcU8sS0FBS0MsU0FBTCxDQUFlbEQsUUFBZixDQUE1QztBQUNBLGFBQU9vRixhQUFhLElBQWIsRUFBbUJ6TCxRQUFuQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTeUcsS0FBVCxDQUNFMUcsTUFERixFQUVFQyxRQUZGLEVBR0VtRyxPQUhGLEVBSUU7QUFDQSxRQUFJNkYsY0FBY3JCLFdBQVd4RSxPQUFYLEVBQW9CbkcsU0FBUzNDLE1BQTdCLEVBQXNDLCtCQUErQjhJLE9BQS9CLEdBQXlDLElBQS9FLENBQWxCO0FBQ0EsUUFBSThGLGVBQWVqQyxNQUFNO0FBQ3ZCZ0IsbUJBQWEsSUFEVTtBQUV2QjFOLFlBQU0wTztBQUZpQixLQUFOLENBQW5CO0FBSUEsUUFBSUMsWUFBSixFQUFrQjtBQUNoQixVQUFJdFIsVUFBVXNSLGFBQWF0UixPQUEzQjtBQUNBLFVBQUl1UixnQkFBZ0J2UixRQUFRQSxRQUFRbkQsTUFBUixHQUFpQixDQUF6QixDQUFwQjtBQUNBd0ksZUFBUzNDLE1BQVQsR0FBa0I0TyxhQUFhNU8sTUFBL0I7QUFDQSxhQUFPb08sYUFBYVMsYUFBYixFQUE0QmxNLFFBQTVCLENBQVA7QUFDRDtBQUNELFdBQU95TCxhQUFhLElBQWIsRUFBbUJ6TCxRQUFuQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU3lMLFlBQVQsQ0FDRTFMLE1BREYsRUFFRUMsUUFGRixFQUdFQyxjQUhGLEVBSUU7QUFDQSxRQUFJRixVQUFVQSxPQUFPc0csUUFBckIsRUFBK0I7QUFDN0IsYUFBT0EsU0FBU3RHLE1BQVQsRUFBaUJFLGtCQUFrQkQsUUFBbkMsQ0FBUDtBQUNEO0FBQ0QsUUFBSUQsVUFBVUEsT0FBT29HLE9BQXJCLEVBQThCO0FBQzVCLGFBQU9NLE1BQU0xRyxNQUFOLEVBQWNDLFFBQWQsRUFBd0JELE9BQU9vRyxPQUEvQixDQUFQO0FBQ0Q7QUFDRCxXQUFPckcsWUFBWUMsTUFBWixFQUFvQkMsUUFBcEIsRUFBOEJDLGNBQTlCLENBQVA7QUFDRDs7QUFFRCxTQUFPO0FBQ0wrSixXQUFPQSxLQURGO0FBRUxzQixlQUFXQTtBQUZOLEdBQVA7QUFJRDs7QUFFRCxTQUFTSSxVQUFULENBQ0VwTyxJQURGLEVBRUVELE1BRkYsRUFHRThPLFFBSEYsRUFJRTtBQUNBLE1BQUl6USxNQUFNOE8sY0FBY2xOLElBQWQsQ0FBVjtBQUNBLE1BQUk0TSxTQUFTeE8sSUFBSXdPLE1BQWpCO0FBQ0EsTUFBSTVLLE9BQU81RCxJQUFJNEQsSUFBZjtBQUNBLE1BQUl1SSxJQUFJc0UsU0FBU25DLEtBQVQsQ0FBZUUsTUFBZixDQUFSOztBQUVBLE1BQUksQ0FBQ3JDLENBQUwsRUFBUTtBQUNOLFdBQU8sS0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLENBQUN4SyxNQUFMLEVBQWE7QUFDbEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJbkYsSUFBSSxDQUFSLEVBQVdOLE1BQU1pUSxFQUFFclEsTUFBeEIsRUFBZ0NVLElBQUlOLEdBQXBDLEVBQXlDLEVBQUVNLENBQTNDLEVBQThDO0FBQzVDLFFBQUl1RyxNQUFNYSxLQUFLcEgsSUFBSSxDQUFULENBQVY7QUFDQSxRQUFJK0csTUFBTSxPQUFPNEksRUFBRTNQLENBQUYsQ0FBUCxLQUFnQixRQUFoQixHQUEyQmdHLG1CQUFtQjJKLEVBQUUzUCxDQUFGLENBQW5CLENBQTNCLEdBQXNEMlAsRUFBRTNQLENBQUYsQ0FBaEU7QUFDQSxRQUFJdUcsR0FBSixFQUFTO0FBQUVwQixhQUFPb0IsSUFBSWxGLElBQVgsSUFBbUIwRixHQUFuQjtBQUF5QjtBQUNyQzs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTNk0saUJBQVQsQ0FBNEJ4TyxJQUE1QixFQUFrQ3lDLE1BQWxDLEVBQTBDO0FBQ3hDLFNBQU9nRixZQUFZekgsSUFBWixFQUFrQnlDLE9BQU9uRSxNQUFQLEdBQWdCbUUsT0FBT25FLE1BQVAsQ0FBYzBCLElBQTlCLEdBQXFDLEdBQXZELEVBQTRELElBQTVELENBQVA7QUFDRDs7QUFFRDs7QUFHQSxJQUFJOE8sZ0JBQWdCblMsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQXBCOztBQUVBLFNBQVNxRyxXQUFULEdBQXdCO0FBQ3RCdkgsU0FBT3dILGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLFVBQVUxVixDQUFWLEVBQWE7QUFDL0MyVjtBQUNBLFFBQUkzVixFQUFFNFYsS0FBRixJQUFXNVYsRUFBRTRWLEtBQUYsQ0FBUS9OLEdBQXZCLEVBQTRCO0FBQzFCZ08sa0JBQVk3VixFQUFFNFYsS0FBRixDQUFRL04sR0FBcEI7QUFDRDtBQUNGLEdBTEQ7QUFNRDs7QUFFRCxTQUFTaU8sWUFBVCxDQUNFeEssTUFERixFQUVFVCxFQUZGLEVBR0VrTCxJQUhGLEVBSUVDLEtBSkYsRUFLRTtBQUNBLE1BQUksQ0FBQzFLLE9BQU8ySyxHQUFaLEVBQWlCO0FBQ2Y7QUFDRDs7QUFFRCxNQUFJQyxXQUFXNUssT0FBT0ssT0FBUCxDQUFld0ssY0FBOUI7QUFDQSxNQUFJLENBQUNELFFBQUwsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQsTUFBSTNXLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMUQsV0FBTyxPQUFPZ1MsUUFBUCxLQUFvQixVQUEzQixFQUF1QyxtQ0FBdkM7QUFDRDs7QUFFRDtBQUNBNUssU0FBTzJLLEdBQVAsQ0FBV0csU0FBWCxDQUFxQixZQUFZO0FBQy9CLFFBQUlDLFdBQVdDLG1CQUFmO0FBQ0EsUUFBSUMsZUFBZUwsU0FBU3JMLEVBQVQsRUFBYWtMLElBQWIsRUFBbUJDLFFBQVFLLFFBQVIsR0FBbUIsSUFBdEMsQ0FBbkI7QUFDQSxRQUFJLENBQUNFLFlBQUwsRUFBbUI7QUFDakI7QUFDRDtBQUNELFFBQUlDLFdBQVcsT0FBT0QsWUFBUCxLQUF3QixRQUF2QztBQUNBLFFBQUlDLFlBQVksT0FBT0QsYUFBYUUsUUFBcEIsS0FBaUMsUUFBakQsRUFBMkQ7QUFDekQsVUFBSUMsS0FBS0MsU0FBU0MsYUFBVCxDQUF1QkwsYUFBYUUsUUFBcEMsQ0FBVDtBQUNBLFVBQUlDLEVBQUosRUFBUTtBQUNOTCxtQkFBV1EsbUJBQW1CSCxFQUFuQixDQUFYO0FBQ0QsT0FGRCxNQUVPLElBQUlJLGdCQUFnQlAsWUFBaEIsQ0FBSixFQUFtQztBQUN4Q0YsbUJBQVdVLGtCQUFrQlIsWUFBbEIsQ0FBWDtBQUNEO0FBQ0YsS0FQRCxNQU9PLElBQUlDLFlBQVlNLGdCQUFnQlAsWUFBaEIsQ0FBaEIsRUFBK0M7QUFDcERGLGlCQUFXVSxrQkFBa0JSLFlBQWxCLENBQVg7QUFDRDs7QUFFRCxRQUFJRixRQUFKLEVBQWM7QUFDWm5JLGFBQU84SSxRQUFQLENBQWdCWCxTQUFTck4sQ0FBekIsRUFBNEJxTixTQUFTWSxDQUFyQztBQUNEO0FBQ0YsR0FyQkQ7QUFzQkQ7O0FBRUQsU0FBU3RCLGtCQUFULEdBQStCO0FBQzdCLE1BQUk5TixNQUFNcVAsYUFBVjtBQUNBLE1BQUlyUCxHQUFKLEVBQVM7QUFDUDJOLGtCQUFjM04sR0FBZCxJQUFxQjtBQUNuQm1CLFNBQUdrRixPQUFPaUosV0FEUztBQUVuQkYsU0FBRy9JLE9BQU9rSjtBQUZTLEtBQXJCO0FBSUQ7QUFDRjs7QUFFRCxTQUFTZCxpQkFBVCxHQUE4QjtBQUM1QixNQUFJek8sTUFBTXFQLGFBQVY7QUFDQSxNQUFJclAsR0FBSixFQUFTO0FBQ1AsV0FBTzJOLGNBQWMzTixHQUFkLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNnUCxrQkFBVCxDQUE2QkgsRUFBN0IsRUFBaUM7QUFDL0IsTUFBSVcsUUFBUVYsU0FBU1csZUFBckI7QUFDQSxNQUFJQyxVQUFVRixNQUFNRyxxQkFBTixFQUFkO0FBQ0EsTUFBSUMsU0FBU2YsR0FBR2MscUJBQUgsRUFBYjtBQUNBLFNBQU87QUFDTHhPLE9BQUd5TyxPQUFPQyxJQUFQLEdBQWNILFFBQVFHLElBRHBCO0FBRUxULE9BQUdRLE9BQU9FLEdBQVAsR0FBYUosUUFBUUk7QUFGbkIsR0FBUDtBQUlEOztBQUVELFNBQVNiLGVBQVQsQ0FBMEJyTyxHQUExQixFQUErQjtBQUM3QixTQUFPbVAsU0FBU25QLElBQUlPLENBQWIsS0FBbUI0TyxTQUFTblAsSUFBSXdPLENBQWIsQ0FBMUI7QUFDRDs7QUFFRCxTQUFTRixpQkFBVCxDQUE0QnRPLEdBQTVCLEVBQWlDO0FBQy9CLFNBQU87QUFDTE8sT0FBRzRPLFNBQVNuUCxJQUFJTyxDQUFiLElBQWtCUCxJQUFJTyxDQUF0QixHQUEwQmtGLE9BQU9pSixXQUQvQjtBQUVMRixPQUFHVyxTQUFTblAsSUFBSXdPLENBQWIsSUFBa0J4TyxJQUFJd08sQ0FBdEIsR0FBMEIvSSxPQUFPa0o7QUFGL0IsR0FBUDtBQUlEOztBQUVELFNBQVNRLFFBQVQsQ0FBbUJDLENBQW5CLEVBQXNCO0FBQ3BCLFNBQU8sT0FBT0EsQ0FBUCxLQUFhLFFBQXBCO0FBQ0Q7O0FBRUQ7O0FBRUEsSUFBSUMsb0JBQW9CN0osYUFBYyxZQUFZO0FBQ2hELE1BQUk4SixLQUFLN0osT0FBTzhKLFNBQVAsQ0FBaUJDLFNBQTFCOztBQUVBLE1BQ0UsQ0FBQ0YsR0FBR3ZOLE9BQUgsQ0FBVyxZQUFYLE1BQTZCLENBQUMsQ0FBOUIsSUFBbUN1TixHQUFHdk4sT0FBSCxDQUFXLGFBQVgsTUFBOEIsQ0FBQyxDQUFuRSxLQUNBdU4sR0FBR3ZOLE9BQUgsQ0FBVyxlQUFYLE1BQWdDLENBQUMsQ0FEakMsSUFFQXVOLEdBQUd2TixPQUFILENBQVcsUUFBWCxNQUF5QixDQUFDLENBRjFCLElBR0F1TixHQUFHdk4sT0FBSCxDQUFXLGVBQVgsTUFBZ0MsQ0FBQyxDQUpuQyxFQUtFO0FBQ0EsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTzBELE9BQU9QLE9BQVAsSUFBa0IsZUFBZU8sT0FBT1AsT0FBL0M7QUFDRCxDQWJvQyxFQUFyQzs7QUFlQTtBQUNBLElBQUl1SyxPQUFPakssYUFBYUMsT0FBT2lLLFdBQXBCLElBQW1DakssT0FBT2lLLFdBQVAsQ0FBbUJDLEdBQXRELEdBQ1BsSyxPQUFPaUssV0FEQSxHQUVQRSxJQUZKOztBQUlBLElBQUlDLE9BQU9DLFFBQVg7O0FBRUEsU0FBU0EsTUFBVCxHQUFtQjtBQUNqQixTQUFPTCxLQUFLRSxHQUFMLEdBQVdJLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBUDtBQUNEOztBQUVELFNBQVN0QixXQUFULEdBQXdCO0FBQ3RCLFNBQU9vQixJQUFQO0FBQ0Q7O0FBRUQsU0FBU3pDLFdBQVQsQ0FBc0JoTyxHQUF0QixFQUEyQjtBQUN6QnlRLFNBQU96USxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzRRLFNBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCdFIsT0FBekIsRUFBa0M7QUFDaEN1TztBQUNBO0FBQ0E7QUFDQSxNQUFJaEksVUFBVU8sT0FBT1AsT0FBckI7QUFDQSxNQUFJO0FBQ0YsUUFBSXZHLE9BQUosRUFBYTtBQUNYdUcsY0FBUWdMLFlBQVIsQ0FBcUIsRUFBRTlRLEtBQUt5USxJQUFQLEVBQXJCLEVBQW9DLEVBQXBDLEVBQXdDSSxHQUF4QztBQUNELEtBRkQsTUFFTztBQUNMSixhQUFPQyxRQUFQO0FBQ0E1SyxjQUFROEssU0FBUixDQUFrQixFQUFFNVEsS0FBS3lRLElBQVAsRUFBbEIsRUFBaUMsRUFBakMsRUFBcUNJLEdBQXJDO0FBQ0Q7QUFDRixHQVBELENBT0UsT0FBTzFZLENBQVAsRUFBVTtBQUNWa08sV0FBTzlFLFFBQVAsQ0FBZ0JoQyxVQUFVLFNBQVYsR0FBc0IsUUFBdEMsRUFBZ0RzUixHQUFoRDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsWUFBVCxDQUF1QkQsR0FBdkIsRUFBNEI7QUFDMUJELFlBQVVDLEdBQVYsRUFBZSxJQUFmO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU0UsUUFBVCxDQUFtQnJZLEtBQW5CLEVBQTBCc1ksRUFBMUIsRUFBOEJDLEVBQTlCLEVBQWtDO0FBQ2hDLE1BQUlDLE9BQU8sVUFBVTNWLEtBQVYsRUFBaUI7QUFDMUIsUUFBSUEsU0FBUzdDLE1BQU1LLE1BQW5CLEVBQTJCO0FBQ3pCa1k7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJdlksTUFBTTZDLEtBQU4sQ0FBSixFQUFrQjtBQUNoQnlWLFdBQUd0WSxNQUFNNkMsS0FBTixDQUFILEVBQWlCLFlBQVk7QUFDM0IyVixlQUFLM1YsUUFBUSxDQUFiO0FBQ0QsU0FGRDtBQUdELE9BSkQsTUFJTztBQUNMMlYsYUFBSzNWLFFBQVEsQ0FBYjtBQUNEO0FBQ0Y7QUFDRixHQVpEO0FBYUEyVixPQUFLLENBQUw7QUFDRDs7QUFFRDs7QUFHQSxJQUFJQyxVQUFVLFNBQVNBLE9BQVQsQ0FBa0IxTixNQUFsQixFQUEwQitDLElBQTFCLEVBQWdDO0FBQzVDLE9BQUsvQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLK0MsSUFBTCxHQUFZNEssY0FBYzVLLElBQWQsQ0FBWjtBQUNBO0FBQ0EsT0FBSy9ELE9BQUwsR0FBZVYsS0FBZjtBQUNBLE9BQUtzUCxPQUFMLEdBQWUsSUFBZjtBQUNBLE9BQUtDLEtBQUwsR0FBYSxLQUFiO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNELENBUkQ7O0FBVUFKLFFBQVF0WCxTQUFSLENBQWtCMlgsTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxDQUFpQlAsRUFBakIsRUFBcUI7QUFDOUMsT0FBS0EsRUFBTCxHQUFVQSxFQUFWO0FBQ0QsQ0FGRDs7QUFJQUUsUUFBUXRYLFNBQVIsQ0FBa0I0WCxPQUFsQixHQUE0QixTQUFTQSxPQUFULENBQWtCUixFQUFsQixFQUFzQjtBQUNoRCxNQUFJLEtBQUtLLEtBQVQsRUFBZ0I7QUFDZEw7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLTSxRQUFMLENBQWM3WCxJQUFkLENBQW1CdVgsRUFBbkI7QUFDRDtBQUNGLENBTkQ7O0FBUUFFLFFBQVF0WCxTQUFSLENBQWtCNlgsWUFBbEIsR0FBaUMsU0FBU0EsWUFBVCxDQUF1Qm5RLFFBQXZCLEVBQWlDb1EsVUFBakMsRUFBNkNDLE9BQTdDLEVBQXNEO0FBQ25GLE1BQUlwTyxTQUFTLElBQWI7O0FBRUYsTUFBSWxHLFFBQVEsS0FBS21HLE1BQUwsQ0FBWThILEtBQVosQ0FBa0JoSyxRQUFsQixFQUE0QixLQUFLa0IsT0FBakMsQ0FBWjtBQUNBLE9BQUtvUCxpQkFBTCxDQUF1QnZVLEtBQXZCLEVBQThCLFlBQVk7QUFDeENrRyxXQUFPc08sV0FBUCxDQUFtQnhVLEtBQW5CO0FBQ0FxVSxrQkFBY0EsV0FBV3JVLEtBQVgsQ0FBZDtBQUNBa0csV0FBT3VPLFNBQVA7O0FBRUE7QUFDQSxRQUFJLENBQUN2TyxPQUFPOE4sS0FBWixFQUFtQjtBQUNqQjlOLGFBQU84TixLQUFQLEdBQWUsSUFBZjtBQUNBOU4sYUFBTytOLFFBQVAsQ0FBZ0JuUixPQUFoQixDQUF3QixVQUFVNlEsRUFBVixFQUFjO0FBQ3BDQSxXQUFHM1QsS0FBSDtBQUNELE9BRkQ7QUFHRDtBQUNGLEdBWkQsRUFZR3NVLE9BWkg7QUFhRCxDQWpCRDs7QUFtQkFULFFBQVF0WCxTQUFSLENBQWtCZ1ksaUJBQWxCLEdBQXNDLFNBQVNBLGlCQUFULENBQTRCdlUsS0FBNUIsRUFBbUNxVSxVQUFuQyxFQUErQ0MsT0FBL0MsRUFBd0Q7QUFDMUYsTUFBSXBPLFNBQVMsSUFBYjs7QUFFRixNQUFJZixVQUFVLEtBQUtBLE9BQW5CO0FBQ0EsTUFBSXVQLFFBQVEsWUFBWTtBQUFFSixlQUFXQSxTQUFYO0FBQXVCLEdBQWpEO0FBQ0EsTUFDRTNQLFlBQVkzRSxLQUFaLEVBQW1CbUYsT0FBbkI7QUFDQTtBQUNBbkYsUUFBTXBCLE9BQU4sQ0FBY25ELE1BQWQsS0FBeUIwSixRQUFRdkcsT0FBUixDQUFnQm5ELE1BSDNDLEVBSUU7QUFDQSxTQUFLZ1osU0FBTDtBQUNBLFdBQU9DLE9BQVA7QUFDRDs7QUFFRCxNQUFJL1UsTUFBTWdWLGFBQWEsS0FBS3hQLE9BQUwsQ0FBYXZHLE9BQTFCLEVBQW1Db0IsTUFBTXBCLE9BQXpDLENBQVY7QUFDRSxNQUFJZ1csVUFBVWpWLElBQUlpVixPQUFsQjtBQUNBLE1BQUlDLGNBQWNsVixJQUFJa1YsV0FBdEI7QUFDQSxNQUFJQyxZQUFZblYsSUFBSW1WLFNBQXBCOztBQUVGLE1BQUkxWixRQUFRLEdBQUdNLE1BQUg7QUFDVjtBQUNBcVoscUJBQW1CRixXQUFuQixDQUZVO0FBR1Y7QUFDQSxPQUFLMU8sTUFBTCxDQUFZNk8sV0FKRjtBQUtWO0FBQ0FDLHFCQUFtQkwsT0FBbkIsQ0FOVTtBQU9WO0FBQ0FFLFlBQVV0UixHQUFWLENBQWMsVUFBVXNJLENBQVYsRUFBYTtBQUFFLFdBQU9BLEVBQUV2QixXQUFUO0FBQXVCLEdBQXBELENBUlU7QUFTVjtBQUNBMksseUJBQXVCSixTQUF2QixDQVZVLENBQVo7O0FBYUEsT0FBS2YsT0FBTCxHQUFlL1QsS0FBZjtBQUNBLE1BQUltVixXQUFXLFVBQVV4VSxJQUFWLEVBQWdCc0wsSUFBaEIsRUFBc0I7QUFDbkMsUUFBSS9GLE9BQU82TixPQUFQLEtBQW1CL1QsS0FBdkIsRUFBOEI7QUFDNUIsYUFBTzBVLE9BQVA7QUFDRDtBQUNEL1QsU0FBS1gsS0FBTCxFQUFZbUYsT0FBWixFQUFxQixVQUFVTyxFQUFWLEVBQWM7QUFDakMsVUFBSUEsT0FBTyxLQUFYLEVBQWtCO0FBQ2hCO0FBQ0FRLGVBQU91TyxTQUFQLENBQWlCLElBQWpCO0FBQ0FDO0FBQ0QsT0FKRCxNQUlPLElBQUksT0FBT2hQLEVBQVAsS0FBYyxRQUFkLElBQTBCLE9BQU9BLEVBQVAsS0FBYyxRQUE1QyxFQUFzRDtBQUMzRDtBQUNDLGVBQU9BLEVBQVAsS0FBYyxRQUFkLElBQTBCQSxHQUFHekQsT0FBOUIsR0FBeUNpRSxPQUFPakUsT0FBUCxDQUFleUQsRUFBZixDQUF6QyxHQUE4RFEsT0FBTzlKLElBQVAsQ0FBWXNKLEVBQVosQ0FBOUQ7QUFDQWdQO0FBQ0QsT0FKTSxNQUlBO0FBQ0w7QUFDQXpJLGFBQUt2RyxFQUFMO0FBQ0Q7QUFDRixLQWJEO0FBY0QsR0FsQkQ7O0FBb0JBK04sV0FBU3JZLEtBQVQsRUFBZ0IrWixRQUFoQixFQUEwQixZQUFZO0FBQ3BDLFFBQUlDLGVBQWUsRUFBbkI7QUFDQSxRQUFJQyxVQUFVLFlBQVk7QUFBRSxhQUFPblAsT0FBT2YsT0FBUCxLQUFtQm5GLEtBQTFCO0FBQWtDLEtBQTlEO0FBQ0EsUUFBSXNWLGNBQWNDLG1CQUFtQlQsU0FBbkIsRUFBOEJNLFlBQTlCLEVBQTRDQyxPQUE1QyxDQUFsQjtBQUNBO0FBQ0E7QUFDQTVCLGFBQVM2QixXQUFULEVBQXNCSCxRQUF0QixFQUFnQyxZQUFZO0FBQzFDLFVBQUlqUCxPQUFPNk4sT0FBUCxLQUFtQi9ULEtBQXZCLEVBQThCO0FBQzVCLGVBQU8wVSxPQUFQO0FBQ0Q7QUFDRHhPLGFBQU82TixPQUFQLEdBQWlCLElBQWpCO0FBQ0FNLGlCQUFXclUsS0FBWDtBQUNBLFVBQUlrRyxPQUFPQyxNQUFQLENBQWMySyxHQUFsQixFQUF1QjtBQUNyQjVLLGVBQU9DLE1BQVAsQ0FBYzJLLEdBQWQsQ0FBa0JHLFNBQWxCLENBQTRCLFlBQVk7QUFDdENtRSx1QkFBYXRTLE9BQWIsQ0FBcUIsVUFBVTZRLEVBQVYsRUFBYztBQUFFLG1CQUFPQSxJQUFQO0FBQWMsV0FBbkQ7QUFDRCxTQUZEO0FBR0Q7QUFDRixLQVhEO0FBWUQsR0FsQkQ7QUFtQkQsQ0F4RUQ7O0FBMEVBRSxRQUFRdFgsU0FBUixDQUFrQmlZLFdBQWxCLEdBQWdDLFNBQVNBLFdBQVQsQ0FBc0J4VSxLQUF0QixFQUE2QjtBQUMzRCxNQUFJd1YsT0FBTyxLQUFLclEsT0FBaEI7QUFDQSxPQUFLQSxPQUFMLEdBQWVuRixLQUFmO0FBQ0EsT0FBSzJULEVBQUwsSUFBVyxLQUFLQSxFQUFMLENBQVEzVCxLQUFSLENBQVg7QUFDQSxPQUFLbUcsTUFBTCxDQUFZc1AsVUFBWixDQUF1QjNTLE9BQXZCLENBQStCLFVBQVVuQyxJQUFWLEVBQWdCO0FBQzdDQSxZQUFRQSxLQUFLWCxLQUFMLEVBQVl3VixJQUFaLENBQVI7QUFDRCxHQUZEO0FBR0QsQ0FQRDs7QUFTQSxTQUFTMUIsYUFBVCxDQUF3QjVLLElBQXhCLEVBQThCO0FBQzVCLE1BQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1QsUUFBSUosU0FBSixFQUFlO0FBQ2I7QUFDQSxVQUFJNE0sU0FBU2xFLFNBQVNDLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBYjtBQUNBdkksYUFBUXdNLFVBQVVBLE9BQU83TixZQUFQLENBQW9CLE1BQXBCLENBQVgsSUFBMkMsR0FBbEQ7QUFDRCxLQUpELE1BSU87QUFDTHFCLGFBQU8sR0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLE1BQUlBLEtBQUtDLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQXZCLEVBQTRCO0FBQzFCRCxXQUFPLE1BQU1BLElBQWI7QUFDRDtBQUNEO0FBQ0EsU0FBT0EsS0FBS2pILE9BQUwsQ0FBYSxLQUFiLEVBQW9CLEVBQXBCLENBQVA7QUFDRDs7QUFFRCxTQUFTMFMsWUFBVCxDQUNFeFAsT0FERixFQUVFOEcsSUFGRixFQUdFO0FBQ0EsTUFBSTlQLENBQUo7QUFDQSxNQUFJd1osTUFBTUMsS0FBS0QsR0FBTCxDQUFTeFEsUUFBUTFKLE1BQWpCLEVBQXlCd1EsS0FBS3hRLE1BQTlCLENBQVY7QUFDQSxPQUFLVSxJQUFJLENBQVQsRUFBWUEsSUFBSXdaLEdBQWhCLEVBQXFCeFosR0FBckIsRUFBMEI7QUFDeEIsUUFBSWdKLFFBQVFoSixDQUFSLE1BQWU4UCxLQUFLOVAsQ0FBTCxDQUFuQixFQUE0QjtBQUMxQjtBQUNEO0FBQ0Y7QUFDRCxTQUFPO0FBQ0x5WSxhQUFTM0ksS0FBS3ZJLEtBQUwsQ0FBVyxDQUFYLEVBQWN2SCxDQUFkLENBREo7QUFFTDJZLGVBQVc3SSxLQUFLdkksS0FBTCxDQUFXdkgsQ0FBWCxDQUZOO0FBR0wwWSxpQkFBYTFQLFFBQVF6QixLQUFSLENBQWN2SCxDQUFkO0FBSFIsR0FBUDtBQUtEOztBQUVELFNBQVMwWixhQUFULENBQ0VDLE9BREYsRUFFRXRZLElBRkYsRUFHRXVZLElBSEYsRUFJRUMsT0FKRixFQUtFO0FBQ0EsTUFBSUMsU0FBU0Msa0JBQWtCSixPQUFsQixFQUEyQixVQUFVSyxHQUFWLEVBQWVDLFFBQWYsRUFBeUJuSSxLQUF6QixFQUFnQ3ZMLEdBQWhDLEVBQXFDO0FBQzNFLFFBQUkyVCxRQUFRQyxhQUFhSCxHQUFiLEVBQWtCM1ksSUFBbEIsQ0FBWjtBQUNBLFFBQUk2WSxLQUFKLEVBQVc7QUFDVCxhQUFPcGEsTUFBTW1ILE9BQU4sQ0FBY2lULEtBQWQsSUFDSEEsTUFBTTdTLEdBQU4sQ0FBVSxVQUFVNlMsS0FBVixFQUFpQjtBQUFFLGVBQU9OLEtBQUtNLEtBQUwsRUFBWUQsUUFBWixFQUFzQm5JLEtBQXRCLEVBQTZCdkwsR0FBN0IsQ0FBUDtBQUEyQyxPQUF4RSxDQURHLEdBRUhxVCxLQUFLTSxLQUFMLEVBQVlELFFBQVosRUFBc0JuSSxLQUF0QixFQUE2QnZMLEdBQTdCLENBRko7QUFHRDtBQUNGLEdBUFksQ0FBYjtBQVFBLFNBQU82VCxRQUFRUCxVQUFVQyxPQUFPRCxPQUFQLEVBQVYsR0FBNkJDLE1BQXJDLENBQVA7QUFDRDs7QUFFRCxTQUFTSyxZQUFULENBQ0VILEdBREYsRUFFRXpULEdBRkYsRUFHRTtBQUNBLE1BQUksT0FBT3lULEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUM3QjtBQUNBQSxVQUFNL08sS0FBS0QsTUFBTCxDQUFZZ1AsR0FBWixDQUFOO0FBQ0Q7QUFDRCxTQUFPQSxJQUFJM1AsT0FBSixDQUFZOUQsR0FBWixDQUFQO0FBQ0Q7O0FBRUQsU0FBU3FTLGtCQUFULENBQTZCRixXQUE3QixFQUEwQztBQUN4QyxTQUFPZ0IsY0FBY2hCLFdBQWQsRUFBMkIsa0JBQTNCLEVBQStDMkIsU0FBL0MsRUFBMEQsSUFBMUQsQ0FBUDtBQUNEOztBQUVELFNBQVN2QixrQkFBVCxDQUE2QkwsT0FBN0IsRUFBc0M7QUFDcEMsU0FBT2lCLGNBQWNqQixPQUFkLEVBQXVCLG1CQUF2QixFQUE0QzRCLFNBQTVDLENBQVA7QUFDRDs7QUFFRCxTQUFTQSxTQUFULENBQW9CSCxLQUFwQixFQUEyQkQsUUFBM0IsRUFBcUM7QUFDbkMsU0FBTyxTQUFTSyxlQUFULEdBQTRCO0FBQ2pDLFdBQU9KLE1BQU03WixLQUFOLENBQVk0WixRQUFaLEVBQXNCbGEsU0FBdEIsQ0FBUDtBQUNELEdBRkQ7QUFHRDs7QUFFRCxTQUFTcVosa0JBQVQsQ0FDRVQsU0FERixFQUVFNEIsR0FGRixFQUdFckIsT0FIRixFQUlFO0FBQ0EsU0FBT1EsY0FBY2YsU0FBZCxFQUF5QixrQkFBekIsRUFBNkMsVUFBVXVCLEtBQVYsRUFBaUJNLENBQWpCLEVBQW9CMUksS0FBcEIsRUFBMkJ2TCxHQUEzQixFQUFnQztBQUNsRixXQUFPa1UsZUFBZVAsS0FBZixFQUFzQnBJLEtBQXRCLEVBQTZCdkwsR0FBN0IsRUFBa0NnVSxHQUFsQyxFQUF1Q3JCLE9BQXZDLENBQVA7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRCxTQUFTdUIsY0FBVCxDQUNFUCxLQURGLEVBRUVwSSxLQUZGLEVBR0V2TCxHQUhGLEVBSUVnVSxHQUpGLEVBS0VyQixPQUxGLEVBTUU7QUFDQSxTQUFPLFNBQVN3QixlQUFULENBQTBCblIsRUFBMUIsRUFBOEJrTCxJQUE5QixFQUFvQzNFLElBQXBDLEVBQTBDO0FBQy9DLFdBQU9vSyxNQUFNM1EsRUFBTixFQUFVa0wsSUFBVixFQUFnQixVQUFVK0MsRUFBVixFQUFjO0FBQ25DMUgsV0FBSzBILEVBQUw7QUFDQSxVQUFJLE9BQU9BLEVBQVAsS0FBYyxVQUFsQixFQUE4QjtBQUM1QitDLFlBQUl0YSxJQUFKLENBQVMsWUFBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EwYSxlQUFLbkQsRUFBTCxFQUFTMUYsTUFBTW5OLFNBQWYsRUFBMEI0QixHQUExQixFQUErQjJTLE9BQS9CO0FBQ0QsU0FQRDtBQVFEO0FBQ0YsS0FaTSxDQUFQO0FBYUQsR0FkRDtBQWVEOztBQUVELFNBQVN5QixJQUFULENBQ0VuRCxFQURGLEVBQ007QUFDSjdTLFNBRkYsRUFHRTRCLEdBSEYsRUFJRTJTLE9BSkYsRUFLRTtBQUNBLE1BQUl2VSxVQUFVNEIsR0FBVixDQUFKLEVBQW9CO0FBQ2xCaVIsT0FBRzdTLFVBQVU0QixHQUFWLENBQUg7QUFDRCxHQUZELE1BRU8sSUFBSTJTLFNBQUosRUFBZTtBQUNwQnphLGVBQVcsWUFBWTtBQUNyQmtjLFdBQUtuRCxFQUFMLEVBQVM3UyxTQUFULEVBQW9CNEIsR0FBcEIsRUFBeUIyUyxPQUF6QjtBQUNELEtBRkQsRUFFRyxFQUZIO0FBR0Q7QUFDRjs7QUFFRCxTQUFTSCxzQkFBVCxDQUFpQ3RXLE9BQWpDLEVBQTBDO0FBQ3hDLFNBQU9zWCxrQkFBa0J0WCxPQUFsQixFQUEyQixVQUFVdVgsR0FBVixFQUFlUSxDQUFmLEVBQWtCMUksS0FBbEIsRUFBeUJ2TCxHQUF6QixFQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSSxPQUFPeVQsR0FBUCxLQUFlLFVBQWYsSUFBNkIsQ0FBQ0EsSUFBSTNQLE9BQXRDLEVBQStDO0FBQzdDLGFBQU8sVUFBVWQsRUFBVixFQUFja0wsSUFBZCxFQUFvQjNFLElBQXBCLEVBQTBCO0FBQy9CLFlBQUk1RixVQUFVbkosS0FBSyxVQUFVNlosV0FBVixFQUF1QjtBQUN4QzlJLGdCQUFNeE4sVUFBTixDQUFpQmlDLEdBQWpCLElBQXdCcVUsV0FBeEI7QUFDQTlLO0FBQ0QsU0FIYSxDQUFkOztBQUtBLFlBQUkrSyxTQUFTOVosS0FBSyxVQUFVK1osTUFBVixFQUFrQjtBQUNsQy9YLGVBQUssS0FBTCxFQUFhLHVDQUF1Q3dELEdBQXZDLEdBQTZDLElBQTdDLEdBQW9EdVUsTUFBakU7QUFDQWhMLGVBQUssS0FBTDtBQUNELFNBSFksQ0FBYjs7QUFLQSxZQUFJdEosTUFBTXdULElBQUk5UCxPQUFKLEVBQWEyUSxNQUFiLENBQVY7QUFDQSxZQUFJclUsT0FBTyxPQUFPQSxJQUFJdVUsSUFBWCxLQUFvQixVQUEvQixFQUEyQztBQUN6Q3ZVLGNBQUl1VSxJQUFKLENBQVM3USxPQUFULEVBQWtCMlEsTUFBbEI7QUFDRDtBQUNGLE9BZkQ7QUFnQkQ7QUFDRixHQXhCTSxDQUFQO0FBeUJEOztBQUVELFNBQVNkLGlCQUFULENBQ0V0WCxPQURGLEVBRUU4VSxFQUZGLEVBR0U7QUFDQSxTQUFPNkMsUUFBUTNYLFFBQVE0RSxHQUFSLENBQVksVUFBVXNJLENBQVYsRUFBYTtBQUN0QyxXQUFPNU4sT0FBT3FGLElBQVAsQ0FBWXVJLEVBQUVyTCxVQUFkLEVBQTBCK0MsR0FBMUIsQ0FBOEIsVUFBVWQsR0FBVixFQUFlO0FBQUUsYUFBT2dSLEdBQzNENUgsRUFBRXJMLFVBQUYsQ0FBYWlDLEdBQWIsQ0FEMkQsRUFFM0RvSixFQUFFaEwsU0FBRixDQUFZNEIsR0FBWixDQUYyRCxFQUczRG9KLENBSDJELEVBR3hEcEosR0FId0QsQ0FBUDtBQUlsRCxLQUpHLENBQVA7QUFLRCxHQU5jLENBQVIsQ0FBUDtBQU9EOztBQUVELFNBQVM2VCxPQUFULENBQWtCMUwsR0FBbEIsRUFBdUI7QUFDckIsU0FBTzVPLE1BQU1NLFNBQU4sQ0FBZ0JiLE1BQWhCLENBQXVCYyxLQUF2QixDQUE2QixFQUE3QixFQUFpQ3FPLEdBQWpDLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMzTixJQUFULENBQWV3VyxFQUFmLEVBQW1CO0FBQ2pCLE1BQUl5RCxTQUFTLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSUEsTUFBSixFQUFZO0FBQUU7QUFBUTtBQUN0QkEsYUFBUyxJQUFUO0FBQ0EsV0FBT3pELEdBQUdsWCxLQUFILENBQVMsSUFBVCxFQUFlTixTQUFmLENBQVA7QUFDRCxHQUpEO0FBS0Q7O0FBRUQ7O0FBR0EsSUFBSWtiLGVBQWdCLFVBQVVDLFVBQVYsRUFBc0I7QUFDeEMsV0FBU0QsWUFBVCxDQUF1QmpSLE1BQXZCLEVBQStCK0MsSUFBL0IsRUFBcUM7QUFDbkMsUUFBSWhELFNBQVMsSUFBYjs7QUFFQW1SLGVBQVdwYyxJQUFYLENBQWdCLElBQWhCLEVBQXNCa0wsTUFBdEIsRUFBOEIrQyxJQUE5Qjs7QUFFQSxRQUFJb08sZUFBZW5SLE9BQU9LLE9BQVAsQ0FBZXdLLGNBQWxDOztBQUVBLFFBQUlzRyxZQUFKLEVBQWtCO0FBQ2hCaEg7QUFDRDs7QUFFRHZILFdBQU93SCxnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxVQUFVMVYsQ0FBVixFQUFhO0FBQy9DcUwsYUFBT2tPLFlBQVAsQ0FBb0JtRCxZQUFZclIsT0FBT2dELElBQW5CLENBQXBCLEVBQThDLFVBQVVsSixLQUFWLEVBQWlCO0FBQzdELFlBQUlzWCxZQUFKLEVBQWtCO0FBQ2hCM0csdUJBQWF4SyxNQUFiLEVBQXFCbkcsS0FBckIsRUFBNEJrRyxPQUFPZixPQUFuQyxFQUE0QyxJQUE1QztBQUNEO0FBQ0YsT0FKRDtBQUtELEtBTkQ7QUFPRDs7QUFFRCxNQUFLa1MsVUFBTCxFQUFrQkQsYUFBYUksU0FBYixHQUF5QkgsVUFBekI7QUFDbEJELGVBQWE3YSxTQUFiLEdBQXlCMkIsT0FBTytMLE1BQVAsQ0FBZW9OLGNBQWNBLFdBQVc5YSxTQUF4QyxDQUF6QjtBQUNBNmEsZUFBYTdhLFNBQWIsQ0FBdUJrYixXQUF2QixHQUFxQ0wsWUFBckM7O0FBRUFBLGVBQWE3YSxTQUFiLENBQXVCbWIsRUFBdkIsR0FBNEIsU0FBU0EsRUFBVCxDQUFhQyxDQUFiLEVBQWdCO0FBQzFDNU8sV0FBT1AsT0FBUCxDQUFla1AsRUFBZixDQUFrQkMsQ0FBbEI7QUFDRCxHQUZEOztBQUlBUCxlQUFhN2EsU0FBYixDQUF1QkgsSUFBdkIsR0FBOEIsU0FBU0EsSUFBVCxDQUFlNkgsUUFBZixFQUF5Qm9RLFVBQXpCLEVBQXFDQyxPQUFyQyxFQUE4QztBQUMxRSxRQUFJcE8sU0FBUyxJQUFiOztBQUVBLFNBQUtrTyxZQUFMLENBQWtCblEsUUFBbEIsRUFBNEIsVUFBVWpFLEtBQVYsRUFBaUI7QUFDM0NzVCxnQkFBVTNKLFVBQVV6RCxPQUFPZ0QsSUFBUCxHQUFjbEosTUFBTXFFLFFBQTlCLENBQVY7QUFDQXNNLG1CQUFhekssT0FBT0MsTUFBcEIsRUFBNEJuRyxLQUE1QixFQUFtQ2tHLE9BQU9mLE9BQTFDLEVBQW1ELEtBQW5EO0FBQ0FrUCxvQkFBY0EsV0FBV3JVLEtBQVgsQ0FBZDtBQUNELEtBSkQsRUFJR3NVLE9BSkg7QUFLRCxHQVJEOztBQVVBOEMsZUFBYTdhLFNBQWIsQ0FBdUIwRixPQUF2QixHQUFpQyxTQUFTQSxPQUFULENBQWtCZ0MsUUFBbEIsRUFBNEJvUSxVQUE1QixFQUF3Q0MsT0FBeEMsRUFBaUQ7QUFDaEYsUUFBSXBPLFNBQVMsSUFBYjs7QUFFQSxTQUFLa08sWUFBTCxDQUFrQm5RLFFBQWxCLEVBQTRCLFVBQVVqRSxLQUFWLEVBQWlCO0FBQzNDd1QsbUJBQWE3SixVQUFVekQsT0FBT2dELElBQVAsR0FBY2xKLE1BQU1xRSxRQUE5QixDQUFiO0FBQ0FzTSxtQkFBYXpLLE9BQU9DLE1BQXBCLEVBQTRCbkcsS0FBNUIsRUFBbUNrRyxPQUFPZixPQUExQyxFQUFtRCxLQUFuRDtBQUNBa1Asb0JBQWNBLFdBQVdyVSxLQUFYLENBQWQ7QUFDRCxLQUpELEVBSUdzVSxPQUpIO0FBS0QsR0FSRDs7QUFVQThDLGVBQWE3YSxTQUFiLENBQXVCa1ksU0FBdkIsR0FBbUMsU0FBU0EsU0FBVCxDQUFvQnJZLElBQXBCLEVBQTBCO0FBQzNELFFBQUltYixZQUFZLEtBQUtyTyxJQUFqQixNQUEyQixLQUFLL0QsT0FBTCxDQUFhZCxRQUE1QyxFQUFzRDtBQUNwRCxVQUFJYyxVQUFVd0UsVUFBVSxLQUFLVCxJQUFMLEdBQVksS0FBSy9ELE9BQUwsQ0FBYWQsUUFBbkMsQ0FBZDtBQUNBakksYUFBT2tYLFVBQVVuTyxPQUFWLENBQVAsR0FBNEJxTyxhQUFhck8sT0FBYixDQUE1QjtBQUNEO0FBQ0YsR0FMRDs7QUFPQWlTLGVBQWE3YSxTQUFiLENBQXVCcWIsa0JBQXZCLEdBQTRDLFNBQVNBLGtCQUFULEdBQStCO0FBQ3pFLFdBQU9MLFlBQVksS0FBS3JPLElBQWpCLENBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9rTyxZQUFQO0FBQ0QsQ0E3RG1CLENBNkRsQnZELE9BN0RrQixDQUFwQjs7QUErREEsU0FBUzBELFdBQVQsQ0FBc0JyTyxJQUF0QixFQUE0QjtBQUMxQixNQUFJM0gsT0FBT3dILE9BQU85RSxRQUFQLENBQWdCbU0sUUFBM0I7QUFDQSxNQUFJbEgsUUFBUTNILEtBQUs4RCxPQUFMLENBQWE2RCxJQUFiLE1BQXVCLENBQW5DLEVBQXNDO0FBQ3BDM0gsV0FBT0EsS0FBS21DLEtBQUwsQ0FBV3dGLEtBQUt6TixNQUFoQixDQUFQO0FBQ0Q7QUFDRCxTQUFPLENBQUM4RixRQUFRLEdBQVQsSUFBZ0J3SCxPQUFPOUUsUUFBUCxDQUFnQjRULE1BQWhDLEdBQXlDOU8sT0FBTzlFLFFBQVAsQ0FBZ0JHLElBQWhFO0FBQ0Q7O0FBRUQ7O0FBR0EsSUFBSTBULGNBQWUsVUFBVVQsVUFBVixFQUFzQjtBQUN2QyxXQUFTUyxXQUFULENBQXNCM1IsTUFBdEIsRUFBOEIrQyxJQUE5QixFQUFvQzZPLFFBQXBDLEVBQThDO0FBQzVDVixlQUFXcGMsSUFBWCxDQUFnQixJQUFoQixFQUFzQmtMLE1BQXRCLEVBQThCK0MsSUFBOUI7QUFDQTtBQUNBLFFBQUk2TyxZQUFZQyxjQUFjLEtBQUs5TyxJQUFuQixDQUFoQixFQUEwQztBQUN4QztBQUNEO0FBQ0QrTztBQUNEOztBQUVELE1BQUtaLFVBQUwsRUFBa0JTLFlBQVlOLFNBQVosR0FBd0JILFVBQXhCO0FBQ2xCUyxjQUFZdmIsU0FBWixHQUF3QjJCLE9BQU8rTCxNQUFQLENBQWVvTixjQUFjQSxXQUFXOWEsU0FBeEMsQ0FBeEI7QUFDQXViLGNBQVl2YixTQUFaLENBQXNCa2IsV0FBdEIsR0FBb0NLLFdBQXBDOztBQUVBO0FBQ0E7QUFDQUEsY0FBWXZiLFNBQVosQ0FBc0IyYixjQUF0QixHQUF1QyxTQUFTQSxjQUFULEdBQTJCO0FBQ2hFLFFBQUloUyxTQUFTLElBQWI7O0FBRUE2QyxXQUFPd0gsZ0JBQVAsQ0FBd0IsWUFBeEIsRUFBc0MsWUFBWTtBQUNoRCxVQUFJLENBQUMwSCxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0Q7QUFDRC9SLGFBQU9rTyxZQUFQLENBQW9CK0QsU0FBcEIsRUFBK0IsVUFBVW5ZLEtBQVYsRUFBaUI7QUFDOUNvWSxvQkFBWXBZLE1BQU1xRSxRQUFsQjtBQUNELE9BRkQ7QUFHRCxLQVBEO0FBUUQsR0FYRDs7QUFhQXlULGNBQVl2YixTQUFaLENBQXNCSCxJQUF0QixHQUE2QixTQUFTQSxJQUFULENBQWU2SCxRQUFmLEVBQXlCb1EsVUFBekIsRUFBcUNDLE9BQXJDLEVBQThDO0FBQ3pFLFNBQUtGLFlBQUwsQ0FBa0JuUSxRQUFsQixFQUE0QixVQUFVakUsS0FBVixFQUFpQjtBQUMzQ3FZLGVBQVNyWSxNQUFNcUUsUUFBZjtBQUNBZ1Esb0JBQWNBLFdBQVdyVSxLQUFYLENBQWQ7QUFDRCxLQUhELEVBR0dzVSxPQUhIO0FBSUQsR0FMRDs7QUFPQXdELGNBQVl2YixTQUFaLENBQXNCMEYsT0FBdEIsR0FBZ0MsU0FBU0EsT0FBVCxDQUFrQmdDLFFBQWxCLEVBQTRCb1EsVUFBNUIsRUFBd0NDLE9BQXhDLEVBQWlEO0FBQy9FLFNBQUtGLFlBQUwsQ0FBa0JuUSxRQUFsQixFQUE0QixVQUFVakUsS0FBVixFQUFpQjtBQUMzQ29ZLGtCQUFZcFksTUFBTXFFLFFBQWxCO0FBQ0FnUSxvQkFBY0EsV0FBV3JVLEtBQVgsQ0FBZDtBQUNELEtBSEQsRUFHR3NVLE9BSEg7QUFJRCxHQUxEOztBQU9Bd0QsY0FBWXZiLFNBQVosQ0FBc0JtYixFQUF0QixHQUEyQixTQUFTQSxFQUFULENBQWFDLENBQWIsRUFBZ0I7QUFDekM1TyxXQUFPUCxPQUFQLENBQWVrUCxFQUFmLENBQWtCQyxDQUFsQjtBQUNELEdBRkQ7O0FBSUFHLGNBQVl2YixTQUFaLENBQXNCa1ksU0FBdEIsR0FBa0MsU0FBU0EsU0FBVCxDQUFvQnJZLElBQXBCLEVBQTBCO0FBQzFELFFBQUkrSSxVQUFVLEtBQUtBLE9BQUwsQ0FBYWQsUUFBM0I7QUFDQSxRQUFJOFQsY0FBY2hULE9BQWxCLEVBQTJCO0FBQ3pCL0ksYUFBT2ljLFNBQVNsVCxPQUFULENBQVAsR0FBMkJpVCxZQUFZalQsT0FBWixDQUEzQjtBQUNEO0FBQ0YsR0FMRDs7QUFPQTJTLGNBQVl2YixTQUFaLENBQXNCcWIsa0JBQXRCLEdBQTJDLFNBQVNBLGtCQUFULEdBQStCO0FBQ3hFLFdBQU9PLFNBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9MLFdBQVA7QUFDRCxDQTNEa0IsQ0EyRGpCakUsT0EzRGlCLENBQW5COztBQTZEQSxTQUFTbUUsYUFBVCxDQUF3QjlPLElBQXhCLEVBQThCO0FBQzVCLE1BQUlqRixXQUFXc1QsWUFBWXJPLElBQVosQ0FBZjtBQUNBLE1BQUksQ0FBQyxPQUFPcEIsSUFBUCxDQUFZN0QsUUFBWixDQUFMLEVBQTRCO0FBQzFCOEUsV0FBTzlFLFFBQVAsQ0FBZ0JoQyxPQUFoQixDQUNFMEgsVUFBVVQsT0FBTyxJQUFQLEdBQWNqRixRQUF4QixDQURGO0FBR0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTZ1UsV0FBVCxHQUF3QjtBQUN0QixNQUFJMVcsT0FBTzRXLFNBQVg7QUFDQSxNQUFJNVcsS0FBSzRILE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQXZCLEVBQTRCO0FBQzFCLFdBQU8sSUFBUDtBQUNEO0FBQ0RpUCxjQUFZLE1BQU03VyxJQUFsQjtBQUNBLFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVM0VyxPQUFULEdBQW9CO0FBQ2xCO0FBQ0E7QUFDQSxNQUFJN1IsT0FBT3lDLE9BQU85RSxRQUFQLENBQWdCcUMsSUFBM0I7QUFDQSxNQUFJckksUUFBUXFJLEtBQUtqQixPQUFMLENBQWEsR0FBYixDQUFaO0FBQ0EsU0FBT3BILFVBQVUsQ0FBQyxDQUFYLEdBQWUsRUFBZixHQUFvQnFJLEtBQUs1QyxLQUFMLENBQVd6RixRQUFRLENBQW5CLENBQTNCO0FBQ0Q7O0FBRUQsU0FBU29hLFFBQVQsQ0FBbUI5VyxJQUFuQixFQUF5QjtBQUN2QndILFNBQU85RSxRQUFQLENBQWdCRyxJQUFoQixHQUF1QjdDLElBQXZCO0FBQ0Q7O0FBRUQsU0FBUzZXLFdBQVQsQ0FBc0I3VyxJQUF0QixFQUE0QjtBQUMxQixNQUFJcEYsSUFBSTRNLE9BQU85RSxRQUFQLENBQWdCcUMsSUFBaEIsQ0FBcUJqQixPQUFyQixDQUE2QixHQUE3QixDQUFSO0FBQ0EwRCxTQUFPOUUsUUFBUCxDQUFnQmhDLE9BQWhCLENBQ0U4RyxPQUFPOUUsUUFBUCxDQUFnQnFDLElBQWhCLENBQXFCNUMsS0FBckIsQ0FBMkIsQ0FBM0IsRUFBOEJ2SCxLQUFLLENBQUwsR0FBU0EsQ0FBVCxHQUFhLENBQTNDLElBQWdELEdBQWhELEdBQXNEb0YsSUFEeEQ7QUFHRDs7QUFFRDs7QUFHQSxJQUFJK1csa0JBQW1CLFVBQVVqQixVQUFWLEVBQXNCO0FBQzNDLFdBQVNpQixlQUFULENBQTBCblMsTUFBMUIsRUFBa0MrQyxJQUFsQyxFQUF3QztBQUN0Q21PLGVBQVdwYyxJQUFYLENBQWdCLElBQWhCLEVBQXNCa0wsTUFBdEIsRUFBOEIrQyxJQUE5QjtBQUNBLFNBQUtFLEtBQUwsR0FBYSxFQUFiO0FBQ0EsU0FBS25MLEtBQUwsR0FBYSxDQUFDLENBQWQ7QUFDRDs7QUFFRCxNQUFLb1osVUFBTCxFQUFrQmlCLGdCQUFnQmQsU0FBaEIsR0FBNEJILFVBQTVCO0FBQ2xCaUIsa0JBQWdCL2IsU0FBaEIsR0FBNEIyQixPQUFPK0wsTUFBUCxDQUFlb04sY0FBY0EsV0FBVzlhLFNBQXhDLENBQTVCO0FBQ0ErYixrQkFBZ0IvYixTQUFoQixDQUEwQmtiLFdBQTFCLEdBQXdDYSxlQUF4Qzs7QUFFQUEsa0JBQWdCL2IsU0FBaEIsQ0FBMEJILElBQTFCLEdBQWlDLFNBQVNBLElBQVQsQ0FBZTZILFFBQWYsRUFBeUJvUSxVQUF6QixFQUFxQ0MsT0FBckMsRUFBOEM7QUFDN0UsUUFBSXBPLFNBQVMsSUFBYjs7QUFFQSxTQUFLa08sWUFBTCxDQUFrQm5RLFFBQWxCLEVBQTRCLFVBQVVqRSxLQUFWLEVBQWlCO0FBQzNDa0csYUFBT2tELEtBQVAsR0FBZWxELE9BQU9rRCxLQUFQLENBQWExRixLQUFiLENBQW1CLENBQW5CLEVBQXNCd0MsT0FBT2pJLEtBQVAsR0FBZSxDQUFyQyxFQUF3Q3ZDLE1BQXhDLENBQStDc0UsS0FBL0MsQ0FBZjtBQUNBa0csYUFBT2pJLEtBQVA7QUFDQW9XLG9CQUFjQSxXQUFXclUsS0FBWCxDQUFkO0FBQ0QsS0FKRCxFQUlHc1UsT0FKSDtBQUtELEdBUkQ7O0FBVUFnRSxrQkFBZ0IvYixTQUFoQixDQUEwQjBGLE9BQTFCLEdBQW9DLFNBQVNBLE9BQVQsQ0FBa0JnQyxRQUFsQixFQUE0Qm9RLFVBQTVCLEVBQXdDQyxPQUF4QyxFQUFpRDtBQUNuRixRQUFJcE8sU0FBUyxJQUFiOztBQUVBLFNBQUtrTyxZQUFMLENBQWtCblEsUUFBbEIsRUFBNEIsVUFBVWpFLEtBQVYsRUFBaUI7QUFDM0NrRyxhQUFPa0QsS0FBUCxHQUFlbEQsT0FBT2tELEtBQVAsQ0FBYTFGLEtBQWIsQ0FBbUIsQ0FBbkIsRUFBc0J3QyxPQUFPakksS0FBN0IsRUFBb0N2QyxNQUFwQyxDQUEyQ3NFLEtBQTNDLENBQWY7QUFDQXFVLG9CQUFjQSxXQUFXclUsS0FBWCxDQUFkO0FBQ0QsS0FIRCxFQUdHc1UsT0FISDtBQUlELEdBUEQ7O0FBU0FnRSxrQkFBZ0IvYixTQUFoQixDQUEwQm1iLEVBQTFCLEdBQStCLFNBQVNBLEVBQVQsQ0FBYUMsQ0FBYixFQUFnQjtBQUM3QyxRQUFJelIsU0FBUyxJQUFiOztBQUVBLFFBQUlxUyxjQUFjLEtBQUt0YSxLQUFMLEdBQWEwWixDQUEvQjtBQUNBLFFBQUlZLGNBQWMsQ0FBZCxJQUFtQkEsZUFBZSxLQUFLblAsS0FBTCxDQUFXM04sTUFBakQsRUFBeUQ7QUFDdkQ7QUFDRDtBQUNELFFBQUl1RSxRQUFRLEtBQUtvSixLQUFMLENBQVdtUCxXQUFYLENBQVo7QUFDQSxTQUFLaEUsaUJBQUwsQ0FBdUJ2VSxLQUF2QixFQUE4QixZQUFZO0FBQ3hDa0csYUFBT2pJLEtBQVAsR0FBZXNhLFdBQWY7QUFDQXJTLGFBQU9zTyxXQUFQLENBQW1CeFUsS0FBbkI7QUFDRCxLQUhEO0FBSUQsR0FaRDs7QUFjQXNZLGtCQUFnQi9iLFNBQWhCLENBQTBCcWIsa0JBQTFCLEdBQStDLFNBQVNBLGtCQUFULEdBQStCO0FBQzVFLFFBQUl6UyxVQUFVLEtBQUtpRSxLQUFMLENBQVcsS0FBS0EsS0FBTCxDQUFXM04sTUFBWCxHQUFvQixDQUEvQixDQUFkO0FBQ0EsV0FBTzBKLFVBQVVBLFFBQVFkLFFBQWxCLEdBQTZCLEdBQXBDO0FBQ0QsR0FIRDs7QUFLQWlVLGtCQUFnQi9iLFNBQWhCLENBQTBCa1ksU0FBMUIsR0FBc0MsU0FBU0EsU0FBVCxHQUFzQjtBQUMxRDtBQUNELEdBRkQ7O0FBSUEsU0FBTzZELGVBQVA7QUFDRCxDQXREc0IsQ0FzRHJCekUsT0F0RHFCLENBQXZCOztBQXdEQTs7QUFFQSxJQUFJMkUsWUFBWSxTQUFTQSxTQUFULENBQW9CaFMsT0FBcEIsRUFBNkI7QUFDM0MsTUFBS0EsWUFBWSxLQUFLLENBQXRCLEVBQTBCQSxVQUFVLEVBQVY7O0FBRTFCLE9BQUtzSyxHQUFMLEdBQVcsSUFBWDtBQUNBLE9BQUsySCxJQUFMLEdBQVksRUFBWjtBQUNBLE9BQUtqUyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxPQUFLd08sV0FBTCxHQUFtQixFQUFuQjtBQUNBLE9BQUtTLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxPQUFLaUQsT0FBTCxHQUFlcEosY0FBYzlJLFFBQVFxRCxNQUFSLElBQWtCLEVBQWhDLENBQWY7O0FBRUEsTUFBSThPLE9BQU9uUyxRQUFRbVMsSUFBUixJQUFnQixNQUEzQjtBQUNBLE9BQUtaLFFBQUwsR0FBZ0JZLFNBQVMsU0FBVCxJQUFzQixDQUFDaEcsaUJBQXZDO0FBQ0EsTUFBSSxLQUFLb0YsUUFBVCxFQUFtQjtBQUNqQlksV0FBTyxNQUFQO0FBQ0Q7QUFDRCxNQUFJLENBQUM3UCxTQUFMLEVBQWdCO0FBQ2Q2UCxXQUFPLFVBQVA7QUFDRDtBQUNELE9BQUtBLElBQUwsR0FBWUEsSUFBWjs7QUFFQSxVQUFRQSxJQUFSO0FBQ0UsU0FBSyxTQUFMO0FBQ0UsV0FBS25RLE9BQUwsR0FBZSxJQUFJNE8sWUFBSixDQUFpQixJQUFqQixFQUF1QjVRLFFBQVEwQyxJQUEvQixDQUFmO0FBQ0E7QUFDRixTQUFLLE1BQUw7QUFDRSxXQUFLVixPQUFMLEdBQWUsSUFBSXNQLFdBQUosQ0FBZ0IsSUFBaEIsRUFBc0J0UixRQUFRMEMsSUFBOUIsRUFBb0MsS0FBSzZPLFFBQXpDLENBQWY7QUFDQTtBQUNGLFNBQUssVUFBTDtBQUNFLFdBQUt2UCxPQUFMLEdBQWUsSUFBSThQLGVBQUosQ0FBb0IsSUFBcEIsRUFBMEI5UixRQUFRMEMsSUFBbEMsQ0FBZjtBQUNBO0FBQ0Y7QUFDRSxVQUFJOU8sUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMxRCxlQUFPLEtBQVAsRUFBZSxtQkFBbUI0WixJQUFsQztBQUNEO0FBYkw7QUFlRCxDQW5DRDs7QUFxQ0EsSUFBSUMscUJBQXFCLEVBQUVwSixjQUFjLEVBQWhCLEVBQXpCOztBQUVBZ0osVUFBVWpjLFNBQVYsQ0FBb0IwUixLQUFwQixHQUE0QixTQUFTQSxLQUFULENBQzFCZSxHQUQwQixFQUUxQjdKLE9BRjBCLEVBRzFCakIsY0FIMEIsRUFJMUI7QUFDQSxTQUFPLEtBQUt3VSxPQUFMLENBQWF6SyxLQUFiLENBQW1CZSxHQUFuQixFQUF3QjdKLE9BQXhCLEVBQWlDakIsY0FBakMsQ0FBUDtBQUNELENBTkQ7O0FBUUEwVSxtQkFBbUJwSixZQUFuQixDQUFnQzlRLEdBQWhDLEdBQXNDLFlBQVk7QUFDaEQsU0FBTyxLQUFLOEosT0FBTCxJQUFnQixLQUFLQSxPQUFMLENBQWFyRCxPQUFwQztBQUNELENBRkQ7O0FBSUFxVCxVQUFVamMsU0FBVixDQUFvQnFFLElBQXBCLEdBQTJCLFNBQVNBLElBQVQsQ0FBZWtRLEdBQWYsQ0FBbUIsNEJBQW5CLEVBQWlEO0FBQ3hFLE1BQUk1SyxTQUFTLElBQWI7O0FBRUY5TCxVQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzFELE9BQ3ZDVCxRQUFRMEosU0FEK0IsRUFFdkMsMkRBQ0EsZ0NBSHVDLENBQXpDOztBQU1BLE9BQUt5USxJQUFMLENBQVVyYyxJQUFWLENBQWUwVSxHQUFmOztBQUVBO0FBQ0EsTUFBSSxLQUFLQSxHQUFULEVBQWM7QUFDWjtBQUNEOztBQUVELE9BQUtBLEdBQUwsR0FBV0EsR0FBWDs7QUFFQSxNQUFJdEksVUFBVSxLQUFLQSxPQUFuQjs7QUFFQSxNQUFJQSxtQkFBbUI0TyxZQUF2QixFQUFxQztBQUNuQzVPLFlBQVE0TCxZQUFSLENBQXFCNUwsUUFBUW9QLGtCQUFSLEVBQXJCO0FBQ0QsR0FGRCxNQUVPLElBQUlwUCxtQkFBbUJzUCxXQUF2QixFQUFvQztBQUN6QyxRQUFJZSxvQkFBb0IsWUFBWTtBQUNsQ3JRLGNBQVEwUCxjQUFSO0FBQ0QsS0FGRDtBQUdBMVAsWUFBUTRMLFlBQVIsQ0FDRTVMLFFBQVFvUCxrQkFBUixFQURGLEVBRUVpQixpQkFGRixFQUdFQSxpQkFIRjtBQUtEOztBQUVEclEsVUFBUTBMLE1BQVIsQ0FBZSxVQUFVbFUsS0FBVixFQUFpQjtBQUM5QmtHLFdBQU91UyxJQUFQLENBQVkzVixPQUFaLENBQW9CLFVBQVVnTyxHQUFWLEVBQWU7QUFDakNBLFVBQUkzSSxNQUFKLEdBQWFuSSxLQUFiO0FBQ0QsS0FGRDtBQUdELEdBSkQ7QUFLRCxDQXRDRDs7QUF3Q0F3WSxVQUFVamMsU0FBVixDQUFvQnVjLFVBQXBCLEdBQWlDLFNBQVNBLFVBQVQsQ0FBcUJwRixFQUFyQixFQUF5QjtBQUN4RCxPQUFLc0IsV0FBTCxDQUFpQjVZLElBQWpCLENBQXNCc1gsRUFBdEI7QUFDRCxDQUZEOztBQUlBOEUsVUFBVWpjLFNBQVYsQ0FBb0J3YyxTQUFwQixHQUFnQyxTQUFTQSxTQUFULENBQW9CckYsRUFBcEIsRUFBd0I7QUFDdEQsT0FBSytCLFVBQUwsQ0FBZ0JyWixJQUFoQixDQUFxQnNYLEVBQXJCO0FBQ0QsQ0FGRDs7QUFJQThFLFVBQVVqYyxTQUFWLENBQW9CNFgsT0FBcEIsR0FBOEIsU0FBU0EsT0FBVCxDQUFrQlIsRUFBbEIsRUFBc0I7QUFDbEQsT0FBS25MLE9BQUwsQ0FBYTJMLE9BQWIsQ0FBcUJSLEVBQXJCO0FBQ0QsQ0FGRDs7QUFJQTZFLFVBQVVqYyxTQUFWLENBQW9CSCxJQUFwQixHQUEyQixTQUFTQSxJQUFULENBQWU2SCxRQUFmLEVBQXlCb1EsVUFBekIsRUFBcUNDLE9BQXJDLEVBQThDO0FBQ3ZFLE9BQUs5TCxPQUFMLENBQWFwTSxJQUFiLENBQWtCNkgsUUFBbEIsRUFBNEJvUSxVQUE1QixFQUF3Q0MsT0FBeEM7QUFDRCxDQUZEOztBQUlBa0UsVUFBVWpjLFNBQVYsQ0FBb0IwRixPQUFwQixHQUE4QixTQUFTQSxPQUFULENBQWtCZ0MsUUFBbEIsRUFBNEJvUSxVQUE1QixFQUF3Q0MsT0FBeEMsRUFBaUQ7QUFDN0UsT0FBSzlMLE9BQUwsQ0FBYXZHLE9BQWIsQ0FBcUJnQyxRQUFyQixFQUErQm9RLFVBQS9CLEVBQTJDQyxPQUEzQztBQUNELENBRkQ7O0FBSUFrRSxVQUFVamMsU0FBVixDQUFvQm1iLEVBQXBCLEdBQXlCLFNBQVNBLEVBQVQsQ0FBYUMsQ0FBYixFQUFnQjtBQUN2QyxPQUFLblAsT0FBTCxDQUFha1AsRUFBYixDQUFnQkMsQ0FBaEI7QUFDRCxDQUZEOztBQUlBYSxVQUFVamMsU0FBVixDQUFvQnljLElBQXBCLEdBQTJCLFNBQVNBLElBQVQsR0FBaUI7QUFDMUMsT0FBS3RCLEVBQUwsQ0FBUSxDQUFDLENBQVQ7QUFDRCxDQUZEOztBQUlBYyxVQUFVamMsU0FBVixDQUFvQjBjLE9BQXBCLEdBQThCLFNBQVNBLE9BQVQsR0FBb0I7QUFDaEQsT0FBS3ZCLEVBQUwsQ0FBUSxDQUFSO0FBQ0QsQ0FGRDs7QUFJQWMsVUFBVWpjLFNBQVYsQ0FBb0IyYyxvQkFBcEIsR0FBMkMsU0FBU0Esb0JBQVQsQ0FBK0J4VCxFQUEvQixFQUFtQztBQUM1RSxNQUFJMUYsUUFBUTBGLEtBQ1IsS0FBS1csT0FBTCxDQUFhWCxFQUFiLEVBQWlCMUYsS0FEVCxHQUVSLEtBQUt3UCxZQUZUO0FBR0EsTUFBSSxDQUFDeFAsS0FBTCxFQUFZO0FBQ1YsV0FBTyxFQUFQO0FBQ0Q7QUFDRCxTQUFPLEdBQUd0RSxNQUFILENBQVVjLEtBQVYsQ0FBZ0IsRUFBaEIsRUFBb0J3RCxNQUFNcEIsT0FBTixDQUFjNEUsR0FBZCxDQUFrQixVQUFVc0ksQ0FBVixFQUFhO0FBQ3hELFdBQU81TixPQUFPcUYsSUFBUCxDQUFZdUksRUFBRXJMLFVBQWQsRUFBMEIrQyxHQUExQixDQUE4QixVQUFVZCxHQUFWLEVBQWU7QUFDbEQsYUFBT29KLEVBQUVyTCxVQUFGLENBQWFpQyxHQUFiLENBQVA7QUFDRCxLQUZNLENBQVA7QUFHRCxHQUowQixDQUFwQixDQUFQO0FBS0QsQ0FaRDs7QUFjQThWLFVBQVVqYyxTQUFWLENBQW9COEosT0FBcEIsR0FBOEIsU0FBU0EsT0FBVCxDQUM1QlgsRUFENEIsRUFFNUJQLE9BRjRCLEVBRzVCWSxNQUg0QixFQUk1QjtBQUNBLE1BQUk5QixXQUFXOEssa0JBQWtCckosRUFBbEIsRUFBc0JQLFdBQVcsS0FBS3FELE9BQUwsQ0FBYXJELE9BQTlDLEVBQXVEWSxNQUF2RCxDQUFmO0FBQ0EsTUFBSS9GLFFBQVEsS0FBS2lPLEtBQUwsQ0FBV2hLLFFBQVgsRUFBcUJrQixPQUFyQixDQUFaO0FBQ0EsTUFBSWQsV0FBV3JFLE1BQU1rRSxjQUFOLElBQXdCbEUsTUFBTXFFLFFBQTdDO0FBQ0EsTUFBSTZFLE9BQU8sS0FBS1YsT0FBTCxDQUFhVSxJQUF4QjtBQUNBLE1BQUk1QyxPQUFPNlMsV0FBV2pRLElBQVgsRUFBaUI3RSxRQUFqQixFQUEyQixLQUFLc1UsSUFBaEMsQ0FBWDtBQUNBLFNBQU87QUFDTDFVLGNBQVVBLFFBREw7QUFFTGpFLFdBQU9BLEtBRkY7QUFHTHNHLFVBQU1BLElBSEQ7QUFJTDtBQUNBOFMsa0JBQWNuVixRQUxUO0FBTUxvVixjQUFVclo7QUFOTCxHQUFQO0FBUUQsQ0FsQkQ7O0FBb0JBd1ksVUFBVWpjLFNBQVYsQ0FBb0JnVCxTQUFwQixHQUFnQyxTQUFTQSxTQUFULENBQW9CMUYsTUFBcEIsRUFBNEI7QUFDMUQsT0FBSzZPLE9BQUwsQ0FBYW5KLFNBQWIsQ0FBdUIxRixNQUF2QjtBQUNBLE1BQUksS0FBS3JCLE9BQUwsQ0FBYXJELE9BQWIsS0FBeUJWLEtBQTdCLEVBQW9DO0FBQ2xDLFNBQUsrRCxPQUFMLENBQWE0TCxZQUFiLENBQTBCLEtBQUs1TCxPQUFMLENBQWFvUCxrQkFBYixFQUExQjtBQUNEO0FBQ0YsQ0FMRDs7QUFPQTFaLE9BQU9NLGdCQUFQLENBQXlCZ2EsVUFBVWpjLFNBQW5DLEVBQThDcWMsa0JBQTlDOztBQUVBLFNBQVNPLFVBQVQsQ0FBcUJqUSxJQUFyQixFQUEyQjdFLFFBQTNCLEVBQXFDc1UsSUFBckMsRUFBMkM7QUFDekMsTUFBSXBYLE9BQU9vWCxTQUFTLE1BQVQsR0FBa0IsTUFBTXRVLFFBQXhCLEdBQW1DQSxRQUE5QztBQUNBLFNBQU82RSxPQUFPUyxVQUFVVCxPQUFPLEdBQVAsR0FBYTNILElBQXZCLENBQVAsR0FBc0NBLElBQTdDO0FBQ0Q7O0FBRURpWCxVQUFVbGEsT0FBVixHQUFvQkEsT0FBcEI7QUFDQWthLFVBQVUzYixPQUFWLEdBQW9CLE9BQXBCOztBQUVBLElBQUlpTSxhQUFhQyxPQUFPeEssR0FBeEIsRUFBNkI7QUFDM0J3SyxTQUFPeEssR0FBUCxDQUFXK2EsR0FBWCxDQUFlZCxTQUFmO0FBQ0Q7O0FBRUQsK0RBQWVBLFNBQWYsRTs7Ozs7Ozs7dURDcHVFQTtBQUFBOzs7OztBQUtBOztBQUVBOzs7QUFHQSxTQUFTZSxTQUFULENBQW9CclcsR0FBcEIsRUFBeUI7QUFDdkIsU0FBT0EsT0FBTyxJQUFQLEdBQ0gsRUFERyxHQUVILE9BQU9BLEdBQVAsS0FBZSxRQUFmLEdBQ0VxSyxLQUFLQyxTQUFMLENBQWV0SyxHQUFmLEVBQW9CLElBQXBCLEVBQTBCLENBQTFCLENBREYsR0FFRTFELE9BQU8wRCxHQUFQLENBSk47QUFLRDs7QUFFRDs7OztBQUlBLFNBQVNzVyxRQUFULENBQW1CdFcsR0FBbkIsRUFBd0I7QUFDdEIsTUFBSXlVLElBQUk4QixXQUFXdlcsR0FBWCxDQUFSO0FBQ0EsU0FBT3dXLE1BQU0vQixDQUFOLElBQVd6VSxHQUFYLEdBQWlCeVUsQ0FBeEI7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNnQyxPQUFULENBQ0U1WCxHQURGLEVBRUU2WCxnQkFGRixFQUdFO0FBQ0EsTUFBSXBXLE1BQU10RixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLE1BQUk0UCxPQUFPOVgsSUFBSWMsS0FBSixDQUFVLEdBQVYsQ0FBWDtBQUNBLE9BQUssSUFBSTFHLElBQUksQ0FBYixFQUFnQkEsSUFBSTBkLEtBQUtwZSxNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcENxSCxRQUFJcVcsS0FBSzFkLENBQUwsQ0FBSixJQUFlLElBQWY7QUFDRDtBQUNELFNBQU95ZCxtQkFDSCxVQUFVMVcsR0FBVixFQUFlO0FBQUUsV0FBT00sSUFBSU4sSUFBSTRXLFdBQUosRUFBSixDQUFQO0FBQWdDLEdBRDlDLEdBRUgsVUFBVTVXLEdBQVYsRUFBZTtBQUFFLFdBQU9NLElBQUlOLEdBQUosQ0FBUDtBQUFrQixHQUZ2QztBQUdEOztBQUVEOzs7QUFHQSxJQUFJNlcsZUFBZUosUUFBUSxnQkFBUixFQUEwQixJQUExQixDQUFuQjs7QUFFQTs7O0FBR0EsU0FBU0ssTUFBVCxDQUFpQm5QLEdBQWpCLEVBQXNCb1AsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSXBQLElBQUlwUCxNQUFSLEVBQWdCO0FBQ2QsUUFBSXdDLFFBQVE0TSxJQUFJeEYsT0FBSixDQUFZNFUsSUFBWixDQUFaO0FBQ0EsUUFBSWhjLFFBQVEsQ0FBQyxDQUFiLEVBQWdCO0FBQ2QsYUFBTzRNLElBQUlxUCxNQUFKLENBQVdqYyxLQUFYLEVBQWtCLENBQWxCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7OztBQUdBLElBQUk0UixpQkFBaUIzUixPQUFPM0IsU0FBUCxDQUFpQnNULGNBQXRDO0FBQ0EsU0FBU3NLLE1BQVQsQ0FBaUI3VyxHQUFqQixFQUFzQlosR0FBdEIsRUFBMkI7QUFDekIsU0FBT21OLGVBQWU1VSxJQUFmLENBQW9CcUksR0FBcEIsRUFBeUJaLEdBQXpCLENBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBUzBYLFdBQVQsQ0FBc0JoYyxLQUF0QixFQUE2QjtBQUMzQixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixRQUFyRDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTaWMsTUFBVCxDQUFpQjNHLEVBQWpCLEVBQXFCO0FBQ25CLE1BQUl6VCxRQUFRL0IsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQVo7QUFDQSxTQUFRLFNBQVNxUSxRQUFULENBQW1CdlksR0FBbkIsRUFBd0I7QUFDOUIsUUFBSTJNLE1BQU16TyxNQUFNOEIsR0FBTixDQUFWO0FBQ0EsV0FBTzJNLFFBQVF6TyxNQUFNOEIsR0FBTixJQUFhMlIsR0FBRzNSLEdBQUgsQ0FBckIsQ0FBUDtBQUNELEdBSEQ7QUFJRDs7QUFFRDs7O0FBR0EsSUFBSXdZLGFBQWEsUUFBakI7QUFDQSxJQUFJQyxXQUFXSCxPQUFPLFVBQVV0WSxHQUFWLEVBQWU7QUFDbkMsU0FBT0EsSUFBSUUsT0FBSixDQUFZc1ksVUFBWixFQUF3QixVQUFVNUQsQ0FBVixFQUFhalYsQ0FBYixFQUFnQjtBQUFFLFdBQU9BLElBQUlBLEVBQUVzTCxXQUFGLEVBQUosR0FBc0IsRUFBN0I7QUFBa0MsR0FBNUUsQ0FBUDtBQUNELENBRmMsQ0FBZjs7QUFJQTs7O0FBR0EsSUFBSXlOLGFBQWFKLE9BQU8sVUFBVXRZLEdBQVYsRUFBZTtBQUNyQyxTQUFPQSxJQUFJb0gsTUFBSixDQUFXLENBQVgsRUFBYzZELFdBQWQsS0FBOEJqTCxJQUFJMkIsS0FBSixDQUFVLENBQVYsQ0FBckM7QUFDRCxDQUZnQixDQUFqQjs7QUFJQTs7O0FBR0EsSUFBSWdYLGNBQWMsZ0JBQWxCO0FBQ0EsSUFBSUMsWUFBWU4sT0FBTyxVQUFVdFksR0FBVixFQUFlO0FBQ3BDLFNBQU9BLElBQ0pFLE9BREksQ0FDSXlZLFdBREosRUFDaUIsT0FEakIsRUFFSnpZLE9BRkksQ0FFSXlZLFdBRkosRUFFaUIsT0FGakIsRUFHSlosV0FISSxFQUFQO0FBSUQsQ0FMZSxDQUFoQjs7QUFPQTs7O0FBR0EsU0FBUy9ELElBQVQsQ0FBZXJDLEVBQWYsRUFBbUJrSCxHQUFuQixFQUF3QjtBQUN0QixXQUFTQyxPQUFULENBQWtCalcsQ0FBbEIsRUFBcUI7QUFDbkIsUUFBSWtXLElBQUk1ZSxVQUFVVCxNQUFsQjtBQUNBLFdBQU9xZixJQUNIQSxJQUFJLENBQUosR0FDRXBILEdBQUdsWCxLQUFILENBQVNvZSxHQUFULEVBQWMxZSxTQUFkLENBREYsR0FFRXdYLEdBQUd6WSxJQUFILENBQVEyZixHQUFSLEVBQWFoVyxDQUFiLENBSEMsR0FJSDhPLEdBQUd6WSxJQUFILENBQVEyZixHQUFSLENBSko7QUFLRDtBQUNEO0FBQ0FDLFVBQVFFLE9BQVIsR0FBa0JySCxHQUFHalksTUFBckI7QUFDQSxTQUFPb2YsT0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTRyxPQUFULENBQWtCbkIsSUFBbEIsRUFBd0JvQixLQUF4QixFQUErQjtBQUM3QkEsVUFBUUEsU0FBUyxDQUFqQjtBQUNBLE1BQUk5ZSxJQUFJMGQsS0FBS3BlLE1BQUwsR0FBY3dmLEtBQXRCO0FBQ0EsTUFBSUMsTUFBTSxJQUFJamYsS0FBSixDQUFVRSxDQUFWLENBQVY7QUFDQSxTQUFPQSxHQUFQLEVBQVk7QUFDVitlLFFBQUkvZSxDQUFKLElBQVMwZCxLQUFLMWQsSUFBSThlLEtBQVQsQ0FBVDtBQUNEO0FBQ0QsU0FBT0MsR0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTL1QsTUFBVCxDQUFpQnpCLEVBQWpCLEVBQXFCeVYsS0FBckIsRUFBNEI7QUFDMUIsT0FBSyxJQUFJelksR0FBVCxJQUFnQnlZLEtBQWhCLEVBQXVCO0FBQ3JCelYsT0FBR2hELEdBQUgsSUFBVXlZLE1BQU16WSxHQUFOLENBQVY7QUFDRDtBQUNELFNBQU9nRCxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBUzJMLFFBQVQsQ0FBbUIvTixHQUFuQixFQUF3QjtBQUN0QixTQUFPQSxRQUFRLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFFBQXRDO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxJQUFJMUIsV0FBVzFELE9BQU8zQixTQUFQLENBQWlCcUYsUUFBaEM7QUFDQSxJQUFJd1osZ0JBQWdCLGlCQUFwQjtBQUNBLFNBQVNDLGFBQVQsQ0FBd0IvWCxHQUF4QixFQUE2QjtBQUMzQixTQUFPMUIsU0FBUzNHLElBQVQsQ0FBY3FJLEdBQWQsTUFBdUI4WCxhQUE5QjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTRSxRQUFULENBQW1CelEsR0FBbkIsRUFBd0I7QUFDdEIsTUFBSWxJLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSXhHLElBQUksQ0FBYixFQUFnQkEsSUFBSTBPLElBQUlwUCxNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDbkMsUUFBSTBPLElBQUkxTyxDQUFKLENBQUosRUFBWTtBQUNWZ0wsYUFBT3hFLEdBQVAsRUFBWWtJLElBQUkxTyxDQUFKLENBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBT3dHLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBUzVGLElBQVQsR0FBaUIsQ0FBRTs7QUFFbkI7OztBQUdBLElBQUl3ZSxLQUFLLFlBQVk7QUFBRSxTQUFPLEtBQVA7QUFBZSxDQUF0Qzs7QUFFQTs7O0FBR0EsSUFBSUMsV0FBVyxVQUFVN0UsQ0FBVixFQUFhO0FBQUUsU0FBT0EsQ0FBUDtBQUFXLENBQXpDOztBQUVBOzs7QUFHQSxTQUFTOEUsYUFBVCxDQUF3QkMsT0FBeEIsRUFBaUM7QUFDL0IsU0FBT0EsUUFBUUMsTUFBUixDQUFlLFVBQVVwWSxJQUFWLEVBQWdCdUksQ0FBaEIsRUFBbUI7QUFDdkMsV0FBT3ZJLEtBQUs3SCxNQUFMLENBQVlvUSxFQUFFOFAsVUFBRixJQUFnQixFQUE1QixDQUFQO0FBQ0QsR0FGTSxFQUVKLEVBRkksRUFFQXpZLElBRkEsQ0FFSyxHQUZMLENBQVA7QUFHRDs7QUFFRDs7OztBQUlBLFNBQVMwWSxVQUFULENBQXFCalgsQ0FBckIsRUFBd0JDLENBQXhCLEVBQTJCO0FBQ3pCLE1BQUlpWCxZQUFZekssU0FBU3pNLENBQVQsQ0FBaEI7QUFDQSxNQUFJbVgsWUFBWTFLLFNBQVN4TSxDQUFULENBQWhCO0FBQ0EsTUFBSWlYLGFBQWFDLFNBQWpCLEVBQTRCO0FBQzFCLFFBQUk7QUFDRixhQUFPeE8sS0FBS0MsU0FBTCxDQUFlNUksQ0FBZixNQUFzQjJJLEtBQUtDLFNBQUwsQ0FBZTNJLENBQWYsQ0FBN0I7QUFDRCxLQUZELENBRUUsT0FBT2hLLENBQVAsRUFBVTtBQUNWO0FBQ0EsYUFBTytKLE1BQU1DLENBQWI7QUFDRDtBQUNGLEdBUEQsTUFPTyxJQUFJLENBQUNpWCxTQUFELElBQWMsQ0FBQ0MsU0FBbkIsRUFBOEI7QUFDbkMsV0FBT3ZjLE9BQU9vRixDQUFQLE1BQWNwRixPQUFPcUYsQ0FBUCxDQUFyQjtBQUNELEdBRk0sTUFFQTtBQUNMLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU21YLFlBQVQsQ0FBdUJuUixHQUF2QixFQUE0QjNILEdBQTVCLEVBQWlDO0FBQy9CLE9BQUssSUFBSS9HLElBQUksQ0FBYixFQUFnQkEsSUFBSTBPLElBQUlwUCxNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDbkMsUUFBSTBmLFdBQVdoUixJQUFJMU8sQ0FBSixDQUFYLEVBQW1CK0csR0FBbkIsQ0FBSixFQUE2QjtBQUFFLGFBQU8vRyxDQUFQO0FBQVU7QUFDMUM7QUFDRCxTQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTZSxJQUFULENBQWV3VyxFQUFmLEVBQW1CO0FBQ2pCLE1BQUl5RCxTQUFTLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSSxDQUFDQSxNQUFMLEVBQWE7QUFDWEEsZUFBUyxJQUFUO0FBQ0F6RDtBQUNEO0FBQ0YsR0FMRDtBQU1EOztBQUVEOztBQUVBLElBQUlyUyxTQUFTO0FBQ1g7OztBQUdBcUgseUJBQXVCeEssT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBSlo7O0FBTVg7OztBQUdBZ1MsVUFBUSxLQVRHOztBQVdYOzs7QUFHQUMsaUJBQWU5aEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFkN0I7O0FBZ0JYOzs7QUFHQTBaLFlBQVUvaEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFuQnhCOztBQXFCWDs7O0FBR0F1USxlQUFhLEtBeEJGOztBQTBCWDs7O0FBR0FvSixnQkFBYyxJQTdCSDs7QUErQlg7OztBQUdBQyxtQkFBaUIsRUFsQ047O0FBb0NYOzs7QUFHQUMsWUFBVXBlLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQXZDQzs7QUF5Q1g7Ozs7QUFJQXNTLGlCQUFlaEIsRUE3Q0o7O0FBK0NYOzs7O0FBSUFpQixvQkFBa0JqQixFQW5EUDs7QUFxRFg7OztBQUdBa0IsbUJBQWlCMWYsSUF4RE47O0FBMERYOzs7QUFHQTJmLHdCQUFzQmxCLFFBN0RYOztBQStEWDs7OztBQUlBbUIsZUFBYXBCLEVBbkVGOztBQXFFWDs7O0FBR0FxQixlQUFhLENBQ1gsV0FEVyxFQUVYLFdBRlcsRUFHWCxRQUhXLENBeEVGOztBQThFWDs7O0FBR0FDLG1CQUFpQixDQUNmLGNBRGUsRUFFZixTQUZlLEVBR2YsYUFIZSxFQUlmLFNBSmUsRUFLZixjQUxlLEVBTWYsU0FOZSxFQU9mLGVBUGUsRUFRZixXQVJlLEVBU2YsV0FUZSxFQVVmLGFBVmUsQ0FqRk47O0FBOEZYOzs7QUFHQUMsbUJBQWlCO0FBakdOLENBQWI7O0FBb0dBOztBQUVBLElBQUlDLGNBQWM3ZSxPQUFPc0csTUFBUCxDQUFjLEVBQWQsQ0FBbEI7O0FBRUE7OztBQUdBLFNBQVN3WSxVQUFULENBQXFCamIsR0FBckIsRUFBMEI7QUFDeEIsTUFBSUwsSUFBSSxDQUFDSyxNQUFNLEVBQVAsRUFBV0osVUFBWCxDQUFzQixDQUF0QixDQUFSO0FBQ0EsU0FBT0QsTUFBTSxJQUFOLElBQWNBLE1BQU0sSUFBM0I7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU3lVLEdBQVQsQ0FBYzdTLEdBQWQsRUFBbUJaLEdBQW5CLEVBQXdCUSxHQUF4QixFQUE2QitaLFVBQTdCLEVBQXlDO0FBQ3ZDL2UsU0FBT0MsY0FBUCxDQUFzQm1GLEdBQXRCLEVBQTJCWixHQUEzQixFQUFnQztBQUM5QnRFLFdBQU84RSxHQUR1QjtBQUU5QitaLGdCQUFZLENBQUMsQ0FBQ0EsVUFGZ0I7QUFHOUJDLGNBQVUsSUFIb0I7QUFJOUJDLGtCQUFjO0FBSmdCLEdBQWhDO0FBTUQ7O0FBRUQ7OztBQUdBLElBQUlDLFNBQVMsU0FBYjtBQUNBLFNBQVM1VCxTQUFULENBQW9CakksSUFBcEIsRUFBMEI7QUFDeEIsTUFBSTZiLE9BQU90VixJQUFQLENBQVl2RyxJQUFaLENBQUosRUFBdUI7QUFDckI7QUFDRDtBQUNELE1BQUkrSCxXQUFXL0gsS0FBS3NCLEtBQUwsQ0FBVyxHQUFYLENBQWY7QUFDQSxTQUFPLFVBQVVTLEdBQVYsRUFBZTtBQUNwQixTQUFLLElBQUluSCxJQUFJLENBQWIsRUFBZ0JBLElBQUltTixTQUFTN04sTUFBN0IsRUFBcUNVLEdBQXJDLEVBQTBDO0FBQ3hDLFVBQUksQ0FBQ21ILEdBQUwsRUFBVTtBQUFFO0FBQVE7QUFDcEJBLFlBQU1BLElBQUlnRyxTQUFTbk4sQ0FBVCxDQUFKLENBQU47QUFDRDtBQUNELFdBQU9tSCxHQUFQO0FBQ0QsR0FORDtBQU9EOztBQUVEO0FBQ0E7O0FBRUE7QUFDQSxJQUFJK1osV0FBVyxlQUFlLEVBQTlCOztBQUVBO0FBQ0EsSUFBSXZVLFlBQVksT0FBT0MsTUFBUCxLQUFrQixXQUFsQztBQUNBLElBQUl1VSxLQUFLeFUsYUFBYUMsT0FBTzhKLFNBQVAsQ0FBaUJDLFNBQWpCLENBQTJCZ0gsV0FBM0IsRUFBdEI7QUFDQSxJQUFJeUQsT0FBT0QsTUFBTSxlQUFleFYsSUFBZixDQUFvQndWLEVBQXBCLENBQWpCO0FBQ0EsSUFBSUUsUUFBUUYsTUFBTUEsR0FBR2pZLE9BQUgsQ0FBVyxVQUFYLElBQXlCLENBQTNDO0FBQ0EsSUFBSW9ZLFNBQVNILE1BQU1BLEdBQUdqWSxPQUFILENBQVcsT0FBWCxJQUFzQixDQUF6QztBQUNBLElBQUlxWSxZQUFZSixNQUFNQSxHQUFHalksT0FBSCxDQUFXLFNBQVgsSUFBd0IsQ0FBOUM7QUFDQSxJQUFJc1ksUUFBUUwsTUFBTSx1QkFBdUJ4VixJQUF2QixDQUE0QndWLEVBQTVCLENBQWxCO0FBQ0EsSUFBSU0sV0FBV04sTUFBTSxjQUFjeFYsSUFBZCxDQUFtQndWLEVBQW5CLENBQU4sSUFBZ0MsQ0FBQ0csTUFBaEQ7O0FBRUE7QUFDQTtBQUNBLElBQUlJLFNBQUo7QUFDQSxJQUFJQyxvQkFBb0IsWUFBWTtBQUNsQyxNQUFJRCxjQUFjMWMsU0FBbEIsRUFBNkI7QUFDM0I7QUFDQSxRQUFJLENBQUMySCxTQUFELElBQWMsT0FBT2pMLE1BQVAsS0FBa0IsV0FBcEMsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBZ2dCLGtCQUFZaGdCLE9BQU8sU0FBUCxFQUFrQmxCLEdBQWxCLENBQXNCb2hCLE9BQXRCLEtBQWtDLFFBQTlDO0FBQ0QsS0FKRCxNQUlPO0FBQ0xGLGtCQUFZLEtBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBT0EsU0FBUDtBQUNELENBWkQ7O0FBY0E7QUFDQSxJQUFJMUIsV0FBV3JULGFBQWFDLE9BQU9pViw0QkFBbkM7O0FBRUE7QUFDQSxTQUFTQyxRQUFULENBQW1CQyxJQUFuQixFQUF5QjtBQUN2QixTQUFPLGVBQWNwVyxJQUFkLENBQW1Cb1csS0FBS3RjLFFBQUwsRUFBbkI7QUFBUDtBQUNEOztBQUVELElBQUl1YyxZQUNGLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNILFNBQVNHLE1BQVQsQ0FBakMsSUFDQSxPQUFPQyxPQUFQLEtBQW1CLFdBRG5CLElBQ2tDSixTQUFTSSxRQUFRQyxPQUFqQixDQUZwQzs7QUFJQTs7O0FBR0EsSUFBSXZpQixXQUFZLFlBQVk7QUFDMUIsTUFBSXdpQixZQUFZLEVBQWhCO0FBQ0EsTUFBSXhLLFVBQVUsS0FBZDtBQUNBLE1BQUl5SyxTQUFKOztBQUVBLFdBQVNDLGVBQVQsR0FBNEI7QUFDMUIxSyxjQUFVLEtBQVY7QUFDQSxRQUFJMkssU0FBU0gsVUFBVTdhLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBYjtBQUNBNmEsY0FBVTlpQixNQUFWLEdBQW1CLENBQW5CO0FBQ0EsU0FBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUl1aUIsT0FBT2pqQixNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEN1aUIsYUFBT3ZpQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUksT0FBT3dpQixPQUFQLEtBQW1CLFdBQW5CLElBQWtDVixTQUFTVSxPQUFULENBQXRDLEVBQXlEO0FBQ3ZELFFBQUlDLElBQUlELFFBQVF0WSxPQUFSLEVBQVI7QUFDQSxRQUFJd1ksV0FBVyxVQUFVQyxHQUFWLEVBQWU7QUFBRTNmLGNBQVE0ZixLQUFSLENBQWNELEdBQWQ7QUFBcUIsS0FBckQ7QUFDQU4sZ0JBQVksWUFBWTtBQUN0QkksUUFBRTFILElBQUYsQ0FBT3VILGVBQVAsRUFBd0JPLEtBQXhCLENBQThCSCxRQUE5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJbEIsS0FBSixFQUFXO0FBQUUvaUIsbUJBQVdtQyxJQUFYO0FBQW1CO0FBQ2pDLEtBUkQ7QUFTRCxHQVpELE1BWU8sSUFBSSxPQUFPa2lCLGdCQUFQLEtBQTRCLFdBQTVCLEtBQ1RoQixTQUFTZ0IsZ0JBQVQ7QUFDQTtBQUNBQSxtQkFBaUJyZCxRQUFqQixPQUFnQyxzQ0FIdkIsQ0FBSixFQUlKO0FBQ0Q7QUFDQTtBQUNBLFFBQUlzZCxVQUFVLENBQWQ7QUFDQSxRQUFJQyxXQUFXLElBQUlGLGdCQUFKLENBQXFCUixlQUFyQixDQUFmO0FBQ0EsUUFBSVcsV0FBVzVOLFNBQVM2TixjQUFULENBQXdCN2YsT0FBTzBmLE9BQVAsQ0FBeEIsQ0FBZjtBQUNBQyxhQUFTRyxPQUFULENBQWlCRixRQUFqQixFQUEyQjtBQUN6QkcscUJBQWU7QUFEVSxLQUEzQjtBQUdBZixnQkFBWSxZQUFZO0FBQ3RCVSxnQkFBVSxDQUFDQSxVQUFVLENBQVgsSUFBZ0IsQ0FBMUI7QUFDQUUsZUFBU3RmLElBQVQsR0FBZ0JOLE9BQU8wZixPQUFQLENBQWhCO0FBQ0QsS0FIRDtBQUlELEdBakJNLE1BaUJBO0FBQ0w7QUFDQTtBQUNBVixnQkFBWSxZQUFZO0FBQ3RCNWpCLGlCQUFXNmpCLGVBQVgsRUFBNEIsQ0FBNUI7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsU0FBTyxTQUFTZSxhQUFULENBQXdCN0wsRUFBeEIsRUFBNEJpSCxHQUE1QixFQUFpQztBQUN0QyxRQUFJNkUsUUFBSjtBQUNBbEIsY0FBVW5pQixJQUFWLENBQWUsWUFBWTtBQUN6QixVQUFJdVgsRUFBSixFQUFRO0FBQUVBLFdBQUcxWSxJQUFILENBQVEyZixHQUFSO0FBQWU7QUFDekIsVUFBSTZFLFFBQUosRUFBYztBQUFFQSxpQkFBUzdFLEdBQVQ7QUFBZ0I7QUFDakMsS0FIRDtBQUlBLFFBQUksQ0FBQzdHLE9BQUwsRUFBYztBQUNaQSxnQkFBVSxJQUFWO0FBQ0F5SztBQUNEO0FBQ0QsUUFBSSxDQUFDN0ssRUFBRCxJQUFPLE9BQU9nTCxPQUFQLEtBQW1CLFdBQTlCLEVBQTJDO0FBQ3pDLGFBQU8sSUFBSUEsT0FBSixDQUFZLFVBQVV0WSxPQUFWLEVBQW1CO0FBQ3BDb1osbUJBQVdwWixPQUFYO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7QUFDRixHQWZEO0FBZ0JELENBMUVjLEVBQWY7O0FBNEVBLElBQUlxWixJQUFKO0FBQ0E7QUFDQSxJQUFJLE9BQU9DLEdBQVAsS0FBZSxXQUFmLElBQThCMUIsU0FBUzBCLEdBQVQsQ0FBbEMsRUFBaUQ7QUFDL0M7QUFDQUQsU0FBT0MsR0FBUDtBQUNELENBSEQsTUFHTztBQUNMO0FBQ0FELFNBQVEsWUFBWTtBQUNsQixhQUFTQyxHQUFULEdBQWdCO0FBQ2QsV0FBS0MsR0FBTCxHQUFXMWhCLE9BQU8rTCxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0Q7QUFDRDBWLFFBQUlwakIsU0FBSixDQUFjc2pCLEdBQWQsR0FBb0IsU0FBU0EsR0FBVCxDQUFjbmQsR0FBZCxFQUFtQjtBQUNyQyxhQUFPLEtBQUtrZCxHQUFMLENBQVNsZCxHQUFULE1BQWtCLElBQXpCO0FBQ0QsS0FGRDtBQUdBaWQsUUFBSXBqQixTQUFKLENBQWN1akIsR0FBZCxHQUFvQixTQUFTQSxHQUFULENBQWNwZCxHQUFkLEVBQW1CO0FBQ3JDLFdBQUtrZCxHQUFMLENBQVNsZCxHQUFULElBQWdCLElBQWhCO0FBQ0QsS0FGRDtBQUdBaWQsUUFBSXBqQixTQUFKLENBQWN3akIsS0FBZCxHQUFzQixTQUFTQSxLQUFULEdBQWtCO0FBQ3RDLFdBQUtILEdBQUwsR0FBVzFoQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBWDtBQUNELEtBRkQ7O0FBSUEsV0FBTzBWLEdBQVA7QUFDRCxHQWZPLEVBQVI7QUFnQkQ7O0FBRUQsSUFBSXpnQixPQUFPbkMsSUFBWDtBQUNBLElBQUlpakIsTUFBTWpqQixJQUFWO0FBQ0EsSUFBSWtqQixtQkFBSjs7QUFFQSxJQUFJN2xCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUl5ZCxhQUFhLE9BQU8vZ0IsT0FBUCxLQUFtQixXQUFwQztBQUNBLE1BQUlnaEIsYUFBYSxpQkFBakI7QUFDQSxNQUFJQyxXQUFXLFVBQVVyZSxHQUFWLEVBQWU7QUFBRSxXQUFPQSxJQUNwQ0UsT0FEb0MsQ0FDNUJrZSxVQUQ0QixFQUNoQixVQUFVemUsQ0FBVixFQUFhO0FBQUUsYUFBT0EsRUFBRXNMLFdBQUYsRUFBUDtBQUF5QixLQUR4QixFQUVwQy9LLE9BRm9DLENBRTVCLE9BRjRCLEVBRW5CLEVBRm1CLENBQVA7QUFFTixHQUYxQjs7QUFJQS9DLFNBQU8sVUFBVW1oQixHQUFWLEVBQWVDLEVBQWYsRUFBbUI7QUFDeEIsUUFBSUosY0FBZSxDQUFDN2UsT0FBTzRhLE1BQTNCLEVBQW9DO0FBQ2xDOWMsY0FBUTRmLEtBQVIsQ0FBYyxpQkFBaUJzQixHQUFqQixHQUF1QixHQUF2QixJQUNaQyxLQUFLQyxlQUFlTixvQkFBb0JLLEVBQXBCLENBQWYsQ0FBTCxHQUErQyxFQURuQyxDQUFkO0FBR0Q7QUFDRixHQU5EOztBQVFBTixRQUFNLFVBQVVLLEdBQVYsRUFBZUMsRUFBZixFQUFtQjtBQUN2QixRQUFJSixjQUFlLENBQUM3ZSxPQUFPNGEsTUFBM0IsRUFBb0M7QUFDbEM5YyxjQUFRRCxJQUFSLENBQWEsZ0JBQWdCbWhCLEdBQWhCLEdBQXNCLEdBQXRCLElBQ1hDLEtBQUtDLGVBQWVOLG9CQUFvQkssRUFBcEIsQ0FBZixDQUFMLEdBQStDLEVBRHBDLENBQWI7QUFHRDtBQUNGLEdBTkQ7O0FBUUFMLHdCQUFzQixVQUFVSyxFQUFWLEVBQWNFLFdBQWQsRUFBMkI7QUFDL0MsUUFBSUYsR0FBR3JZLEtBQUgsS0FBYXFZLEVBQWpCLEVBQXFCO0FBQ25CLGFBQU8sUUFBUDtBQUNEO0FBQ0QsUUFBSTlpQixPQUFPLE9BQU84aUIsRUFBUCxLQUFjLFFBQWQsR0FDUEEsRUFETyxHQUVQLE9BQU9BLEVBQVAsS0FBYyxVQUFkLElBQTRCQSxHQUFHOVosT0FBL0IsR0FDRThaLEdBQUc5WixPQUFILENBQVdoSixJQURiLEdBRUU4aUIsR0FBR0csTUFBSCxHQUNFSCxHQUFHaFksUUFBSCxDQUFZOUssSUFBWixJQUFvQjhpQixHQUFHaFksUUFBSCxDQUFZb1ksYUFEbEMsR0FFRUosR0FBRzlpQixJQU5YOztBQVFBLFFBQUltakIsT0FBT0wsR0FBR0csTUFBSCxJQUFhSCxHQUFHaFksUUFBSCxDQUFZc1ksTUFBcEM7QUFDQSxRQUFJLENBQUNwakIsSUFBRCxJQUFTbWpCLElBQWIsRUFBbUI7QUFDakIsVUFBSTFTLFFBQVEwUyxLQUFLMVMsS0FBTCxDQUFXLGlCQUFYLENBQVo7QUFDQXpRLGFBQU95USxTQUFTQSxNQUFNLENBQU4sQ0FBaEI7QUFDRDs7QUFFRCxXQUNFLENBQUN6USxPQUFRLE1BQU80aUIsU0FBUzVpQixJQUFULENBQVAsR0FBeUIsR0FBakMsR0FBd0MsYUFBekMsS0FDQ21qQixRQUFRSCxnQkFBZ0IsS0FBeEIsR0FBaUMsU0FBU0csSUFBMUMsR0FBa0QsRUFEbkQsQ0FERjtBQUlELEdBdEJEOztBQXdCQSxNQUFJSixpQkFBaUIsVUFBVXhlLEdBQVYsRUFBZTtBQUNsQyxRQUFJQSxRQUFRLGFBQVosRUFBMkI7QUFDekJBLGFBQU8sMkRBQVA7QUFDRDtBQUNELFdBQVEsaUJBQWlCQSxHQUFqQixHQUF1QixHQUEvQjtBQUNELEdBTEQ7QUFNRDs7QUFFRDs7QUFHQSxJQUFJOGUsUUFBUSxDQUFaOztBQUVBOzs7O0FBSUEsSUFBSUMsTUFBTSxTQUFTQSxHQUFULEdBQWdCO0FBQ3hCLE9BQUtDLEVBQUwsR0FBVUYsT0FBVjtBQUNBLE9BQUtHLElBQUwsR0FBWSxFQUFaO0FBQ0QsQ0FIRDs7QUFLQUYsSUFBSXZrQixTQUFKLENBQWMwa0IsTUFBZCxHQUF1QixTQUFTQSxNQUFULENBQWlCQyxHQUFqQixFQUFzQjtBQUMzQyxPQUFLRixJQUFMLENBQVU1a0IsSUFBVixDQUFlOGtCLEdBQWY7QUFDRCxDQUZEOztBQUlBSixJQUFJdmtCLFNBQUosQ0FBYzRrQixTQUFkLEdBQTBCLFNBQVNBLFNBQVQsQ0FBb0JELEdBQXBCLEVBQXlCO0FBQ2pEbEgsU0FBTyxLQUFLZ0gsSUFBWixFQUFrQkUsR0FBbEI7QUFDRCxDQUZEOztBQUlBSixJQUFJdmtCLFNBQUosQ0FBYzZrQixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsR0FBbUI7QUFDeEMsTUFBSU4sSUFBSTFiLE1BQVIsRUFBZ0I7QUFDZDBiLFFBQUkxYixNQUFKLENBQVdpYyxNQUFYLENBQWtCLElBQWxCO0FBQ0Q7QUFDRixDQUpEOztBQU1BUCxJQUFJdmtCLFNBQUosQ0FBYytrQixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsR0FBbUI7QUFDeEM7QUFDQSxNQUFJTixPQUFPLEtBQUtBLElBQUwsQ0FBVXRkLEtBQVYsRUFBWDtBQUNBLE9BQUssSUFBSXZILElBQUksQ0FBUixFQUFXMmUsSUFBSWtHLEtBQUt2bEIsTUFBekIsRUFBaUNVLElBQUkyZSxDQUFyQyxFQUF3QzNlLEdBQXhDLEVBQTZDO0FBQzNDNmtCLFNBQUs3a0IsQ0FBTCxFQUFRb2xCLE1BQVI7QUFDRDtBQUNGLENBTkQ7O0FBUUE7QUFDQTtBQUNBO0FBQ0FULElBQUkxYixNQUFKLEdBQWEsSUFBYjtBQUNBLElBQUlvYyxjQUFjLEVBQWxCOztBQUVBLFNBQVNDLFVBQVQsQ0FBcUJDLE9BQXJCLEVBQThCO0FBQzVCLE1BQUlaLElBQUkxYixNQUFSLEVBQWdCO0FBQUVvYyxnQkFBWXBsQixJQUFaLENBQWlCMGtCLElBQUkxYixNQUFyQjtBQUErQjtBQUNqRDBiLE1BQUkxYixNQUFKLEdBQWFzYyxPQUFiO0FBQ0Q7O0FBRUQsU0FBU0MsU0FBVCxHQUFzQjtBQUNwQmIsTUFBSTFiLE1BQUosR0FBYW9jLFlBQVluWSxHQUFaLEVBQWI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxJQUFJdVksYUFBYTNsQixNQUFNTSxTQUF2QjtBQUNBLElBQUlzbEIsZUFBZTNqQixPQUFPK0wsTUFBUCxDQUFjMlgsVUFBZCxDQUFuQixDQUE2QyxDQUMzQyxNQUQyQyxFQUUzQyxLQUYyQyxFQUczQyxPQUgyQyxFQUkzQyxTQUoyQyxFQUszQyxRQUwyQyxFQU0zQyxNQU4yQyxFQU8zQyxTQVAyQyxFQVM1QzllLE9BVDRDLENBU3BDLFVBQVVnZixNQUFWLEVBQWtCO0FBQ3pCO0FBQ0EsTUFBSUMsV0FBV0gsV0FBV0UsTUFBWCxDQUFmO0FBQ0EzTCxNQUFJMEwsWUFBSixFQUFrQkMsTUFBbEIsRUFBMEIsU0FBU0UsT0FBVCxHQUFvQjtBQUM1QyxRQUFJQyxjQUFjL2xCLFNBQWxCOztBQUVBO0FBQ0E7QUFDQSxRQUFJQyxJQUFJRCxVQUFVVCxNQUFsQjtBQUNBLFFBQUlPLE9BQU8sSUFBSUMsS0FBSixDQUFVRSxDQUFWLENBQVg7QUFDQSxXQUFPQSxHQUFQLEVBQVk7QUFDVkgsV0FBS0csQ0FBTCxJQUFVOGxCLFlBQVk5bEIsQ0FBWixDQUFWO0FBQ0Q7QUFDRCxRQUFJc0gsU0FBU3NlLFNBQVN2bEIsS0FBVCxDQUFlLElBQWYsRUFBcUJSLElBQXJCLENBQWI7QUFDQSxRQUFJa21CLEtBQUssS0FBS0MsTUFBZDtBQUNBLFFBQUlDLFFBQUo7QUFDQSxZQUFRTixNQUFSO0FBQ0UsV0FBSyxNQUFMO0FBQ0VNLG1CQUFXcG1CLElBQVg7QUFDQTtBQUNGLFdBQUssU0FBTDtBQUNFb21CLG1CQUFXcG1CLElBQVg7QUFDQTtBQUNGLFdBQUssUUFBTDtBQUNFb21CLG1CQUFXcG1CLEtBQUswSCxLQUFMLENBQVcsQ0FBWCxDQUFYO0FBQ0E7QUFUSjtBQVdBLFFBQUkwZSxRQUFKLEVBQWM7QUFBRUYsU0FBR0csWUFBSCxDQUFnQkQsUUFBaEI7QUFBNEI7QUFDNUM7QUFDQUYsT0FBR0ksR0FBSCxDQUFPaEIsTUFBUDtBQUNBLFdBQU83ZCxNQUFQO0FBQ0QsR0E1QkQ7QUE2QkQsQ0F6QzRDOztBQTJDN0M7O0FBRUEsSUFBSThlLFlBQVlya0IsT0FBT3NrQixtQkFBUCxDQUEyQlgsWUFBM0IsQ0FBaEI7O0FBRUE7Ozs7OztBQU1BLElBQUlZLGdCQUFnQjtBQUNsQkMsaUJBQWUsSUFERztBQUVsQkMsa0JBQWdCO0FBRkUsQ0FBcEI7O0FBS0E7Ozs7OztBQU1BLElBQUlDLFdBQVcsU0FBU0EsUUFBVCxDQUFtQnhrQixLQUFuQixFQUEwQjtBQUN2QyxPQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxPQUFLa2tCLEdBQUwsR0FBVyxJQUFJeEIsR0FBSixFQUFYO0FBQ0EsT0FBSytCLE9BQUwsR0FBZSxDQUFmO0FBQ0ExTSxNQUFJL1gsS0FBSixFQUFXLFFBQVgsRUFBcUIsSUFBckI7QUFDQSxNQUFJbkMsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixRQUFJMGtCLFVBQVV6RixXQUNWMEYsWUFEVSxHQUVWQyxXQUZKO0FBR0FGLFlBQVExa0IsS0FBUixFQUFleWpCLFlBQWYsRUFBNkJVLFNBQTdCO0FBQ0EsU0FBS0YsWUFBTCxDQUFrQmprQixLQUFsQjtBQUNELEdBTkQsTUFNTztBQUNMLFNBQUs2a0IsSUFBTCxDQUFVN2tCLEtBQVY7QUFDRDtBQUNGLENBZEQ7O0FBZ0JBOzs7OztBQUtBd2tCLFNBQVNybUIsU0FBVCxDQUFtQjBtQixJQUFuQixHQUEwQixTQUFTQSxJQUFULENBQWUzZixHQUFmLEVBQW9CO0FBQzVDLE1BQUlDLE9BQU9yRixPQUFPcUYsSUFBUCxDQUFZRCxHQUFaLENBQVg7QUFDQSxPQUFLLElBQUluSCxJQUFJLENBQWIsRUFBZ0JBLElBQUlvSCxLQUFLOUgsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDK21CLHNCQUFrQjVmLEdBQWxCLEVBQXVCQyxLQUFLcEgsQ0FBTCxDQUF2QixFQUFnQ21ILElBQUlDLEtBQUtwSCxDQUFMLENBQUosQ0FBaEM7QUFDRDtBQUNGLENBTEQ7O0FBT0E7OztBQUdBeW1CLFNBQVNybUIsU0FBVCxDQUFtQjhsQixZQUFuQixHQUFrQyxTQUFTQSxZQUFULENBQXVCYyxLQUF2QixFQUE4QjtBQUM5RCxPQUFLLElBQUlobkIsSUFBSSxDQUFSLEVBQVcyZSxJQUFJcUksTUFBTTFuQixNQUExQixFQUFrQ1UsSUFBSTJlLENBQXRDLEVBQXlDM2UsR0FBekMsRUFBOEM7QUFDNUNtakIsWUFBUTZELE1BQU1obkIsQ0FBTixDQUFSO0FBQ0Q7QUFDRixDQUpEOztBQU1BOztBQUVBOzs7O0FBSUEsU0FBUzRtQixZQUFULENBQXVCM2QsTUFBdkIsRUFBK0JnZSxHQUEvQixFQUFvQztBQUNsQztBQUNBaGUsU0FBT29TLFNBQVAsR0FBbUI0TCxHQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNBLFNBQVNKLFdBQVQsQ0FBc0I1ZCxNQUF0QixFQUE4QmdlLEdBQTlCLEVBQW1DN2YsSUFBbkMsRUFBeUM7QUFDdkMsT0FBSyxJQUFJcEgsSUFBSSxDQUFSLEVBQVcyZSxJQUFJdlgsS0FBSzlILE1BQXpCLEVBQWlDVSxJQUFJMmUsQ0FBckMsRUFBd0MzZSxHQUF4QyxFQUE2QztBQUMzQyxRQUFJdUcsTUFBTWEsS0FBS3BILENBQUwsQ0FBVjtBQUNBZ2EsUUFBSS9RLE1BQUosRUFBWTFDLEdBQVosRUFBaUIwZ0IsSUFBSTFnQixHQUFKLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7QUFLQSxTQUFTNGMsT0FBVCxDQUFrQmxoQixLQUFsQixFQUF5QmlsQixVQUF6QixFQUFxQztBQUNuQyxNQUFJLENBQUNoUyxTQUFTalQsS0FBVCxDQUFMLEVBQXNCO0FBQ3BCO0FBQ0Q7QUFDRCxNQUFJOGpCLEVBQUo7QUFDQSxNQUFJL0gsT0FBTy9iLEtBQVAsRUFBYyxRQUFkLEtBQTJCQSxNQUFNK2pCLE1BQU4sWUFBd0JTLFFBQXZELEVBQWlFO0FBQy9EVixTQUFLOWpCLE1BQU0rakIsTUFBWDtBQUNELEdBRkQsTUFFTyxJQUNMTSxjQUFjQyxhQUFkLElBQ0EsQ0FBQzVFLG1CQURELEtBRUM3aEIsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsS0FBd0JpZCxjQUFjamQsS0FBZCxDQUZ6QixLQUdBRixPQUFPb2xCLFlBQVAsQ0FBb0JsbEIsS0FBcEIsQ0FIQSxJQUlBLENBQUNBLE1BQU1xaUIsTUFMRixFQU1MO0FBQ0F5QixTQUFLLElBQUlVLFFBQUosQ0FBYXhrQixLQUFiLENBQUw7QUFDRDtBQUNELE1BQUlpbEIsY0FBY25CLEVBQWxCLEVBQXNCO0FBQ3BCQSxPQUFHVyxPQUFIO0FBQ0Q7QUFDRCxTQUFPWCxFQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNnQixpQkFBVCxDQUNFNWYsR0FERixFQUVFWixHQUZGLEVBR0VRLEdBSEYsRUFJRXFnQixZQUpGLEVBS0U7QUFDQSxNQUFJakIsTUFBTSxJQUFJeEIsR0FBSixFQUFWOztBQUVBLE1BQUkwQyxXQUFXdGxCLE9BQU91bEIsd0JBQVAsQ0FBZ0NuZ0IsR0FBaEMsRUFBcUNaLEdBQXJDLENBQWY7QUFDQSxNQUFJOGdCLFlBQVlBLFNBQVNyRyxZQUFULEtBQTBCLEtBQTFDLEVBQWlEO0FBQy9DO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJdUcsU0FBU0YsWUFBWUEsU0FBUzlrQixHQUFsQztBQUNBLE1BQUlpbEIsU0FBU0gsWUFBWUEsU0FBUzVELEdBQWxDOztBQUVBLE1BQUlnRSxVQUFVdEUsUUFBUXBjLEdBQVIsQ0FBZDtBQUNBaEYsU0FBT0MsY0FBUCxDQUFzQm1GLEdBQXRCLEVBQTJCWixHQUEzQixFQUFnQztBQUM5QnVhLGdCQUFZLElBRGtCO0FBRTlCRSxrQkFBYyxJQUZnQjtBQUc5QnplLFNBQUssU0FBU21sQixjQUFULEdBQTJCO0FBQzlCLFVBQUl6bEIsUUFBUXNsQixTQUFTQSxPQUFPem9CLElBQVAsQ0FBWXFJLEdBQVosQ0FBVCxHQUE0QkosR0FBeEM7QUFDQSxVQUFJNGQsSUFBSTFiLE1BQVIsRUFBZ0I7QUFDZGtkLFlBQUlsQixNQUFKO0FBQ0EsWUFBSXdDLE9BQUosRUFBYTtBQUNYQSxrQkFBUXRCLEdBQVIsQ0FBWWxCLE1BQVo7QUFDRDtBQUNELFlBQUlubEIsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsQ0FBSixFQUEwQjtBQUN4QjBsQixzQkFBWTFsQixLQUFaO0FBQ0Q7QUFDRjtBQUNELGFBQU9BLEtBQVA7QUFDRCxLQWY2QjtBQWdCOUJ3aEIsU0FBSyxTQUFTbUUsY0FBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDcEMsVUFBSTVsQixRQUFRc2xCLFNBQVNBLE9BQU96b0IsSUFBUCxDQUFZcUksR0FBWixDQUFULEdBQTRCSixHQUF4QztBQUNBO0FBQ0EsVUFBSThnQixXQUFXNWxCLEtBQVgsSUFBcUI0bEIsV0FBV0EsTUFBWCxJQUFxQjVsQixVQUFVQSxLQUF4RCxFQUFnRTtBQUM5RDtBQUNEO0FBQ0Q7QUFDQSxVQUFJaEUsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUM4Z0IsWUFBN0MsRUFBMkQ7QUFDekRBO0FBQ0Q7QUFDRCxVQUFJSSxNQUFKLEVBQVk7QUFDVkEsZUFBTzFvQixJQUFQLENBQVlxSSxHQUFaLEVBQWlCMGdCLE1BQWpCO0FBQ0QsT0FGRCxNQUVPO0FBQ0w5Z0IsY0FBTThnQixNQUFOO0FBQ0Q7QUFDREosZ0JBQVV0RSxRQUFRMEUsTUFBUixDQUFWO0FBQ0ExQixVQUFJaEIsTUFBSjtBQUNEO0FBakM2QixHQUFoQztBQW1DRDs7QUFFRDs7Ozs7QUFLQSxTQUFTMUIsR0FBVCxDQUFjeGEsTUFBZCxFQUFzQjFDLEdBQXRCLEVBQTJCUSxHQUEzQixFQUFnQztBQUM5QixNQUFJakgsTUFBTW1ILE9BQU4sQ0FBY2dDLE1BQWQsS0FBeUIsT0FBTzFDLEdBQVAsS0FBZSxRQUE1QyxFQUFzRDtBQUNwRDBDLFdBQU8zSixNQUFQLEdBQWdCbWEsS0FBS0QsR0FBTCxDQUFTdlEsT0FBTzNKLE1BQWhCLEVBQXdCaUgsR0FBeEIsQ0FBaEI7QUFDQTBDLFdBQU84VSxNQUFQLENBQWN4WCxHQUFkLEVBQW1CLENBQW5CLEVBQXNCUSxHQUF0QjtBQUNBLFdBQU9BLEdBQVA7QUFDRDtBQUNELE1BQUlpWCxPQUFPL1UsTUFBUCxFQUFlMUMsR0FBZixDQUFKLEVBQXlCO0FBQ3ZCMEMsV0FBTzFDLEdBQVAsSUFBY1EsR0FBZDtBQUNBLFdBQU9BLEdBQVA7QUFDRDtBQUNELE1BQUlnZixLQUFNOWMsTUFBRCxDQUFVK2MsTUFBbkI7QUFDQSxNQUFJL2MsT0FBT3FiLE1BQVAsSUFBa0J5QixNQUFNQSxHQUFHVyxPQUEvQixFQUF5QztBQUN2Q3pvQixZQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLDBFQUNBLHFEQUZ1QyxDQUF6QztBQUlBLFdBQU9nRSxHQUFQO0FBQ0Q7QUFDRCxNQUFJLENBQUNnZixFQUFMLEVBQVM7QUFDUDljLFdBQU8xQyxHQUFQLElBQWNRLEdBQWQ7QUFDQSxXQUFPQSxHQUFQO0FBQ0Q7QUFDRGdnQixvQkFBa0JoQixHQUFHOWpCLEtBQXJCLEVBQTRCc0UsR0FBNUIsRUFBaUNRLEdBQWpDO0FBQ0FnZixLQUFHSSxHQUFILENBQU9oQixNQUFQO0FBQ0EsU0FBT3BlLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBUytnQixHQUFULENBQWM3ZSxNQUFkLEVBQXNCMUMsR0FBdEIsRUFBMkI7QUFDekIsTUFBSXpHLE1BQU1tSCxPQUFOLENBQWNnQyxNQUFkLEtBQXlCLE9BQU8xQyxHQUFQLEtBQWUsUUFBNUMsRUFBc0Q7QUFDcEQwQyxXQUFPOFUsTUFBUCxDQUFjeFgsR0FBZCxFQUFtQixDQUFuQjtBQUNBO0FBQ0Q7QUFDRCxNQUFJd2YsS0FBTTljLE1BQUQsQ0FBVStjLE1BQW5CO0FBQ0EsTUFBSS9jLE9BQU9xYixNQUFQLElBQWtCeUIsTUFBTUEsR0FBR1csT0FBL0IsRUFBeUM7QUFDdkN6b0IsWUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QyxtRUFDQSx3QkFGdUMsQ0FBekM7QUFJQTtBQUNEO0FBQ0QsTUFBSSxDQUFDaWIsT0FBTy9VLE1BQVAsRUFBZTFDLEdBQWYsQ0FBTCxFQUEwQjtBQUN4QjtBQUNEO0FBQ0QsU0FBTzBDLE9BQU8xQyxHQUFQLENBQVA7QUFDQSxNQUFJLENBQUN3ZixFQUFMLEVBQVM7QUFDUDtBQUNEO0FBQ0RBLEtBQUdJLEdBQUgsQ0FBT2hCLE1BQVA7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVN3QyxXQUFULENBQXNCMWxCLEtBQXRCLEVBQTZCO0FBQzNCLE9BQUssSUFBSXZELElBQUssS0FBSyxDQUFkLEVBQWtCc0IsSUFBSSxDQUF0QixFQUF5QjJlLElBQUkxYyxNQUFNM0MsTUFBeEMsRUFBZ0RVLElBQUkyZSxDQUFwRCxFQUF1RDNlLEdBQXZELEVBQTREO0FBQzFEdEIsUUFBSXVELE1BQU1qQyxDQUFOLENBQUo7QUFDQXRCLFNBQUtBLEVBQUVzbkIsTUFBUCxJQUFpQnRuQixFQUFFc25CLE1BQUYsQ0FBU0csR0FBVCxDQUFhbEIsTUFBYixFQUFqQjtBQUNBLFFBQUlubEIsTUFBTW1ILE9BQU4sQ0FBY3ZJLENBQWQsQ0FBSixFQUFzQjtBQUNwQmlwQixrQkFBWWpwQixDQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBOzs7OztBQUtBLElBQUk0TixTQUFTcEgsT0FBT3FILHFCQUFwQjs7QUFFQTs7O0FBR0EsSUFBSXRPLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZ0csU0FBTzhJLEVBQVAsR0FBWTlJLE9BQU95YixTQUFQLEdBQW1CLFVBQVVya0IsTUFBVixFQUFrQmtCLEtBQWxCLEVBQXlCdWYsRUFBekIsRUFBNkI1ZCxHQUE3QixFQUFrQztBQUMvRCxRQUFJLENBQUM0ZCxFQUFMLEVBQVM7QUFDUHBoQixXQUNFLGNBQWN3RCxHQUFkLEdBQW9CLHNDQUFwQixHQUNBLGtDQUZGO0FBSUQ7QUFDRCxXQUFPeWhCLGFBQWF0a0IsTUFBYixFQUFxQmtCLEtBQXJCLENBQVA7QUFDRCxHQVJEO0FBU0Q7O0FBRUQ7OztBQUdBLFNBQVNxakIsU0FBVCxDQUFvQjFlLEVBQXBCLEVBQXdCa0wsSUFBeEIsRUFBOEI7QUFDNUIsTUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFBRSxXQUFPbEwsRUFBUDtBQUFXO0FBQ3hCLE1BQUloRCxHQUFKLEVBQVMyaEIsS0FBVCxFQUFnQkMsT0FBaEI7QUFDQSxNQUFJL2dCLE9BQU9yRixPQUFPcUYsSUFBUCxDQUFZcU4sSUFBWixDQUFYO0FBQ0EsT0FBSyxJQUFJelUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb0gsS0FBSzlILE1BQXpCLEVBQWlDVSxHQUFqQyxFQUFzQztBQUNwQ3VHLFVBQU1hLEtBQUtwSCxDQUFMLENBQU47QUFDQWtvQixZQUFRM2UsR0FBR2hELEdBQUgsQ0FBUjtBQUNBNGhCLGNBQVUxVCxLQUFLbE8sR0FBTCxDQUFWO0FBQ0EsUUFBSSxDQUFDeVgsT0FBT3pVLEVBQVAsRUFBV2hELEdBQVgsQ0FBTCxFQUFzQjtBQUNwQmtkLFVBQUlsYSxFQUFKLEVBQVFoRCxHQUFSLEVBQWE0aEIsT0FBYjtBQUNELEtBRkQsTUFFTyxJQUFJakosY0FBY2dKLEtBQWQsS0FBd0JoSixjQUFjaUosT0FBZCxDQUE1QixFQUFvRDtBQUN6REYsZ0JBQVVDLEtBQVYsRUFBaUJDLE9BQWpCO0FBQ0Q7QUFDRjtBQUNELFNBQU81ZSxFQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBK0MsT0FBTzNJLElBQVAsR0FBYyxVQUNaeWtCLFNBRFksRUFFWkMsUUFGWSxFQUdabEUsRUFIWSxFQUlaO0FBQ0EsTUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDUDtBQUNBLFFBQUksQ0FBQ2tFLFFBQUwsRUFBZTtBQUNiLGFBQU9ELFNBQVA7QUFDRDtBQUNELFFBQUksT0FBT0MsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ3BxQixjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLDRDQUNBLGlEQURBLEdBRUEsY0FIdUMsRUFJdkNvaEIsRUFKdUMsQ0FBekM7QUFNQSxhQUFPaUUsU0FBUDtBQUNEO0FBQ0QsUUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2QsYUFBT0MsUUFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQU8sU0FBU0MsWUFBVCxHQUF5QjtBQUM5QixhQUFPTCxVQUNMSSxTQUFTdnBCLElBQVQsQ0FBYyxJQUFkLENBREssRUFFTHNwQixVQUFVdHBCLElBQVYsQ0FBZSxJQUFmLENBRkssQ0FBUDtBQUlELEtBTEQ7QUFNRCxHQTVCRCxNQTRCTyxJQUFJc3BCLGFBQWFDLFFBQWpCLEVBQTJCO0FBQ2hDLFdBQU8sU0FBU0Usb0JBQVQsR0FBaUM7QUFDdEM7QUFDQSxVQUFJQyxlQUFlLE9BQU9ILFFBQVAsS0FBb0IsVUFBcEIsR0FDZkEsU0FBU3ZwQixJQUFULENBQWNxbEIsRUFBZCxDQURlLEdBRWZrRSxRQUZKO0FBR0EsVUFBSUksY0FBYyxPQUFPTCxTQUFQLEtBQXFCLFVBQXJCLEdBQ2RBLFVBQVV0cEIsSUFBVixDQUFlcWxCLEVBQWYsQ0FEYyxHQUVkbmYsU0FGSjtBQUdBLFVBQUl3akIsWUFBSixFQUFrQjtBQUNoQixlQUFPUCxVQUFVTyxZQUFWLEVBQXdCQyxXQUF4QixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBT0EsV0FBUDtBQUNEO0FBQ0YsS0FiRDtBQWNEO0FBQ0YsQ0FqREQ7O0FBbURBOzs7QUFHQSxTQUFTQyxTQUFULENBQ0VOLFNBREYsRUFFRUMsUUFGRixFQUdFO0FBQ0EsU0FBT0EsV0FDSEQsWUFDRUEsVUFBVTdvQixNQUFWLENBQWlCOG9CLFFBQWpCLENBREYsR0FFRXZvQixNQUFNbUgsT0FBTixDQUFjb2hCLFFBQWQsSUFDRUEsUUFERixHQUVFLENBQUNBLFFBQUQsQ0FMRCxHQU1IRCxTQU5KO0FBT0Q7O0FBRURsakIsT0FBT3diLGVBQVAsQ0FBdUIvWixPQUF2QixDQUErQixVQUFVbkMsSUFBVixFQUFnQjtBQUM3QzhILFNBQU85SCxJQUFQLElBQWVra0IsU0FBZjtBQUNELENBRkQ7O0FBSUE7Ozs7Ozs7QUFPQSxTQUFTQyxXQUFULENBQXNCUCxTQUF0QixFQUFpQ0MsUUFBakMsRUFBMkM7QUFDekMsTUFBSTdoQixNQUFNekUsT0FBTytMLE1BQVAsQ0FBY3NhLGFBQWEsSUFBM0IsQ0FBVjtBQUNBLFNBQU9DLFdBQ0hyZCxPQUFPeEUsR0FBUCxFQUFZNmhCLFFBQVosQ0FERyxHQUVIN2hCLEdBRko7QUFHRDs7QUFFRHRCLE9BQU91YixXQUFQLENBQW1COVosT0FBbkIsQ0FBMkIsVUFBVXZELElBQVYsRUFBZ0I7QUFDekNrSixTQUFPbEosT0FBTyxHQUFkLElBQXFCdWxCLFdBQXJCO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7O0FBTUFyYyxPQUFPc2MsS0FBUCxHQUFlLFVBQVVSLFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCO0FBQzVDO0FBQ0EsTUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFBRSxXQUFPdG1CLE9BQU8rTCxNQUFQLENBQWNzYSxhQUFhLElBQTNCLENBQVA7QUFBeUM7QUFDMUQsTUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQUUsV0FBT0MsUUFBUDtBQUFpQjtBQUNuQyxNQUFJdEosTUFBTSxFQUFWO0FBQ0EvVCxTQUFPK1QsR0FBUCxFQUFZcUosU0FBWjtBQUNBLE9BQUssSUFBSTdoQixHQUFULElBQWdCOGhCLFFBQWhCLEVBQTBCO0FBQ3hCLFFBQUkza0IsU0FBU3FiLElBQUl4WSxHQUFKLENBQWI7QUFDQSxRQUFJM0IsUUFBUXlqQixTQUFTOWhCLEdBQVQsQ0FBWjtBQUNBLFFBQUk3QyxVQUFVLENBQUM1RCxNQUFNbUgsT0FBTixDQUFjdkQsTUFBZCxDQUFmLEVBQXNDO0FBQ3BDQSxlQUFTLENBQUNBLE1BQUQsQ0FBVDtBQUNEO0FBQ0RxYixRQUFJeFksR0FBSixJQUFXN0MsU0FDUEEsT0FBT25FLE1BQVAsQ0FBY3FGLEtBQWQsQ0FETyxHQUVQLENBQUNBLEtBQUQsQ0FGSjtBQUdEO0FBQ0QsU0FBT21hLEdBQVA7QUFDRCxDQWpCRDs7QUFtQkE7OztBQUdBelMsT0FBT25KLEtBQVAsR0FDQW1KLE9BQU91YyxPQUFQLEdBQ0F2YyxPQUFPd2MsUUFBUCxHQUFrQixVQUFVVixTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUMvQyxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUFFLFdBQU90bUIsT0FBTytMLE1BQVAsQ0FBY3NhLGFBQWEsSUFBM0IsQ0FBUDtBQUF5QztBQUMxRCxNQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFBRSxXQUFPQyxRQUFQO0FBQWlCO0FBQ25DLE1BQUl0SixNQUFNaGQsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQVY7QUFDQTlDLFNBQU8rVCxHQUFQLEVBQVlxSixTQUFaO0FBQ0FwZCxTQUFPK1QsR0FBUCxFQUFZc0osUUFBWjtBQUNBLFNBQU90SixHQUFQO0FBQ0QsQ0FURDs7QUFXQTs7O0FBR0EsSUFBSWlKLGVBQWUsVUFBVUksU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDaEQsU0FBT0EsYUFBYXJqQixTQUFiLEdBQ0hvakIsU0FERyxHQUVIQyxRQUZKO0FBR0QsQ0FKRDs7QUFNQTs7O0FBR0EsU0FBU1UsZUFBVCxDQUEwQjFlLE9BQTFCLEVBQW1DO0FBQ2pDLE9BQUssSUFBSTlELEdBQVQsSUFBZ0I4RCxRQUFRL0YsVUFBeEIsRUFBb0M7QUFDbEMsUUFBSTBrQixRQUFRemlCLElBQUlvWCxXQUFKLEVBQVo7QUFDQSxRQUFJQyxhQUFhb0wsS0FBYixLQUF1QjlqQixPQUFPa2IsYUFBUCxDQUFxQjRJLEtBQXJCLENBQTNCLEVBQXdEO0FBQ3REam1CLFdBQ0UsZ0VBQ0EsTUFEQSxHQUNTd0QsR0FGWDtBQUlEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFNBQVMwaUIsY0FBVCxDQUF5QjVlLE9BQXpCLEVBQWtDO0FBQ2hDLE1BQUlsSCxRQUFRa0gsUUFBUWxILEtBQXBCO0FBQ0EsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFBRTtBQUFRO0FBQ3RCLE1BQUlxRCxNQUFNLEVBQVY7QUFDQSxNQUFJeEcsQ0FBSixFQUFPK0csR0FBUCxFQUFZMUYsSUFBWjtBQUNBLE1BQUl2QixNQUFNbUgsT0FBTixDQUFjOUQsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCbkQsUUFBSW1ELE1BQU03RCxNQUFWO0FBQ0EsV0FBT1UsR0FBUCxFQUFZO0FBQ1YrRyxZQUFNNUQsTUFBTW5ELENBQU4sQ0FBTjtBQUNBLFVBQUksT0FBTytHLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQjFGLGVBQU9nZCxTQUFTdFgsR0FBVCxDQUFQO0FBQ0FQLFlBQUluRixJQUFKLElBQVksRUFBRStCLE1BQU0sSUFBUixFQUFaO0FBQ0QsT0FIRCxNQUdPLElBQUluRixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRHZELGFBQUssZ0RBQUw7QUFDRDtBQUNGO0FBQ0YsR0FYRCxNQVdPLElBQUltYyxjQUFjL2IsS0FBZCxDQUFKLEVBQTBCO0FBQy9CLFNBQUssSUFBSW9ELEdBQVQsSUFBZ0JwRCxLQUFoQixFQUF1QjtBQUNyQjRELFlBQU01RCxNQUFNb0QsR0FBTixDQUFOO0FBQ0FsRixhQUFPZ2QsU0FBUzlYLEdBQVQsQ0FBUDtBQUNBQyxVQUFJbkYsSUFBSixJQUFZNmQsY0FBY25ZLEdBQWQsSUFDUkEsR0FEUSxHQUVSLEVBQUUzRCxNQUFNMkQsR0FBUixFQUZKO0FBR0Q7QUFDRjtBQUNEc0QsVUFBUWxILEtBQVIsR0FBZ0JxRCxHQUFoQjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTMGlCLG1CQUFULENBQThCN2UsT0FBOUIsRUFBdUM7QUFDckMsTUFBSThlLE9BQU85ZSxRQUFRK2UsVUFBbkI7QUFDQSxNQUFJRCxJQUFKLEVBQVU7QUFDUixTQUFLLElBQUk1aUIsR0FBVCxJQUFnQjRpQixJQUFoQixFQUFzQjtBQUNwQixVQUFJblAsTUFBTW1QLEtBQUs1aUIsR0FBTCxDQUFWO0FBQ0EsVUFBSSxPQUFPeVQsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCbVAsYUFBSzVpQixHQUFMLElBQVksRUFBRXFULE1BQU1JLEdBQVIsRUFBYW9MLFFBQVFwTCxHQUFyQixFQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxTQUFTcVAsWUFBVCxDQUNFM2xCLE1BREYsRUFFRWtCLEtBRkYsRUFHRXVmLEVBSEYsRUFJRTtBQUNBLE1BQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN5aUIsb0JBQWdCbmtCLEtBQWhCO0FBQ0Q7QUFDRHFrQixpQkFBZXJrQixLQUFmO0FBQ0Fza0Isc0JBQW9CdGtCLEtBQXBCO0FBQ0EsTUFBSTBrQixjQUFjMWtCLE1BQU0ya0IsT0FBeEI7QUFDQSxNQUFJRCxXQUFKLEVBQWlCO0FBQ2Y1bEIsYUFBUyxPQUFPNGxCLFdBQVAsS0FBdUIsVUFBdkIsR0FDTEQsYUFBYTNsQixNQUFiLEVBQXFCNGxCLFlBQVlqZixPQUFqQyxFQUEwQzhaLEVBQTFDLENBREssR0FFTGtGLGFBQWEzbEIsTUFBYixFQUFxQjRsQixXQUFyQixFQUFrQ25GLEVBQWxDLENBRko7QUFHRDtBQUNELE1BQUl2ZixNQUFNNGtCLE1BQVYsRUFBa0I7QUFDaEIsU0FBSyxJQUFJeHBCLElBQUksQ0FBUixFQUFXMmUsSUFBSS9aLE1BQU00a0IsTUFBTixDQUFhbHFCLE1BQWpDLEVBQXlDVSxJQUFJMmUsQ0FBN0MsRUFBZ0QzZSxHQUFoRCxFQUFxRDtBQUNuRCxVQUFJaU0sUUFBUXJILE1BQU00a0IsTUFBTixDQUFheHBCLENBQWIsQ0FBWjtBQUNBLFVBQUlpTSxNQUFNN0wsU0FBTixZQUEyQnFwQixLQUEvQixFQUFzQztBQUNwQ3hkLGdCQUFRQSxNQUFNNUIsT0FBZDtBQUNEO0FBQ0QzRyxlQUFTMmxCLGFBQWEzbEIsTUFBYixFQUFxQnVJLEtBQXJCLEVBQTRCa1ksRUFBNUIsQ0FBVDtBQUNEO0FBQ0Y7QUFDRCxNQUFJOVosVUFBVSxFQUFkO0FBQ0EsTUFBSTlELEdBQUo7QUFDQSxPQUFLQSxHQUFMLElBQVk3QyxNQUFaLEVBQW9CO0FBQ2xCZ21CLGVBQVduakIsR0FBWDtBQUNEO0FBQ0QsT0FBS0EsR0FBTCxJQUFZM0IsS0FBWixFQUFtQjtBQUNqQixRQUFJLENBQUNvWixPQUFPdGEsTUFBUCxFQUFlNkMsR0FBZixDQUFMLEVBQTBCO0FBQ3hCbWpCLGlCQUFXbmpCLEdBQVg7QUFDRDtBQUNGO0FBQ0QsV0FBU21qQixVQUFULENBQXFCbmpCLEdBQXJCLEVBQTBCO0FBQ3hCLFFBQUlvakIsUUFBUXJkLE9BQU8vRixHQUFQLEtBQWV5aEIsWUFBM0I7QUFDQTNkLFlBQVE5RCxHQUFSLElBQWVvakIsTUFBTWptQixPQUFPNkMsR0FBUCxDQUFOLEVBQW1CM0IsTUFBTTJCLEdBQU4sQ0FBbkIsRUFBK0I0ZCxFQUEvQixFQUFtQzVkLEdBQW5DLENBQWY7QUFDRDtBQUNELFNBQU84RCxPQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBU3VmLFlBQVQsQ0FDRXZmLE9BREYsRUFFRWpILElBRkYsRUFHRXdoQixFQUhGLEVBSUVpRixXQUpGLEVBS0U7QUFDQTtBQUNBLE1BQUksT0FBT2pGLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUMxQjtBQUNEO0FBQ0QsTUFBSWtGLFNBQVN6ZixRQUFRakgsSUFBUixDQUFiO0FBQ0E7QUFDQSxNQUFJNGEsT0FBTzhMLE1BQVAsRUFBZWxGLEVBQWYsQ0FBSixFQUF3QjtBQUFFLFdBQU9rRixPQUFPbEYsRUFBUCxDQUFQO0FBQW1CO0FBQzdDLE1BQUltRixjQUFjMUwsU0FBU3VHLEVBQVQsQ0FBbEI7QUFDQSxNQUFJNUcsT0FBTzhMLE1BQVAsRUFBZUMsV0FBZixDQUFKLEVBQWlDO0FBQUUsV0FBT0QsT0FBT0MsV0FBUCxDQUFQO0FBQTRCO0FBQy9ELE1BQUlDLGVBQWUxTCxXQUFXeUwsV0FBWCxDQUFuQjtBQUNBLE1BQUkvTCxPQUFPOEwsTUFBUCxFQUFlRSxZQUFmLENBQUosRUFBa0M7QUFBRSxXQUFPRixPQUFPRSxZQUFQLENBQVA7QUFBNkI7QUFDakU7QUFDQSxNQUFJeGpCLE1BQU1zakIsT0FBT2xGLEVBQVAsS0FBY2tGLE9BQU9DLFdBQVAsQ0FBZCxJQUFxQ0QsT0FBT0UsWUFBUCxDQUEvQztBQUNBLE1BQUkvckIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN1akIsV0FBekMsSUFBd0QsQ0FBQ3JqQixHQUE3RCxFQUFrRTtBQUNoRXpELFNBQ0UsdUJBQXVCSyxLQUFLbUUsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBdkIsR0FBMkMsSUFBM0MsR0FBa0RxZCxFQURwRCxFQUVFdmEsT0FGRjtBQUlEO0FBQ0QsU0FBTzdELEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxTQUFTeWpCLFlBQVQsQ0FDRTFqQixHQURGLEVBRUUyakIsV0FGRixFQUdFbkMsU0FIRixFQUlFNUQsRUFKRixFQUtFO0FBQ0EsTUFBSWdHLE9BQU9ELFlBQVkzakIsR0FBWixDQUFYO0FBQ0EsTUFBSTZqQixTQUFTLENBQUNwTSxPQUFPK0osU0FBUCxFQUFrQnhoQixHQUFsQixDQUFkO0FBQ0EsTUFBSXRFLFFBQVE4bEIsVUFBVXhoQixHQUFWLENBQVo7QUFDQTtBQUNBLE1BQUk4akIsT0FBTzFnQixPQUFQLEVBQWdCd2dCLEtBQUsvbUIsSUFBckIsQ0FBSixFQUFnQztBQUM5QixRQUFJZ25CLFVBQVUsQ0FBQ3BNLE9BQU9tTSxJQUFQLEVBQWEsU0FBYixDQUFmLEVBQXdDO0FBQ3RDbG9CLGNBQVEsS0FBUjtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUNvb0IsT0FBT2huQixNQUFQLEVBQWU4bUIsS0FBSy9tQixJQUFwQixDQUFELEtBQStCbkIsVUFBVSxFQUFWLElBQWdCQSxVQUFVdWMsVUFBVWpZLEdBQVYsQ0FBekQsQ0FBSixFQUE4RTtBQUNuRnRFLGNBQVEsSUFBUjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLE1BQUlBLFVBQVUrQyxTQUFkLEVBQXlCO0FBQ3ZCL0MsWUFBUXFvQixvQkFBb0JuRyxFQUFwQixFQUF3QmdHLElBQXhCLEVBQThCNWpCLEdBQTlCLENBQVI7QUFDQTtBQUNBO0FBQ0EsUUFBSWdrQixvQkFBb0JqRSxjQUFjQyxhQUF0QztBQUNBRCxrQkFBY0MsYUFBZCxHQUE4QixJQUE5QjtBQUNBcEQsWUFBUWxoQixLQUFSO0FBQ0Fxa0Isa0JBQWNDLGFBQWQsR0FBOEJnRSxpQkFBOUI7QUFDRDtBQUNELE1BQUl0c0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNra0IsZUFBV0wsSUFBWCxFQUFpQjVqQixHQUFqQixFQUFzQnRFLEtBQXRCLEVBQTZCa2lCLEVBQTdCLEVBQWlDaUcsTUFBakM7QUFDRDtBQUNELFNBQU9ub0IsS0FBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTcW9CLG1CQUFULENBQThCbkcsRUFBOUIsRUFBa0NnRyxJQUFsQyxFQUF3QzVqQixHQUF4QyxFQUE2QztBQUMzQztBQUNBLE1BQUksQ0FBQ3lYLE9BQU9tTSxJQUFQLEVBQWEsU0FBYixDQUFMLEVBQThCO0FBQzVCLFdBQU9ubEIsU0FBUDtBQUNEO0FBQ0QsTUFBSWdWLE1BQU1tUSxLQUFLam9CLE9BQWY7QUFDQTtBQUNBLE1BQUlqRSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzRPLFNBQVM4RSxHQUFULENBQTdDLEVBQTREO0FBQzFEalgsU0FDRSxxQ0FBcUN3RCxHQUFyQyxHQUEyQyxLQUEzQyxHQUNBLDJEQURBLEdBRUEsOEJBSEYsRUFJRTRkLEVBSkY7QUFNRDtBQUNEO0FBQ0E7QUFDQSxNQUFJQSxNQUFNQSxHQUFHaFksUUFBSCxDQUFZNGIsU0FBbEIsSUFDRjVELEdBQUdoWSxRQUFILENBQVk0YixTQUFaLENBQXNCeGhCLEdBQXRCLE1BQStCdkIsU0FEN0IsSUFFRm1mLEdBQUdzRyxNQUFILENBQVVsa0IsR0FBVixNQUFtQnZCLFNBRnJCLEVBRWdDO0FBQzlCLFdBQU9tZixHQUFHc0csTUFBSCxDQUFVbGtCLEdBQVYsQ0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFNBQU8sT0FBT3lULEdBQVAsS0FBZSxVQUFmLElBQTZCMFEsUUFBUVAsS0FBSy9tQixJQUFiLE1BQXVCLFVBQXBELEdBQ0g0VyxJQUFJbGIsSUFBSixDQUFTcWxCLEVBQVQsQ0FERyxHQUVIbkssR0FGSjtBQUdEOztBQUVEOzs7QUFHQSxTQUFTd1EsVUFBVCxDQUNFTCxJQURGLEVBRUU5b0IsSUFGRixFQUdFWSxLQUhGLEVBSUVraUIsRUFKRixFQUtFaUcsTUFMRixFQU1FO0FBQ0EsTUFBSUQsS0FBSzNnQixRQUFMLElBQWlCNGdCLE1BQXJCLEVBQTZCO0FBQzNCcm5CLFNBQ0UsNkJBQTZCMUIsSUFBN0IsR0FBb0MsR0FEdEMsRUFFRThpQixFQUZGO0FBSUE7QUFDRDtBQUNELE1BQUlsaUIsU0FBUyxJQUFULElBQWlCLENBQUNrb0IsS0FBSzNnQixRQUEzQixFQUFxQztBQUNuQztBQUNEO0FBQ0QsTUFBSXBHLE9BQU8rbUIsS0FBSy9tQixJQUFoQjtBQUNBLE1BQUl1bkIsUUFBUSxDQUFDdm5CLElBQUQsSUFBU0EsU0FBUyxJQUE5QjtBQUNBLE1BQUl3bkIsZ0JBQWdCLEVBQXBCO0FBQ0EsTUFBSXhuQixJQUFKLEVBQVU7QUFDUixRQUFJLENBQUN0RCxNQUFNbUgsT0FBTixDQUFjN0QsSUFBZCxDQUFMLEVBQTBCO0FBQ3hCQSxhQUFPLENBQUNBLElBQUQsQ0FBUDtBQUNEO0FBQ0QsU0FBSyxJQUFJcEQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb0QsS0FBSzlELE1BQVQsSUFBbUIsQ0FBQ3FyQixLQUFwQyxFQUEyQzNxQixHQUEzQyxFQUFnRDtBQUM5QyxVQUFJNnFCLGVBQWVDLFdBQVc3b0IsS0FBWCxFQUFrQm1CLEtBQUtwRCxDQUFMLENBQWxCLENBQW5CO0FBQ0E0cUIsb0JBQWMzcUIsSUFBZCxDQUFtQjRxQixhQUFhRSxZQUFiLElBQTZCLEVBQWhEO0FBQ0FKLGNBQVFFLGFBQWFGLEtBQXJCO0FBQ0Q7QUFDRjtBQUNELE1BQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1Y1bkIsU0FDRSwrQ0FBK0MxQixJQUEvQyxHQUFzRCxJQUF0RCxHQUNBLFlBREEsR0FDZXVwQixjQUFjdmpCLEdBQWQsQ0FBa0JpWCxVQUFsQixFQUE4QnRYLElBQTlCLENBQW1DLElBQW5DLENBRGYsR0FFQSxRQUZBLEdBRVdqRixPQUFPM0IsU0FBUCxDQUFpQnFGLFFBQWpCLENBQTBCM0csSUFBMUIsQ0FBK0JtRCxLQUEvQixFQUFzQ3NGLEtBQXRDLENBQTRDLENBQTVDLEVBQStDLENBQUMsQ0FBaEQsQ0FGWCxHQUVnRSxHQUhsRSxFQUlFNGMsRUFKRjtBQU1BO0FBQ0Q7QUFDRCxNQUFJNkcsWUFBWWIsS0FBS2EsU0FBckI7QUFDQSxNQUFJQSxTQUFKLEVBQWU7QUFDYixRQUFJLENBQUNBLFVBQVUvb0IsS0FBVixDQUFMLEVBQXVCO0FBQ3JCYyxXQUNFLDJEQUEyRDFCLElBQTNELEdBQWtFLElBRHBFLEVBRUU4aUIsRUFGRjtBQUlEO0FBQ0Y7QUFDRjs7QUFFRDs7O0FBR0EsU0FBUzJHLFVBQVQsQ0FBcUI3b0IsS0FBckIsRUFBNEJtQixJQUE1QixFQUFrQztBQUNoQyxNQUFJdW5CLEtBQUo7QUFDQSxNQUFJSSxlQUFlTCxRQUFRdG5CLElBQVIsQ0FBbkI7QUFDQSxNQUFJMm5CLGlCQUFpQixRQUFyQixFQUErQjtBQUM3QkosWUFBUSxPQUFPMW9CLEtBQVAsTUFBa0I4b0IsZUFBZSxRQUFqQyxDQUFSO0FBQ0QsR0FGRCxNQUVPLElBQUlBLGlCQUFpQixRQUFyQixFQUErQjtBQUNwQ0osWUFBUSxPQUFPMW9CLEtBQVAsTUFBa0I4b0IsZUFBZSxRQUFqQyxDQUFSO0FBQ0QsR0FGTSxNQUVBLElBQUlBLGlCQUFpQixTQUFyQixFQUFnQztBQUNyQ0osWUFBUSxPQUFPMW9CLEtBQVAsTUFBa0I4b0IsZUFBZSxTQUFqQyxDQUFSO0FBQ0QsR0FGTSxNQUVBLElBQUlBLGlCQUFpQixVQUFyQixFQUFpQztBQUN0Q0osWUFBUSxPQUFPMW9CLEtBQVAsTUFBa0I4b0IsZUFBZSxVQUFqQyxDQUFSO0FBQ0QsR0FGTSxNQUVBLElBQUlBLGlCQUFpQixRQUFyQixFQUErQjtBQUNwQ0osWUFBUXpMLGNBQWNqZCxLQUFkLENBQVI7QUFDRCxHQUZNLE1BRUEsSUFBSThvQixpQkFBaUIsT0FBckIsRUFBOEI7QUFDbkNKLFlBQVE3cUIsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsQ0FBUjtBQUNELEdBRk0sTUFFQTtBQUNMMG9CLFlBQVExb0IsaUJBQWlCbUIsSUFBekI7QUFDRDtBQUNELFNBQU87QUFDTHVuQixXQUFPQSxLQURGO0FBRUxJLGtCQUFjQTtBQUZULEdBQVA7QUFJRDs7QUFFRDs7Ozs7QUFLQSxTQUFTTCxPQUFULENBQWtCblQsRUFBbEIsRUFBc0I7QUFDcEIsTUFBSXpGLFFBQVF5RixNQUFNQSxHQUFHOVIsUUFBSCxHQUFjcU0sS0FBZCxDQUFvQixvQkFBcEIsQ0FBbEI7QUFDQSxTQUFPQSxTQUFTQSxNQUFNLENBQU4sQ0FBaEI7QUFDRDs7QUFFRCxTQUFTdVksTUFBVCxDQUFpQmpuQixJQUFqQixFQUF1Qm1VLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ3pYLE1BQU1tSCxPQUFOLENBQWNzUSxFQUFkLENBQUwsRUFBd0I7QUFDdEIsV0FBT21ULFFBQVFuVCxFQUFSLE1BQWdCbVQsUUFBUXRuQixJQUFSLENBQXZCO0FBQ0Q7QUFDRCxPQUFLLElBQUlwRCxJQUFJLENBQVIsRUFBV04sTUFBTTZYLEdBQUdqWSxNQUF6QixFQUFpQ1UsSUFBSU4sR0FBckMsRUFBMENNLEdBQTFDLEVBQStDO0FBQzdDLFFBQUkwcUIsUUFBUW5ULEdBQUd2WCxDQUFILENBQVIsTUFBbUIwcUIsUUFBUXRuQixJQUFSLENBQXZCLEVBQXNDO0FBQ3BDLGFBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVM2bkIsV0FBVCxDQUFzQnRJLEdBQXRCLEVBQTJCd0IsRUFBM0IsRUFBK0IrRyxJQUEvQixFQUFxQztBQUNuQyxNQUFJaG1CLE9BQU8rYSxZQUFYLEVBQXlCO0FBQ3ZCL2EsV0FBTythLFlBQVAsQ0FBb0JuaEIsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0I2akIsR0FBL0IsRUFBb0N3QixFQUFwQyxFQUF3QytHLElBQXhDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSWp0QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3ZELFdBQU0sY0FBY21vQixJQUFkLEdBQXFCLEdBQTNCLEVBQWlDL0csRUFBakM7QUFDRDtBQUNEO0FBQ0EsUUFBSXhYLGFBQWEsT0FBTzNKLE9BQVAsS0FBbUIsV0FBcEMsRUFBaUQ7QUFDL0NBLGNBQVE0ZixLQUFSLENBQWNELEdBQWQ7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFNQSxHQUFOO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBLElBQUl3SSxTQUFKOztBQUVBLElBQUlsdEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSThrQixpQkFBaUI1TixRQUNuQiwyQ0FDQSxnRkFEQSxHQUVBLHdFQUZBLEdBR0EsU0FKbUIsQ0FJVDtBQUpTLEdBQXJCOztBQU9BLE1BQUk2TixpQkFBaUIsVUFBVXBpQixNQUFWLEVBQWtCMUMsR0FBbEIsRUFBdUI7QUFDMUN4RCxTQUNFLDBCQUEwQndELEdBQTFCLEdBQWdDLHdDQUFoQyxHQUNBLCtEQURBLEdBRUEsZ0NBSEYsRUFJRTBDLE1BSkY7QUFNRCxHQVBEOztBQVNBLE1BQUlxaUIsV0FDRixPQUFPQyxLQUFQLEtBQWlCLFdBQWpCLElBQ0FBLE1BQU05bEIsUUFBTixHQUFpQnFNLEtBQWpCLENBQXVCLGFBQXZCLENBRkY7O0FBSUEsTUFBSXdaLFFBQUosRUFBYztBQUNaLFFBQUlFLG9CQUFvQmhPLFFBQVEsdUNBQVIsQ0FBeEI7QUFDQXRZLFdBQU9pYixRQUFQLEdBQWtCLElBQUlvTCxLQUFKLENBQVVybUIsT0FBT2liLFFBQWpCLEVBQTJCO0FBQzNDc0QsV0FBSyxTQUFTQSxHQUFULENBQWN4YSxNQUFkLEVBQXNCMUMsR0FBdEIsRUFBMkJ0RSxLQUEzQixFQUFrQztBQUNyQyxZQUFJdXBCLGtCQUFrQmpsQixHQUFsQixDQUFKLEVBQTRCO0FBQzFCeEQsZUFBTSw4REFBOER3RCxHQUFwRTtBQUNBLGlCQUFPLEtBQVA7QUFDRCxTQUhELE1BR087QUFDTDBDLGlCQUFPMUMsR0FBUCxJQUFjdEUsS0FBZDtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGO0FBVDBDLEtBQTNCLENBQWxCO0FBV0Q7O0FBRUQsTUFBSXdwQixhQUFhO0FBQ2YvSCxTQUFLLFNBQVNBLEdBQVQsQ0FBY3phLE1BQWQsRUFBc0IxQyxHQUF0QixFQUEyQjtBQUM5QixVQUFJbWQsTUFBTW5kLE9BQU8wQyxNQUFqQjtBQUNBLFVBQUl5aUIsWUFBWU4sZUFBZTdrQixHQUFmLEtBQXVCQSxJQUFJeUcsTUFBSixDQUFXLENBQVgsTUFBa0IsR0FBekQ7QUFDQSxVQUFJLENBQUMwVyxHQUFELElBQVEsQ0FBQ2dJLFNBQWIsRUFBd0I7QUFDdEJMLHVCQUFlcGlCLE1BQWYsRUFBdUIxQyxHQUF2QjtBQUNEO0FBQ0QsYUFBT21kLE9BQU8sQ0FBQ2dJLFNBQWY7QUFDRDtBQVJjLEdBQWpCOztBQVdBLE1BQUlDLGFBQWE7QUFDZnBwQixTQUFLLFNBQVNBLEdBQVQsQ0FBYzBHLE1BQWQsRUFBc0IxQyxHQUF0QixFQUEyQjtBQUM5QixVQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLEVBQUVBLE9BQU8wQyxNQUFULENBQS9CLEVBQWlEO0FBQy9Db2lCLHVCQUFlcGlCLE1BQWYsRUFBdUIxQyxHQUF2QjtBQUNEO0FBQ0QsYUFBTzBDLE9BQU8xQyxHQUFQLENBQVA7QUFDRDtBQU5jLEdBQWpCOztBQVNBNGtCLGNBQVksU0FBU0EsU0FBVCxDQUFvQmhILEVBQXBCLEVBQXdCO0FBQ2xDLFFBQUltSCxRQUFKLEVBQWM7QUFDWjtBQUNBLFVBQUlqaEIsVUFBVThaLEdBQUdoWSxRQUFqQjtBQUNBLFVBQUl5ZixXQUFXdmhCLFFBQVEvRyxNQUFSLElBQWtCK0csUUFBUS9HLE1BQVIsQ0FBZXVvQixhQUFqQyxHQUNYRixVQURXLEdBRVhGLFVBRko7QUFHQXRILFNBQUcySCxZQUFILEdBQWtCLElBQUlQLEtBQUosQ0FBVXBILEVBQVYsRUFBY3lILFFBQWQsQ0FBbEI7QUFDRCxLQVBELE1BT087QUFDTHpILFNBQUcySCxZQUFILEdBQWtCM0gsRUFBbEI7QUFDRDtBQUNGLEdBWEQ7QUFZRDs7QUFFRCxJQUFJNEgsSUFBSjtBQUNBLElBQUlDLE9BQUo7O0FBRUEsSUFBSS90QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJMmxCLE9BQU90ZixhQUFhQyxPQUFPaUssV0FBL0I7QUFDQTtBQUNBLE1BQ0VvVixRQUNBQSxLQUFLRixJQURMLElBRUFFLEtBQUtELE9BRkwsSUFHQUMsS0FBS0MsVUFITCxJQUlBRCxLQUFLRSxhQUxQLEVBTUU7QUFDQUosV0FBTyxVQUFVdGlCLEdBQVYsRUFBZTtBQUFFLGFBQU93aUIsS0FBS0YsSUFBTCxDQUFVdGlCLEdBQVYsQ0FBUDtBQUF3QixLQUFoRDtBQUNBdWlCLGNBQVUsVUFBVTNxQixJQUFWLEVBQWdCK3FCLFFBQWhCLEVBQTBCQyxNQUExQixFQUFrQztBQUMxQ0osV0FBS0QsT0FBTCxDQUFhM3FCLElBQWIsRUFBbUIrcUIsUUFBbkIsRUFBNkJDLE1BQTdCO0FBQ0FKLFdBQUtDLFVBQUwsQ0FBZ0JFLFFBQWhCO0FBQ0FILFdBQUtDLFVBQUwsQ0FBZ0JHLE1BQWhCO0FBQ0FKLFdBQUtFLGFBQUwsQ0FBbUI5cUIsSUFBbkI7QUFDRCxLQUxEO0FBTUQ7QUFDRjs7QUFFRDs7QUFFQSxJQUFJaXJCLFFBQVEsU0FBU0EsS0FBVCxDQUNWN2lCLEdBRFUsRUFFVjlGLElBRlUsRUFHVkYsUUFIVSxFQUlWOG9CLElBSlUsRUFLVkMsR0FMVSxFQU1WQyxPQU5VLEVBT1ZDLGdCQVBVLEVBUVY7QUFDQSxPQUFLampCLEdBQUwsR0FBV0EsR0FBWDtBQUNBLE9BQUs5RixJQUFMLEdBQVlBLElBQVo7QUFDQSxPQUFLRixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUs4b0IsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsT0FBS0MsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS0csRUFBTCxHQUFVM25CLFNBQVY7QUFDQSxPQUFLeW5CLE9BQUwsR0FBZUEsT0FBZjtBQUNBLE9BQUtHLGlCQUFMLEdBQXlCNW5CLFNBQXpCO0FBQ0EsT0FBS3VCLEdBQUwsR0FBVzVDLFFBQVFBLEtBQUs0QyxHQUF4QjtBQUNBLE9BQUttbUIsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUNBLE9BQUtHLGlCQUFMLEdBQXlCN25CLFNBQXpCO0FBQ0EsT0FBS3RCLE1BQUwsR0FBY3NCLFNBQWQ7QUFDQSxPQUFLNk4sR0FBTCxHQUFXLEtBQVg7QUFDQSxPQUFLOUgsUUFBTCxHQUFnQixLQUFoQjtBQUNBLE9BQUsraEIsWUFBTCxHQUFvQixJQUFwQjtBQUNBLE9BQUtDLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsT0FBS0MsTUFBTCxHQUFjLEtBQWQ7QUFDRCxDQTNCRDs7QUE2QkEsSUFBSXhRLHFCQUFxQixFQUFFN1gsT0FBTyxFQUFULEVBQXpCOztBQUVBO0FBQ0E7QUFDQTZYLG1CQUFtQjdYLEtBQW5CLENBQXlCckMsR0FBekIsR0FBK0IsWUFBWTtBQUN6QyxTQUFPLEtBQUtzcUIsaUJBQVo7QUFDRCxDQUZEOztBQUlBOXFCLE9BQU9NLGdCQUFQLENBQXlCaXFCLE1BQU1sc0IsU0FBL0IsRUFBMENxYyxrQkFBMUM7O0FBRUEsSUFBSXlRLG1CQUFtQixZQUFZO0FBQ2pDLE1BQUlDLE9BQU8sSUFBSWIsS0FBSixFQUFYO0FBQ0FhLE9BQUtaLElBQUwsR0FBWSxFQUFaO0FBQ0FZLE9BQUtKLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxTQUFPSSxJQUFQO0FBQ0QsQ0FMRDs7QUFPQSxTQUFTQyxlQUFULENBQTBCcm1CLEdBQTFCLEVBQStCO0FBQzdCLFNBQU8sSUFBSXVsQixLQUFKLENBQVV0bkIsU0FBVixFQUFxQkEsU0FBckIsRUFBZ0NBLFNBQWhDLEVBQTJDM0IsT0FBTzBELEdBQVAsQ0FBM0MsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3NtQixVQUFULENBQXFCM29CLEtBQXJCLEVBQTRCO0FBQzFCLE1BQUk0b0IsU0FBUyxJQUFJaEIsS0FBSixDQUNYNW5CLE1BQU0rRSxHQURLLEVBRVgvRSxNQUFNZixJQUZLLEVBR1hlLE1BQU1qQixRQUhLLEVBSVhpQixNQUFNNm5CLElBSkssRUFLWDduQixNQUFNOG5CLEdBTEssRUFNWDluQixNQUFNK25CLE9BTkssRUFPWC9uQixNQUFNZ29CLGdCQVBLLENBQWI7QUFTQVksU0FBT1gsRUFBUCxHQUFZam9CLE1BQU1pb0IsRUFBbEI7QUFDQVcsU0FBT3ZpQixRQUFQLEdBQWtCckcsTUFBTXFHLFFBQXhCO0FBQ0F1aUIsU0FBTy9tQixHQUFQLEdBQWE3QixNQUFNNkIsR0FBbkI7QUFDQSttQixTQUFPTixRQUFQLEdBQWtCLElBQWxCO0FBQ0EsU0FBT00sTUFBUDtBQUNEOztBQUVELFNBQVNDLFdBQVQsQ0FBc0JDLE1BQXRCLEVBQThCO0FBQzVCLE1BQUk5dEIsTUFBTTh0QixPQUFPbHVCLE1BQWpCO0FBQ0EsTUFBSWtILE1BQU0sSUFBSTFHLEtBQUosQ0FBVUosR0FBVixDQUFWO0FBQ0EsT0FBSyxJQUFJTSxJQUFJLENBQWIsRUFBZ0JBLElBQUlOLEdBQXBCLEVBQXlCTSxHQUF6QixFQUE4QjtBQUM1QndHLFFBQUl4RyxDQUFKLElBQVNxdEIsV0FBV0csT0FBT3h0QixDQUFQLENBQVgsQ0FBVDtBQUNEO0FBQ0QsU0FBT3dHLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJaW5CLGlCQUFpQnZQLE9BQU8sVUFBVTdjLElBQVYsRUFBZ0I7QUFDMUMsTUFBSXFzQixVQUFVcnNCLEtBQUsyTCxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFqQyxDQUQwQyxDQUNKO0FBQ3RDM0wsU0FBT3FzQixVQUFVcnNCLEtBQUtrRyxLQUFMLENBQVcsQ0FBWCxDQUFWLEdBQTBCbEcsSUFBakM7QUFDQSxNQUFJMk8sVUFBVTNPLEtBQUsyTCxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFqQztBQUNBM0wsU0FBTzJPLFVBQVUzTyxLQUFLa0csS0FBTCxDQUFXLENBQVgsQ0FBVixHQUEwQmxHLElBQWpDO0FBQ0EsU0FBTztBQUNMQSxVQUFNQSxJQUREO0FBRUxOLFVBQU0yc0IsT0FGRDtBQUdMMWQsYUFBU0E7QUFISixHQUFQO0FBS0QsQ0FWb0IsQ0FBckI7O0FBWUEsU0FBUzJkLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzdCLFdBQVNDLE9BQVQsR0FBb0I7QUFDbEIsUUFBSS9ILGNBQWMvbEIsU0FBbEI7O0FBRUEsUUFBSTZ0QixNQUFNQyxRQUFRRCxHQUFsQjtBQUNBLFFBQUk5dEIsTUFBTW1ILE9BQU4sQ0FBYzJtQixHQUFkLENBQUosRUFBd0I7QUFDdEIsV0FBSyxJQUFJNXRCLElBQUksQ0FBYixFQUFnQkEsSUFBSTR0QixJQUFJdHVCLE1BQXhCLEVBQWdDVSxHQUFoQyxFQUFxQztBQUNuQzR0QixZQUFJNXRCLENBQUosRUFBT0ssS0FBUCxDQUFhLElBQWIsRUFBbUJ5bEIsV0FBbkI7QUFDRDtBQUNGLEtBSkQsTUFJTztBQUNMO0FBQ0EsYUFBTzhILElBQUl2dEIsS0FBSixDQUFVLElBQVYsRUFBZ0JOLFNBQWhCLENBQVA7QUFDRDtBQUNGO0FBQ0Q4dEIsVUFBUUQsR0FBUixHQUFjQSxHQUFkO0FBQ0EsU0FBT0MsT0FBUDtBQUNEOztBQUVELFNBQVNDLGVBQVQsQ0FDRWp0QixFQURGLEVBRUVrdEIsS0FGRixFQUdFcEssR0FIRixFQUlFcUssU0FKRixFQUtFN0osRUFMRixFQU1FO0FBQ0EsTUFBSTlpQixJQUFKLEVBQVU0c0IsR0FBVixFQUFlQyxHQUFmLEVBQW9CcGtCLEtBQXBCO0FBQ0EsT0FBS3pJLElBQUwsSUFBYVIsRUFBYixFQUFpQjtBQUNmb3RCLFVBQU1wdEIsR0FBR1EsSUFBSCxDQUFOO0FBQ0E2c0IsVUFBTUgsTUFBTTFzQixJQUFOLENBQU47QUFDQXlJLFlBQVEyakIsZUFBZXBzQixJQUFmLENBQVI7QUFDQSxRQUFJLENBQUM0c0IsR0FBTCxFQUFVO0FBQ1Jod0IsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QyxpQ0FBa0MrRyxNQUFNekksSUFBeEMsR0FBZ0QsVUFBaEQsR0FBNkRnQyxPQUFPNHFCLEdBQVAsQ0FEdEIsRUFFdkM5SixFQUZ1QyxDQUF6QztBQUlELEtBTEQsTUFLTyxJQUFJLENBQUMrSixHQUFMLEVBQVU7QUFDZixVQUFJLENBQUNELElBQUlMLEdBQVQsRUFBYztBQUNaSyxjQUFNcHRCLEdBQUdRLElBQUgsSUFBV3NzQixnQkFBZ0JNLEdBQWhCLENBQWpCO0FBQ0Q7QUFDRHRLLFVBQUk3WixNQUFNekksSUFBVixFQUFnQjRzQixHQUFoQixFQUFxQm5rQixNQUFNL0ksSUFBM0IsRUFBaUMrSSxNQUFNa0csT0FBdkM7QUFDRCxLQUxNLE1BS0EsSUFBSWllLFFBQVFDLEdBQVosRUFBaUI7QUFDdEJBLFVBQUlOLEdBQUosR0FBVUssR0FBVjtBQUNBcHRCLFNBQUdRLElBQUgsSUFBVzZzQixHQUFYO0FBQ0Q7QUFDRjtBQUNELE9BQUs3c0IsSUFBTCxJQUFhMHNCLEtBQWIsRUFBb0I7QUFDbEIsUUFBSSxDQUFDbHRCLEdBQUdRLElBQUgsQ0FBTCxFQUFlO0FBQ2J5SSxjQUFRMmpCLGVBQWVwc0IsSUFBZixDQUFSO0FBQ0Eyc0IsZ0JBQVVsa0IsTUFBTXpJLElBQWhCLEVBQXNCMHNCLE1BQU0xc0IsSUFBTixDQUF0QixFQUFtQ3lJLE1BQU1rRyxPQUF6QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxTQUFTbWUsY0FBVCxDQUF5Qm5VLEdBQXpCLEVBQThCb1UsT0FBOUIsRUFBdUM1cEIsSUFBdkMsRUFBNkM7QUFDM0MsTUFBSXFwQixPQUFKO0FBQ0EsTUFBSVEsVUFBVXJVLElBQUlvVSxPQUFKLENBQWQ7O0FBRUEsV0FBU0UsV0FBVCxHQUF3QjtBQUN0QjlwQixTQUFLbkUsS0FBTCxDQUFXLElBQVgsRUFBaUJOLFNBQWpCO0FBQ0E7QUFDQTtBQUNBOGQsV0FBT2dRLFFBQVFELEdBQWYsRUFBb0JVLFdBQXBCO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDRCxPQUFMLEVBQWM7QUFDWjtBQUNBUixjQUFVRixnQkFBZ0IsQ0FBQ1csV0FBRCxDQUFoQixDQUFWO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQSxRQUFJRCxRQUFRVCxHQUFSLElBQWVTLFFBQVFFLE1BQTNCLEVBQW1DO0FBQ2pDO0FBQ0FWLGdCQUFVUSxPQUFWO0FBQ0FSLGNBQVFELEdBQVIsQ0FBWTN0QixJQUFaLENBQWlCcXVCLFdBQWpCO0FBQ0QsS0FKRCxNQUlPO0FBQ0w7QUFDQVQsZ0JBQVVGLGdCQUFnQixDQUFDVSxPQUFELEVBQVVDLFdBQVYsQ0FBaEIsQ0FBVjtBQUNEO0FBQ0Y7O0FBRURULFVBQVFVLE1BQVIsR0FBaUIsSUFBakI7QUFDQXZVLE1BQUlvVSxPQUFKLElBQWVQLE9BQWY7QUFDRDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNXLHVCQUFULENBQWtDL3FCLFFBQWxDLEVBQTRDO0FBQzFDLE9BQUssSUFBSXpELElBQUksQ0FBYixFQUFnQkEsSUFBSXlELFNBQVNuRSxNQUE3QixFQUFxQ1UsR0FBckMsRUFBMEM7QUFDeEMsUUFBSUYsTUFBTW1ILE9BQU4sQ0FBY3hELFNBQVN6RCxDQUFULENBQWQsQ0FBSixFQUFnQztBQUM5QixhQUFPRixNQUFNTSxTQUFOLENBQWdCYixNQUFoQixDQUF1QmMsS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUNvRCxRQUFqQyxDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU9BLFFBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNnckIsaUJBQVQsQ0FBNEJockIsUUFBNUIsRUFBc0M7QUFDcEMsU0FBT3dhLFlBQVl4YSxRQUFaLElBQ0gsQ0FBQzJwQixnQkFBZ0IzcEIsUUFBaEIsQ0FBRCxDQURHLEdBRUgzRCxNQUFNbUgsT0FBTixDQUFjeEQsUUFBZCxJQUNFaXJCLHVCQUF1QmpyQixRQUF2QixDQURGLEdBRUV1QixTQUpOO0FBS0Q7O0FBRUQsU0FBUzBwQixzQkFBVCxDQUFpQ2pyQixRQUFqQyxFQUEyQ2tyQixXQUEzQyxFQUF3RDtBQUN0RCxNQUFJbm9CLE1BQU0sRUFBVjtBQUNBLE1BQUl4RyxDQUFKLEVBQU91RixDQUFQLEVBQVVxcEIsSUFBVjtBQUNBLE9BQUs1dUIsSUFBSSxDQUFULEVBQVlBLElBQUl5RCxTQUFTbkUsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDdUYsUUFBSTlCLFNBQVN6RCxDQUFULENBQUo7QUFDQSxRQUFJdUYsS0FBSyxJQUFMLElBQWEsT0FBT0EsQ0FBUCxLQUFhLFNBQTlCLEVBQXlDO0FBQUU7QUFBVTtBQUNyRHFwQixXQUFPcG9CLElBQUlBLElBQUlsSCxNQUFKLEdBQWEsQ0FBakIsQ0FBUDtBQUNBO0FBQ0EsUUFBSVEsTUFBTW1ILE9BQU4sQ0FBYzFCLENBQWQsQ0FBSixFQUFzQjtBQUNwQmlCLFVBQUl2RyxJQUFKLENBQVNJLEtBQVQsQ0FBZW1HLEdBQWYsRUFBb0Jrb0IsdUJBQXVCbnBCLENBQXZCLEVBQTJCLENBQUNvcEIsZUFBZSxFQUFoQixJQUFzQixHQUF0QixHQUE0QjN1QixDQUF2RCxDQUFwQjtBQUNELEtBRkQsTUFFTyxJQUFJaWUsWUFBWTFZLENBQVosQ0FBSixFQUFvQjtBQUN6QixVQUFJcXBCLFFBQVFBLEtBQUtyQyxJQUFqQixFQUF1QjtBQUNyQnFDLGFBQUtyQyxJQUFMLElBQWFscEIsT0FBT2tDLENBQVAsQ0FBYjtBQUNELE9BRkQsTUFFTyxJQUFJQSxNQUFNLEVBQVYsRUFBYztBQUNuQjtBQUNBaUIsWUFBSXZHLElBQUosQ0FBU210QixnQkFBZ0I3bkIsQ0FBaEIsQ0FBVDtBQUNEO0FBQ0YsS0FQTSxNQU9BO0FBQ0wsVUFBSUEsRUFBRWduQixJQUFGLElBQVVxQyxJQUFWLElBQWtCQSxLQUFLckMsSUFBM0IsRUFBaUM7QUFDL0IvbEIsWUFBSUEsSUFBSWxILE1BQUosR0FBYSxDQUFqQixJQUFzQjh0QixnQkFBZ0J3QixLQUFLckMsSUFBTCxHQUFZaG5CLEVBQUVnbkIsSUFBOUIsQ0FBdEI7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBLFlBQUlobkIsRUFBRWtFLEdBQUYsSUFBU2xFLEVBQUVnQixHQUFGLElBQVMsSUFBbEIsSUFBMEJvb0IsZUFBZSxJQUE3QyxFQUFtRDtBQUNqRHBwQixZQUFFZ0IsR0FBRixHQUFRLFlBQVlvb0IsV0FBWixHQUEwQixHQUExQixHQUFnQzN1QixDQUFoQyxHQUFvQyxJQUE1QztBQUNEO0FBQ0R3RyxZQUFJdkcsSUFBSixDQUFTc0YsQ0FBVDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9pQixHQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU3FvQixzQkFBVCxDQUFpQ3ByQixRQUFqQyxFQUEyQztBQUN6QyxTQUFPQSxZQUFZQSxTQUFTZ0UsTUFBVCxDQUFnQixVQUFVbEMsQ0FBVixFQUFhO0FBQUUsV0FBT0EsS0FBS0EsRUFBRW1uQixnQkFBZDtBQUFpQyxHQUFoRSxFQUFrRSxDQUFsRSxDQUFuQjtBQUNEOztBQUVEOztBQUVBLFNBQVNvQyxVQUFULENBQXFCM0ssRUFBckIsRUFBeUI7QUFDdkJBLEtBQUc0SyxPQUFILEdBQWFodEIsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQWI7QUFDQXFXLEtBQUc2SyxhQUFILEdBQW1CLEtBQW5CO0FBQ0E7QUFDQSxNQUFJQyxZQUFZOUssR0FBR2hZLFFBQUgsQ0FBWStpQixnQkFBNUI7QUFDQSxNQUFJRCxTQUFKLEVBQWU7QUFDYkUsNkJBQXlCaEwsRUFBekIsRUFBNkI4SyxTQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsSUFBSWhtQixNQUFKOztBQUVBLFNBQVMwYSxHQUFULENBQWM3WixLQUFkLEVBQXFCeU4sRUFBckIsRUFBeUJtVyxPQUF6QixFQUFrQztBQUNoQyxNQUFJQSxPQUFKLEVBQWE7QUFDWHprQixXQUFPbW1CLEtBQVAsQ0FBYXRsQixLQUFiLEVBQW9CeU4sRUFBcEI7QUFDRCxHQUZELE1BRU87QUFDTHRPLFdBQU9vbUIsR0FBUCxDQUFXdmxCLEtBQVgsRUFBa0J5TixFQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUytYLFFBQVQsQ0FBbUJ4bEIsS0FBbkIsRUFBMEJ5TixFQUExQixFQUE4QjtBQUM1QnRPLFNBQU9zbUIsSUFBUCxDQUFZemxCLEtBQVosRUFBbUJ5TixFQUFuQjtBQUNEOztBQUVELFNBQVM0WCx3QkFBVCxDQUNFaEwsRUFERixFQUVFOEssU0FGRixFQUdFTyxZQUhGLEVBSUU7QUFDQXZtQixXQUFTa2IsRUFBVDtBQUNBMkosa0JBQWdCbUIsU0FBaEIsRUFBMkJPLGdCQUFnQixFQUEzQyxFQUErQzdMLEdBQS9DLEVBQW9EMkwsUUFBcEQsRUFBOERuTCxFQUE5RDtBQUNEOztBQUVELFNBQVNzTCxXQUFULENBQXNCcnRCLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUlzdEIsU0FBUyxRQUFiO0FBQ0F0dEIsTUFBSWhDLFNBQUosQ0FBY2l2QixHQUFkLEdBQW9CLFVBQVV2bEIsS0FBVixFQUFpQnlOLEVBQWpCLEVBQXFCO0FBQ3ZDLFFBQUl4TixTQUFTLElBQWI7O0FBRUEsUUFBSW9hLEtBQUssSUFBVDtBQUNBLFFBQUlya0IsTUFBTW1ILE9BQU4sQ0FBYzZDLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixXQUFLLElBQUk5SixJQUFJLENBQVIsRUFBVzJlLElBQUk3VSxNQUFNeEssTUFBMUIsRUFBa0NVLElBQUkyZSxDQUF0QyxFQUF5QzNlLEdBQXpDLEVBQThDO0FBQzVDK0osZUFBT3NsQixHQUFQLENBQVd2bEIsTUFBTTlKLENBQU4sQ0FBWCxFQUFxQnVYLEVBQXJCO0FBQ0Q7QUFDRixLQUpELE1BSU87QUFDTCxPQUFDNE0sR0FBRzRLLE9BQUgsQ0FBV2psQixLQUFYLE1BQXNCcWEsR0FBRzRLLE9BQUgsQ0FBV2psQixLQUFYLElBQW9CLEVBQTFDLENBQUQsRUFBZ0Q3SixJQUFoRCxDQUFxRHNYLEVBQXJEO0FBQ0E7QUFDQTtBQUNBLFVBQUltWSxPQUFPL2pCLElBQVAsQ0FBWTdCLEtBQVosQ0FBSixFQUF3QjtBQUN0QnFhLFdBQUc2SyxhQUFILEdBQW1CLElBQW5CO0FBQ0Q7QUFDRjtBQUNELFdBQU83SyxFQUFQO0FBQ0QsR0FqQkQ7O0FBbUJBL2hCLE1BQUloQyxTQUFKLENBQWNndkIsS0FBZCxHQUFzQixVQUFVdGxCLEtBQVYsRUFBaUJ5TixFQUFqQixFQUFxQjtBQUN6QyxRQUFJNE0sS0FBSyxJQUFUO0FBQ0EsYUFBU3RqQixFQUFULEdBQWU7QUFDYnNqQixTQUFHb0wsSUFBSCxDQUFRemxCLEtBQVIsRUFBZWpKLEVBQWY7QUFDQTBXLFNBQUdsWCxLQUFILENBQVM4akIsRUFBVCxFQUFhcGtCLFNBQWI7QUFDRDtBQUNEYyxPQUFHMFcsRUFBSCxHQUFRQSxFQUFSO0FBQ0E0TSxPQUFHa0wsR0FBSCxDQUFPdmxCLEtBQVAsRUFBY2pKLEVBQWQ7QUFDQSxXQUFPc2pCLEVBQVA7QUFDRCxHQVREOztBQVdBL2hCLE1BQUloQyxTQUFKLENBQWNtdkIsSUFBZCxHQUFxQixVQUFVemxCLEtBQVYsRUFBaUJ5TixFQUFqQixFQUFxQjtBQUN4QyxRQUFJeE4sU0FBUyxJQUFiOztBQUVBLFFBQUlvYSxLQUFLLElBQVQ7QUFDQTtBQUNBLFFBQUksQ0FBQ3BrQixVQUFVVCxNQUFmLEVBQXVCO0FBQ3JCNmtCLFNBQUc0SyxPQUFILEdBQWFodEIsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQWI7QUFDQSxhQUFPcVcsRUFBUDtBQUNEO0FBQ0Q7QUFDQSxRQUFJcmtCLE1BQU1tSCxPQUFOLENBQWM2QyxLQUFkLENBQUosRUFBMEI7QUFDeEIsV0FBSyxJQUFJNmxCLE1BQU0sQ0FBVixFQUFhaFIsSUFBSTdVLE1BQU14SyxNQUE1QixFQUFvQ3F3QixNQUFNaFIsQ0FBMUMsRUFBNkNnUixLQUE3QyxFQUFvRDtBQUNsRDVsQixlQUFPd2xCLElBQVAsQ0FBWXpsQixNQUFNNmxCLEdBQU4sQ0FBWixFQUF3QnBZLEVBQXhCO0FBQ0Q7QUFDRCxhQUFPNE0sRUFBUDtBQUNEO0FBQ0Q7QUFDQSxRQUFJNUosTUFBTTRKLEdBQUc0SyxPQUFILENBQVdqbEIsS0FBWCxDQUFWO0FBQ0EsUUFBSSxDQUFDeVEsR0FBTCxFQUFVO0FBQ1IsYUFBTzRKLEVBQVA7QUFDRDtBQUNELFFBQUlwa0IsVUFBVVQsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQjZrQixTQUFHNEssT0FBSCxDQUFXamxCLEtBQVgsSUFBb0IsSUFBcEI7QUFDQSxhQUFPcWEsRUFBUDtBQUNEO0FBQ0Q7QUFDQSxRQUFJM00sRUFBSjtBQUNBLFFBQUl4WCxJQUFJdWEsSUFBSWpiLE1BQVo7QUFDQSxXQUFPVSxHQUFQLEVBQVk7QUFDVndYLFdBQUsrQyxJQUFJdmEsQ0FBSixDQUFMO0FBQ0EsVUFBSXdYLE9BQU9ELEVBQVAsSUFBYUMsR0FBR0QsRUFBSCxLQUFVQSxFQUEzQixFQUErQjtBQUM3QmdELFlBQUl3RCxNQUFKLENBQVcvZCxDQUFYLEVBQWMsQ0FBZDtBQUNBO0FBQ0Q7QUFDRjtBQUNELFdBQU9ta0IsRUFBUDtBQUNELEdBcENEOztBQXNDQS9oQixNQUFJaEMsU0FBSixDQUFjd3ZCLEtBQWQsR0FBc0IsVUFBVTlsQixLQUFWLEVBQWlCO0FBQ3JDLFFBQUlxYSxLQUFLLElBQVQ7QUFDQSxRQUFJbG1CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUl1cEIsaUJBQWlCL2xCLE1BQU02VCxXQUFOLEVBQXJCO0FBQ0EsVUFBSWtTLG1CQUFtQi9sQixLQUFuQixJQUE0QnFhLEdBQUc0SyxPQUFILENBQVdjLGNBQVgsQ0FBaEMsRUFBNEQ7QUFDMURoTSxZQUNFLGFBQWFnTSxjQUFiLEdBQThCLDZCQUE5QixHQUNDL0wsb0JBQW9CSyxFQUFwQixDQURELEdBQzRCLHVDQUQ1QixHQUNzRXJhLEtBRHRFLEdBQzhFLE1BRDlFLEdBRUEsb0VBRkEsR0FHQSxrRUFIQSxHQUlBLDRCQUpBLEdBSWdDMFUsVUFBVTFVLEtBQVYsQ0FKaEMsR0FJb0Qsa0JBSnBELEdBSXlFQSxLQUp6RSxHQUlpRixLQUxuRjtBQU9EO0FBQ0Y7QUFDRCxRQUFJeVEsTUFBTTRKLEdBQUc0SyxPQUFILENBQVdqbEIsS0FBWCxDQUFWO0FBQ0EsUUFBSXlRLEdBQUosRUFBUztBQUNQQSxZQUFNQSxJQUFJamIsTUFBSixHQUFhLENBQWIsR0FBaUJ1ZixRQUFRdEUsR0FBUixDQUFqQixHQUFnQ0EsR0FBdEM7QUFDQSxVQUFJMWEsT0FBT2dmLFFBQVE5ZSxTQUFSLEVBQW1CLENBQW5CLENBQVg7QUFDQSxXQUFLLElBQUlDLElBQUksQ0FBUixFQUFXMmUsSUFBSXBFLElBQUlqYixNQUF4QixFQUFnQ1UsSUFBSTJlLENBQXBDLEVBQXVDM2UsR0FBdkMsRUFBNEM7QUFDMUN1YSxZQUFJdmEsQ0FBSixFQUFPSyxLQUFQLENBQWE4akIsRUFBYixFQUFpQnRrQixJQUFqQjtBQUNEO0FBQ0Y7QUFDRCxXQUFPc2tCLEVBQVA7QUFDRCxHQXZCRDtBQXdCRDs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBUzJMLFlBQVQsQ0FDRXJzQixRQURGLEVBRUVncEIsT0FGRixFQUdFO0FBQ0EsTUFBSXNELFFBQVEsRUFBWjtBQUNBLE1BQUksQ0FBQ3RzQixRQUFMLEVBQWU7QUFDYixXQUFPc3NCLEtBQVA7QUFDRDtBQUNELE1BQUlDLGNBQWMsRUFBbEI7QUFDQSxNQUFJM3VCLElBQUosRUFBVXVELEtBQVY7QUFDQSxPQUFLLElBQUk1RSxJQUFJLENBQVIsRUFBVzJlLElBQUlsYixTQUFTbkUsTUFBN0IsRUFBcUNVLElBQUkyZSxDQUF6QyxFQUE0QzNlLEdBQTVDLEVBQWlEO0FBQy9DNEUsWUFBUW5CLFNBQVN6RCxDQUFULENBQVI7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDNEUsTUFBTTZuQixPQUFOLEtBQWtCQSxPQUFsQixJQUE2QjduQixNQUFNZ29CLGlCQUFOLEtBQTRCSCxPQUExRCxLQUNBN25CLE1BQU1qQixJQUROLEtBQ2V0QyxPQUFPdUQsTUFBTWpCLElBQU4sQ0FBV3NzQixJQURqQyxDQUFKLEVBQzRDO0FBQzFDLFVBQUlBLE9BQVFGLE1BQU0xdUIsSUFBTixNQUFnQjB1QixNQUFNMXVCLElBQU4sSUFBYyxFQUE5QixDQUFaO0FBQ0EsVUFBSXVELE1BQU02RSxHQUFOLEtBQWMsVUFBbEIsRUFBOEI7QUFDNUJ3bUIsYUFBS2h3QixJQUFMLENBQVVJLEtBQVYsQ0FBZ0I0dkIsSUFBaEIsRUFBc0JyckIsTUFBTW5CLFFBQTVCO0FBQ0QsT0FGRCxNQUVPO0FBQ0x3c0IsYUFBS2h3QixJQUFMLENBQVUyRSxLQUFWO0FBQ0Q7QUFDRixLQVJELE1BUU87QUFDTG9yQixrQkFBWS92QixJQUFaLENBQWlCMkUsS0FBakI7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxNQUFJLENBQUNvckIsWUFBWWxuQixLQUFaLENBQWtCb25CLFlBQWxCLENBQUwsRUFBc0M7QUFDcENILFVBQU03dEIsT0FBTixHQUFnQjh0QixXQUFoQjtBQUNEO0FBQ0QsU0FBT0QsS0FBUDtBQUNEOztBQUVELFNBQVNHLFlBQVQsQ0FBdUIvQyxJQUF2QixFQUE2QjtBQUMzQixTQUFPQSxLQUFLSixTQUFMLElBQWtCSSxLQUFLWixJQUFMLEtBQWMsR0FBdkM7QUFDRDs7QUFFRCxTQUFTNEQsa0JBQVQsQ0FDRXZDLEdBREYsRUFFRTtBQUNBLE1BQUlwbkIsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJeEcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHRCLElBQUl0dUIsTUFBeEIsRUFBZ0NVLEdBQWhDLEVBQXFDO0FBQ25Dd0csUUFBSW9uQixJQUFJNXRCLENBQUosRUFBTyxDQUFQLENBQUosSUFBaUI0dEIsSUFBSTV0QixDQUFKLEVBQU8sQ0FBUCxDQUFqQjtBQUNEO0FBQ0QsU0FBT3dHLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJNHBCLGlCQUFpQixJQUFyQjs7QUFFQSxTQUFTQyxhQUFULENBQXdCbE0sRUFBeEIsRUFBNEI7QUFDMUIsTUFBSTlaLFVBQVU4WixHQUFHaFksUUFBakI7O0FBRUE7QUFDQSxNQUFJekksU0FBUzJHLFFBQVEzRyxNQUFyQjtBQUNBLE1BQUlBLFVBQVUsQ0FBQzJHLFFBQVFpbUIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBTzVzQixPQUFPeUksUUFBUCxDQUFnQm1rQixRQUFoQixJQUE0QjVzQixPQUFPVSxPQUExQyxFQUFtRDtBQUNqRFYsZUFBU0EsT0FBT1UsT0FBaEI7QUFDRDtBQUNEVixXQUFPNnNCLFNBQVAsQ0FBaUJ0d0IsSUFBakIsQ0FBc0Jra0IsRUFBdEI7QUFDRDs7QUFFREEsS0FBRy9mLE9BQUgsR0FBYVYsTUFBYjtBQUNBeWdCLEtBQUdyWSxLQUFILEdBQVdwSSxTQUFTQSxPQUFPb0ksS0FBaEIsR0FBd0JxWSxFQUFuQzs7QUFFQUEsS0FBR29NLFNBQUgsR0FBZSxFQUFmO0FBQ0FwTSxLQUFHcU0sS0FBSCxHQUFXLEVBQVg7O0FBRUFyTSxLQUFHc00sUUFBSCxHQUFjLElBQWQ7QUFDQXRNLEtBQUdoZ0IsU0FBSCxHQUFlLElBQWY7QUFDQWdnQixLQUFHdU0sZUFBSCxHQUFxQixLQUFyQjtBQUNBdk0sS0FBR3dNLFVBQUgsR0FBZ0IsS0FBaEI7QUFDQXhNLEtBQUd5TSxZQUFILEdBQWtCLEtBQWxCO0FBQ0F6TSxLQUFHME0saUJBQUgsR0FBdUIsS0FBdkI7QUFDRDs7QUFFRCxTQUFTQyxjQUFULENBQXlCMXVCLEdBQXpCLEVBQThCO0FBQzVCQSxNQUFJaEMsU0FBSixDQUFjMndCLE9BQWQsR0FBd0IsVUFBVXJzQixLQUFWLEVBQWlCc3NCLFNBQWpCLEVBQTRCO0FBQ2xELFFBQUk3TSxLQUFLLElBQVQ7QUFDQSxRQUFJQSxHQUFHd00sVUFBUCxFQUFtQjtBQUNqQk0sZUFBUzlNLEVBQVQsRUFBYSxjQUFiO0FBQ0Q7QUFDRCxRQUFJK00sU0FBUy9NLEdBQUdnTixHQUFoQjtBQUNBLFFBQUlDLFlBQVlqTixHQUFHa04sTUFBbkI7QUFDQSxRQUFJQyxxQkFBcUJsQixjQUF6QjtBQUNBQSxxQkFBaUJqTSxFQUFqQjtBQUNBQSxPQUFHa04sTUFBSCxHQUFZM3NCLEtBQVo7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDMHNCLFNBQUwsRUFBZ0I7QUFDZDtBQUNBak4sU0FBR2dOLEdBQUgsR0FBU2hOLEdBQUdvTixTQUFILENBQ1BwTixHQUFHZ04sR0FESSxFQUNDenNCLEtBREQsRUFDUXNzQixTQURSLEVBQ21CLEtBRG5CLENBQ3lCO0FBRHpCLFFBRVA3TSxHQUFHaFksUUFBSCxDQUFZcWxCLFVBRkwsRUFHUHJOLEdBQUdoWSxRQUFILENBQVlzbEIsT0FITCxDQUFUO0FBS0QsS0FQRCxNQU9PO0FBQ0w7QUFDQXROLFNBQUdnTixHQUFILEdBQVNoTixHQUFHb04sU0FBSCxDQUFhSCxTQUFiLEVBQXdCMXNCLEtBQXhCLENBQVQ7QUFDRDtBQUNEMHJCLHFCQUFpQmtCLGtCQUFqQjtBQUNBO0FBQ0EsUUFBSUosTUFBSixFQUFZO0FBQ1ZBLGFBQU9RLE9BQVAsR0FBaUIsSUFBakI7QUFDRDtBQUNELFFBQUl2TixHQUFHZ04sR0FBUCxFQUFZO0FBQ1ZoTixTQUFHZ04sR0FBSCxDQUFPTyxPQUFQLEdBQWlCdk4sRUFBakI7QUFDRDtBQUNEO0FBQ0EsUUFBSUEsR0FBR2pnQixNQUFILElBQWFpZ0IsR0FBRy9mLE9BQWhCLElBQTJCK2YsR0FBR2pnQixNQUFILEtBQWNpZ0IsR0FBRy9mLE9BQUgsQ0FBV2l0QixNQUF4RCxFQUFnRTtBQUM5RGxOLFNBQUcvZixPQUFILENBQVcrc0IsR0FBWCxHQUFpQmhOLEdBQUdnTixHQUFwQjtBQUNEO0FBQ0Q7QUFDQTtBQUNELEdBckNEOztBQXVDQS91QixNQUFJaEMsU0FBSixDQUFjdXhCLFlBQWQsR0FBNkIsWUFBWTtBQUN2QyxRQUFJeE4sS0FBSyxJQUFUO0FBQ0EsUUFBSUEsR0FBR3NNLFFBQVAsRUFBaUI7QUFDZnRNLFNBQUdzTSxRQUFILENBQVlyTCxNQUFaO0FBQ0Q7QUFDRixHQUxEOztBQU9BaGpCLE1BQUloQyxTQUFKLENBQWN3eEIsUUFBZCxHQUF5QixZQUFZO0FBQ25DLFFBQUl6TixLQUFLLElBQVQ7QUFDQSxRQUFJQSxHQUFHME0saUJBQVAsRUFBMEI7QUFDeEI7QUFDRDtBQUNESSxhQUFTOU0sRUFBVCxFQUFhLGVBQWI7QUFDQUEsT0FBRzBNLGlCQUFILEdBQXVCLElBQXZCO0FBQ0E7QUFDQSxRQUFJbnRCLFNBQVN5Z0IsR0FBRy9mLE9BQWhCO0FBQ0EsUUFBSVYsVUFBVSxDQUFDQSxPQUFPbXRCLGlCQUFsQixJQUF1QyxDQUFDMU0sR0FBR2hZLFFBQUgsQ0FBWW1rQixRQUF4RCxFQUFrRTtBQUNoRXpTLGFBQU9uYSxPQUFPNnNCLFNBQWQsRUFBeUJwTSxFQUF6QjtBQUNEO0FBQ0Q7QUFDQSxRQUFJQSxHQUFHc00sUUFBUCxFQUFpQjtBQUNmdE0sU0FBR3NNLFFBQUgsQ0FBWW9CLFFBQVo7QUFDRDtBQUNELFFBQUk3eEIsSUFBSW1rQixHQUFHMk4sU0FBSCxDQUFheHlCLE1BQXJCO0FBQ0EsV0FBT1UsR0FBUCxFQUFZO0FBQ1Zta0IsU0FBRzJOLFNBQUgsQ0FBYTl4QixDQUFiLEVBQWdCNnhCLFFBQWhCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsUUFBSTFOLEdBQUc0TixLQUFILENBQVMvTCxNQUFiLEVBQXFCO0FBQ25CN0IsU0FBRzROLEtBQUgsQ0FBUy9MLE1BQVQsQ0FBZ0JVLE9BQWhCO0FBQ0Q7QUFDRDtBQUNBdkMsT0FBR3lNLFlBQUgsR0FBa0IsSUFBbEI7QUFDQUssYUFBUzlNLEVBQVQsRUFBYSxXQUFiO0FBQ0E7QUFDQUEsT0FBR29MLElBQUg7QUFDQTtBQUNBLFFBQUlwTCxHQUFHZ04sR0FBUCxFQUFZO0FBQ1ZoTixTQUFHZ04sR0FBSCxDQUFPTyxPQUFQLEdBQWlCLElBQWpCO0FBQ0Q7QUFDRDtBQUNBdk4sT0FBR29OLFNBQUgsQ0FBYXBOLEdBQUdrTixNQUFoQixFQUF3QixJQUF4QjtBQUNELEdBcENEO0FBcUNEOztBQUVELFNBQVNXLGNBQVQsQ0FDRTdOLEVBREYsRUFFRS9PLEVBRkYsRUFHRTRiLFNBSEYsRUFJRTtBQUNBN00sS0FBR2dOLEdBQUgsR0FBUy9iLEVBQVQ7QUFDQSxNQUFJLENBQUMrTyxHQUFHaFksUUFBSCxDQUFZN0ksTUFBakIsRUFBeUI7QUFDdkI2Z0IsT0FBR2hZLFFBQUgsQ0FBWTdJLE1BQVosR0FBcUI0cEIsZ0JBQXJCO0FBQ0EsUUFBSWp2QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBLFVBQUs2ZCxHQUFHaFksUUFBSCxDQUFZeEosUUFBWixJQUF3QndoQixHQUFHaFksUUFBSCxDQUFZeEosUUFBWixDQUFxQnFLLE1BQXJCLENBQTRCLENBQTVCLE1BQW1DLEdBQTVELElBQ0ZtWCxHQUFHaFksUUFBSCxDQUFZaUosRUFEVixJQUNnQkEsRUFEcEIsRUFDd0I7QUFDdEJyUyxhQUNFLG9FQUNBLG1FQURBLEdBRUEsdURBSEYsRUFJRW9oQixFQUpGO0FBTUQsT0FSRCxNQVFPO0FBQ0xwaEIsYUFDRSxxRUFERixFQUVFb2hCLEVBRkY7QUFJRDtBQUNGO0FBQ0Y7QUFDRDhNLFdBQVM5TSxFQUFULEVBQWEsYUFBYjs7QUFFQSxNQUFJOE4sZUFBSjtBQUNBO0FBQ0EsTUFBSWgwQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BCLE9BQU8yUixXQUFoRCxJQUErRGtWLElBQW5FLEVBQXlFO0FBQ3ZFa0csc0JBQWtCLFlBQVk7QUFDNUIsVUFBSTV3QixPQUFPOGlCLEdBQUcrTixLQUFkO0FBQ0EsVUFBSXROLEtBQUtULEdBQUdnTyxJQUFaO0FBQ0EsVUFBSS9GLFdBQVcsb0JBQW9CeEgsRUFBbkM7QUFDQSxVQUFJeUgsU0FBUyxrQkFBa0J6SCxFQUEvQjs7QUFFQW1ILFdBQUtLLFFBQUw7QUFDQSxVQUFJMW5CLFFBQVF5ZixHQUFHaU8sT0FBSCxFQUFaO0FBQ0FyRyxXQUFLTSxNQUFMO0FBQ0FMLGNBQVMzcUIsT0FBTyxTQUFoQixFQUE0QitxQixRQUE1QixFQUFzQ0MsTUFBdEM7O0FBRUFOLFdBQUtLLFFBQUw7QUFDQWpJLFNBQUc0TSxPQUFILENBQVdyc0IsS0FBWCxFQUFrQnNzQixTQUFsQjtBQUNBakYsV0FBS00sTUFBTDtBQUNBTCxjQUFTM3FCLE9BQU8sUUFBaEIsRUFBMkIrcUIsUUFBM0IsRUFBcUNDLE1BQXJDO0FBQ0QsS0FmRDtBQWdCRCxHQWpCRCxNQWlCTztBQUNMNEYsc0JBQWtCLFlBQVk7QUFDNUI5TixTQUFHNE0sT0FBSCxDQUFXNU0sR0FBR2lPLE9BQUgsRUFBWCxFQUF5QnBCLFNBQXpCO0FBQ0QsS0FGRDtBQUdEOztBQUVEN00sS0FBR3NNLFFBQUgsR0FBYyxJQUFJNEIsT0FBSixDQUFZbE8sRUFBWixFQUFnQjhOLGVBQWhCLEVBQWlDcnhCLElBQWpDLENBQWQ7QUFDQW93QixjQUFZLEtBQVo7O0FBRUE7QUFDQTtBQUNBLE1BQUk3TSxHQUFHamdCLE1BQUgsSUFBYSxJQUFqQixFQUF1QjtBQUNyQmlnQixPQUFHd00sVUFBSCxHQUFnQixJQUFoQjtBQUNBTSxhQUFTOU0sRUFBVCxFQUFhLFNBQWI7QUFDRDtBQUNELFNBQU9BLEVBQVA7QUFDRDs7QUFFRCxTQUFTbU8sb0JBQVQsQ0FDRW5PLEVBREYsRUFFRTRELFNBRkYsRUFHRWtILFNBSEYsRUFJRXNELFdBSkYsRUFLRUMsY0FMRixFQU1FO0FBQ0E7QUFDQTtBQUNBLE1BQUlDLGNBQWMsQ0FBQyxFQUNqQkQsa0JBQWdDO0FBQ2hDck8sS0FBR2hZLFFBQUgsQ0FBWXVtQixlQURaLElBQ2dDO0FBQ2hDSCxjQUFZNXVCLElBQVosQ0FBaUJndkIsV0FGakIsSUFFZ0M7QUFDaEN4TyxLQUFHeU8sWUFBSCxLQUFvQmhTLFdBSkgsQ0FJZTtBQUpmLEdBQW5COztBQU9BdUQsS0FBR2hZLFFBQUgsQ0FBWTBtQixZQUFaLEdBQTJCTixXQUEzQjtBQUNBcE8sS0FBR2pnQixNQUFILEdBQVlxdUIsV0FBWixDQVhBLENBV3lCO0FBQ3pCLE1BQUlwTyxHQUFHa04sTUFBUCxFQUFlO0FBQUU7QUFDZmxOLE9BQUdrTixNQUFILENBQVUzdEIsTUFBVixHQUFtQjZ1QixXQUFuQjtBQUNEO0FBQ0RwTyxLQUFHaFksUUFBSCxDQUFZdW1CLGVBQVosR0FBOEJGLGNBQTlCOztBQUVBO0FBQ0EsTUFBSXpLLGFBQWE1RCxHQUFHaFksUUFBSCxDQUFZaEosS0FBN0IsRUFBb0M7QUFDbENtakIsa0JBQWNDLGFBQWQsR0FBOEIsS0FBOUI7QUFDQSxRQUFJdG9CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZ2dCLG9CQUFjRSxjQUFkLEdBQStCLElBQS9CO0FBQ0Q7QUFDRCxRQUFJcmpCLFFBQVFnaEIsR0FBR3NHLE1BQWY7QUFDQSxRQUFJcUksV0FBVzNPLEdBQUdoWSxRQUFILENBQVk0bUIsU0FBWixJQUF5QixFQUF4QztBQUNBLFNBQUssSUFBSS95QixJQUFJLENBQWIsRUFBZ0JBLElBQUk4eUIsU0FBU3h6QixNQUE3QixFQUFxQ1UsR0FBckMsRUFBMEM7QUFDeEMsVUFBSXVHLE1BQU11c0IsU0FBUzl5QixDQUFULENBQVY7QUFDQW1ELFlBQU1vRCxHQUFOLElBQWEwakIsYUFBYTFqQixHQUFiLEVBQWtCNGQsR0FBR2hZLFFBQUgsQ0FBWWhKLEtBQTlCLEVBQXFDNGtCLFNBQXJDLEVBQWdENUQsRUFBaEQsQ0FBYjtBQUNEO0FBQ0RtQyxrQkFBY0MsYUFBZCxHQUE4QixJQUE5QjtBQUNBLFFBQUl0b0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnZ0Isb0JBQWNFLGNBQWQsR0FBK0IsS0FBL0I7QUFDRDtBQUNEO0FBQ0FyQyxPQUFHaFksUUFBSCxDQUFZNGIsU0FBWixHQUF3QkEsU0FBeEI7QUFDRDtBQUNEO0FBQ0EsTUFBSWtILFNBQUosRUFBZTtBQUNiLFFBQUlPLGVBQWVyTCxHQUFHaFksUUFBSCxDQUFZK2lCLGdCQUEvQjtBQUNBL0ssT0FBR2hZLFFBQUgsQ0FBWStpQixnQkFBWixHQUErQkQsU0FBL0I7QUFDQUUsNkJBQXlCaEwsRUFBekIsRUFBNkI4SyxTQUE3QixFQUF3Q08sWUFBeEM7QUFDRDtBQUNEO0FBQ0EsTUFBSWlELFdBQUosRUFBaUI7QUFDZnRPLE9BQUdyWixNQUFILEdBQVlnbEIsYUFBYTBDLGNBQWIsRUFBNkJELFlBQVk5RixPQUF6QyxDQUFaO0FBQ0F0SSxPQUFHd04sWUFBSDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3FCLGdCQUFULENBQTJCN08sRUFBM0IsRUFBK0I7QUFDN0IsU0FBT0EsT0FBT0EsS0FBS0EsR0FBRy9mLE9BQWYsQ0FBUCxFQUFnQztBQUM5QixRQUFJK2YsR0FBR2hnQixTQUFQLEVBQWtCO0FBQUUsYUFBTyxJQUFQO0FBQWE7QUFDbEM7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFTOHVCLHNCQUFULENBQWlDOU8sRUFBakMsRUFBcUMrTyxNQUFyQyxFQUE2QztBQUMzQyxNQUFJQSxNQUFKLEVBQVk7QUFDVi9PLE9BQUd1TSxlQUFILEdBQXFCLEtBQXJCO0FBQ0EsUUFBSXNDLGlCQUFpQjdPLEVBQWpCLENBQUosRUFBMEI7QUFDeEI7QUFDRDtBQUNGLEdBTEQsTUFLTyxJQUFJQSxHQUFHdU0sZUFBUCxFQUF3QjtBQUM3QjtBQUNEO0FBQ0QsTUFBSXZNLEdBQUdoZ0IsU0FBSCxJQUFnQmdnQixHQUFHaGdCLFNBQUgsSUFBZ0IsSUFBcEMsRUFBMEM7QUFDeENnZ0IsT0FBR2hnQixTQUFILEdBQWUsS0FBZjtBQUNBLFNBQUssSUFBSW5FLElBQUksQ0FBYixFQUFnQkEsSUFBSW1rQixHQUFHb00sU0FBSCxDQUFhanhCLE1BQWpDLEVBQXlDVSxHQUF6QyxFQUE4QztBQUM1Q2l6Qiw2QkFBdUI5TyxHQUFHb00sU0FBSCxDQUFhdndCLENBQWIsQ0FBdkI7QUFDRDtBQUNEaXhCLGFBQVM5TSxFQUFULEVBQWEsV0FBYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2dQLHdCQUFULENBQW1DaFAsRUFBbkMsRUFBdUMrTyxNQUF2QyxFQUErQztBQUM3QyxNQUFJQSxNQUFKLEVBQVk7QUFDVi9PLE9BQUd1TSxlQUFILEdBQXFCLElBQXJCO0FBQ0EsUUFBSXNDLGlCQUFpQjdPLEVBQWpCLENBQUosRUFBMEI7QUFDeEI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxDQUFDQSxHQUFHaGdCLFNBQVIsRUFBbUI7QUFDakJnZ0IsT0FBR2hnQixTQUFILEdBQWUsSUFBZjtBQUNBLFNBQUssSUFBSW5FLElBQUksQ0FBYixFQUFnQkEsSUFBSW1rQixHQUFHb00sU0FBSCxDQUFhanhCLE1BQWpDLEVBQXlDVSxHQUF6QyxFQUE4QztBQUM1Q216QiwrQkFBeUJoUCxHQUFHb00sU0FBSCxDQUFhdndCLENBQWIsQ0FBekI7QUFDRDtBQUNEaXhCLGFBQVM5TSxFQUFULEVBQWEsYUFBYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzhNLFFBQVQsQ0FBbUI5TSxFQUFuQixFQUF1QjNmLElBQXZCLEVBQTZCO0FBQzNCLE1BQUlvbkIsV0FBV3pILEdBQUdoWSxRQUFILENBQVkzSCxJQUFaLENBQWY7QUFDQSxNQUFJb25CLFFBQUosRUFBYztBQUNaLFNBQUssSUFBSTVyQixJQUFJLENBQVIsRUFBV3NSLElBQUlzYSxTQUFTdHNCLE1BQTdCLEVBQXFDVSxJQUFJc1IsQ0FBekMsRUFBNEN0UixHQUE1QyxFQUFpRDtBQUMvQyxVQUFJO0FBQ0Y0ckIsaUJBQVM1ckIsQ0FBVCxFQUFZbEIsSUFBWixDQUFpQnFsQixFQUFqQjtBQUNELE9BRkQsQ0FFRSxPQUFPemxCLENBQVAsRUFBVTtBQUNWdXNCLG9CQUFZdnNCLENBQVosRUFBZXlsQixFQUFmLEVBQW9CM2YsT0FBTyxPQUEzQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELE1BQUkyZixHQUFHNkssYUFBUCxFQUFzQjtBQUNwQjdLLE9BQUd5TCxLQUFILENBQVMsVUFBVXByQixJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBR0EsSUFBSXZGLFFBQVEsRUFBWjtBQUNBLElBQUl5a0IsTUFBTSxFQUFWO0FBQ0EsSUFBSTBQLFdBQVcsRUFBZjtBQUNBLElBQUlDLFVBQVUsS0FBZDtBQUNBLElBQUlDLFdBQVcsS0FBZjtBQUNBLElBQUl4eEIsUUFBUSxDQUFaOztBQUVBOzs7QUFHQSxTQUFTeXhCLG1CQUFULEdBQWdDO0FBQzlCdDBCLFFBQU1LLE1BQU4sR0FBZSxDQUFmO0FBQ0Fva0IsUUFBTSxFQUFOO0FBQ0EsTUFBSXpsQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzhzQixlQUFXLEVBQVg7QUFDRDtBQUNEQyxZQUFVQyxXQUFXLEtBQXJCO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNFLG1CQUFULEdBQWdDO0FBQzlCRixhQUFXLElBQVg7QUFDQSxNQUFJRyxPQUFKLEVBQWE3TyxFQUFiLEVBQWlCVCxFQUFqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FsbEIsUUFBTXkwQixJQUFOLENBQVcsVUFBVWpyQixDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFBRSxXQUFPRCxFQUFFbWMsRUFBRixHQUFPbGMsRUFBRWtjLEVBQWhCO0FBQXFCLEdBQWxEOztBQUVBO0FBQ0E7QUFDQSxPQUFLOWlCLFFBQVEsQ0FBYixFQUFnQkEsUUFBUTdDLE1BQU1LLE1BQTlCLEVBQXNDd0MsT0FBdEMsRUFBK0M7QUFDN0MyeEIsY0FBVXgwQixNQUFNNkMsS0FBTixDQUFWO0FBQ0E4aUIsU0FBSzZPLFFBQVE3TyxFQUFiO0FBQ0FsQixRQUFJa0IsRUFBSixJQUFVLElBQVY7QUFDQTZPLFlBQVE5ekIsR0FBUjtBQUNBO0FBQ0EsUUFBSTFCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDb2QsSUFBSWtCLEVBQUosS0FBVyxJQUF4RCxFQUE4RDtBQUM1RHdPLGVBQVN4TyxFQUFULElBQWUsQ0FBQ3dPLFNBQVN4TyxFQUFULEtBQWdCLENBQWpCLElBQXNCLENBQXJDO0FBQ0EsVUFBSXdPLFNBQVN4TyxFQUFULElBQWUxZixPQUFPeWIsZUFBMUIsRUFBMkM7QUFDekM1ZCxhQUNFLDJDQUNFMHdCLFFBQVFFLElBQVIsR0FDSyxrQ0FBbUNGLFFBQVFHLFVBQTNDLEdBQXlELElBRDlELEdBRUksaUNBSE4sQ0FERixFQU1FSCxRQUFRdFAsRUFOVjtBQVFBO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsTUFBSTBQLFdBQVc1MEIsTUFBTXNJLEtBQU4sRUFBZjtBQUNBZ3NCOztBQUVBO0FBQ0F6eEIsVUFBUSt4QixTQUFTdjBCLE1BQWpCO0FBQ0EsU0FBT3dDLE9BQVAsRUFBZ0I7QUFDZDJ4QixjQUFVSSxTQUFTL3hCLEtBQVQsQ0FBVjtBQUNBcWlCLFNBQUtzUCxRQUFRdFAsRUFBYjtBQUNBLFFBQUlBLEdBQUdzTSxRQUFILEtBQWdCZ0QsT0FBaEIsSUFBMkJ0UCxHQUFHd00sVUFBbEMsRUFBOEM7QUFDNUNNLGVBQVM5TSxFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLE1BQUluRSxZQUFZOWEsT0FBTzhhLFFBQXZCLEVBQWlDO0FBQy9CQSxhQUFTN2UsSUFBVCxDQUFjLE9BQWQ7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVMyeUIsWUFBVCxDQUF1QkwsT0FBdkIsRUFBZ0M7QUFDOUIsTUFBSTdPLEtBQUs2TyxRQUFRN08sRUFBakI7QUFDQSxNQUFJbEIsSUFBSWtCLEVBQUosS0FBVyxJQUFmLEVBQXFCO0FBQ25CbEIsUUFBSWtCLEVBQUosSUFBVSxJQUFWO0FBQ0EsUUFBSSxDQUFDME8sUUFBTCxFQUFlO0FBQ2JyMEIsWUFBTWdCLElBQU4sQ0FBV3d6QixPQUFYO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQTtBQUNBLFVBQUl6ekIsSUFBSWYsTUFBTUssTUFBTixHQUFlLENBQXZCO0FBQ0EsYUFBT1UsS0FBSyxDQUFMLElBQVVmLE1BQU1lLENBQU4sRUFBUzRrQixFQUFULEdBQWM2TyxRQUFRN08sRUFBdkMsRUFBMkM7QUFDekM1a0I7QUFDRDtBQUNEZixZQUFNOGUsTUFBTixDQUFhdEUsS0FBS0QsR0FBTCxDQUFTeFosQ0FBVCxFQUFZOEIsS0FBWixJQUFxQixDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QzJ4QixPQUF4QztBQUNEO0FBQ0Q7QUFDQSxRQUFJLENBQUNKLE9BQUwsRUFBYztBQUNaQSxnQkFBVSxJQUFWO0FBQ0F6ekIsZUFBUzR6QixtQkFBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxJQUFJTyxRQUFRLENBQVo7O0FBRUE7Ozs7O0FBS0EsSUFBSTFCLFVBQVUsU0FBU0EsT0FBVCxDQUNabE8sRUFEWSxFQUVaNlAsT0FGWSxFQUdaeGMsRUFIWSxFQUlabk4sT0FKWSxFQUtaO0FBQ0EsT0FBSzhaLEVBQUwsR0FBVUEsRUFBVjtBQUNBQSxLQUFHMk4sU0FBSCxDQUFhN3hCLElBQWIsQ0FBa0IsSUFBbEI7QUFDQTtBQUNBLE1BQUlvSyxPQUFKLEVBQWE7QUFDWCxTQUFLNHBCLElBQUwsR0FBWSxDQUFDLENBQUM1cEIsUUFBUTRwQixJQUF0QjtBQUNBLFNBQUtOLElBQUwsR0FBWSxDQUFDLENBQUN0cEIsUUFBUXNwQixJQUF0QjtBQUNBLFNBQUtPLElBQUwsR0FBWSxDQUFDLENBQUM3cEIsUUFBUTZwQixJQUF0QjtBQUNBLFNBQUtDLElBQUwsR0FBWSxDQUFDLENBQUM5cEIsUUFBUThwQixJQUF0QjtBQUNELEdBTEQsTUFLTztBQUNMLFNBQUtGLElBQUwsR0FBWSxLQUFLTixJQUFMLEdBQVksS0FBS08sSUFBTCxHQUFZLEtBQUtDLElBQUwsR0FBWSxLQUFoRDtBQUNEO0FBQ0QsT0FBSzNjLEVBQUwsR0FBVUEsRUFBVjtBQUNBLE9BQUtvTixFQUFMLEdBQVUsRUFBRW1QLEtBQVosQ0FiQSxDQWFtQjtBQUNuQixPQUFLSyxNQUFMLEdBQWMsSUFBZDtBQUNBLE9BQUtDLEtBQUwsR0FBYSxLQUFLSCxJQUFsQixDQWZBLENBZXdCO0FBQ3hCLE9BQUtJLElBQUwsR0FBWSxFQUFaO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQSxPQUFLQyxNQUFMLEdBQWMsSUFBSWpSLElBQUosRUFBZDtBQUNBLE9BQUtrUixTQUFMLEdBQWlCLElBQUlsUixJQUFKLEVBQWpCO0FBQ0EsT0FBS3FRLFVBQUwsR0FBa0IzMUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsR0FDZDB0QixRQUFRdnVCLFFBQVIsRUFEYyxHQUVkLEVBRko7QUFHQTtBQUNBLE1BQUksT0FBT3V1QixPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDLFNBQUt6TSxNQUFMLEdBQWN5TSxPQUFkO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsU0FBS3pNLE1BQUwsR0FBY2xhLFVBQVUybUIsT0FBVixDQUFkO0FBQ0EsUUFBSSxDQUFDLEtBQUt6TSxNQUFWLEVBQWtCO0FBQ2hCLFdBQUtBLE1BQUwsR0FBYyxZQUFZLENBQUUsQ0FBNUI7QUFDQXRwQixjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLDZCQUE2Qml4QixPQUE3QixHQUF1QyxLQUF2QyxHQUNBLG1EQURBLEdBRUEsMkNBSHVDLEVBSXZDN1AsRUFKdUMsQ0FBekM7QUFNRDtBQUNGO0FBQ0QsT0FBS2xpQixLQUFMLEdBQWEsS0FBS2l5QixJQUFMLEdBQ1RsdkIsU0FEUyxHQUVULEtBQUt6QyxHQUFMLEVBRko7QUFHRCxDQTlDRDs7QUFnREE7OztBQUdBOHZCLFFBQVFqeUIsU0FBUixDQUFrQm1DLEdBQWxCLEdBQXdCLFNBQVNBLEdBQVQsR0FBZ0I7QUFDdEMraUIsYUFBVyxJQUFYO0FBQ0EsTUFBSXJqQixLQUFKO0FBQ0EsTUFBSWtpQixLQUFLLEtBQUtBLEVBQWQ7QUFDQSxNQUFJLEtBQUt3UCxJQUFULEVBQWU7QUFDYixRQUFJO0FBQ0YxeEIsY0FBUSxLQUFLc2xCLE1BQUwsQ0FBWXpvQixJQUFaLENBQWlCcWxCLEVBQWpCLEVBQXFCQSxFQUFyQixDQUFSO0FBQ0QsS0FGRCxDQUVFLE9BQU96bEIsQ0FBUCxFQUFVO0FBQ1Z1c0Isa0JBQVl2c0IsQ0FBWixFQUFleWxCLEVBQWYsRUFBb0IsMEJBQTJCLEtBQUt5UCxVQUFoQyxHQUE4QyxJQUFsRTtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wzeEIsWUFBUSxLQUFLc2xCLE1BQUwsQ0FBWXpvQixJQUFaLENBQWlCcWxCLEVBQWpCLEVBQXFCQSxFQUFyQixDQUFSO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsTUFBSSxLQUFLOFAsSUFBVCxFQUFlO0FBQ2JTLGFBQVN6eUIsS0FBVDtBQUNEO0FBQ0R1akI7QUFDQSxPQUFLbVAsV0FBTDtBQUNBLFNBQU8xeUIsS0FBUDtBQUNELENBckJEOztBQXVCQTs7O0FBR0Fvd0IsUUFBUWp5QixTQUFSLENBQWtCOGtCLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsQ0FBaUJpQixHQUFqQixFQUFzQjtBQUMvQyxNQUFJdkIsS0FBS3VCLElBQUl2QixFQUFiO0FBQ0EsTUFBSSxDQUFDLEtBQUs2UCxTQUFMLENBQWUvUSxHQUFmLENBQW1Ca0IsRUFBbkIsQ0FBTCxFQUE2QjtBQUMzQixTQUFLNlAsU0FBTCxDQUFlOVEsR0FBZixDQUFtQmlCLEVBQW5CO0FBQ0EsU0FBSzJQLE9BQUwsQ0FBYXQwQixJQUFiLENBQWtCa21CLEdBQWxCO0FBQ0EsUUFBSSxDQUFDLEtBQUtxTyxNQUFMLENBQVk5USxHQUFaLENBQWdCa0IsRUFBaEIsQ0FBTCxFQUEwQjtBQUN4QnVCLFVBQUlyQixNQUFKLENBQVcsSUFBWDtBQUNEO0FBQ0Y7QUFDRixDQVREOztBQVdBOzs7QUFHQXVOLFFBQVFqeUIsU0FBUixDQUFrQnUwQixXQUFsQixHQUFnQyxTQUFTQSxXQUFULEdBQXdCO0FBQ3BELE1BQUk1cUIsU0FBUyxJQUFiOztBQUVGLE1BQUkvSixJQUFJLEtBQUtzMEIsSUFBTCxDQUFVaDFCLE1BQWxCO0FBQ0EsU0FBT1UsR0FBUCxFQUFZO0FBQ1YsUUFBSW1tQixNQUFNcGMsT0FBT3VxQixJQUFQLENBQVl0MEIsQ0FBWixDQUFWO0FBQ0EsUUFBSSxDQUFDK0osT0FBTzBxQixTQUFQLENBQWlCL1EsR0FBakIsQ0FBcUJ5QyxJQUFJdkIsRUFBekIsQ0FBTCxFQUFtQztBQUNqQ3VCLFVBQUluQixTQUFKLENBQWNqYixNQUFkO0FBQ0Q7QUFDRjtBQUNELE1BQUk2cUIsTUFBTSxLQUFLSixNQUFmO0FBQ0EsT0FBS0EsTUFBTCxHQUFjLEtBQUtDLFNBQW5CO0FBQ0EsT0FBS0EsU0FBTCxHQUFpQkcsR0FBakI7QUFDQSxPQUFLSCxTQUFMLENBQWU3USxLQUFmO0FBQ0FnUixRQUFNLEtBQUtOLElBQVg7QUFDQSxPQUFLQSxJQUFMLEdBQVksS0FBS0MsT0FBakI7QUFDQSxPQUFLQSxPQUFMLEdBQWVLLEdBQWY7QUFDQSxPQUFLTCxPQUFMLENBQWFqMUIsTUFBYixHQUFzQixDQUF0QjtBQUNELENBbEJEOztBQW9CQTs7OztBQUlBK3lCLFFBQVFqeUIsU0FBUixDQUFrQmdsQixNQUFsQixHQUEyQixTQUFTQSxNQUFULEdBQW1CO0FBQzVDO0FBQ0EsTUFBSSxLQUFLOE8sSUFBVCxFQUFlO0FBQ2IsU0FBS0csS0FBTCxHQUFhLElBQWI7QUFDRCxHQUZELE1BRU8sSUFBSSxLQUFLRixJQUFULEVBQWU7QUFDcEIsU0FBS3gwQixHQUFMO0FBQ0QsR0FGTSxNQUVBO0FBQ0xtMEIsaUJBQWEsSUFBYjtBQUNEO0FBQ0YsQ0FURDs7QUFXQTs7OztBQUlBekIsUUFBUWp5QixTQUFSLENBQWtCVCxHQUFsQixHQUF3QixTQUFTQSxHQUFULEdBQWdCO0FBQ3RDLE1BQUksS0FBS3kwQixNQUFULEVBQWlCO0FBQ2YsUUFBSW55QixRQUFRLEtBQUtNLEdBQUwsRUFBWjtBQUNBLFFBQ0VOLFVBQVUsS0FBS0EsS0FBZjtBQUNBO0FBQ0E7QUFDQTtBQUNBaVQsYUFBU2pULEtBQVQsQ0FKQSxJQUtBLEtBQUtneUIsSUFOUCxFQU9FO0FBQ0E7QUFDQSxVQUFJWSxXQUFXLEtBQUs1eUIsS0FBcEI7QUFDQSxXQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxVQUFJLEtBQUsweEIsSUFBVCxFQUFlO0FBQ2IsWUFBSTtBQUNGLGVBQUtuYyxFQUFMLENBQVExWSxJQUFSLENBQWEsS0FBS3FsQixFQUFsQixFQUFzQmxpQixLQUF0QixFQUE2QjR5QixRQUE3QjtBQUNELFNBRkQsQ0FFRSxPQUFPbjJCLENBQVAsRUFBVTtBQUNWdXNCLHNCQUFZdnNCLENBQVosRUFBZSxLQUFLeWxCLEVBQXBCLEVBQXlCLDRCQUE2QixLQUFLeVAsVUFBbEMsR0FBZ0QsSUFBekU7QUFDRDtBQUNGLE9BTkQsTUFNTztBQUNMLGFBQUtwYyxFQUFMLENBQVExWSxJQUFSLENBQWEsS0FBS3FsQixFQUFsQixFQUFzQmxpQixLQUF0QixFQUE2QjR5QixRQUE3QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLENBekJEOztBQTJCQTs7OztBQUlBeEMsUUFBUWp5QixTQUFSLENBQWtCMDBCLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBcUI7QUFDaEQsT0FBSzd5QixLQUFMLEdBQWEsS0FBS00sR0FBTCxFQUFiO0FBQ0EsT0FBSzh4QixLQUFMLEdBQWEsS0FBYjtBQUNELENBSEQ7O0FBS0E7OztBQUdBaEMsUUFBUWp5QixTQUFSLENBQWtCNmtCLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDMUMsTUFBSWxiLFNBQVMsSUFBYjs7QUFFRixNQUFJL0osSUFBSSxLQUFLczBCLElBQUwsQ0FBVWgxQixNQUFsQjtBQUNBLFNBQU9VLEdBQVAsRUFBWTtBQUNWK0osV0FBT3VxQixJQUFQLENBQVl0MEIsQ0FBWixFQUFlaWxCLE1BQWY7QUFDRDtBQUNGLENBUEQ7O0FBU0E7OztBQUdBb04sUUFBUWp5QixTQUFSLENBQWtCeXhCLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBcUI7QUFDOUMsTUFBSTluQixTQUFTLElBQWI7O0FBRUYsTUFBSSxLQUFLcXFCLE1BQVQsRUFBaUI7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFJLENBQUMsS0FBS2pRLEVBQUwsQ0FBUTBNLGlCQUFiLEVBQWdDO0FBQzlCaFQsYUFBTyxLQUFLc0csRUFBTCxDQUFRMk4sU0FBZixFQUEwQixJQUExQjtBQUNEO0FBQ0QsUUFBSTl4QixJQUFJLEtBQUtzMEIsSUFBTCxDQUFVaDFCLE1BQWxCO0FBQ0EsV0FBT1UsR0FBUCxFQUFZO0FBQ1YrSixhQUFPdXFCLElBQVAsQ0FBWXQwQixDQUFaLEVBQWVnbEIsU0FBZixDQUF5QmpiLE1BQXpCO0FBQ0Q7QUFDRCxTQUFLcXFCLE1BQUwsR0FBYyxLQUFkO0FBQ0Q7QUFDRixDQWhCRDs7QUFrQkE7Ozs7O0FBS0EsSUFBSVcsY0FBYyxJQUFJeFIsSUFBSixFQUFsQjtBQUNBLFNBQVNtUixRQUFULENBQW1CM3RCLEdBQW5CLEVBQXdCO0FBQ3RCZ3VCLGNBQVluUixLQUFaO0FBQ0FvUixZQUFVanVCLEdBQVYsRUFBZWd1QixXQUFmO0FBQ0Q7O0FBRUQsU0FBU0MsU0FBVCxDQUFvQmp1QixHQUFwQixFQUF5Qmt1QixJQUF6QixFQUErQjtBQUM3QixNQUFJajFCLENBQUosRUFBT29ILElBQVA7QUFDQSxNQUFJOHRCLE1BQU1wMUIsTUFBTW1ILE9BQU4sQ0FBY0YsR0FBZCxDQUFWO0FBQ0EsTUFBSyxDQUFDbXVCLEdBQUQsSUFBUSxDQUFDaGdCLFNBQVNuTyxHQUFULENBQVYsSUFBNEIsQ0FBQ2hGLE9BQU9vbEIsWUFBUCxDQUFvQnBnQixHQUFwQixDQUFqQyxFQUEyRDtBQUN6RDtBQUNEO0FBQ0QsTUFBSUEsSUFBSWlmLE1BQVIsRUFBZ0I7QUFDZCxRQUFJbVAsUUFBUXB1QixJQUFJaWYsTUFBSixDQUFXRyxHQUFYLENBQWV2QixFQUEzQjtBQUNBLFFBQUlxUSxLQUFLdlIsR0FBTCxDQUFTeVIsS0FBVCxDQUFKLEVBQXFCO0FBQ25CO0FBQ0Q7QUFDREYsU0FBS3RSLEdBQUwsQ0FBU3dSLEtBQVQ7QUFDRDtBQUNELE1BQUlELEdBQUosRUFBUztBQUNQbDFCLFFBQUkrRyxJQUFJekgsTUFBUjtBQUNBLFdBQU9VLEdBQVAsRUFBWTtBQUFFZzFCLGdCQUFVanVCLElBQUkvRyxDQUFKLENBQVYsRUFBa0JpMUIsSUFBbEI7QUFBMEI7QUFDekMsR0FIRCxNQUdPO0FBQ0w3dEIsV0FBT3JGLE9BQU9xRixJQUFQLENBQVlMLEdBQVosQ0FBUDtBQUNBL0csUUFBSW9ILEtBQUs5SCxNQUFUO0FBQ0EsV0FBT1UsR0FBUCxFQUFZO0FBQUVnMUIsZ0JBQVVqdUIsSUFBSUssS0FBS3BILENBQUwsQ0FBSixDQUFWLEVBQXdCaTFCLElBQXhCO0FBQWdDO0FBQy9DO0FBQ0Y7O0FBRUQ7O0FBRUEsSUFBSUcsMkJBQTJCO0FBQzdCdFUsY0FBWSxJQURpQjtBQUU3QkUsZ0JBQWMsSUFGZTtBQUc3QnplLE9BQUszQixJQUh3QjtBQUk3QjZpQixPQUFLN2lCO0FBSndCLENBQS9COztBQU9BLFNBQVN5MEIsS0FBVCxDQUFnQnBzQixNQUFoQixFQUF3QnFzQixTQUF4QixFQUFtQy91QixHQUFuQyxFQUF3QztBQUN0QzZ1QiwyQkFBeUI3eUIsR0FBekIsR0FBK0IsU0FBU2d6QixXQUFULEdBQXdCO0FBQ3JELFdBQU8sS0FBS0QsU0FBTCxFQUFnQi91QixHQUFoQixDQUFQO0FBQ0QsR0FGRDtBQUdBNnVCLDJCQUF5QjNSLEdBQXpCLEdBQStCLFNBQVMrUixXQUFULENBQXNCenVCLEdBQXRCLEVBQTJCO0FBQ3hELFNBQUt1dUIsU0FBTCxFQUFnQi91QixHQUFoQixJQUF1QlEsR0FBdkI7QUFDRCxHQUZEO0FBR0FoRixTQUFPQyxjQUFQLENBQXNCaUgsTUFBdEIsRUFBOEIxQyxHQUE5QixFQUFtQzZ1Qix3QkFBbkM7QUFDRDs7QUFFRCxTQUFTSyxTQUFULENBQW9CdFIsRUFBcEIsRUFBd0I7QUFDdEJBLEtBQUcyTixTQUFILEdBQWUsRUFBZjtBQUNBLE1BQUk5Z0IsT0FBT21ULEdBQUdoWSxRQUFkO0FBQ0EsTUFBSTZFLEtBQUs3TixLQUFULEVBQWdCO0FBQUV1eUIsY0FBVXZSLEVBQVYsRUFBY25ULEtBQUs3TixLQUFuQjtBQUE0QjtBQUM5QyxNQUFJNk4sS0FBSzZYLE9BQVQsRUFBa0I7QUFBRThNLGdCQUFZeFIsRUFBWixFQUFnQm5ULEtBQUs2WCxPQUFyQjtBQUFnQztBQUNwRCxNQUFJN1gsS0FBS3JOLElBQVQsRUFBZTtBQUNiaXlCLGFBQVN6UixFQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0xoQixZQUFRZ0IsR0FBRzROLEtBQUgsR0FBVyxFQUFuQixFQUF1QixJQUF2QixDQUE0QixnQkFBNUI7QUFDRDtBQUNELE1BQUkvZ0IsS0FBSzhYLFFBQVQsRUFBbUI7QUFBRStNLGlCQUFhMVIsRUFBYixFQUFpQm5ULEtBQUs4WCxRQUF0QjtBQUFrQztBQUN2RCxNQUFJOVgsS0FBSzRYLEtBQVQsRUFBZ0I7QUFBRWtOLGNBQVUzUixFQUFWLEVBQWNuVCxLQUFLNFgsS0FBbkI7QUFBNEI7QUFDL0M7O0FBRUQsSUFBSW1OLGlCQUFpQixFQUFFeHZCLEtBQUssQ0FBUCxFQUFVL0MsS0FBSyxDQUFmLEVBQWtCeXNCLE1BQU0sQ0FBeEIsRUFBckI7O0FBRUEsU0FBU3lGLFNBQVQsQ0FBb0J2UixFQUFwQixFQUF3QjZSLFlBQXhCLEVBQXNDO0FBQ3BDLE1BQUlqTyxZQUFZNUQsR0FBR2hZLFFBQUgsQ0FBWTRiLFNBQVosSUFBeUIsRUFBekM7QUFDQSxNQUFJNWtCLFFBQVFnaEIsR0FBR3NHLE1BQUgsR0FBWSxFQUF4QjtBQUNBO0FBQ0E7QUFDQSxNQUFJcmpCLE9BQU8rYyxHQUFHaFksUUFBSCxDQUFZNG1CLFNBQVosR0FBd0IsRUFBbkM7QUFDQSxNQUFJa0QsU0FBUyxDQUFDOVIsR0FBRy9mLE9BQWpCO0FBQ0E7QUFDQWtpQixnQkFBY0MsYUFBZCxHQUE4QjBQLE1BQTlCO0FBQ0EsTUFBSUMsT0FBTyxVQUFXM3ZCLEdBQVgsRUFBaUI7QUFDMUJhLFNBQUtuSCxJQUFMLENBQVVzRyxHQUFWO0FBQ0EsUUFBSXRFLFFBQVFnb0IsYUFBYTFqQixHQUFiLEVBQWtCeXZCLFlBQWxCLEVBQWdDak8sU0FBaEMsRUFBMkM1RCxFQUEzQyxDQUFaO0FBQ0E7QUFDQSxRQUFJbG1CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUl5dkIsZUFBZXh2QixHQUFmLENBQUosRUFBeUI7QUFDdkJ4RCxhQUNHLE9BQU93RCxHQUFQLEdBQWEsa0VBRGhCLEVBRUU0ZCxFQUZGO0FBSUQ7QUFDRDRDLHdCQUFrQjVqQixLQUFsQixFQUF5Qm9ELEdBQXpCLEVBQThCdEUsS0FBOUIsRUFBcUMsWUFBWTtBQUMvQyxZQUFJa2lCLEdBQUcvZixPQUFILElBQWMsQ0FBQ2tpQixjQUFjRSxjQUFqQyxFQUFpRDtBQUMvQ3pqQixlQUNFLDREQUNBLHdEQURBLEdBRUEsK0RBRkEsR0FHQSwrQkFIQSxHQUdrQ3dELEdBSGxDLEdBR3dDLElBSjFDLEVBS0U0ZCxFQUxGO0FBT0Q7QUFDRixPQVZEO0FBV0QsS0FsQkQsTUFrQk87QUFDTDRDLHdCQUFrQjVqQixLQUFsQixFQUF5Qm9ELEdBQXpCLEVBQThCdEUsS0FBOUI7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQUksRUFBRXNFLE9BQU80ZCxFQUFULENBQUosRUFBa0I7QUFDaEJrUixZQUFNbFIsRUFBTixFQUFVLFFBQVYsRUFBb0I1ZCxHQUFwQjtBQUNEO0FBQ0YsR0EvQkQ7O0FBaUNBLE9BQUssSUFBSUEsR0FBVCxJQUFnQnl2QixZQUFoQixFQUE4QkUsS0FBTTN2QixHQUFOO0FBQzlCK2YsZ0JBQWNDLGFBQWQsR0FBOEIsSUFBOUI7QUFDRDs7QUFFRCxTQUFTcVAsUUFBVCxDQUFtQnpSLEVBQW5CLEVBQXVCO0FBQ3JCLE1BQUl4Z0IsT0FBT3dnQixHQUFHaFksUUFBSCxDQUFZeEksSUFBdkI7QUFDQUEsU0FBT3dnQixHQUFHNE4sS0FBSCxHQUFXLE9BQU9wdUIsSUFBUCxLQUFnQixVQUFoQixHQUNkd3lCLFFBQVF4eUIsSUFBUixFQUFjd2dCLEVBQWQsQ0FEYyxHQUVkeGdCLFFBQVEsRUFGWjtBQUdBLE1BQUksQ0FBQ3ViLGNBQWN2YixJQUFkLENBQUwsRUFBMEI7QUFDeEJBLFdBQU8sRUFBUDtBQUNBMUYsWUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2Qyw4Q0FDQSxvRUFGdUMsRUFHdkNvaEIsRUFIdUMsQ0FBekM7QUFLRDtBQUNEO0FBQ0EsTUFBSS9jLE9BQU9yRixPQUFPcUYsSUFBUCxDQUFZekQsSUFBWixDQUFYO0FBQ0EsTUFBSVIsUUFBUWdoQixHQUFHaFksUUFBSCxDQUFZaEosS0FBeEI7QUFDQSxNQUFJbkQsSUFBSW9ILEtBQUs5SCxNQUFiO0FBQ0EsU0FBT1UsR0FBUCxFQUFZO0FBQ1YsUUFBSW1ELFNBQVM2YSxPQUFPN2EsS0FBUCxFQUFjaUUsS0FBS3BILENBQUwsQ0FBZCxDQUFiLEVBQXFDO0FBQ25DL0IsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2Qyx5QkFBMEJxRSxLQUFLcEgsQ0FBTCxDQUExQixHQUFxQyxvQ0FBckMsR0FDQSxpQ0FGdUMsRUFHdkNta0IsRUFIdUMsQ0FBekM7QUFLRCxLQU5ELE1BTU8sSUFBSSxDQUFDdEQsV0FBV3paLEtBQUtwSCxDQUFMLENBQVgsQ0FBTCxFQUEwQjtBQUMvQnExQixZQUFNbFIsRUFBTixFQUFVLE9BQVYsRUFBbUIvYyxLQUFLcEgsQ0FBTCxDQUFuQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBbWpCLFVBQVF4ZixJQUFSLEVBQWMsSUFBZCxDQUFtQixnQkFBbkI7QUFDRDs7QUFFRCxTQUFTd3lCLE9BQVQsQ0FBa0J4eUIsSUFBbEIsRUFBd0J3Z0IsRUFBeEIsRUFBNEI7QUFDMUIsTUFBSTtBQUNGLFdBQU94Z0IsS0FBSzdFLElBQUwsQ0FBVXFsQixFQUFWLENBQVA7QUFDRCxHQUZELENBRUUsT0FBT3psQixDQUFQLEVBQVU7QUFDVnVzQixnQkFBWXZzQixDQUFaLEVBQWV5bEIsRUFBZixFQUFtQixRQUFuQjtBQUNBLFdBQU8sRUFBUDtBQUNEO0FBQ0Y7O0FBRUQsSUFBSWlTLHlCQUF5QixFQUFFbEMsTUFBTSxJQUFSLEVBQTdCOztBQUVBLFNBQVMyQixZQUFULENBQXVCMVIsRUFBdkIsRUFBMkIyRSxRQUEzQixFQUFxQztBQUNuQyxNQUFJdU4sV0FBV2xTLEdBQUdtUyxpQkFBSCxHQUF1QnYwQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBdEM7O0FBRUEsT0FBSyxJQUFJdkgsR0FBVCxJQUFnQnVpQixRQUFoQixFQUEwQjtBQUN4QixRQUFJeU4sVUFBVXpOLFNBQVN2aUIsR0FBVCxDQUFkO0FBQ0EsUUFBSWdoQixTQUFTLE9BQU9nUCxPQUFQLEtBQW1CLFVBQW5CLEdBQWdDQSxPQUFoQyxHQUEwQ0EsUUFBUWgwQixHQUEvRDtBQUNBO0FBQ0E4ekIsYUFBUzl2QixHQUFULElBQWdCLElBQUk4ckIsT0FBSixDQUFZbE8sRUFBWixFQUFnQm9ELE1BQWhCLEVBQXdCM21CLElBQXhCLEVBQThCdzFCLHNCQUE5QixDQUFoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLEVBQUU3dkIsT0FBTzRkLEVBQVQsQ0FBSixFQUFrQjtBQUNoQnFTLHFCQUFlclMsRUFBZixFQUFtQjVkLEdBQW5CLEVBQXdCZ3dCLE9BQXhCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNDLGNBQVQsQ0FBeUJ2dEIsTUFBekIsRUFBaUMxQyxHQUFqQyxFQUFzQ2d3QixPQUF0QyxFQUErQztBQUM3QyxNQUFJLE9BQU9BLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakNuQiw2QkFBeUI3eUIsR0FBekIsR0FBK0JrMEIscUJBQXFCbHdCLEdBQXJCLENBQS9CO0FBQ0E2dUIsNkJBQXlCM1IsR0FBekIsR0FBK0I3aUIsSUFBL0I7QUFDRCxHQUhELE1BR087QUFDTHcwQiw2QkFBeUI3eUIsR0FBekIsR0FBK0JnMEIsUUFBUWgwQixHQUFSLEdBQzNCZzBCLFFBQVF6eUIsS0FBUixLQUFrQixLQUFsQixHQUNFMnlCLHFCQUFxQmx3QixHQUFyQixDQURGLEdBRUVnd0IsUUFBUWgwQixHQUhpQixHQUkzQjNCLElBSko7QUFLQXcwQiw2QkFBeUIzUixHQUF6QixHQUErQjhTLFFBQVE5UyxHQUFSLEdBQzNCOFMsUUFBUTlTLEdBRG1CLEdBRTNCN2lCLElBRko7QUFHRDtBQUNEbUIsU0FBT0MsY0FBUCxDQUFzQmlILE1BQXRCLEVBQThCMUMsR0FBOUIsRUFBbUM2dUIsd0JBQW5DO0FBQ0Q7O0FBRUQsU0FBU3FCLG9CQUFULENBQStCbHdCLEdBQS9CLEVBQW9DO0FBQ2xDLFNBQU8sU0FBU213QixjQUFULEdBQTJCO0FBQ2hDLFFBQUlqRCxVQUFVLEtBQUs2QyxpQkFBTCxJQUEwQixLQUFLQSxpQkFBTCxDQUF1Qi92QixHQUF2QixDQUF4QztBQUNBLFFBQUlrdEIsT0FBSixFQUFhO0FBQ1gsVUFBSUEsUUFBUVksS0FBWixFQUFtQjtBQUNqQlosZ0JBQVFxQixRQUFSO0FBQ0Q7QUFDRCxVQUFJblEsSUFBSTFiLE1BQVIsRUFBZ0I7QUFDZHdxQixnQkFBUXhPLE1BQVI7QUFDRDtBQUNELGFBQU93TyxRQUFReHhCLEtBQWY7QUFDRDtBQUNGLEdBWEQ7QUFZRDs7QUFFRCxTQUFTMHpCLFdBQVQsQ0FBc0J4UixFQUF0QixFQUEwQjBFLE9BQTFCLEVBQW1DO0FBQ2pDLE1BQUkxbEIsUUFBUWdoQixHQUFHaFksUUFBSCxDQUFZaEosS0FBeEI7QUFDQSxPQUFLLElBQUlvRCxHQUFULElBQWdCc2lCLE9BQWhCLEVBQXlCO0FBQ3ZCMUUsT0FBRzVkLEdBQUgsSUFBVXNpQixRQUFRdGlCLEdBQVIsS0FBZ0IsSUFBaEIsR0FBdUIzRixJQUF2QixHQUE4QmdaLEtBQUtpUCxRQUFRdGlCLEdBQVIsQ0FBTCxFQUFtQjRkLEVBQW5CLENBQXhDO0FBQ0EsUUFBSWxtQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJdWlCLFFBQVF0aUIsR0FBUixLQUFnQixJQUFwQixFQUEwQjtBQUN4QnhELGFBQ0UsY0FBY3dELEdBQWQsR0FBb0IseURBQXBCLEdBQ0EsMkNBRkYsRUFHRTRkLEVBSEY7QUFLRDtBQUNELFVBQUloaEIsU0FBUzZhLE9BQU83YSxLQUFQLEVBQWNvRCxHQUFkLENBQWIsRUFBaUM7QUFDL0J4RCxhQUNHLGNBQWN3RCxHQUFkLEdBQW9CLHdDQUR2QixFQUVFNGQsRUFGRjtBQUlEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQVMyUixTQUFULENBQW9CM1IsRUFBcEIsRUFBd0J5RSxLQUF4QixFQUErQjtBQUM3QixPQUFLLElBQUlyaUIsR0FBVCxJQUFnQnFpQixLQUFoQixFQUF1QjtBQUNyQixRQUFJcGUsVUFBVW9lLE1BQU1yaUIsR0FBTixDQUFkO0FBQ0EsUUFBSXpHLE1BQU1tSCxPQUFOLENBQWN1RCxPQUFkLENBQUosRUFBNEI7QUFDMUIsV0FBSyxJQUFJeEssSUFBSSxDQUFiLEVBQWdCQSxJQUFJd0ssUUFBUWxMLE1BQTVCLEVBQW9DVSxHQUFwQyxFQUF5QztBQUN2QzIyQixzQkFBY3hTLEVBQWQsRUFBa0I1ZCxHQUFsQixFQUF1QmlFLFFBQVF4SyxDQUFSLENBQXZCO0FBQ0Q7QUFDRixLQUpELE1BSU87QUFDTDIyQixvQkFBY3hTLEVBQWQsRUFBa0I1ZCxHQUFsQixFQUF1QmlFLE9BQXZCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNtc0IsYUFBVCxDQUF3QnhTLEVBQXhCLEVBQTRCNWQsR0FBNUIsRUFBaUNpRSxPQUFqQyxFQUEwQztBQUN4QyxNQUFJSCxPQUFKO0FBQ0EsTUFBSTZVLGNBQWMxVSxPQUFkLENBQUosRUFBNEI7QUFDMUJILGNBQVVHLE9BQVY7QUFDQUEsY0FBVUEsUUFBUUEsT0FBbEI7QUFDRDtBQUNELE1BQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQkEsY0FBVTJaLEdBQUczWixPQUFILENBQVY7QUFDRDtBQUNEMlosS0FBR3lTLE1BQUgsQ0FBVXJ3QixHQUFWLEVBQWVpRSxPQUFmLEVBQXdCSCxPQUF4QjtBQUNEOztBQUVELFNBQVN3c0IsVUFBVCxDQUFxQnowQixHQUFyQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxNQUFJMDBCLFVBQVUsRUFBZDtBQUNBQSxVQUFRdjBCLEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxLQUFLd3ZCLEtBQVo7QUFBbUIsR0FBL0M7QUFDQSxNQUFJZ0YsV0FBVyxFQUFmO0FBQ0FBLFdBQVN4MEIsR0FBVCxHQUFlLFlBQVk7QUFBRSxXQUFPLEtBQUtrb0IsTUFBWjtBQUFvQixHQUFqRDtBQUNBLE1BQUl4c0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN3d0IsWUFBUXJULEdBQVIsR0FBYyxVQUFVdVQsT0FBVixFQUFtQjtBQUMvQmowQixXQUNFLDBDQUNBLHFDQUZGLEVBR0UsSUFIRjtBQUtELEtBTkQ7QUFPQWcwQixhQUFTdFQsR0FBVCxHQUFlLFlBQVk7QUFDekIxZ0IsV0FBSyxxQkFBTCxFQUE0QixJQUE1QjtBQUNELEtBRkQ7QUFHRDtBQUNEaEIsU0FBT0MsY0FBUCxDQUFzQkksSUFBSWhDLFNBQTFCLEVBQXFDLE9BQXJDLEVBQThDMDJCLE9BQTlDO0FBQ0EvMEIsU0FBT0MsY0FBUCxDQUFzQkksSUFBSWhDLFNBQTFCLEVBQXFDLFFBQXJDLEVBQStDMjJCLFFBQS9DOztBQUVBMzBCLE1BQUloQyxTQUFKLENBQWM2MkIsSUFBZCxHQUFxQnhULEdBQXJCO0FBQ0FyaEIsTUFBSWhDLFNBQUosQ0FBYzgyQixPQUFkLEdBQXdCcFAsR0FBeEI7O0FBRUExbEIsTUFBSWhDLFNBQUosQ0FBY3cyQixNQUFkLEdBQXVCLFVBQ3JCNUMsT0FEcUIsRUFFckJ4YyxFQUZxQixFQUdyQm5OLE9BSHFCLEVBSXJCO0FBQ0EsUUFBSThaLEtBQUssSUFBVDtBQUNBOVosY0FBVUEsV0FBVyxFQUFyQjtBQUNBQSxZQUFRc3BCLElBQVIsR0FBZSxJQUFmO0FBQ0EsUUFBSUYsVUFBVSxJQUFJcEIsT0FBSixDQUFZbE8sRUFBWixFQUFnQjZQLE9BQWhCLEVBQXlCeGMsRUFBekIsRUFBNkJuTixPQUE3QixDQUFkO0FBQ0EsUUFBSUEsUUFBUThzQixTQUFaLEVBQXVCO0FBQ3JCM2YsU0FBRzFZLElBQUgsQ0FBUXFsQixFQUFSLEVBQVlzUCxRQUFReHhCLEtBQXBCO0FBQ0Q7QUFDRCxXQUFPLFNBQVNtMUIsU0FBVCxHQUFzQjtBQUMzQjNELGNBQVE1QixRQUFSO0FBQ0QsS0FGRDtBQUdELEdBZkQ7QUFnQkQ7O0FBRUQ7O0FBRUE7QUFDQSxJQUFJd0Ysc0JBQXNCO0FBQ3hCNXlCLFFBQU0sU0FBU0EsSUFBVCxDQUNKQyxLQURJLEVBRUpzc0IsU0FGSSxFQUdKc0csU0FISSxFQUlKQyxNQUpJLEVBS0o7QUFDQSxRQUFJLENBQUM3eUIsTUFBTW1vQixpQkFBUCxJQUE0Qm5vQixNQUFNbW9CLGlCQUFOLENBQXdCK0QsWUFBeEQsRUFBc0U7QUFDcEUsVUFBSWhzQixRQUFRRixNQUFNbW9CLGlCQUFOLEdBQTBCMkssZ0NBQ3BDOXlCLEtBRG9DLEVBRXBDMHJCLGNBRm9DLEVBR3BDa0gsU0FIb0MsRUFJcENDLE1BSm9DLENBQXRDO0FBTUEzeUIsWUFBTTZ5QixNQUFOLENBQWF6RyxZQUFZdHNCLE1BQU04bkIsR0FBbEIsR0FBd0J4bkIsU0FBckMsRUFBZ0Rnc0IsU0FBaEQ7QUFDRCxLQVJELE1BUU8sSUFBSXRzQixNQUFNZixJQUFOLENBQVcrekIsU0FBZixFQUEwQjtBQUMvQjtBQUNBLFVBQUlDLGNBQWNqekIsS0FBbEIsQ0FGK0IsQ0FFTjtBQUN6QjJ5QiwwQkFBb0J4eUIsUUFBcEIsQ0FBNkI4eUIsV0FBN0IsRUFBMENBLFdBQTFDO0FBQ0Q7QUFDRixHQXBCdUI7O0FBc0J4Qjl5QixZQUFVLFNBQVNBLFFBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCSixLQUE3QixFQUFvQztBQUM1QyxRQUFJMkYsVUFBVTNGLE1BQU1nb0IsZ0JBQXBCO0FBQ0EsUUFBSTluQixRQUFRRixNQUFNbW9CLGlCQUFOLEdBQTBCL25CLFNBQVMrbkIsaUJBQS9DO0FBQ0F5Rix5QkFDRTF0QixLQURGLEVBRUV5RixRQUFRMGQsU0FGVixFQUVxQjtBQUNuQjFkLFlBQVE0a0IsU0FIVixFQUdxQjtBQUNuQnZxQixTQUpGLEVBSVM7QUFDUDJGLFlBQVE1RyxRQUxWLENBS21CO0FBTG5CO0FBT0QsR0FoQ3VCOztBQWtDeEJtMEIsVUFBUSxTQUFTQSxNQUFULENBQWlCbHpCLEtBQWpCLEVBQXdCO0FBQzlCLFFBQUksQ0FBQ0EsTUFBTW1vQixpQkFBTixDQUF3QjhELFVBQTdCLEVBQXlDO0FBQ3ZDanNCLFlBQU1tb0IsaUJBQU4sQ0FBd0I4RCxVQUF4QixHQUFxQyxJQUFyQztBQUNBTSxlQUFTdnNCLE1BQU1tb0IsaUJBQWYsRUFBa0MsU0FBbEM7QUFDRDtBQUNELFFBQUlub0IsTUFBTWYsSUFBTixDQUFXK3pCLFNBQWYsRUFBMEI7QUFDeEJ6RSw2QkFBdUJ2dUIsTUFBTW1vQixpQkFBN0IsRUFBZ0QsSUFBaEQsQ0FBcUQsWUFBckQ7QUFDRDtBQUNGLEdBMUN1Qjs7QUE0Q3hCOW5CLFdBQVMsU0FBU0EsT0FBVCxDQUFrQkwsS0FBbEIsRUFBeUI7QUFDaEMsUUFBSSxDQUFDQSxNQUFNbW9CLGlCQUFOLENBQXdCK0QsWUFBN0IsRUFBMkM7QUFDekMsVUFBSSxDQUFDbHNCLE1BQU1mLElBQU4sQ0FBVyt6QixTQUFoQixFQUEyQjtBQUN6Qmh6QixjQUFNbW9CLGlCQUFOLENBQXdCK0UsUUFBeEI7QUFDRCxPQUZELE1BRU87QUFDTHVCLGlDQUF5Qnp1QixNQUFNbW9CLGlCQUEvQixFQUFrRCxJQUFsRCxDQUF1RCxZQUF2RDtBQUNEO0FBQ0Y7QUFDRjtBQXBEdUIsQ0FBMUI7O0FBdURBLElBQUlnTCxlQUFlOTFCLE9BQU9xRixJQUFQLENBQVlpd0IsbUJBQVosQ0FBbkI7O0FBRUEsU0FBU1MsZUFBVCxDQUNFL1YsSUFERixFQUVFcGUsSUFGRixFQUdFOG9CLE9BSEYsRUFJRWhwQixRQUpGLEVBS0VnRyxHQUxGLEVBTUU7QUFDQSxNQUFJLENBQUNzWSxJQUFMLEVBQVc7QUFDVDtBQUNEOztBQUVELE1BQUlnVyxXQUFXdEwsUUFBUXRnQixRQUFSLENBQWlCNnJCLEtBQWhDO0FBQ0EsTUFBSTlpQixTQUFTNk0sSUFBVCxDQUFKLEVBQW9CO0FBQ2xCQSxXQUFPZ1csU0FBUy9zQixNQUFULENBQWdCK1csSUFBaEIsQ0FBUDtBQUNEOztBQUVELE1BQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QixRQUFJOWpCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDdkQsV0FBTSxtQ0FBb0NNLE9BQU8wZSxJQUFQLENBQTFDLEVBQTBEMEssT0FBMUQ7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJLENBQUMxSyxLQUFLa1csR0FBVixFQUFlO0FBQ2IsUUFBSWxXLEtBQUs3RSxRQUFULEVBQW1CO0FBQ2pCNkUsYUFBT0EsS0FBSzdFLFFBQVo7QUFDRCxLQUZELE1BRU87QUFDTDZFLGFBQU9tVyxzQkFBc0JuVyxJQUF0QixFQUE0QmdXLFFBQTVCLEVBQXNDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBdEwsZ0JBQVFrRixZQUFSO0FBQ0QsT0FKTSxDQUFQO0FBS0EsVUFBSSxDQUFDNVAsSUFBTCxFQUFXO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0E7QUFDQW9XLDRCQUEwQnBXLElBQTFCOztBQUVBcGUsU0FBT0EsUUFBUSxFQUFmOztBQUVBO0FBQ0EsTUFBSUEsS0FBS3kwQixLQUFULEVBQWdCO0FBQ2RDLG1CQUFldFcsS0FBSzFYLE9BQXBCLEVBQTZCMUcsSUFBN0I7QUFDRDs7QUFFRDtBQUNBLE1BQUlva0IsWUFBWXVRLGFBQWEzMEIsSUFBYixFQUFtQm9lLElBQW5CLEVBQXlCdFksR0FBekIsQ0FBaEI7O0FBRUE7QUFDQSxNQUFJc1ksS0FBSzFYLE9BQUwsQ0FBYW5ILFVBQWpCLEVBQTZCO0FBQzNCLFdBQU9xMUIsMEJBQTBCeFcsSUFBMUIsRUFBZ0NnRyxTQUFoQyxFQUEyQ3BrQixJQUEzQyxFQUFpRDhvQixPQUFqRCxFQUEwRGhwQixRQUExRCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUl3ckIsWUFBWXRyQixLQUFLOUMsRUFBckI7QUFDQTtBQUNBOEMsT0FBSzlDLEVBQUwsR0FBVThDLEtBQUs2MEIsUUFBZjs7QUFFQSxNQUFJelcsS0FBSzFYLE9BQUwsQ0FBYWltQixRQUFqQixFQUEyQjtBQUN6QjtBQUNBO0FBQ0Ezc0IsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQ7QUFDQTgwQixhQUFXOTBCLElBQVg7O0FBRUE7QUFDQSxNQUFJdEMsT0FBTzBnQixLQUFLMVgsT0FBTCxDQUFhaEosSUFBYixJQUFxQm9JLEdBQWhDO0FBQ0EsTUFBSS9FLFFBQVEsSUFBSTRuQixLQUFKLENBQ1QsbUJBQW9CdkssS0FBS2tXLEdBQXpCLElBQWlDNTJCLE9BQVEsTUFBTUEsSUFBZCxHQUFzQixFQUF2RCxDQURTLEVBRVZzQyxJQUZVLEVBRUpxQixTQUZJLEVBRU9BLFNBRlAsRUFFa0JBLFNBRmxCLEVBRTZCeW5CLE9BRjdCLEVBR1YsRUFBRTFLLE1BQU1BLElBQVIsRUFBY2dHLFdBQVdBLFNBQXpCLEVBQW9Da0gsV0FBV0EsU0FBL0MsRUFBMER4bEIsS0FBS0EsR0FBL0QsRUFBb0VoRyxVQUFVQSxRQUE5RSxFQUhVLENBQVo7QUFLQSxTQUFPaUIsS0FBUDtBQUNEOztBQUVELFNBQVM2ekIseUJBQVQsQ0FDRXhXLElBREYsRUFFRWdHLFNBRkYsRUFHRXBrQixJQUhGLEVBSUU4b0IsT0FKRixFQUtFaHBCLFFBTEYsRUFNRTtBQUNBLE1BQUlOLFFBQVEsRUFBWjtBQUNBLE1BQUkrbUIsY0FBY25JLEtBQUsxWCxPQUFMLENBQWFsSCxLQUEvQjtBQUNBLE1BQUkrbUIsV0FBSixFQUFpQjtBQUNmLFNBQUssSUFBSTNqQixHQUFULElBQWdCMmpCLFdBQWhCLEVBQTZCO0FBQzNCL21CLFlBQU1vRCxHQUFOLElBQWEwakIsYUFBYTFqQixHQUFiLEVBQWtCMmpCLFdBQWxCLEVBQStCbkMsU0FBL0IsQ0FBYjtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsTUFBSTJRLFdBQVczMkIsT0FBTytMLE1BQVAsQ0FBYzJlLE9BQWQsQ0FBZjtBQUNBLE1BQUlscEIsSUFBSSxVQUFVa0YsQ0FBVixFQUFhQyxDQUFiLEVBQWdCbkQsQ0FBaEIsRUFBbUJvekIsQ0FBbkIsRUFBc0I7QUFBRSxXQUFPQyxjQUFjRixRQUFkLEVBQXdCandCLENBQXhCLEVBQTJCQyxDQUEzQixFQUE4Qm5ELENBQTlCLEVBQWlDb3pCLENBQWpDLEVBQW9DLElBQXBDLENBQVA7QUFBbUQsR0FBbkY7QUFDQSxNQUFJajBCLFFBQVFxZCxLQUFLMVgsT0FBTCxDQUFhL0csTUFBYixDQUFvQnhFLElBQXBCLENBQXlCLElBQXpCLEVBQStCeUUsQ0FBL0IsRUFBa0M7QUFDNUNKLFdBQU9BLEtBRHFDO0FBRTVDUSxVQUFNQSxJQUZzQztBQUc1Q0QsWUFBUStvQixPQUhvQztBQUk1Q2hwQixjQUFVQSxRQUprQztBQUs1Q3NzQixXQUFPLFlBQVk7QUFBRSxhQUFPRCxhQUFhcnNCLFFBQWIsRUFBdUJncEIsT0FBdkIsQ0FBUDtBQUF5QztBQUxsQixHQUFsQyxDQUFaO0FBT0EsTUFBSS9uQixpQkFBaUI0bkIsS0FBckIsRUFBNEI7QUFDMUI1bkIsVUFBTWtvQixpQkFBTixHQUEwQkgsT0FBMUI7QUFDQSxRQUFJOW9CLEtBQUtzc0IsSUFBVCxFQUFlO0FBQ2IsT0FBQ3ZyQixNQUFNZixJQUFOLEtBQWVlLE1BQU1mLElBQU4sR0FBYSxFQUE1QixDQUFELEVBQWtDc3NCLElBQWxDLEdBQXlDdHNCLEtBQUtzc0IsSUFBOUM7QUFDRDtBQUNGO0FBQ0QsU0FBT3ZyQixLQUFQO0FBQ0Q7O0FBRUQsU0FBUzh5QiwrQkFBVCxDQUNFOXlCLEtBREYsRUFDUztBQUNQaEIsTUFGRixFQUVVO0FBQ1I0ekIsU0FIRixFQUlFQyxNQUpGLEVBS0U7QUFDQSxNQUFJc0Isd0JBQXdCbjBCLE1BQU1nb0IsZ0JBQWxDO0FBQ0EsTUFBSXJpQixVQUFVO0FBQ1p5dUIsa0JBQWMsSUFERjtBQUVacDFCLFlBQVFBLE1BRkk7QUFHWnFrQixlQUFXOFEsc0JBQXNCOVEsU0FIckI7QUFJWnhELG1CQUFlc1Usc0JBQXNCcHZCLEdBSnpCO0FBS1pvcEIsa0JBQWNudUIsS0FMRjtBQU1ad3FCLHNCQUFrQjJKLHNCQUFzQjVKLFNBTjVCO0FBT1p5RCxxQkFBaUJtRyxzQkFBc0JwMUIsUUFQM0I7QUFRWit0QixnQkFBWThGLGFBQWEsSUFSYjtBQVNaN0YsYUFBUzhGLFVBQVU7QUFUUCxHQUFkO0FBV0E7QUFDQSxNQUFJd0IsaUJBQWlCcjBCLE1BQU1mLElBQU4sQ0FBV28xQixjQUFoQztBQUNBLE1BQUlBLGNBQUosRUFBb0I7QUFDbEIxdUIsWUFBUS9HLE1BQVIsR0FBaUJ5MUIsZUFBZXoxQixNQUFoQztBQUNBK0csWUFBUTJ1QixlQUFSLEdBQTBCRCxlQUFlQyxlQUF6QztBQUNEO0FBQ0QsU0FBTyxJQUFJSCxzQkFBc0I5VyxJQUExQixDQUErQjFYLE9BQS9CLENBQVA7QUFDRDs7QUFFRCxTQUFTNnRCLHFCQUFULENBQ0V2MkIsT0FERixFQUVFbzJCLFFBRkYsRUFHRXZnQixFQUhGLEVBSUU7QUFDQSxNQUFJN1YsUUFBUXMzQixTQUFaLEVBQXVCO0FBQ3JCO0FBQ0F0M0IsWUFBUXUzQixnQkFBUixDQUF5Qmo1QixJQUF6QixDQUE4QnVYLEVBQTlCO0FBQ0QsR0FIRCxNQUdPO0FBQ0w3VixZQUFRczNCLFNBQVIsR0FBb0IsSUFBcEI7QUFDQSxRQUFJMWUsTUFBTTVZLFFBQVF1M0IsZ0JBQVIsR0FBMkIsQ0FBQzFoQixFQUFELENBQXJDO0FBQ0EsUUFBSTJjLE9BQU8sSUFBWDs7QUFFQSxRQUFJanFCLFVBQVUsVUFBVTFELEdBQVYsRUFBZTtBQUMzQixVQUFJME8sU0FBUzFPLEdBQVQsQ0FBSixFQUFtQjtBQUNqQkEsY0FBTXV4QixTQUFTL3NCLE1BQVQsQ0FBZ0J4RSxHQUFoQixDQUFOO0FBQ0Q7QUFDRDtBQUNBN0UsY0FBUXViLFFBQVIsR0FBbUIxVyxHQUFuQjtBQUNBO0FBQ0E7QUFDQSxVQUFJLENBQUMydEIsSUFBTCxFQUFXO0FBQ1QsYUFBSyxJQUFJbjBCLElBQUksQ0FBUixFQUFXMmUsSUFBSXBFLElBQUlqYixNQUF4QixFQUFnQ1UsSUFBSTJlLENBQXBDLEVBQXVDM2UsR0FBdkMsRUFBNEM7QUFDMUN1YSxjQUFJdmEsQ0FBSixFQUFPd0csR0FBUDtBQUNEO0FBQ0Y7QUFDRixLQWJEOztBQWVBLFFBQUlxVSxTQUFTLFVBQVVDLE1BQVYsRUFBa0I7QUFDN0I3YyxjQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLHdDQUF5Q00sT0FBTzFCLE9BQVAsQ0FBekMsSUFDQ21aLFNBQVUsZUFBZUEsTUFBekIsR0FBbUMsRUFEcEMsQ0FEdUMsQ0FBekM7QUFJRCxLQUxEOztBQU9BLFFBQUl0VSxNQUFNN0UsUUFBUXVJLE9BQVIsRUFBaUIyUSxNQUFqQixDQUFWOztBQUVBO0FBQ0EsUUFBSXJVLE9BQU8sT0FBT0EsSUFBSXVVLElBQVgsS0FBb0IsVUFBM0IsSUFBeUMsQ0FBQ3BaLFFBQVF1YixRQUF0RCxFQUFnRTtBQUM5RDFXLFVBQUl1VSxJQUFKLENBQVM3USxPQUFULEVBQWtCMlEsTUFBbEI7QUFDRDs7QUFFRHNaLFdBQU8sS0FBUDtBQUNBO0FBQ0EsV0FBT3h5QixRQUFRdWIsUUFBZjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU29iLFlBQVQsQ0FBdUIzMEIsSUFBdkIsRUFBNkJvZSxJQUE3QixFQUFtQ3RZLEdBQW5DLEVBQXdDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE1BQUl5Z0IsY0FBY25JLEtBQUsxWCxPQUFMLENBQWFsSCxLQUEvQjtBQUNBLE1BQUksQ0FBQyttQixXQUFMLEVBQWtCO0FBQ2hCO0FBQ0Q7QUFDRCxNQUFJMWpCLE1BQU0sRUFBVjtBQUNBLE1BQUlvRSxRQUFRakgsS0FBS2lILEtBQWpCO0FBQ0EsTUFBSXpILFFBQVFRLEtBQUtSLEtBQWpCO0FBQ0EsTUFBSWcyQixXQUFXeDFCLEtBQUt3MUIsUUFBcEI7QUFDQSxNQUFJdnVCLFNBQVN6SCxLQUFULElBQWtCZzJCLFFBQXRCLEVBQWdDO0FBQzlCLFNBQUssSUFBSTV5QixHQUFULElBQWdCMmpCLFdBQWhCLEVBQTZCO0FBQzNCLFVBQUlrUCxTQUFTNWEsVUFBVWpZLEdBQVYsQ0FBYjtBQUNBLFVBQUl0SSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxZQUFJK3lCLGlCQUFpQjl5QixJQUFJb1gsV0FBSixFQUFyQjtBQUNBLFlBQ0VwWCxRQUFROHlCLGNBQVIsSUFDQXp1QixLQURBLElBQ1NBLE1BQU04SSxjQUFOLENBQXFCMmxCLGNBQXJCLENBRlgsRUFHRTtBQUNBeFYsY0FDRSxZQUFZd1YsY0FBWixHQUE2Qiw0QkFBN0IsR0FDQ3ZWLG9CQUFvQnJhLE9BQU9zWSxJQUEzQixDQURELEdBQ3FDLGdDQURyQyxHQUVBLEtBRkEsR0FFUXhiLEdBRlIsR0FFYyxNQUZkLEdBR0EsZ0VBSEEsR0FJQSxtRUFKQSxHQUtBLHVDQUxBLEdBSzBDNnlCLE1BTDFDLEdBS21ELGtCQUxuRCxHQUt3RTd5QixHQUx4RSxHQUs4RSxLQU5oRjtBQVFEO0FBQ0Y7QUFDRCt5QixnQkFBVTl5QixHQUFWLEVBQWVyRCxLQUFmLEVBQXNCb0QsR0FBdEIsRUFBMkI2eUIsTUFBM0IsRUFBbUMsSUFBbkMsS0FDQUUsVUFBVTl5QixHQUFWLEVBQWVvRSxLQUFmLEVBQXNCckUsR0FBdEIsRUFBMkI2eUIsTUFBM0IsQ0FEQSxJQUVBRSxVQUFVOXlCLEdBQVYsRUFBZTJ5QixRQUFmLEVBQXlCNXlCLEdBQXpCLEVBQThCNnlCLE1BQTlCLENBRkE7QUFHRDtBQUNGO0FBQ0QsU0FBTzV5QixHQUFQO0FBQ0Q7O0FBRUQsU0FBUzh5QixTQUFULENBQ0U5eUIsR0FERixFQUVFeUIsSUFGRixFQUdFMUIsR0FIRixFQUlFNnlCLE1BSkYsRUFLRUcsUUFMRixFQU1FO0FBQ0EsTUFBSXR4QixJQUFKLEVBQVU7QUFDUixRQUFJK1YsT0FBTy9WLElBQVAsRUFBYTFCLEdBQWIsQ0FBSixFQUF1QjtBQUNyQkMsVUFBSUQsR0FBSixJQUFXMEIsS0FBSzFCLEdBQUwsQ0FBWDtBQUNBLFVBQUksQ0FBQ2d6QixRQUFMLEVBQWU7QUFDYixlQUFPdHhCLEtBQUsxQixHQUFMLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNELEtBTkQsTUFNTyxJQUFJeVgsT0FBTy9WLElBQVAsRUFBYW14QixNQUFiLENBQUosRUFBMEI7QUFDL0I1eUIsVUFBSUQsR0FBSixJQUFXMEIsS0FBS214QixNQUFMLENBQVg7QUFDQSxVQUFJLENBQUNHLFFBQUwsRUFBZTtBQUNiLGVBQU90eEIsS0FBS214QixNQUFMLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFTWCxVQUFULENBQXFCOTBCLElBQXJCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0EsS0FBS2EsSUFBVixFQUFnQjtBQUNkYixTQUFLYSxJQUFMLEdBQVksRUFBWjtBQUNEO0FBQ0QsT0FBSyxJQUFJeEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNjNCLGFBQWF2NEIsTUFBakMsRUFBeUNVLEdBQXpDLEVBQThDO0FBQzVDLFFBQUl1RyxNQUFNc3hCLGFBQWE3M0IsQ0FBYixDQUFWO0FBQ0EsUUFBSXc1QixhQUFhNzFCLEtBQUthLElBQUwsQ0FBVStCLEdBQVYsQ0FBakI7QUFDQSxRQUFJa3pCLE9BQU9wQyxvQkFBb0I5d0IsR0FBcEIsQ0FBWDtBQUNBNUMsU0FBS2EsSUFBTCxDQUFVK0IsR0FBVixJQUFpQml6QixhQUFhRSxZQUFZRCxJQUFaLEVBQWtCRCxVQUFsQixDQUFiLEdBQTZDQyxJQUE5RDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsV0FBVCxDQUFzQkMsR0FBdEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQzlCLFNBQU8sVUFBVW54QixDQUFWLEVBQWFDLENBQWIsRUFBZ0JuRCxDQUFoQixFQUFtQm96QixDQUFuQixFQUFzQjtBQUMzQmdCLFFBQUlseEIsQ0FBSixFQUFPQyxDQUFQLEVBQVVuRCxDQUFWLEVBQWFvekIsQ0FBYjtBQUNBaUIsUUFBSW54QixDQUFKLEVBQU9DLENBQVAsRUFBVW5ELENBQVYsRUFBYW96QixDQUFiO0FBQ0QsR0FIRDtBQUlEOztBQUVEO0FBQ0E7QUFDQSxTQUFTTixjQUFULENBQXlCaHVCLE9BQXpCLEVBQWtDMUcsSUFBbEMsRUFBd0M7QUFDdEMsTUFBSXdtQixPQUFROWYsUUFBUSt0QixLQUFSLElBQWlCL3RCLFFBQVErdEIsS0FBUixDQUFjak8sSUFBaEMsSUFBeUMsT0FBcEQ7QUFDQSxNQUFJcmdCLFFBQVNPLFFBQVErdEIsS0FBUixJQUFpQi90QixRQUFRK3RCLEtBQVIsQ0FBY3R1QixLQUFoQyxJQUEwQyxPQUF0RCxDQUE4RCxDQUFDbkcsS0FBS1IsS0FBTCxLQUFlUSxLQUFLUixLQUFMLEdBQWEsRUFBNUIsQ0FBRCxFQUFrQ2duQixJQUFsQyxJQUEwQ3htQixLQUFLeTBCLEtBQUwsQ0FBV24yQixLQUFyRDtBQUM5RCxNQUFJcEIsS0FBSzhDLEtBQUs5QyxFQUFMLEtBQVk4QyxLQUFLOUMsRUFBTCxHQUFVLEVBQXRCLENBQVQ7QUFDQSxNQUFJQSxHQUFHaUosS0FBSCxDQUFKLEVBQWU7QUFDYmpKLE9BQUdpSixLQUFILElBQVksQ0FBQ25HLEtBQUt5MEIsS0FBTCxDQUFXeUIsUUFBWixFQUFzQnQ2QixNQUF0QixDQUE2QnNCLEdBQUdpSixLQUFILENBQTdCLENBQVo7QUFDRCxHQUZELE1BRU87QUFDTGpKLE9BQUdpSixLQUFILElBQVluRyxLQUFLeTBCLEtBQUwsQ0FBV3lCLFFBQXZCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxJQUFJQyxtQkFBbUIsQ0FBdkI7QUFDQSxJQUFJQyxtQkFBbUIsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBLFNBQVNuQixhQUFULENBQ0VuTSxPQURGLEVBRUVoakIsR0FGRixFQUdFOUYsSUFIRixFQUlFRixRQUpGLEVBS0V1MkIsaUJBTEYsRUFNRUMsZUFORixFQU9FO0FBQ0EsTUFBSW42QixNQUFNbUgsT0FBTixDQUFjdEQsSUFBZCxLQUF1QnNhLFlBQVl0YSxJQUFaLENBQTNCLEVBQThDO0FBQzVDcTJCLHdCQUFvQnYyQixRQUFwQjtBQUNBQSxlQUFXRSxJQUFYO0FBQ0FBLFdBQU9xQixTQUFQO0FBQ0Q7QUFDRCxNQUFJaTFCLGVBQUosRUFBcUI7QUFBRUQsd0JBQW9CRCxnQkFBcEI7QUFBdUM7QUFDOUQsU0FBT0csZUFBZXpOLE9BQWYsRUFBd0JoakIsR0FBeEIsRUFBNkI5RixJQUE3QixFQUFtQ0YsUUFBbkMsRUFBNkN1MkIsaUJBQTdDLENBQVA7QUFDRDs7QUFFRCxTQUFTRSxjQUFULENBQ0V6TixPQURGLEVBRUVoakIsR0FGRixFQUdFOUYsSUFIRixFQUlFRixRQUpGLEVBS0V1MkIsaUJBTEYsRUFNRTtBQUNBLE1BQUlyMkIsUUFBUUEsS0FBS3FpQixNQUFqQixFQUF5QjtBQUN2Qi9uQixZQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3ZELEtBQ3ZDLHFEQUFzRHFPLEtBQUtDLFNBQUwsQ0FBZTFOLElBQWYsQ0FBdEQsR0FBOEUsSUFBOUUsR0FDQSx3REFGdUMsRUFHdkM4b0IsT0FIdUMsQ0FBekM7QUFLQSxXQUFPUyxrQkFBUDtBQUNEO0FBQ0QsTUFBSSxDQUFDempCLEdBQUwsRUFBVTtBQUNSO0FBQ0EsV0FBT3lqQixrQkFBUDtBQUNEO0FBQ0Q7QUFDQSxNQUFJcHRCLE1BQU1tSCxPQUFOLENBQWN4RCxRQUFkLEtBQ0EsT0FBT0EsU0FBUyxDQUFULENBQVAsS0FBdUIsVUFEM0IsRUFDdUM7QUFDckNFLFdBQU9BLFFBQVEsRUFBZjtBQUNBQSxTQUFLZ3ZCLFdBQUwsR0FBbUIsRUFBRXp3QixTQUFTdUIsU0FBUyxDQUFULENBQVgsRUFBbkI7QUFDQUEsYUFBU25FLE1BQVQsR0FBa0IsQ0FBbEI7QUFDRDtBQUNELE1BQUkwNkIsc0JBQXNCRCxnQkFBMUIsRUFBNEM7QUFDMUN0MkIsZUFBV2dyQixrQkFBa0JockIsUUFBbEIsQ0FBWDtBQUNELEdBRkQsTUFFTyxJQUFJdTJCLHNCQUFzQkYsZ0JBQTFCLEVBQTRDO0FBQ2pEcjJCLGVBQVcrcUIsd0JBQXdCL3FCLFFBQXhCLENBQVg7QUFDRDtBQUNELE1BQUlpQixLQUFKLEVBQVdpb0IsRUFBWDtBQUNBLE1BQUksT0FBT2xqQixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsUUFBSXNZLElBQUo7QUFDQTRLLFNBQUt6bkIsT0FBT29iLGVBQVAsQ0FBdUI3VyxHQUF2QixDQUFMO0FBQ0EsUUFBSXZFLE9BQU9rYixhQUFQLENBQXFCM1csR0FBckIsQ0FBSixFQUErQjtBQUM3QjtBQUNBL0UsY0FBUSxJQUFJNG5CLEtBQUosQ0FDTnBuQixPQUFPcWIsb0JBQVAsQ0FBNEI5VyxHQUE1QixDQURNLEVBQzRCOUYsSUFENUIsRUFDa0NGLFFBRGxDLEVBRU51QixTQUZNLEVBRUtBLFNBRkwsRUFFZ0J5bkIsT0FGaEIsQ0FBUjtBQUlELEtBTkQsTUFNTyxJQUFLMUssT0FBTzZILGFBQWE2QyxRQUFRdGdCLFFBQXJCLEVBQStCLFlBQS9CLEVBQTZDMUMsR0FBN0MsQ0FBWixFQUFnRTtBQUNyRTtBQUNBL0UsY0FBUW96QixnQkFBZ0IvVixJQUFoQixFQUFzQnBlLElBQXRCLEVBQTRCOG9CLE9BQTVCLEVBQXFDaHBCLFFBQXJDLEVBQStDZ0csR0FBL0MsQ0FBUjtBQUNELEtBSE0sTUFHQTtBQUNMO0FBQ0E7QUFDQTtBQUNBL0UsY0FBUSxJQUFJNG5CLEtBQUosQ0FDTjdpQixHQURNLEVBQ0Q5RixJQURDLEVBQ0tGLFFBREwsRUFFTnVCLFNBRk0sRUFFS0EsU0FGTCxFQUVnQnluQixPQUZoQixDQUFSO0FBSUQ7QUFDRixHQXJCRCxNQXFCTztBQUNMO0FBQ0EvbkIsWUFBUW96QixnQkFBZ0JydUIsR0FBaEIsRUFBcUI5RixJQUFyQixFQUEyQjhvQixPQUEzQixFQUFvQ2hwQixRQUFwQyxDQUFSO0FBQ0Q7QUFDRCxNQUFJaUIsS0FBSixFQUFXO0FBQ1QsUUFBSWlvQixFQUFKLEVBQVE7QUFBRXdOLGNBQVF6MUIsS0FBUixFQUFlaW9CLEVBQWY7QUFBcUI7QUFDL0IsV0FBT2pvQixLQUFQO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsV0FBT3dvQixrQkFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2lOLE9BQVQsQ0FBa0J6MUIsS0FBbEIsRUFBeUJpb0IsRUFBekIsRUFBNkI7QUFDM0Jqb0IsUUFBTWlvQixFQUFOLEdBQVdBLEVBQVg7QUFDQSxNQUFJam9CLE1BQU0rRSxHQUFOLEtBQWMsZUFBbEIsRUFBbUM7QUFDakM7QUFDQTtBQUNEO0FBQ0QsTUFBSS9FLE1BQU1qQixRQUFWLEVBQW9CO0FBQ2xCLFNBQUssSUFBSXpELElBQUksQ0FBUixFQUFXMmUsSUFBSWphLE1BQU1qQixRQUFOLENBQWVuRSxNQUFuQyxFQUEyQ1UsSUFBSTJlLENBQS9DLEVBQWtEM2UsR0FBbEQsRUFBdUQ7QUFDckQsVUFBSTRFLFFBQVFGLE1BQU1qQixRQUFOLENBQWV6RCxDQUFmLENBQVo7QUFDQSxVQUFJNEUsTUFBTTZFLEdBQU4sSUFBYSxDQUFDN0UsTUFBTStuQixFQUF4QixFQUE0QjtBQUMxQndOLGdCQUFRdjFCLEtBQVIsRUFBZStuQixFQUFmO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFNBQVN5TixVQUFULENBQ0VyekIsR0FERixFQUVFekQsTUFGRixFQUdFO0FBQ0EsTUFBSXliLEdBQUosRUFBUy9lLENBQVQsRUFBWTJlLENBQVosRUFBZXZYLElBQWYsRUFBcUJiLEdBQXJCO0FBQ0EsTUFBSXpHLE1BQU1tSCxPQUFOLENBQWNGLEdBQWQsS0FBc0IsT0FBT0EsR0FBUCxLQUFlLFFBQXpDLEVBQW1EO0FBQ2pEZ1ksVUFBTSxJQUFJamYsS0FBSixDQUFVaUgsSUFBSXpILE1BQWQsQ0FBTjtBQUNBLFNBQUtVLElBQUksQ0FBSixFQUFPMmUsSUFBSTVYLElBQUl6SCxNQUFwQixFQUE0QlUsSUFBSTJlLENBQWhDLEVBQW1DM2UsR0FBbkMsRUFBd0M7QUFDdEMrZSxVQUFJL2UsQ0FBSixJQUFTc0QsT0FBT3lELElBQUkvRyxDQUFKLENBQVAsRUFBZUEsQ0FBZixDQUFUO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSSxPQUFPK0csR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDZ1ksVUFBTSxJQUFJamYsS0FBSixDQUFVaUgsR0FBVixDQUFOO0FBQ0EsU0FBSy9HLElBQUksQ0FBVCxFQUFZQSxJQUFJK0csR0FBaEIsRUFBcUIvRyxHQUFyQixFQUEwQjtBQUN4QitlLFVBQUkvZSxDQUFKLElBQVNzRCxPQUFPdEQsSUFBSSxDQUFYLEVBQWNBLENBQWQsQ0FBVDtBQUNEO0FBQ0YsR0FMTSxNQUtBLElBQUlrVixTQUFTbk8sR0FBVCxDQUFKLEVBQW1CO0FBQ3hCSyxXQUFPckYsT0FBT3FGLElBQVAsQ0FBWUwsR0FBWixDQUFQO0FBQ0FnWSxVQUFNLElBQUlqZixLQUFKLENBQVVzSCxLQUFLOUgsTUFBZixDQUFOO0FBQ0EsU0FBS1UsSUFBSSxDQUFKLEVBQU8yZSxJQUFJdlgsS0FBSzlILE1BQXJCLEVBQTZCVSxJQUFJMmUsQ0FBakMsRUFBb0MzZSxHQUFwQyxFQUF5QztBQUN2Q3VHLFlBQU1hLEtBQUtwSCxDQUFMLENBQU47QUFDQStlLFVBQUkvZSxDQUFKLElBQVNzRCxPQUFPeUQsSUFBSVIsR0FBSixDQUFQLEVBQWlCQSxHQUFqQixFQUFzQnZHLENBQXRCLENBQVQ7QUFDRDtBQUNGO0FBQ0QsU0FBTytlLEdBQVA7QUFDRDs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBU3NiLFVBQVQsQ0FDRWg1QixJQURGLEVBRUV1YSxRQUZGLEVBR0V6WSxLQUhGLEVBSUVtM0IsVUFKRixFQUtFO0FBQ0EsTUFBSUMsZUFBZSxLQUFLM0gsWUFBTCxDQUFrQnZ4QixJQUFsQixDQUFuQjtBQUNBLE1BQUlrNUIsWUFBSixFQUFrQjtBQUFFO0FBQ2xCcDNCLFlBQVFBLFNBQVMsRUFBakI7QUFDQSxRQUFJbTNCLFVBQUosRUFBZ0I7QUFDZHR2QixhQUFPN0gsS0FBUCxFQUFjbTNCLFVBQWQ7QUFDRDtBQUNELFdBQU9DLGFBQWFwM0IsS0FBYixLQUF1QnlZLFFBQTlCO0FBQ0QsR0FORCxNQU1PO0FBQ0wsUUFBSTRlLFlBQVksS0FBSzF2QixNQUFMLENBQVl6SixJQUFaLENBQWhCO0FBQ0E7QUFDQSxRQUFJbTVCLGFBQWF2OEIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBMUMsRUFBd0Q7QUFDdERrMEIsZ0JBQVVDLFNBQVYsSUFBdUIxM0IsS0FDckIsa0NBQWtDMUIsSUFBbEMsR0FBeUMsbUNBQXpDLEdBQ0EseUNBRnFCLEVBR3JCLElBSHFCLENBQXZCO0FBS0FtNUIsZ0JBQVVDLFNBQVYsR0FBc0IsSUFBdEI7QUFDRDtBQUNELFdBQU9ELGFBQWE1ZSxRQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFNBQVM4ZSxhQUFULENBQXdCOVYsRUFBeEIsRUFBNEI7QUFDMUIsU0FBT2dGLGFBQWEsS0FBS3pkLFFBQWxCLEVBQTRCLFNBQTVCLEVBQXVDeVksRUFBdkMsRUFBMkMsSUFBM0MsS0FBb0R2RixRQUEzRDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxTQUFTc2IsYUFBVCxDQUNFQyxZQURGLEVBRUVyMEIsR0FGRixFQUdFczBCLFlBSEYsRUFJRTtBQUNBLE1BQUkxYSxXQUFXamIsT0FBT2liLFFBQVAsQ0FBZ0I1WixHQUFoQixLQUF3QnMwQixZQUF2QztBQUNBLE1BQUkvNkIsTUFBTW1ILE9BQU4sQ0FBY2taLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixXQUFPQSxTQUFTalgsT0FBVCxDQUFpQjB4QixZQUFqQixNQUFtQyxDQUFDLENBQTNDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT3phLGFBQWF5YSxZQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFNBQVNFLGVBQVQsQ0FDRW4zQixJQURGLEVBRUU4RixHQUZGLEVBR0V4SCxLQUhGLEVBSUU4NEIsTUFKRixFQUtFO0FBQ0EsTUFBSTk0QixLQUFKLEVBQVc7QUFDVCxRQUFJLENBQUNpVCxTQUFTalQsS0FBVCxDQUFMLEVBQXNCO0FBQ3BCaEUsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUN2RCxLQUN2QywwREFEdUMsRUFFdkMsSUFGdUMsQ0FBekM7QUFJRCxLQUxELE1BS087QUFDTCxVQUFJakQsTUFBTW1ILE9BQU4sQ0FBY2hGLEtBQWQsQ0FBSixFQUEwQjtBQUN4QkEsZ0JBQVFrZCxTQUFTbGQsS0FBVCxDQUFSO0FBQ0Q7QUFDRCxVQUFJZ0csSUFBSjtBQUNBLFdBQUssSUFBSTFCLEdBQVQsSUFBZ0J0RSxLQUFoQixFQUF1QjtBQUNyQixZQUFJc0UsUUFBUSxPQUFSLElBQW1CQSxRQUFRLE9BQS9CLEVBQXdDO0FBQ3RDMEIsaUJBQU90RSxJQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsY0FBSVAsT0FBT08sS0FBS2lILEtBQUwsSUFBY2pILEtBQUtpSCxLQUFMLENBQVd4SCxJQUFwQztBQUNBNkUsaUJBQU84eUIsVUFBVTcxQixPQUFPc2IsV0FBUCxDQUFtQi9XLEdBQW5CLEVBQXdCckcsSUFBeEIsRUFBOEJtRCxHQUE5QixDQUFWLEdBQ0g1QyxLQUFLdzFCLFFBQUwsS0FBa0J4MUIsS0FBS3cxQixRQUFMLEdBQWdCLEVBQWxDLENBREcsR0FFSHgxQixLQUFLaUgsS0FBTCxLQUFlakgsS0FBS2lILEtBQUwsR0FBYSxFQUE1QixDQUZKO0FBR0Q7QUFDRCxZQUFJLEVBQUVyRSxPQUFPMEIsSUFBVCxDQUFKLEVBQW9CO0FBQ2xCQSxlQUFLMUIsR0FBTCxJQUFZdEUsTUFBTXNFLEdBQU4sQ0FBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsU0FBTzVDLElBQVA7QUFDRDs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBU3EzQixZQUFULENBQ0VsNUIsS0FERixFQUVFbTVCLE9BRkYsRUFHRTtBQUNBLE1BQUlDLE9BQU8sS0FBS0MsWUFBTCxDQUFrQnI1QixLQUFsQixDQUFYO0FBQ0E7QUFDQTtBQUNBLE1BQUlvNUIsUUFBUSxDQUFDRCxPQUFiLEVBQXNCO0FBQ3BCLFdBQU9uN0IsTUFBTW1ILE9BQU4sQ0FBY2kwQixJQUFkLElBQ0gzTixZQUFZMk4sSUFBWixDQURHLEdBRUg3TixXQUFXNk4sSUFBWCxDQUZKO0FBR0Q7QUFDRDtBQUNBQSxTQUFPLEtBQUtDLFlBQUwsQ0FBa0JyNUIsS0FBbEIsSUFDTCxLQUFLcUssUUFBTCxDQUFjNnNCLGVBQWQsQ0FBOEJsM0IsS0FBOUIsRUFBcUNoRCxJQUFyQyxDQUEwQyxLQUFLZ3RCLFlBQS9DLENBREY7QUFFQXNQLGFBQVdGLElBQVgsRUFBa0IsZUFBZXA1QixLQUFqQyxFQUF5QyxLQUF6QztBQUNBLFNBQU9vNUIsSUFBUDtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU0csUUFBVCxDQUNFSCxJQURGLEVBRUVwNUIsS0FGRixFQUdFeUUsR0FIRixFQUlFO0FBQ0E2MEIsYUFBV0YsSUFBWCxFQUFrQixhQUFhcDVCLEtBQWIsSUFBc0J5RSxNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBMUMsQ0FBbEIsRUFBa0UsSUFBbEU7QUFDQSxTQUFPMjBCLElBQVA7QUFDRDs7QUFFRCxTQUFTRSxVQUFULENBQ0VGLElBREYsRUFFRTMwQixHQUZGLEVBR0UwbUIsTUFIRixFQUlFO0FBQ0EsTUFBSW50QixNQUFNbUgsT0FBTixDQUFjaTBCLElBQWQsQ0FBSixFQUF5QjtBQUN2QixTQUFLLElBQUlsN0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJazdCLEtBQUs1N0IsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDLFVBQUlrN0IsS0FBS2w3QixDQUFMLEtBQVcsT0FBT2s3QixLQUFLbDdCLENBQUwsQ0FBUCxLQUFtQixRQUFsQyxFQUE0QztBQUMxQ3M3Qix1QkFBZUosS0FBS2w3QixDQUFMLENBQWYsRUFBeUJ1RyxNQUFNLEdBQU4sR0FBWXZHLENBQXJDLEVBQXlDaXRCLE1BQXpDO0FBQ0Q7QUFDRjtBQUNGLEdBTkQsTUFNTztBQUNMcU8sbUJBQWVKLElBQWYsRUFBcUIzMEIsR0FBckIsRUFBMEIwbUIsTUFBMUI7QUFDRDtBQUNGOztBQUVELFNBQVNxTyxjQUFULENBQXlCbk8sSUFBekIsRUFBK0I1bUIsR0FBL0IsRUFBb0MwbUIsTUFBcEMsRUFBNEM7QUFDMUNFLE9BQUtwaUIsUUFBTCxHQUFnQixJQUFoQjtBQUNBb2lCLE9BQUs1bUIsR0FBTCxHQUFXQSxHQUFYO0FBQ0E0bUIsT0FBS0YsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU3NPLFVBQVQsQ0FBcUJwWCxFQUFyQixFQUF5QjtBQUN2QkEsS0FBR2pnQixNQUFILEdBQVksSUFBWixDQUR1QixDQUNMO0FBQ2xCaWdCLEtBQUdrTixNQUFILEdBQVksSUFBWixDQUZ1QixDQUVMO0FBQ2xCbE4sS0FBR2dYLFlBQUgsR0FBa0IsSUFBbEI7QUFDQSxNQUFJNUksY0FBY3BPLEdBQUdoWSxRQUFILENBQVkwbUIsWUFBOUI7QUFDQSxNQUFJMkksZ0JBQWdCakosZUFBZUEsWUFBWTlGLE9BQS9DO0FBQ0F0SSxLQUFHclosTUFBSCxHQUFZZ2xCLGFBQWEzTCxHQUFHaFksUUFBSCxDQUFZdW1CLGVBQXpCLEVBQTBDOEksYUFBMUMsQ0FBWjtBQUNBclgsS0FBR3lPLFlBQUgsR0FBa0JoUyxXQUFsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F1RCxLQUFHc1gsRUFBSCxHQUFRLFVBQVVoekIsQ0FBVixFQUFhQyxDQUFiLEVBQWdCbkQsQ0FBaEIsRUFBbUJvekIsQ0FBbkIsRUFBc0I7QUFBRSxXQUFPQyxjQUFjelUsRUFBZCxFQUFrQjFiLENBQWxCLEVBQXFCQyxDQUFyQixFQUF3Qm5ELENBQXhCLEVBQTJCb3pCLENBQTNCLEVBQThCLEtBQTlCLENBQVA7QUFBOEMsR0FBOUU7QUFDQTtBQUNBO0FBQ0F4VSxLQUFHdVgsY0FBSCxHQUFvQixVQUFVanpCLENBQVYsRUFBYUMsQ0FBYixFQUFnQm5ELENBQWhCLEVBQW1Cb3pCLENBQW5CLEVBQXNCO0FBQUUsV0FBT0MsY0FBY3pVLEVBQWQsRUFBa0IxYixDQUFsQixFQUFxQkMsQ0FBckIsRUFBd0JuRCxDQUF4QixFQUEyQm96QixDQUEzQixFQUE4QixJQUE5QixDQUFQO0FBQTZDLEdBQXpGO0FBQ0Q7O0FBRUQsU0FBU2dELFdBQVQsQ0FBc0J2NUIsR0FBdEIsRUFBMkI7QUFDekJBLE1BQUloQyxTQUFKLENBQWMwVSxTQUFkLEdBQTBCLFVBQVV5QyxFQUFWLEVBQWM7QUFDdEMsV0FBTzNYLFNBQVMyWCxFQUFULEVBQWEsSUFBYixDQUFQO0FBQ0QsR0FGRDs7QUFJQW5WLE1BQUloQyxTQUFKLENBQWNneUIsT0FBZCxHQUF3QixZQUFZO0FBQ2xDLFFBQUlqTyxLQUFLLElBQVQ7QUFDQSxRQUFJM2dCLE1BQU0yZ0IsR0FBR2hZLFFBQWI7QUFDQSxRQUFJN0ksU0FBU0UsSUFBSUYsTUFBakI7QUFDQSxRQUFJMDFCLGtCQUFrQngxQixJQUFJdzFCLGVBQTFCO0FBQ0EsUUFBSW5HLGVBQWVydkIsSUFBSXF2QixZQUF2Qjs7QUFFQSxRQUFJMU8sR0FBR3dNLFVBQVAsRUFBbUI7QUFDakI7QUFDQSxXQUFLLElBQUlwcUIsR0FBVCxJQUFnQjRkLEdBQUdyWixNQUFuQixFQUEyQjtBQUN6QnFaLFdBQUdyWixNQUFILENBQVV2RSxHQUFWLElBQWlCZ25CLFlBQVlwSixHQUFHclosTUFBSCxDQUFVdkUsR0FBVixDQUFaLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRDRkLE9BQUd5TyxZQUFILEdBQW1CQyxnQkFBZ0JBLGFBQWFsdkIsSUFBYixDQUFrQmd2QixXQUFuQyxJQUFtRC9SLFdBQXJFOztBQUVBLFFBQUlvWSxtQkFBbUIsQ0FBQzdVLEdBQUdnWCxZQUEzQixFQUF5QztBQUN2Q2hYLFNBQUdnWCxZQUFILEdBQWtCLEVBQWxCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0FoWCxPQUFHamdCLE1BQUgsR0FBWTJ1QixZQUFaO0FBQ0E7QUFDQSxRQUFJbnVCLEtBQUo7QUFDQSxRQUFJO0FBQ0ZBLGNBQVFwQixPQUFPeEUsSUFBUCxDQUFZcWxCLEdBQUcySCxZQUFmLEVBQTZCM0gsR0FBR3VYLGNBQWhDLENBQVI7QUFDRCxLQUZELENBRUUsT0FBT2g5QixDQUFQLEVBQVU7QUFDVnVzQixrQkFBWXZzQixDQUFaLEVBQWV5bEIsRUFBZixFQUFtQixpQkFBbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJbG1CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNUIsZ0JBQVF5ZixHQUFHaFksUUFBSCxDQUFZeXZCLFdBQVosR0FDSnpYLEdBQUdoWSxRQUFILENBQVl5dkIsV0FBWixDQUF3Qjk4QixJQUF4QixDQUE2QnFsQixHQUFHMkgsWUFBaEMsRUFBOEMzSCxHQUFHdVgsY0FBakQsRUFBaUVoOUIsQ0FBakUsQ0FESSxHQUVKeWxCLEdBQUdrTixNQUZQO0FBR0QsT0FKRCxNQUlPO0FBQ0wzc0IsZ0JBQVF5ZixHQUFHa04sTUFBWDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFFBQUksRUFBRTNzQixpQkFBaUI0bkIsS0FBbkIsQ0FBSixFQUErQjtBQUM3QixVQUFJcnVCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDeEcsTUFBTW1ILE9BQU4sQ0FBY3ZDLEtBQWQsQ0FBN0MsRUFBbUU7QUFDakUzQixhQUNFLHdFQUNBLG1DQUZGLEVBR0VvaEIsRUFIRjtBQUtEO0FBQ0R6ZixjQUFRd29CLGtCQUFSO0FBQ0Q7QUFDRDtBQUNBeG9CLFVBQU1oQixNQUFOLEdBQWVtdkIsWUFBZjtBQUNBLFdBQU9udUIsS0FBUDtBQUNELEdBckREOztBQXVEQTtBQUNBO0FBQ0E7QUFDQXRDLE1BQUloQyxTQUFKLENBQWN5N0IsRUFBZCxHQUFtQlIsUUFBbkI7QUFDQWo1QixNQUFJaEMsU0FBSixDQUFjMDdCLEVBQWQsR0FBbUJ6ZSxRQUFuQjtBQUNBamIsTUFBSWhDLFNBQUosQ0FBYzI3QixFQUFkLEdBQW1CM2UsU0FBbkI7QUFDQWhiLE1BQUloQyxTQUFKLENBQWM0N0IsRUFBZCxHQUFtQjVCLFVBQW5CO0FBQ0FoNEIsTUFBSWhDLFNBQUosQ0FBYzY3QixFQUFkLEdBQW1CNUIsVUFBbkI7QUFDQWo0QixNQUFJaEMsU0FBSixDQUFjODdCLEVBQWQsR0FBbUJ4YyxVQUFuQjtBQUNBdGQsTUFBSWhDLFNBQUosQ0FBYys3QixFQUFkLEdBQW1CdGMsWUFBbkI7QUFDQXpkLE1BQUloQyxTQUFKLENBQWNnOEIsRUFBZCxHQUFtQnBCLFlBQW5CO0FBQ0E1NEIsTUFBSWhDLFNBQUosQ0FBY2k4QixFQUFkLEdBQW1CM0IsYUFBbkI7QUFDQXQ0QixNQUFJaEMsU0FBSixDQUFjazhCLEVBQWQsR0FBbUIzQixhQUFuQjtBQUNBdjRCLE1BQUloQyxTQUFKLENBQWNtOEIsRUFBZCxHQUFtQnpCLGVBQW5CO0FBQ0ExNEIsTUFBSWhDLFNBQUosQ0FBY284QixFQUFkLEdBQW1CcFAsZUFBbkI7QUFDQWhyQixNQUFJaEMsU0FBSixDQUFjcThCLEVBQWQsR0FBbUJ2UCxnQkFBbkI7QUFDQTlxQixNQUFJaEMsU0FBSixDQUFjczhCLEVBQWQsR0FBbUJ2TSxrQkFBbkI7QUFDRDs7QUFFRDs7QUFFQSxTQUFTd00sV0FBVCxDQUFzQnhZLEVBQXRCLEVBQTBCO0FBQ3hCLE1BQUl5WSxVQUFVelksR0FBR2hZLFFBQUgsQ0FBWXl3QixPQUExQjtBQUNBLE1BQUlBLE9BQUosRUFBYTtBQUNYelksT0FBRzBZLFNBQUgsR0FBZSxPQUFPRCxPQUFQLEtBQW1CLFVBQW5CLEdBQ1hBLFFBQVE5OUIsSUFBUixDQUFhcWxCLEVBQWIsQ0FEVyxHQUVYeVksT0FGSjtBQUdEO0FBQ0Y7O0FBRUQsU0FBU0UsY0FBVCxDQUF5QjNZLEVBQXpCLEVBQTZCO0FBQzNCLE1BQUk0WSxTQUFTNVksR0FBR2hZLFFBQUgsQ0FBWTR3QixNQUF6QjtBQUNBLE1BQUlBLE1BQUosRUFBWTtBQUNWO0FBQ0E7QUFDQSxRQUFJOTFCLFVBQVVuSCxNQUFNbUgsT0FBTixDQUFjODFCLE1BQWQsQ0FBZDtBQUNBLFFBQUkzMUIsT0FBT0gsVUFDUDgxQixNQURPLEdBRVAvYSxZQUNFRSxRQUFRQyxPQUFSLENBQWdCNGEsTUFBaEIsQ0FERixHQUVFaDdCLE9BQU9xRixJQUFQLENBQVkyMUIsTUFBWixDQUpOOztBQU1BLFFBQUk3RyxPQUFPLFVBQVdsMkIsQ0FBWCxFQUFlO0FBQ3hCLFVBQUl1RyxNQUFNYSxLQUFLcEgsQ0FBTCxDQUFWO0FBQ0EsVUFBSWc5QixhQUFhLzFCLFVBQVVWLEdBQVYsR0FBZ0J3MkIsT0FBT3gyQixHQUFQLENBQWpDO0FBQ0EsVUFBSXNMLFNBQVNzUyxFQUFiO0FBQ0EsYUFBT3RTLE1BQVAsRUFBZTtBQUNiLFlBQUlBLE9BQU9nckIsU0FBUCxJQUFvQkcsY0FBY25yQixPQUFPZ3JCLFNBQTdDLEVBQXdEO0FBQ3REO0FBQ0EsY0FBSTUrQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3lnQiw4QkFBa0I1QyxFQUFsQixFQUFzQjVkLEdBQXRCLEVBQTJCc0wsT0FBT2dyQixTQUFQLENBQWlCRyxVQUFqQixDQUEzQixFQUF5RCxZQUFZO0FBQ25FajZCLG1CQUNFLHlFQUNBLDBEQURBLEdBRUEsNkJBRkEsR0FFZ0N3RCxHQUZoQyxHQUVzQyxJQUh4QyxFQUlFNGQsRUFKRjtBQU1ELGFBUEQ7QUFRRCxXQVRELE1BU087QUFDTDRDLDhCQUFrQjVDLEVBQWxCLEVBQXNCNWQsR0FBdEIsRUFBMkJzTCxPQUFPZ3JCLFNBQVAsQ0FBaUJHLFVBQWpCLENBQTNCO0FBQ0Q7QUFDRDtBQUNEO0FBQ0RuckIsaUJBQVNBLE9BQU96TixPQUFoQjtBQUNEO0FBQ0YsS0F2QkQ7O0FBeUJBLFNBQUssSUFBSXBFLElBQUksQ0FBYixFQUFnQkEsSUFBSW9ILEtBQUs5SCxNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0NrMkIsS0FBTWwyQixDQUFOO0FBQ3ZDO0FBQ0Y7O0FBRUQ7O0FBRUEsSUFBSWk5QixNQUFNLENBQVY7O0FBRUEsU0FBU0MsU0FBVCxDQUFvQjk2QixHQUFwQixFQUF5QjtBQUN2QkEsTUFBSWhDLFNBQUosQ0FBYys4QixLQUFkLEdBQXNCLFVBQVU5eUIsT0FBVixFQUFtQjtBQUN2QyxRQUFJOFosS0FBSyxJQUFUO0FBQ0E7QUFDQUEsT0FBR2dPLElBQUgsR0FBVThLLEtBQVY7O0FBRUEsUUFBSTdRLFFBQUosRUFBY0MsTUFBZDtBQUNBO0FBQ0EsUUFBSXB1QixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BCLE9BQU8yUixXQUFoRCxJQUErRGtWLElBQW5FLEVBQXlFO0FBQ3ZFSyxpQkFBVyxtQkFBb0JqSSxHQUFHZ08sSUFBbEM7QUFDQTlGLGVBQVMsa0JBQW1CbEksR0FBR2dPLElBQS9CO0FBQ0FwRyxXQUFLSyxRQUFMO0FBQ0Q7O0FBRUQ7QUFDQWpJLE9BQUdHLE1BQUgsR0FBWSxJQUFaO0FBQ0E7QUFDQSxRQUFJamEsV0FBV0EsUUFBUXl1QixZQUF2QixFQUFxQztBQUNuQztBQUNBO0FBQ0E7QUFDQXNFLDRCQUFzQmpaLEVBQXRCLEVBQTBCOVosT0FBMUI7QUFDRCxLQUxELE1BS087QUFDTDhaLFNBQUdoWSxRQUFILEdBQWNrZCxhQUNaOE8sMEJBQTBCaFUsR0FBRzdJLFdBQTdCLENBRFksRUFFWmpSLFdBQVcsRUFGQyxFQUdaOFosRUFIWSxDQUFkO0FBS0Q7QUFDRDtBQUNBLFFBQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2a0IsZ0JBQVVoSCxFQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBLFNBQUcySCxZQUFILEdBQWtCM0gsRUFBbEI7QUFDRDtBQUNEO0FBQ0FBLE9BQUdrWixLQUFILEdBQVdsWixFQUFYO0FBQ0FrTSxrQkFBY2xNLEVBQWQ7QUFDQTJLLGVBQVczSyxFQUFYO0FBQ0FvWCxlQUFXcFgsRUFBWDtBQUNBOE0sYUFBUzlNLEVBQVQsRUFBYSxjQUFiO0FBQ0EyWSxtQkFBZTNZLEVBQWYsRUF4Q3VDLENBd0NuQjtBQUNwQnNSLGNBQVV0UixFQUFWO0FBQ0F3WSxnQkFBWXhZLEVBQVosRUExQ3VDLENBMEN0QjtBQUNqQjhNLGFBQVM5TSxFQUFULEVBQWEsU0FBYjs7QUFFQTtBQUNBLFFBQUlsbUIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNwQixPQUFPMlIsV0FBaEQsSUFBK0RrVixJQUFuRSxFQUF5RTtBQUN2RTVILFNBQUcrTixLQUFILEdBQVdwTyxvQkFBb0JLLEVBQXBCLEVBQXdCLEtBQXhCLENBQVg7QUFDQTRILFdBQUtNLE1BQUw7QUFDQUwsY0FBVTdILEdBQUcrTixLQUFKLEdBQWEsT0FBdEIsRUFBZ0M5RixRQUFoQyxFQUEwQ0MsTUFBMUM7QUFDRDs7QUFFRCxRQUFJbEksR0FBR2hZLFFBQUgsQ0FBWWlKLEVBQWhCLEVBQW9CO0FBQ2xCK08sU0FBR3NULE1BQUgsQ0FBVXRULEdBQUdoWSxRQUFILENBQVlpSixFQUF0QjtBQUNEO0FBQ0YsR0F2REQ7QUF3REQ7O0FBRUQsU0FBU2dvQixxQkFBVCxDQUFnQ2paLEVBQWhDLEVBQW9DOVosT0FBcEMsRUFBNkM7QUFDM0MsTUFBSTJHLE9BQU9tVCxHQUFHaFksUUFBSCxHQUFjcEssT0FBTytMLE1BQVAsQ0FBY3FXLEdBQUc3SSxXQUFILENBQWVqUixPQUE3QixDQUF6QjtBQUNBO0FBQ0EyRyxPQUFLdE4sTUFBTCxHQUFjMkcsUUFBUTNHLE1BQXRCO0FBQ0FzTixPQUFLK1csU0FBTCxHQUFpQjFkLFFBQVEwZCxTQUF6QjtBQUNBL1csT0FBSzZoQixZQUFMLEdBQW9CeG9CLFFBQVF3b0IsWUFBNUI7QUFDQTdoQixPQUFLa2UsZ0JBQUwsR0FBd0I3a0IsUUFBUTZrQixnQkFBaEM7QUFDQWxlLE9BQUswaEIsZUFBTCxHQUF1QnJvQixRQUFRcW9CLGVBQS9CO0FBQ0ExaEIsT0FBS3VULGFBQUwsR0FBcUJsYSxRQUFRa2EsYUFBN0I7QUFDQXZULE9BQUt3Z0IsVUFBTCxHQUFrQm5uQixRQUFRbW5CLFVBQTFCO0FBQ0F4Z0IsT0FBS3lnQixPQUFMLEdBQWVwbkIsUUFBUW9uQixPQUF2QjtBQUNBLE1BQUlwbkIsUUFBUS9HLE1BQVosRUFBb0I7QUFDbEIwTixTQUFLMU4sTUFBTCxHQUFjK0csUUFBUS9HLE1BQXRCO0FBQ0EwTixTQUFLZ29CLGVBQUwsR0FBdUIzdUIsUUFBUTJ1QixlQUEvQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2IseUJBQVQsQ0FBb0NwVyxJQUFwQyxFQUEwQztBQUN4QyxNQUFJMVgsVUFBVTBYLEtBQUsxWCxPQUFuQjtBQUNBLE1BQUkwWCxLQUFLdWIsS0FBVCxFQUFnQjtBQUNkLFFBQUlDLGVBQWVwRiwwQkFBMEJwVyxLQUFLdWIsS0FBL0IsQ0FBbkI7QUFDQSxRQUFJRSxxQkFBcUJ6YixLQUFLd2IsWUFBOUI7QUFDQSxRQUFJQSxpQkFBaUJDLGtCQUFyQixFQUF5QztBQUN2QztBQUNBO0FBQ0F6YixXQUFLd2IsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQTtBQUNBLFVBQUlFLGtCQUFrQkMsdUJBQXVCM2IsSUFBdkIsQ0FBdEI7QUFDQTtBQUNBLFVBQUkwYixlQUFKLEVBQXFCO0FBQ25CenlCLGVBQU8rVyxLQUFLNGIsYUFBWixFQUEyQkYsZUFBM0I7QUFDRDtBQUNEcHpCLGdCQUFVMFgsS0FBSzFYLE9BQUwsR0FBZWdmLGFBQWFrVSxZQUFiLEVBQTJCeGIsS0FBSzRiLGFBQWhDLENBQXpCO0FBQ0EsVUFBSXR6QixRQUFRaEosSUFBWixFQUFrQjtBQUNoQmdKLGdCQUFRL0YsVUFBUixDQUFtQitGLFFBQVFoSixJQUEzQixJQUFtQzBnQixJQUFuQztBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU8xWCxPQUFQO0FBQ0Q7O0FBRUQsU0FBU3F6QixzQkFBVCxDQUFpQzNiLElBQWpDLEVBQXVDO0FBQ3JDLE1BQUk2YixRQUFKO0FBQ0EsTUFBSUMsU0FBUzliLEtBQUsxWCxPQUFsQjtBQUNBLE1BQUl5ekIsU0FBUy9iLEtBQUtnYyxhQUFsQjtBQUNBLE9BQUssSUFBSXgzQixHQUFULElBQWdCczNCLE1BQWhCLEVBQXdCO0FBQ3RCLFFBQUlBLE9BQU90M0IsR0FBUCxNQUFnQnUzQixPQUFPdjNCLEdBQVAsQ0FBcEIsRUFBaUM7QUFDL0IsVUFBSSxDQUFDcTNCLFFBQUwsRUFBZTtBQUFFQSxtQkFBVyxFQUFYO0FBQWdCO0FBQ2pDQSxlQUFTcjNCLEdBQVQsSUFBZ0J5M0IsT0FBT0gsT0FBT3QzQixHQUFQLENBQVAsRUFBb0J1M0IsT0FBT3YzQixHQUFQLENBQXBCLENBQWhCO0FBQ0Q7QUFDRjtBQUNELFNBQU9xM0IsUUFBUDtBQUNEOztBQUVELFNBQVNJLE1BQVQsQ0FBaUJILE1BQWpCLEVBQXlCQyxNQUF6QixFQUFpQztBQUMvQjtBQUNBO0FBQ0EsTUFBSWgrQixNQUFNbUgsT0FBTixDQUFjNDJCLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixRQUFJcjNCLE1BQU0sRUFBVjtBQUNBczNCLGFBQVNoK0IsTUFBTW1ILE9BQU4sQ0FBYzYyQixNQUFkLElBQXdCQSxNQUF4QixHQUFpQyxDQUFDQSxNQUFELENBQTFDO0FBQ0EsU0FBSyxJQUFJOTlCLElBQUksQ0FBYixFQUFnQkEsSUFBSTY5QixPQUFPditCLE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0QyxVQUFJODlCLE9BQU81MEIsT0FBUCxDQUFlMjBCLE9BQU83OUIsQ0FBUCxDQUFmLElBQTRCLENBQWhDLEVBQW1DO0FBQ2pDd0csWUFBSXZHLElBQUosQ0FBUzQ5QixPQUFPNzlCLENBQVAsQ0FBVDtBQUNEO0FBQ0Y7QUFDRCxXQUFPd0csR0FBUDtBQUNELEdBVEQsTUFTTztBQUNMLFdBQU9xM0IsTUFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3BVLEtBQVQsQ0FBZ0JwZixPQUFoQixFQUF5QjtBQUN2QixNQUFJcE0sUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFDRixFQUFFLGdCQUFnQm1qQixLQUFsQixDQURGLEVBQzRCO0FBQzFCMW1CLFNBQUssa0VBQUw7QUFDRDtBQUNELE9BQUtvNkIsS0FBTCxDQUFXOXlCLE9BQVg7QUFDRDs7QUFFRDZ5QixVQUFVelQsS0FBVjtBQUNBb04sV0FBV3BOLEtBQVg7QUFDQWdHLFlBQVloRyxLQUFaO0FBQ0FxSCxlQUFlckgsS0FBZjtBQUNBa1MsWUFBWWxTLEtBQVo7O0FBRUE7O0FBRUEsU0FBU3dVLE9BQVQsQ0FBa0I3N0IsR0FBbEIsRUFBdUI7QUFDckJBLE1BQUkrYSxHQUFKLEdBQVUsVUFBVStnQixNQUFWLEVBQWtCO0FBQzFCO0FBQ0EsUUFBSUEsT0FBT3J5QixTQUFYLEVBQXNCO0FBQ3BCO0FBQ0Q7QUFDRDtBQUNBLFFBQUloTSxPQUFPZ2YsUUFBUTllLFNBQVIsRUFBbUIsQ0FBbkIsQ0FBWDtBQUNBRixTQUFLMEksT0FBTCxDQUFhLElBQWI7QUFDQSxRQUFJLE9BQU8yMUIsT0FBTy83QixPQUFkLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3hDKzdCLGFBQU8vN0IsT0FBUCxDQUFlOUIsS0FBZixDQUFxQjY5QixNQUFyQixFQUE2QnIrQixJQUE3QjtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU9xK0IsTUFBUCxLQUFrQixVQUF0QixFQUFrQztBQUN2Q0EsYUFBTzc5QixLQUFQLENBQWEsSUFBYixFQUFtQlIsSUFBbkI7QUFDRDtBQUNEcStCLFdBQU9yeUIsU0FBUCxHQUFtQixJQUFuQjtBQUNBLFdBQU8sSUFBUDtBQUNELEdBZkQ7QUFnQkQ7O0FBRUQ7O0FBRUEsU0FBU3N5QixXQUFULENBQXNCLzdCLEdBQXRCLEVBQTJCO0FBQ3pCQSxNQUFJNkosS0FBSixHQUFZLFVBQVVBLEtBQVYsRUFBaUI7QUFDM0IsU0FBSzVCLE9BQUwsR0FBZWdmLGFBQWEsS0FBS2hmLE9BQWxCLEVBQTJCNEIsS0FBM0IsQ0FBZjtBQUNELEdBRkQ7QUFHRDs7QUFFRDs7QUFFQSxTQUFTbXlCLFVBQVQsQ0FBcUJoOEIsR0FBckIsRUFBMEI7QUFDeEI7Ozs7O0FBS0FBLE1BQUk2MUIsR0FBSixHQUFVLENBQVY7QUFDQSxNQUFJQSxNQUFNLENBQVY7O0FBRUE7OztBQUdBNzFCLE1BQUk0SSxNQUFKLEdBQWEsVUFBVTJ5QixhQUFWLEVBQXlCO0FBQ3BDQSxvQkFBZ0JBLGlCQUFpQixFQUFqQztBQUNBLFFBQUlVLFFBQVEsSUFBWjtBQUNBLFFBQUlDLFVBQVVELE1BQU1wRyxHQUFwQjtBQUNBLFFBQUlzRyxjQUFjWixjQUFjYSxLQUFkLEtBQXdCYixjQUFjYSxLQUFkLEdBQXNCLEVBQTlDLENBQWxCO0FBQ0EsUUFBSUQsWUFBWUQsT0FBWixDQUFKLEVBQTBCO0FBQ3hCLGFBQU9DLFlBQVlELE9BQVosQ0FBUDtBQUNEOztBQUVELFFBQUlqOUIsT0FBT3M4QixjQUFjdDhCLElBQWQsSUFBc0JnOUIsTUFBTWgwQixPQUFOLENBQWNoSixJQUEvQztBQUNBLFFBQUlwRCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJLENBQUMsbUJBQW1CcUYsSUFBbkIsQ0FBd0J0SyxJQUF4QixDQUFMLEVBQW9DO0FBQ2xDMEIsYUFDRSw4QkFBOEIxQixJQUE5QixHQUFxQyxxQkFBckMsR0FDQSwyREFEQSxHQUVBLCtCQUhGO0FBS0Q7QUFDRjs7QUFFRCxRQUFJbzlCLE1BQU0sU0FBU0MsWUFBVCxDQUF1QnIwQixPQUF2QixFQUFnQztBQUN4QyxXQUFLOHlCLEtBQUwsQ0FBVzl5QixPQUFYO0FBQ0QsS0FGRDtBQUdBbzBCLFFBQUlyK0IsU0FBSixHQUFnQjJCLE9BQU8rTCxNQUFQLENBQWN1d0IsTUFBTWorQixTQUFwQixDQUFoQjtBQUNBcStCLFFBQUlyK0IsU0FBSixDQUFja2IsV0FBZCxHQUE0Qm1qQixHQUE1QjtBQUNBQSxRQUFJeEcsR0FBSixHQUFVQSxLQUFWO0FBQ0F3RyxRQUFJcDBCLE9BQUosR0FBY2dmLGFBQ1pnVixNQUFNaDBCLE9BRE0sRUFFWnN6QixhQUZZLENBQWQ7QUFJQWMsUUFBSSxPQUFKLElBQWVKLEtBQWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSUksSUFBSXAwQixPQUFKLENBQVlsSCxLQUFoQixFQUF1QjtBQUNyQnc3QixrQkFBWUYsR0FBWjtBQUNEO0FBQ0QsUUFBSUEsSUFBSXAwQixPQUFKLENBQVl5ZSxRQUFoQixFQUEwQjtBQUN4QjhWLHFCQUFlSCxHQUFmO0FBQ0Q7O0FBRUQ7QUFDQUEsUUFBSXp6QixNQUFKLEdBQWFxekIsTUFBTXJ6QixNQUFuQjtBQUNBeXpCLFFBQUl4eUIsS0FBSixHQUFZb3lCLE1BQU1weUIsS0FBbEI7QUFDQXd5QixRQUFJdGhCLEdBQUosR0FBVWtoQixNQUFNbGhCLEdBQWhCOztBQUVBO0FBQ0E7QUFDQWpZLFdBQU91YixXQUFQLENBQW1COVosT0FBbkIsQ0FBMkIsVUFBVXZELElBQVYsRUFBZ0I7QUFDekNxN0IsVUFBSXI3QixJQUFKLElBQVlpN0IsTUFBTWo3QixJQUFOLENBQVo7QUFDRCxLQUZEO0FBR0E7QUFDQSxRQUFJL0IsSUFBSixFQUFVO0FBQ1JvOUIsVUFBSXAwQixPQUFKLENBQVkvRixVQUFaLENBQXVCakQsSUFBdkIsSUFBK0JvOUIsR0FBL0I7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQUEsUUFBSWxCLFlBQUosR0FBbUJjLE1BQU1oMEIsT0FBekI7QUFDQW8wQixRQUFJZCxhQUFKLEdBQW9CQSxhQUFwQjtBQUNBYyxRQUFJVixhQUFKLEdBQW9CL3lCLE9BQU8sRUFBUCxFQUFXeXpCLElBQUlwMEIsT0FBZixDQUFwQjs7QUFFQTtBQUNBazBCLGdCQUFZRCxPQUFaLElBQXVCRyxHQUF2QjtBQUNBLFdBQU9BLEdBQVA7QUFDRCxHQW5FRDtBQW9FRDs7QUFFRCxTQUFTRSxXQUFULENBQXNCRSxJQUF0QixFQUE0QjtBQUMxQixNQUFJMTdCLFFBQVEwN0IsS0FBS3gwQixPQUFMLENBQWFsSCxLQUF6QjtBQUNBLE9BQUssSUFBSW9ELEdBQVQsSUFBZ0JwRCxLQUFoQixFQUF1QjtBQUNyQmt5QixVQUFNd0osS0FBS3orQixTQUFYLEVBQXNCLFFBQXRCLEVBQWdDbUcsR0FBaEM7QUFDRDtBQUNGOztBQUVELFNBQVNxNEIsY0FBVCxDQUF5QkMsSUFBekIsRUFBK0I7QUFDN0IsTUFBSS9WLFdBQVcrVixLQUFLeDBCLE9BQUwsQ0FBYXllLFFBQTVCO0FBQ0EsT0FBSyxJQUFJdmlCLEdBQVQsSUFBZ0J1aUIsUUFBaEIsRUFBMEI7QUFDeEIwTixtQkFBZXFJLEtBQUt6K0IsU0FBcEIsRUFBK0JtRyxHQUEvQixFQUFvQ3VpQixTQUFTdmlCLEdBQVQsQ0FBcEM7QUFDRDtBQUNGOztBQUVEOztBQUVBLFNBQVN1NEIsa0JBQVQsQ0FBNkIxOEIsR0FBN0IsRUFBa0M7QUFDaEM7OztBQUdBOEMsU0FBT3ViLFdBQVAsQ0FBbUI5WixPQUFuQixDQUEyQixVQUFVdkQsSUFBVixFQUFnQjtBQUN6Q2hCLFFBQUlnQixJQUFKLElBQVksVUFDVndoQixFQURVLEVBRVZtYSxVQUZVLEVBR1Y7QUFDQSxVQUFJLENBQUNBLFVBQUwsRUFBaUI7QUFDZixlQUFPLEtBQUsxMEIsT0FBTCxDQUFhakgsT0FBTyxHQUFwQixFQUF5QndoQixFQUF6QixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0w7QUFDQSxZQUFJM21CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGNBQUlsRCxTQUFTLFdBQVQsSUFBd0I4QixPQUFPa2IsYUFBUCxDQUFxQndFLEVBQXJCLENBQTVCLEVBQXNEO0FBQ3BEN2hCLGlCQUNFLGdFQUNBLE1BREEsR0FDUzZoQixFQUZYO0FBSUQ7QUFDRjtBQUNELFlBQUl4aEIsU0FBUyxXQUFULElBQXdCOGIsY0FBYzZmLFVBQWQsQ0FBNUIsRUFBdUQ7QUFDckRBLHFCQUFXMTlCLElBQVgsR0FBa0IwOUIsV0FBVzE5QixJQUFYLElBQW1CdWpCLEVBQXJDO0FBQ0FtYSx1QkFBYSxLQUFLMTBCLE9BQUwsQ0FBYTJ0QixLQUFiLENBQW1CaHRCLE1BQW5CLENBQTBCK3pCLFVBQTFCLENBQWI7QUFDRDtBQUNELFlBQUkzN0IsU0FBUyxXQUFULElBQXdCLE9BQU8yN0IsVUFBUCxLQUFzQixVQUFsRCxFQUE4RDtBQUM1REEsdUJBQWEsRUFBRW5sQixNQUFNbWxCLFVBQVIsRUFBb0IzWixRQUFRMlosVUFBNUIsRUFBYjtBQUNEO0FBQ0QsYUFBSzEwQixPQUFMLENBQWFqSCxPQUFPLEdBQXBCLEVBQXlCd2hCLEVBQXpCLElBQStCbWEsVUFBL0I7QUFDQSxlQUFPQSxVQUFQO0FBQ0Q7QUFDRixLQTFCRDtBQTJCRCxHQTVCRDtBQTZCRDs7QUFFRDs7QUFFQSxJQUFJQyxlQUFlLENBQUMzN0IsTUFBRCxFQUFTaU0sTUFBVCxDQUFuQjs7QUFFQSxTQUFTMnZCLGdCQUFULENBQTJCanVCLElBQTNCLEVBQWlDO0FBQy9CLFNBQU9BLFNBQVNBLEtBQUsrUSxJQUFMLENBQVUxWCxPQUFWLENBQWtCaEosSUFBbEIsSUFBMEIyUCxLQUFLdkgsR0FBeEMsQ0FBUDtBQUNEOztBQUVELFNBQVNzSCxPQUFULENBQWtCUixPQUFsQixFQUEyQmxQLElBQTNCLEVBQWlDO0FBQy9CLE1BQUksT0FBT2tQLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBT0EsUUFBUTdKLEtBQVIsQ0FBYyxHQUFkLEVBQW1Cd0MsT0FBbkIsQ0FBMkI3SCxJQUEzQixJQUFtQyxDQUFDLENBQTNDO0FBQ0QsR0FGRCxNQUVPLElBQUlrUCxtQkFBbUJqQixNQUF2QixFQUErQjtBQUNwQyxXQUFPaUIsUUFBUTVFLElBQVIsQ0FBYXRLLElBQWIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFTNjlCLFVBQVQsQ0FBcUJwN0IsS0FBckIsRUFBNEIyRCxNQUE1QixFQUFvQztBQUNsQyxPQUFLLElBQUlsQixHQUFULElBQWdCekMsS0FBaEIsRUFBdUI7QUFDckIsUUFBSXE3QixhQUFhcjdCLE1BQU15QyxHQUFOLENBQWpCO0FBQ0EsUUFBSTQ0QixVQUFKLEVBQWdCO0FBQ2QsVUFBSTk5QixPQUFPNDlCLGlCQUFpQkUsV0FBV3pTLGdCQUE1QixDQUFYO0FBQ0EsVUFBSXJyQixRQUFRLENBQUNvRyxPQUFPcEcsSUFBUCxDQUFiLEVBQTJCO0FBQ3pCKzlCLHdCQUFnQkQsVUFBaEI7QUFDQXI3QixjQUFNeUMsR0FBTixJQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTNjRCLGVBQVQsQ0FBMEIxNkIsS0FBMUIsRUFBaUM7QUFDL0IsTUFBSUEsS0FBSixFQUFXO0FBQ1QsUUFBSSxDQUFDQSxNQUFNbW9CLGlCQUFOLENBQXdCMW9CLFNBQTdCLEVBQXdDO0FBQ3RDOHNCLGVBQVN2c0IsTUFBTW1vQixpQkFBZixFQUFrQyxhQUFsQztBQUNEO0FBQ0Rub0IsVUFBTW1vQixpQkFBTixDQUF3QitFLFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJeU4sWUFBWTtBQUNkaCtCLFFBQU0sWUFEUTtBQUVkaXZCLFlBQVUsSUFGSTs7QUFJZG50QixTQUFPO0FBQ0xtOEIsYUFBU04sWUFESjtBQUVMTyxhQUFTUDtBQUZKLEdBSk87O0FBU2R0eUIsV0FBUyxTQUFTQSxPQUFULEdBQW9CO0FBQzNCLFNBQUs1SSxLQUFMLEdBQWEvQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNELEdBWGE7O0FBYWQweEIsYUFBVyxTQUFTQSxTQUFULEdBQXNCO0FBQy9CLFFBQUl6MUIsU0FBUyxJQUFiOztBQUVBLFNBQUssSUFBSXhELEdBQVQsSUFBZ0J3RCxPQUFPakcsS0FBdkIsRUFBOEI7QUFDNUJzN0Isc0JBQWdCcjFCLE9BQU9qRyxLQUFQLENBQWF5QyxHQUFiLENBQWhCO0FBQ0Q7QUFDRixHQW5CYTs7QUFxQmRxaUIsU0FBTztBQUNMMFcsYUFBUyxTQUFTQSxPQUFULENBQWtCdjRCLEdBQWxCLEVBQXVCO0FBQzlCbTRCLGlCQUFXLEtBQUtwN0IsS0FBaEIsRUFBdUIsVUFBVXpDLElBQVYsRUFBZ0I7QUFBRSxlQUFPMFAsUUFBUWhLLEdBQVIsRUFBYTFGLElBQWIsQ0FBUDtBQUE0QixPQUFyRTtBQUNELEtBSEk7QUFJTGsrQixhQUFTLFNBQVNBLE9BQVQsQ0FBa0J4NEIsR0FBbEIsRUFBdUI7QUFDOUJtNEIsaUJBQVcsS0FBS3A3QixLQUFoQixFQUF1QixVQUFVekMsSUFBVixFQUFnQjtBQUFFLGVBQU8sQ0FBQzBQLFFBQVFoSyxHQUFSLEVBQWExRixJQUFiLENBQVI7QUFBNkIsT0FBdEU7QUFDRDtBQU5JLEdBckJPOztBQThCZGlDLFVBQVEsU0FBU0EsTUFBVCxHQUFtQjtBQUN6QixRQUFJb0IsUUFBUW1xQix1QkFBdUIsS0FBSy9qQixNQUFMLENBQVk1SSxPQUFuQyxDQUFaO0FBQ0EsUUFBSXdxQixtQkFBbUJob0IsU0FBU0EsTUFBTWdvQixnQkFBdEM7QUFDQSxRQUFJQSxnQkFBSixFQUFzQjtBQUNwQjtBQUNBLFVBQUlyckIsT0FBTzQ5QixpQkFBaUJ2UyxnQkFBakIsQ0FBWDtBQUNBLFVBQUlyckIsU0FDRCxLQUFLaStCLE9BQUwsSUFBZ0IsQ0FBQ3Z1QixRQUFRLEtBQUt1dUIsT0FBYixFQUFzQmorQixJQUF0QixDQUFsQixJQUNDLEtBQUtrK0IsT0FBTCxJQUFnQnh1QixRQUFRLEtBQUt3dUIsT0FBYixFQUFzQmwrQixJQUF0QixDQUZmLENBQUosRUFHRztBQUNELGVBQU9xRCxLQUFQO0FBQ0Q7QUFDRCxVQUFJNkIsTUFBTTdCLE1BQU02QixHQUFOLElBQWE7QUFDckI7QUFDQTtBQUZRLFFBR05tbUIsaUJBQWlCM0ssSUFBakIsQ0FBc0JrVyxHQUF0QixJQUE2QnZMLGlCQUFpQmpqQixHQUFqQixHQUF3QixPQUFRaWpCLGlCQUFpQmpqQixHQUFqRCxHQUF5RCxFQUF0RixDQUhNLEdBSU4vRSxNQUFNNkIsR0FKVjtBQUtBLFVBQUksS0FBS3pDLEtBQUwsQ0FBV3lDLEdBQVgsQ0FBSixFQUFxQjtBQUNuQjdCLGNBQU1tb0IsaUJBQU4sR0FBMEIsS0FBSy9vQixLQUFMLENBQVd5QyxHQUFYLEVBQWdCc21CLGlCQUExQztBQUNELE9BRkQsTUFFTztBQUNMLGFBQUsvb0IsS0FBTCxDQUFXeUMsR0FBWCxJQUFrQjdCLEtBQWxCO0FBQ0Q7QUFDREEsWUFBTWYsSUFBTixDQUFXK3pCLFNBQVgsR0FBdUIsSUFBdkI7QUFDRDtBQUNELFdBQU9oekIsS0FBUDtBQUNEO0FBdkRhLENBQWhCOztBQTBEQSxJQUFJKzZCLG9CQUFvQjtBQUN0QkosYUFBV0E7QUFEVyxDQUF4Qjs7QUFJQTs7QUFFQSxTQUFTSyxhQUFULENBQXdCdDlCLEdBQXhCLEVBQTZCO0FBQzNCO0FBQ0EsTUFBSXU5QixZQUFZLEVBQWhCO0FBQ0FBLFlBQVVwOUIsR0FBVixHQUFnQixZQUFZO0FBQUUsV0FBTzJDLE1BQVA7QUFBZ0IsR0FBOUM7QUFDQSxNQUFJakgsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNxNUIsY0FBVWxjLEdBQVYsR0FBZ0IsWUFBWTtBQUMxQjFnQixXQUNFLHNFQURGO0FBR0QsS0FKRDtBQUtEO0FBQ0RoQixTQUFPQyxjQUFQLENBQXNCSSxHQUF0QixFQUEyQixRQUEzQixFQUFxQ3U5QixTQUFyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQXY5QixNQUFJOEksSUFBSixHQUFXO0FBQ1RuSSxVQUFNQSxJQURHO0FBRVRpSSxZQUFRQSxNQUZDO0FBR1RxZSxrQkFBY0EsWUFITDtBQUlUamQsb0JBQWdCMmE7QUFKUCxHQUFYOztBQU9BM2tCLE1BQUlxaEIsR0FBSixHQUFVQSxHQUFWO0FBQ0FyaEIsTUFBSXc5QixNQUFKLEdBQWE5WCxHQUFiO0FBQ0ExbEIsTUFBSXhDLFFBQUosR0FBZUEsUUFBZjs7QUFFQXdDLE1BQUlpSSxPQUFKLEdBQWN0SSxPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBZDtBQUNBNUksU0FBT3ViLFdBQVAsQ0FBbUI5WixPQUFuQixDQUEyQixVQUFVdkQsSUFBVixFQUFnQjtBQUN6Q2hCLFFBQUlpSSxPQUFKLENBQVlqSCxPQUFPLEdBQW5CLElBQTBCckIsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQTFCO0FBQ0QsR0FGRDs7QUFJQTtBQUNBO0FBQ0ExTCxNQUFJaUksT0FBSixDQUFZMnRCLEtBQVosR0FBb0I1MUIsR0FBcEI7O0FBRUE0SSxTQUFPNUksSUFBSWlJLE9BQUosQ0FBWS9GLFVBQW5CLEVBQStCbTdCLGlCQUEvQjs7QUFFQXhCLFVBQVE3N0IsR0FBUjtBQUNBKzdCLGNBQVkvN0IsR0FBWjtBQUNBZzhCLGFBQVdoOEIsR0FBWDtBQUNBMDhCLHFCQUFtQjE4QixHQUFuQjtBQUNEOztBQUVEczlCLGNBQWNqVyxLQUFkOztBQUVBMW5CLE9BQU9DLGNBQVAsQ0FBc0J5bkIsTUFBTXJwQixTQUE1QixFQUF1QyxXQUF2QyxFQUFvRDtBQUNsRG1DLE9BQUtvZjtBQUQ2QyxDQUFwRDs7QUFJQThILE1BQU0vb0IsT0FBTixHQUFnQixPQUFoQjs7QUFFQTs7QUFFQTtBQUNBLElBQUltL0IsY0FBY3JpQixRQUFRLDhCQUFSLENBQWxCO0FBQ0EsSUFBSWdELGNBQWMsVUFBVS9XLEdBQVYsRUFBZXJHLElBQWYsRUFBcUIwOEIsSUFBckIsRUFBMkI7QUFDM0MsU0FDR0EsU0FBUyxPQUFULElBQW9CRCxZQUFZcDJCLEdBQVosQ0FBckIsSUFBMENyRyxTQUFTLFFBQW5ELElBQ0MwOEIsU0FBUyxVQUFULElBQXVCcjJCLFFBQVEsUUFEaEMsSUFFQ3EyQixTQUFTLFNBQVQsSUFBc0JyMkIsUUFBUSxPQUYvQixJQUdDcTJCLFNBQVMsT0FBVCxJQUFvQnIyQixRQUFRLE9BSi9CO0FBTUQsQ0FQRDs7QUFTQSxJQUFJczJCLG1CQUFtQnZpQixRQUFRLHNDQUFSLENBQXZCOztBQUVBLElBQUl3aUIsZ0JBQWdCeGlCLFFBQ2xCLCtFQUNBLHFFQURBLEdBRUEsa0ZBRkEsR0FHQSw0RUFIQSxHQUlBLGdFQUpBLEdBS0EsaUNBTmtCLENBQXBCOztBQVNBLElBQUl5aUIsVUFBVSw4QkFBZDs7QUFFQSxJQUFJQyxVQUFVLFVBQVU3K0IsSUFBVixFQUFnQjtBQUM1QixTQUFPQSxLQUFLMkwsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkIsSUFBMEIzTCxLQUFLa0csS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLE9BQXREO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJNDRCLGVBQWUsVUFBVTkrQixJQUFWLEVBQWdCO0FBQ2pDLFNBQU82K0IsUUFBUTcrQixJQUFSLElBQWdCQSxLQUFLa0csS0FBTCxDQUFXLENBQVgsRUFBY2xHLEtBQUsvQixNQUFuQixDQUFoQixHQUE2QyxFQUFwRDtBQUNELENBRkQ7O0FBSUEsSUFBSThnQyxtQkFBbUIsVUFBVXI1QixHQUFWLEVBQWU7QUFDcEMsU0FBT0EsT0FBTyxJQUFQLElBQWVBLFFBQVEsS0FBOUI7QUFDRCxDQUZEOztBQUlBOztBQUVBLFNBQVNzNUIsZ0JBQVQsQ0FBMkIzN0IsS0FBM0IsRUFBa0M7QUFDaEMsTUFBSWYsT0FBT2UsTUFBTWYsSUFBakI7QUFDQSxNQUFJMjhCLGFBQWE1N0IsS0FBakI7QUFDQSxNQUFJNjdCLFlBQVk3N0IsS0FBaEI7QUFDQSxTQUFPNjdCLFVBQVUxVCxpQkFBakIsRUFBb0M7QUFDbEMwVCxnQkFBWUEsVUFBVTFULGlCQUFWLENBQTRCd0UsTUFBeEM7QUFDQSxRQUFJa1AsVUFBVTU4QixJQUFkLEVBQW9CO0FBQ2xCQSxhQUFPNjhCLGVBQWVELFVBQVU1OEIsSUFBekIsRUFBK0JBLElBQS9CLENBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBUTI4QixhQUFhQSxXQUFXNThCLE1BQWhDLEVBQXlDO0FBQ3ZDLFFBQUk0OEIsV0FBVzM4QixJQUFmLEVBQXFCO0FBQ25CQSxhQUFPNjhCLGVBQWU3OEIsSUFBZixFQUFxQjI4QixXQUFXMzhCLElBQWhDLENBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTzg4QixpQkFBaUI5OEIsSUFBakIsQ0FBUDtBQUNEOztBQUVELFNBQVM2OEIsY0FBVCxDQUF5QjU3QixLQUF6QixFQUFnQ2xCLE1BQWhDLEVBQXdDO0FBQ3RDLFNBQU87QUFDTGc5QixpQkFBYW5oQyxPQUFPcUYsTUFBTTg3QixXQUFiLEVBQTBCaDlCLE9BQU9nOUIsV0FBakMsQ0FEUjtBQUVMLzFCLFdBQU8vRixNQUFNK0YsS0FBTixHQUNILENBQUMvRixNQUFNK0YsS0FBUCxFQUFjakgsT0FBT2lILEtBQXJCLENBREcsR0FFSGpILE9BQU9pSDtBQUpOLEdBQVA7QUFNRDs7QUFFRCxTQUFTODFCLGdCQUFULENBQTJCOThCLElBQTNCLEVBQWlDO0FBQy9CLE1BQUlnOUIsZUFBZWg5QixLQUFLZ0gsS0FBeEI7QUFDQSxNQUFJKzFCLGNBQWMvOEIsS0FBSys4QixXQUF2QjtBQUNBLE1BQUlBLGVBQWVDLFlBQW5CLEVBQWlDO0FBQy9CLFdBQU9waEMsT0FBT21oQyxXQUFQLEVBQW9CRSxlQUFlRCxZQUFmLENBQXBCLENBQVA7QUFDRDtBQUNEO0FBQ0EsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQsU0FBU3BoQyxNQUFULENBQWlCa0osQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCO0FBQ3JCLFNBQU9ELElBQUlDLElBQUtELElBQUksR0FBSixHQUFVQyxDQUFmLEdBQW9CRCxDQUF4QixHQUE2QkMsS0FBSyxFQUF6QztBQUNEOztBQUVELFNBQVNrNEIsY0FBVCxDQUF5QjMrQixLQUF6QixFQUFnQztBQUM5QixNQUFJdUUsTUFBTSxFQUFWO0FBQ0EsTUFBSSxDQUFDdkUsS0FBTCxFQUFZO0FBQ1YsV0FBT3VFLEdBQVA7QUFDRDtBQUNELE1BQUksT0FBT3ZFLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBT0EsS0FBUDtBQUNEO0FBQ0QsTUFBSW5DLE1BQU1tSCxPQUFOLENBQWNoRixLQUFkLENBQUosRUFBMEI7QUFDeEIsUUFBSTQrQixXQUFKO0FBQ0EsU0FBSyxJQUFJN2dDLElBQUksQ0FBUixFQUFXMmUsSUFBSTFjLE1BQU0zQyxNQUExQixFQUFrQ1UsSUFBSTJlLENBQXRDLEVBQXlDM2UsR0FBekMsRUFBOEM7QUFDNUMsVUFBSWlDLE1BQU1qQyxDQUFOLENBQUosRUFBYztBQUNaLFlBQUs2Z0MsY0FBY0QsZUFBZTMrQixNQUFNakMsQ0FBTixDQUFmLENBQW5CLEVBQThDO0FBQzVDd0csaUJBQU9xNkIsY0FBYyxHQUFyQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQU9yNkIsSUFBSWUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsQ0FBUDtBQUNEO0FBQ0QsTUFBSTJOLFNBQVNqVCxLQUFULENBQUosRUFBcUI7QUFDbkIsU0FBSyxJQUFJc0UsR0FBVCxJQUFnQnRFLEtBQWhCLEVBQXVCO0FBQ3JCLFVBQUlBLE1BQU1zRSxHQUFOLENBQUosRUFBZ0I7QUFBRUMsZUFBT0QsTUFBTSxHQUFiO0FBQW1CO0FBQ3RDO0FBQ0QsV0FBT0MsSUFBSWUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFPZixHQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsSUFBSXM2QixlQUFlO0FBQ2pCQyxPQUFLLDRCQURZO0FBRWpCQyxRQUFNO0FBRlcsQ0FBbkI7O0FBS0EsSUFBSUMsWUFBWXpqQixRQUNkLCtDQUNBLDJFQURBLEdBRUEsNERBRkEsR0FHQSx3RUFIQSxHQUlBLDZFQUpBLEdBS0EsMkRBTEEsR0FNQSxrREFOQSxHQU9BLHlFQVBBLEdBUUEsa0NBUkEsR0FTQSx1Q0FUQSxHQVVBLGlDQVhjLENBQWhCOztBQWNBO0FBQ0E7QUFDQSxJQUFJMGpCLFFBQVExakIsUUFDViwyRUFDQSwwRUFEQSxHQUVBLGtFQUhVLEVBSVYsSUFKVSxDQUFaOztBQU9BLElBQUkyakIsV0FBVyxVQUFVMTNCLEdBQVYsRUFBZTtBQUFFLFNBQU9BLFFBQVEsS0FBZjtBQUF1QixDQUF2RDs7QUFFQSxJQUFJMlcsZ0JBQWdCLFVBQVUzVyxHQUFWLEVBQWU7QUFDakMsU0FBT3czQixVQUFVeDNCLEdBQVYsS0FBa0J5M0IsTUFBTXozQixHQUFOLENBQXpCO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTNlcsZUFBVCxDQUEwQjdXLEdBQTFCLEVBQStCO0FBQzdCLE1BQUl5M0IsTUFBTXozQixHQUFOLENBQUosRUFBZ0I7QUFDZCxXQUFPLEtBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJQSxRQUFRLE1BQVosRUFBb0I7QUFDbEIsV0FBTyxNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJMjNCLHNCQUFzQnIvQixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBMUI7QUFDQSxTQUFTdVMsZ0JBQVQsQ0FBMkI1VyxHQUEzQixFQUFnQztBQUM5QjtBQUNBLE1BQUksQ0FBQ2tELFNBQUwsRUFBZ0I7QUFDZCxXQUFPLElBQVA7QUFDRDtBQUNELE1BQUl5VCxjQUFjM1csR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFdBQU8sS0FBUDtBQUNEO0FBQ0RBLFFBQU1BLElBQUlrVSxXQUFKLEVBQU47QUFDQTtBQUNBLE1BQUl5akIsb0JBQW9CMzNCLEdBQXBCLEtBQTRCLElBQWhDLEVBQXNDO0FBQ3BDLFdBQU8yM0Isb0JBQW9CMzNCLEdBQXBCLENBQVA7QUFDRDtBQUNELE1BQUkyTCxLQUFLQyxTQUFTdWpCLGFBQVQsQ0FBdUJudkIsR0FBdkIsQ0FBVDtBQUNBLE1BQUlBLElBQUlQLE9BQUosQ0FBWSxHQUFaLElBQW1CLENBQUMsQ0FBeEIsRUFBMkI7QUFDekI7QUFDQSxXQUFRazRCLG9CQUFvQjMzQixHQUFwQixJQUNOMkwsR0FBR2tHLFdBQUgsS0FBbUIxTyxPQUFPeTBCLGtCQUExQixJQUNBanNCLEdBQUdrRyxXQUFILEtBQW1CMU8sT0FBTzAwQixXQUY1QjtBQUlELEdBTkQsTUFNTztBQUNMLFdBQVFGLG9CQUFvQjMzQixHQUFwQixJQUEyQixxQkFBcUJrQyxJQUFyQixDQUEwQnlKLEdBQUczUCxRQUFILEVBQTFCLENBQW5DO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBU1MsS0FBVCxDQUFnQmtQLEVBQWhCLEVBQW9CO0FBQ2xCLE1BQUksT0FBT0EsRUFBUCxLQUFjLFFBQWxCLEVBQTRCO0FBQzFCLFFBQUltc0IsV0FBV2xzQixTQUFTQyxhQUFULENBQXVCRixFQUF2QixDQUFmO0FBQ0EsUUFBSSxDQUFDbXNCLFFBQUwsRUFBZTtBQUNidGpDLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsMEJBQTBCcVMsRUFEYSxDQUF6QztBQUdBLGFBQU9DLFNBQVN1akIsYUFBVCxDQUF1QixLQUF2QixDQUFQO0FBQ0Q7QUFDRCxXQUFPMkksUUFBUDtBQUNELEdBVEQsTUFTTztBQUNMLFdBQU9uc0IsRUFBUDtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsU0FBU29zQixlQUFULENBQTBCQyxPQUExQixFQUFtQy84QixLQUFuQyxFQUEwQztBQUN4QyxNQUFJOG5CLE1BQU1uWCxTQUFTdWpCLGFBQVQsQ0FBdUI2SSxPQUF2QixDQUFWO0FBQ0EsTUFBSUEsWUFBWSxRQUFoQixFQUEwQjtBQUN4QixXQUFPalYsR0FBUDtBQUNEO0FBQ0Q7QUFDQSxNQUFJOW5CLE1BQU1mLElBQU4sSUFBY2UsTUFBTWYsSUFBTixDQUFXaUgsS0FBekIsSUFBa0NsRyxNQUFNZixJQUFOLENBQVdpSCxLQUFYLENBQWlCODJCLFFBQWpCLEtBQThCMThCLFNBQXBFLEVBQStFO0FBQzdFd25CLFFBQUltVixZQUFKLENBQWlCLFVBQWpCLEVBQTZCLFVBQTdCO0FBQ0Q7QUFDRCxTQUFPblYsR0FBUDtBQUNEOztBQUVELFNBQVNvVixlQUFULENBQTBCQyxTQUExQixFQUFxQ0osT0FBckMsRUFBOEM7QUFDNUMsU0FBT3BzQixTQUFTdXNCLGVBQVQsQ0FBeUJkLGFBQWFlLFNBQWIsQ0FBekIsRUFBa0RKLE9BQWxELENBQVA7QUFDRDs7QUFFRCxTQUFTdmUsY0FBVCxDQUF5QnFKLElBQXpCLEVBQStCO0FBQzdCLFNBQU9sWCxTQUFTNk4sY0FBVCxDQUF3QnFKLElBQXhCLENBQVA7QUFDRDs7QUFFRCxTQUFTdVYsYUFBVCxDQUF3QnZWLElBQXhCLEVBQThCO0FBQzVCLFNBQU9sWCxTQUFTeXNCLGFBQVQsQ0FBdUJ2VixJQUF2QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU3dWLFlBQVQsQ0FBdUJ6QixVQUF2QixFQUFtQzBCLE9BQW5DLEVBQTRDQyxhQUE1QyxFQUEyRDtBQUN6RDNCLGFBQVd5QixZQUFYLENBQXdCQyxPQUF4QixFQUFpQ0MsYUFBakM7QUFDRDs7QUFFRCxTQUFTQyxXQUFULENBQXNCL1UsSUFBdEIsRUFBNEJ2b0IsS0FBNUIsRUFBbUM7QUFDakN1b0IsT0FBSytVLFdBQUwsQ0FBaUJ0OUIsS0FBakI7QUFDRDs7QUFFRCxTQUFTdTlCLFdBQVQsQ0FBc0JoVixJQUF0QixFQUE0QnZvQixLQUE1QixFQUFtQztBQUNqQ3VvQixPQUFLZ1YsV0FBTCxDQUFpQnY5QixLQUFqQjtBQUNEOztBQUVELFNBQVMwN0IsVUFBVCxDQUFxQm5ULElBQXJCLEVBQTJCO0FBQ3pCLFNBQU9BLEtBQUttVCxVQUFaO0FBQ0Q7O0FBRUQsU0FBUzhCLFdBQVQsQ0FBc0JqVixJQUF0QixFQUE0QjtBQUMxQixTQUFPQSxLQUFLaVYsV0FBWjtBQUNEOztBQUVELFNBQVNYLE9BQVQsQ0FBa0J0VSxJQUFsQixFQUF3QjtBQUN0QixTQUFPQSxLQUFLc1UsT0FBWjtBQUNEOztBQUVELFNBQVNZLGNBQVQsQ0FBeUJsVixJQUF6QixFQUErQlosSUFBL0IsRUFBcUM7QUFDbkNZLE9BQUttVixXQUFMLEdBQW1CL1YsSUFBbkI7QUFDRDs7QUFFRCxTQUFTb1YsWUFBVCxDQUF1QnhVLElBQXZCLEVBQTZCNW1CLEdBQTdCLEVBQWtDUSxHQUFsQyxFQUF1QztBQUNyQ29tQixPQUFLd1UsWUFBTCxDQUFrQnA3QixHQUFsQixFQUF1QlEsR0FBdkI7QUFDRDs7QUFHRCxJQUFJdzdCLFVBQVV4Z0MsT0FBT3NHLE1BQVAsQ0FBYztBQUMzQnV3QixpQkFBZTRJLGVBRFk7QUFFM0JJLG1CQUFpQkEsZUFGVTtBQUczQjFlLGtCQUFnQkEsY0FIVztBQUkzQjRlLGlCQUFlQSxhQUpZO0FBSzNCQyxnQkFBY0EsWUFMYTtBQU0zQkcsZUFBYUEsV0FOYztBQU8zQkMsZUFBYUEsV0FQYztBQVEzQjdCLGNBQVlBLFVBUmU7QUFTM0I4QixlQUFhQSxXQVRjO0FBVTNCWCxXQUFTQSxPQVZrQjtBQVczQlksa0JBQWdCQSxjQVhXO0FBWTNCVixnQkFBY0E7QUFaYSxDQUFkLENBQWQ7O0FBZUE7O0FBRUEsSUFBSW4rQixNQUFNO0FBQ1JzSyxVQUFRLFNBQVNBLE1BQVQsQ0FBaUIwTSxDQUFqQixFQUFvQjlWLEtBQXBCLEVBQTJCO0FBQ2pDODlCLGdCQUFZOTlCLEtBQVo7QUFDRCxHQUhPO0FBSVIwZ0IsVUFBUSxTQUFTQSxNQUFULENBQWlCdGdCLFFBQWpCLEVBQTJCSixLQUEzQixFQUFrQztBQUN4QyxRQUFJSSxTQUFTbkIsSUFBVCxDQUFjSCxHQUFkLEtBQXNCa0IsTUFBTWYsSUFBTixDQUFXSCxHQUFyQyxFQUEwQztBQUN4Q2cvQixrQkFBWTE5QixRQUFaLEVBQXNCLElBQXRCO0FBQ0EwOUIsa0JBQVk5OUIsS0FBWjtBQUNEO0FBQ0YsR0FUTztBQVVSSyxXQUFTLFNBQVNBLE9BQVQsQ0FBa0JMLEtBQWxCLEVBQXlCO0FBQ2hDODlCLGdCQUFZOTlCLEtBQVosRUFBbUIsSUFBbkI7QUFDRDtBQVpPLENBQVY7O0FBZUEsU0FBUzg5QixXQUFULENBQXNCOTlCLEtBQXRCLEVBQTZCKzlCLFNBQTdCLEVBQXdDO0FBQ3RDLE1BQUlsOEIsTUFBTTdCLE1BQU1mLElBQU4sQ0FBV0gsR0FBckI7QUFDQSxNQUFJLENBQUMrQyxHQUFMLEVBQVU7QUFBRTtBQUFROztBQUVwQixNQUFJNGQsS0FBS3pmLE1BQU0rbkIsT0FBZjtBQUNBLE1BQUlqcEIsTUFBTWtCLE1BQU1tb0IsaUJBQU4sSUFBMkJub0IsTUFBTThuQixHQUEzQztBQUNBLE1BQUlrVyxPQUFPdmUsR0FBR3FNLEtBQWQ7QUFDQSxNQUFJaVMsU0FBSixFQUFlO0FBQ2IsUUFBSTNpQyxNQUFNbUgsT0FBTixDQUFjeTdCLEtBQUtuOEIsR0FBTCxDQUFkLENBQUosRUFBOEI7QUFDNUJzWCxhQUFPNmtCLEtBQUtuOEIsR0FBTCxDQUFQLEVBQWtCL0MsR0FBbEI7QUFDRCxLQUZELE1BRU8sSUFBSWsvQixLQUFLbjhCLEdBQUwsTUFBYy9DLEdBQWxCLEVBQXVCO0FBQzVCay9CLFdBQUtuOEIsR0FBTCxJQUFZdkIsU0FBWjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wsUUFBSU4sTUFBTWYsSUFBTixDQUFXZy9CLFFBQWYsRUFBeUI7QUFDdkIsVUFBSTdpQyxNQUFNbUgsT0FBTixDQUFjeTdCLEtBQUtuOEIsR0FBTCxDQUFkLEtBQTRCbThCLEtBQUtuOEIsR0FBTCxFQUFVMkMsT0FBVixDQUFrQjFGLEdBQWxCLElBQXlCLENBQXpELEVBQTREO0FBQzFEay9CLGFBQUtuOEIsR0FBTCxFQUFVdEcsSUFBVixDQUFldUQsR0FBZjtBQUNELE9BRkQsTUFFTztBQUNMay9CLGFBQUtuOEIsR0FBTCxJQUFZLENBQUMvQyxHQUFELENBQVo7QUFDRDtBQUNGLEtBTkQsTUFNTztBQUNMay9CLFdBQUtuOEIsR0FBTCxJQUFZL0MsR0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJby9CLFlBQVksSUFBSXRXLEtBQUosQ0FBVSxFQUFWLEVBQWMsRUFBZCxFQUFrQixFQUFsQixDQUFoQjs7QUFFQSxJQUFJL25CLFFBQVEsQ0FBQyxRQUFELEVBQVcsVUFBWCxFQUF1QixRQUF2QixFQUFpQyxRQUFqQyxFQUEyQyxTQUEzQyxDQUFaOztBQUVBLFNBQVNzK0IsT0FBVCxDQUFrQnRzQixDQUFsQixFQUFxQjtBQUNuQixTQUFPQSxNQUFNdlIsU0FBTixJQUFtQnVSLE1BQU0sSUFBaEM7QUFDRDs7QUFFRCxTQUFTdXNCLEtBQVQsQ0FBZ0J2c0IsQ0FBaEIsRUFBbUI7QUFDakIsU0FBT0EsTUFBTXZSLFNBQU4sSUFBbUJ1UixNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsU0FBU3dzQixNQUFULENBQWlCeHNCLENBQWpCLEVBQW9CO0FBQ2xCLFNBQU9BLE1BQU0sSUFBYjtBQUNEOztBQUVELFNBQVN5c0IsU0FBVCxDQUFvQnY2QixDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEI7QUFDeEIsU0FDRUQsRUFBRWxDLEdBQUYsS0FBVW1DLEVBQUVuQyxHQUFaLElBQ0FrQyxFQUFFZ0IsR0FBRixLQUFVZixFQUFFZSxHQURaLElBRUFoQixFQUFFc2tCLFNBQUYsS0FBZ0Jya0IsRUFBRXFrQixTQUZsQixJQUdBK1YsTUFBTXI2QixFQUFFOUUsSUFBUixNQUFrQm0vQixNQUFNcDZCLEVBQUUvRSxJQUFSLENBSGxCLElBSUFzL0IsY0FBY3g2QixDQUFkLEVBQWlCQyxDQUFqQixDQUxGO0FBT0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQVN1NkIsYUFBVCxDQUF3Qng2QixDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEI7QUFDNUIsTUFBSUQsRUFBRWdCLEdBQUYsS0FBVSxPQUFkLEVBQXVCO0FBQUUsV0FBTyxJQUFQO0FBQWE7QUFDdEMsTUFBSXpKLENBQUo7QUFDQSxNQUFJa2pDLFFBQVFKLE1BQU05aUMsSUFBSXlJLEVBQUU5RSxJQUFaLEtBQXFCbS9CLE1BQU05aUMsSUFBSUEsRUFBRTRLLEtBQVosQ0FBckIsSUFBMkM1SyxFQUFFb0QsSUFBekQ7QUFDQSxNQUFJKy9CLFFBQVFMLE1BQU05aUMsSUFBSTBJLEVBQUUvRSxJQUFaLEtBQXFCbS9CLE1BQU05aUMsSUFBSUEsRUFBRTRLLEtBQVosQ0FBckIsSUFBMkM1SyxFQUFFb0QsSUFBekQ7QUFDQSxTQUFPOC9CLFVBQVVDLEtBQWpCO0FBQ0Q7O0FBRUQsU0FBU0MsaUJBQVQsQ0FBNEIzL0IsUUFBNUIsRUFBc0M0L0IsUUFBdEMsRUFBZ0RDLE1BQWhELEVBQXdEO0FBQ3RELE1BQUl0akMsQ0FBSixFQUFPdUcsR0FBUDtBQUNBLE1BQUljLE1BQU0sRUFBVjtBQUNBLE9BQUtySCxJQUFJcWpDLFFBQVQsRUFBbUJyakMsS0FBS3NqQyxNQUF4QixFQUFnQyxFQUFFdGpDLENBQWxDLEVBQXFDO0FBQ25DdUcsVUFBTTlDLFNBQVN6RCxDQUFULEVBQVl1RyxHQUFsQjtBQUNBLFFBQUl1OEIsTUFBTXY4QixHQUFOLENBQUosRUFBZ0I7QUFBRWMsVUFBSWQsR0FBSixJQUFXdkcsQ0FBWDtBQUFlO0FBQ2xDO0FBQ0QsU0FBT3FILEdBQVA7QUFDRDs7QUFFRCxTQUFTazhCLG1CQUFULENBQThCQyxPQUE5QixFQUF1QztBQUNyQyxNQUFJeGpDLENBQUosRUFBT3NSLENBQVA7QUFDQSxNQUFJaUosTUFBTSxFQUFWOztBQUVBLE1BQUlnRixVQUFVaWtCLFFBQVFqa0IsT0FBdEI7QUFDQSxNQUFJZ2pCLFVBQVVpQixRQUFRakIsT0FBdEI7O0FBRUEsT0FBS3ZpQyxJQUFJLENBQVQsRUFBWUEsSUFBSXVFLE1BQU1qRixNQUF0QixFQUE4QixFQUFFVSxDQUFoQyxFQUFtQztBQUNqQ3VhLFFBQUloVyxNQUFNdkUsQ0FBTixDQUFKLElBQWdCLEVBQWhCO0FBQ0EsU0FBS3NSLElBQUksQ0FBVCxFQUFZQSxJQUFJaU8sUUFBUWpnQixNQUF4QixFQUFnQyxFQUFFZ1MsQ0FBbEMsRUFBcUM7QUFDbkMsVUFBSXd4QixNQUFNdmpCLFFBQVFqTyxDQUFSLEVBQVcvTSxNQUFNdkUsQ0FBTixDQUFYLENBQU4sQ0FBSixFQUFpQztBQUMvQnVhLFlBQUloVyxNQUFNdkUsQ0FBTixDQUFKLEVBQWNDLElBQWQsQ0FBbUJzZixRQUFRak8sQ0FBUixFQUFXL00sTUFBTXZFLENBQU4sQ0FBWCxDQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTeWpDLFdBQVQsQ0FBc0JqWCxHQUF0QixFQUEyQjtBQUN6QixXQUFPLElBQUlGLEtBQUosQ0FBVWlXLFFBQVFkLE9BQVIsQ0FBZ0JqVixHQUFoQixFQUFxQjdPLFdBQXJCLEVBQVYsRUFBOEMsRUFBOUMsRUFBa0QsRUFBbEQsRUFBc0QzWSxTQUF0RCxFQUFpRXduQixHQUFqRSxDQUFQO0FBQ0Q7O0FBRUQsV0FBU2tYLFVBQVQsQ0FBcUJDLFFBQXJCLEVBQStCMVUsU0FBL0IsRUFBMEM7QUFDeEMsYUFBU2pCLFNBQVQsR0FBc0I7QUFDcEIsVUFBSSxFQUFFQSxVQUFVaUIsU0FBWixLQUEwQixDQUE5QixFQUFpQztBQUMvQjJVLG1CQUFXRCxRQUFYO0FBQ0Q7QUFDRjtBQUNEM1YsY0FBVWlCLFNBQVYsR0FBc0JBLFNBQXRCO0FBQ0EsV0FBT2pCLFNBQVA7QUFDRDs7QUFFRCxXQUFTNFYsVUFBVCxDQUFxQnh1QixFQUFyQixFQUF5QjtBQUN2QixRQUFJMVIsU0FBUzYrQixRQUFRakMsVUFBUixDQUFtQmxyQixFQUFuQixDQUFiO0FBQ0E7QUFDQSxRQUFJMHRCLE1BQU1wL0IsTUFBTixDQUFKLEVBQW1CO0FBQ2pCNitCLGNBQVFMLFdBQVIsQ0FBb0J4K0IsTUFBcEIsRUFBNEIwUixFQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXl1QixRQUFRLENBQVo7QUFDQSxXQUFTQyxTQUFULENBQW9CcC9CLEtBQXBCLEVBQTJCcS9CLGtCQUEzQixFQUErQ3pNLFNBQS9DLEVBQTBEQyxNQUExRCxFQUFrRXlNLE1BQWxFLEVBQTBFO0FBQ3hFdC9CLFVBQU1vb0IsWUFBTixHQUFxQixDQUFDa1gsTUFBdEIsQ0FEd0UsQ0FDMUM7QUFDOUIsUUFBSWxNLGdCQUFnQnB6QixLQUFoQixFQUF1QnEvQixrQkFBdkIsRUFBMkN6TSxTQUEzQyxFQUFzREMsTUFBdEQsQ0FBSixFQUFtRTtBQUNqRTtBQUNEOztBQUVELFFBQUk1ekIsT0FBT2UsTUFBTWYsSUFBakI7QUFDQSxRQUFJRixXQUFXaUIsTUFBTWpCLFFBQXJCO0FBQ0EsUUFBSWdHLE1BQU0vRSxNQUFNK0UsR0FBaEI7QUFDQSxRQUFJcTVCLE1BQU1yNUIsR0FBTixDQUFKLEVBQWdCO0FBQ2QsVUFBSXhMLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFlBQUkzQyxRQUFRQSxLQUFLc2dDLEdBQWpCLEVBQXNCO0FBQ3BCSjtBQUNEO0FBQ0QsWUFDRSxDQUFDQSxLQUFELElBQ0EsQ0FBQ24vQixNQUFNaW9CLEVBRFAsSUFFQSxFQUFFem5CLE9BQU9nYixlQUFQLENBQXVCNWdCLE1BQXZCLElBQWlDNEYsT0FBT2diLGVBQVAsQ0FBdUJoWCxPQUF2QixDQUErQk8sR0FBL0IsSUFBc0MsQ0FBQyxDQUExRSxDQUZBLElBR0F2RSxPQUFPbWIsZ0JBQVAsQ0FBd0I1VyxHQUF4QixDQUpGLEVBS0U7QUFDQTFHLGVBQ0UsOEJBQThCMEcsR0FBOUIsR0FBb0MsY0FBcEMsR0FDQSw4REFEQSxHQUVBLHlDQUhGLEVBSUUvRSxNQUFNK25CLE9BSlI7QUFNRDtBQUNGO0FBQ0QvbkIsWUFBTThuQixHQUFOLEdBQVk5bkIsTUFBTWlvQixFQUFOLEdBQ1I0VixRQUFRWCxlQUFSLENBQXdCbDlCLE1BQU1pb0IsRUFBOUIsRUFBa0NsakIsR0FBbEMsQ0FEUSxHQUVSODRCLFFBQVEzSixhQUFSLENBQXNCbnZCLEdBQXRCLEVBQTJCL0UsS0FBM0IsQ0FGSjtBQUdBdy9CLGVBQVN4L0IsS0FBVDs7QUFFQTtBQUNBO0FBQ0V5L0IsdUJBQWV6L0IsS0FBZixFQUFzQmpCLFFBQXRCLEVBQWdDc2dDLGtCQUFoQztBQUNBLFlBQUlqQixNQUFNbi9CLElBQU4sQ0FBSixFQUFpQjtBQUNmeWdDLDRCQUFrQjEvQixLQUFsQixFQUF5QnEvQixrQkFBekI7QUFDRDtBQUNEbk0sZUFBT04sU0FBUCxFQUFrQjV5QixNQUFNOG5CLEdBQXhCLEVBQTZCK0ssTUFBN0I7QUFDRDs7QUFFRCxVQUFJdDVCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDM0MsSUFBekMsSUFBaURBLEtBQUtzZ0MsR0FBMUQsRUFBK0Q7QUFDN0RKO0FBQ0Q7QUFDRixLQXBDRCxNQW9DTyxJQUFJZCxPQUFPcitCLE1BQU1xb0IsU0FBYixDQUFKLEVBQTZCO0FBQ2xDcm9CLFlBQU04bkIsR0FBTixHQUFZK1YsUUFBUVQsYUFBUixDQUFzQnA5QixNQUFNNm5CLElBQTVCLENBQVo7QUFDQXFMLGFBQU9OLFNBQVAsRUFBa0I1eUIsTUFBTThuQixHQUF4QixFQUE2QitLLE1BQTdCO0FBQ0QsS0FITSxNQUdBO0FBQ0w3eUIsWUFBTThuQixHQUFOLEdBQVkrVixRQUFRcmYsY0FBUixDQUF1QnhlLE1BQU02bkIsSUFBN0IsQ0FBWjtBQUNBcUwsYUFBT04sU0FBUCxFQUFrQjV5QixNQUFNOG5CLEdBQXhCLEVBQTZCK0ssTUFBN0I7QUFDRDtBQUNGOztBQUVELFdBQVNPLGVBQVQsQ0FBMEJwekIsS0FBMUIsRUFBaUNxL0Isa0JBQWpDLEVBQXFEek0sU0FBckQsRUFBZ0VDLE1BQWhFLEVBQXdFO0FBQ3RFLFFBQUl2M0IsSUFBSTBFLE1BQU1mLElBQWQ7QUFDQSxRQUFJbS9CLE1BQU05aUMsQ0FBTixDQUFKLEVBQWM7QUFDWixVQUFJcWtDLGdCQUFnQnZCLE1BQU1wK0IsTUFBTW1vQixpQkFBWixLQUFrQzdzQixFQUFFMDNCLFNBQXhEO0FBQ0EsVUFBSW9MLE1BQU05aUMsSUFBSUEsRUFBRXdFLElBQVosS0FBcUJzK0IsTUFBTTlpQyxJQUFJQSxFQUFFeUUsSUFBWixDQUF6QixFQUE0QztBQUMxQ3pFLFVBQUUwRSxLQUFGLEVBQVMsS0FBVCxDQUFlLGVBQWYsRUFBZ0M0eUIsU0FBaEMsRUFBMkNDLE1BQTNDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUl1TCxNQUFNcCtCLE1BQU1tb0IsaUJBQVosQ0FBSixFQUFvQztBQUNsQ3lYLHNCQUFjNS9CLEtBQWQsRUFBcUJxL0Isa0JBQXJCO0FBQ0EsWUFBSWhCLE9BQU9zQixhQUFQLENBQUosRUFBMkI7QUFDekJFLDhCQUFvQjcvQixLQUFwQixFQUEyQnEvQixrQkFBM0IsRUFBK0N6TSxTQUEvQyxFQUEwREMsTUFBMUQ7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTK00sYUFBVCxDQUF3QjUvQixLQUF4QixFQUErQnEvQixrQkFBL0IsRUFBbUQ7QUFDakQsUUFBSWpCLE1BQU1wK0IsTUFBTWYsSUFBTixDQUFXNmdDLGFBQWpCLENBQUosRUFBcUM7QUFDbkNULHlCQUFtQjlqQyxJQUFuQixDQUF3QkksS0FBeEIsQ0FBOEIwakMsa0JBQTlCLEVBQWtEci9CLE1BQU1mLElBQU4sQ0FBVzZnQyxhQUE3RDtBQUNEO0FBQ0Q5L0IsVUFBTThuQixHQUFOLEdBQVk5bkIsTUFBTW1vQixpQkFBTixDQUF3QnNFLEdBQXBDO0FBQ0EsUUFBSXNULFlBQVkvL0IsS0FBWixDQUFKLEVBQXdCO0FBQ3RCMC9CLHdCQUFrQjEvQixLQUFsQixFQUF5QnEvQixrQkFBekI7QUFDQUcsZUFBU3gvQixLQUFUO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBODlCLGtCQUFZOTlCLEtBQVo7QUFDQTtBQUNBcS9CLHlCQUFtQjlqQyxJQUFuQixDQUF3QnlFLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTNi9CLG1CQUFULENBQThCNy9CLEtBQTlCLEVBQXFDcS9CLGtCQUFyQyxFQUF5RHpNLFNBQXpELEVBQW9FQyxNQUFwRSxFQUE0RTtBQUMxRSxRQUFJdjNCLENBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUkwa0MsWUFBWWhnQyxLQUFoQjtBQUNBLFdBQU9nZ0MsVUFBVTdYLGlCQUFqQixFQUFvQztBQUNsQzZYLGtCQUFZQSxVQUFVN1gsaUJBQVYsQ0FBNEJ3RSxNQUF4QztBQUNBLFVBQUl5UixNQUFNOWlDLElBQUkwa0MsVUFBVS9nQyxJQUFwQixLQUE2Qm0vQixNQUFNOWlDLElBQUlBLEVBQUUya0MsVUFBWixDQUFqQyxFQUEwRDtBQUN4RCxhQUFLM2tDLElBQUksQ0FBVCxFQUFZQSxJQUFJdWEsSUFBSXFxQixRQUFKLENBQWF0bEMsTUFBN0IsRUFBcUMsRUFBRVUsQ0FBdkMsRUFBMEM7QUFDeEN1YSxjQUFJcXFCLFFBQUosQ0FBYTVrQyxDQUFiLEVBQWdCNGlDLFNBQWhCLEVBQTJCOEIsU0FBM0I7QUFDRDtBQUNEWCwyQkFBbUI5akMsSUFBbkIsQ0FBd0J5a0MsU0FBeEI7QUFDQTtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0E5TSxXQUFPTixTQUFQLEVBQWtCNXlCLE1BQU04bkIsR0FBeEIsRUFBNkIrSyxNQUE3QjtBQUNEOztBQUVELFdBQVNLLE1BQVQsQ0FBaUJsMEIsTUFBakIsRUFBeUI4b0IsR0FBekIsRUFBOEJocEIsR0FBOUIsRUFBbUM7QUFDakMsUUFBSXMvQixNQUFNcC9CLE1BQU4sQ0FBSixFQUFtQjtBQUNqQixVQUFJby9CLE1BQU10L0IsR0FBTixDQUFKLEVBQWdCO0FBQ2QrK0IsZ0JBQVFSLFlBQVIsQ0FBcUJyK0IsTUFBckIsRUFBNkI4b0IsR0FBN0IsRUFBa0NocEIsR0FBbEM7QUFDRCxPQUZELE1BRU87QUFDTCsrQixnQkFBUUosV0FBUixDQUFvQnorQixNQUFwQixFQUE0QjhvQixHQUE1QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTMlgsY0FBVCxDQUF5QnovQixLQUF6QixFQUFnQ2pCLFFBQWhDLEVBQTBDc2dDLGtCQUExQyxFQUE4RDtBQUM1RCxRQUFJamtDLE1BQU1tSCxPQUFOLENBQWN4RCxRQUFkLENBQUosRUFBNkI7QUFDM0IsV0FBSyxJQUFJekQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUQsU0FBU25FLE1BQTdCLEVBQXFDLEVBQUVVLENBQXZDLEVBQTBDO0FBQ3hDOGpDLGtCQUFVcmdDLFNBQVN6RCxDQUFULENBQVYsRUFBdUIrakMsa0JBQXZCLEVBQTJDci9CLE1BQU04bkIsR0FBakQsRUFBc0QsSUFBdEQsRUFBNEQsSUFBNUQ7QUFDRDtBQUNGLEtBSkQsTUFJTyxJQUFJdk8sWUFBWXZaLE1BQU02bkIsSUFBbEIsQ0FBSixFQUE2QjtBQUNsQ2dXLGNBQVFKLFdBQVIsQ0FBb0J6OUIsTUFBTThuQixHQUExQixFQUErQitWLFFBQVFyZixjQUFSLENBQXVCeGUsTUFBTTZuQixJQUE3QixDQUEvQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2tZLFdBQVQsQ0FBc0IvL0IsS0FBdEIsRUFBNkI7QUFDM0IsV0FBT0EsTUFBTW1vQixpQkFBYixFQUFnQztBQUM5Qm5vQixjQUFRQSxNQUFNbW9CLGlCQUFOLENBQXdCd0UsTUFBaEM7QUFDRDtBQUNELFdBQU95UixNQUFNcCtCLE1BQU0rRSxHQUFaLENBQVA7QUFDRDs7QUFFRCxXQUFTMjZCLGlCQUFULENBQTRCMS9CLEtBQTVCLEVBQW1DcS9CLGtCQUFuQyxFQUF1RDtBQUNyRCxTQUFLLElBQUlwVSxNQUFNLENBQWYsRUFBa0JBLE1BQU1wVixJQUFJek0sTUFBSixDQUFXeE8sTUFBbkMsRUFBMkMsRUFBRXF3QixHQUE3QyxFQUFrRDtBQUNoRHBWLFVBQUl6TSxNQUFKLENBQVc2aEIsR0FBWCxFQUFnQmlULFNBQWhCLEVBQTJCbCtCLEtBQTNCO0FBQ0Q7QUFDRDFFLFFBQUkwRSxNQUFNZixJQUFOLENBQVdhLElBQWYsQ0FKcUQsQ0FJaEM7QUFDckIsUUFBSXMrQixNQUFNOWlDLENBQU4sQ0FBSixFQUFjO0FBQ1osVUFBSThpQyxNQUFNOWlDLEVBQUU4TixNQUFSLENBQUosRUFBcUI7QUFBRTlOLFVBQUU4TixNQUFGLENBQVM4MEIsU0FBVCxFQUFvQmwrQixLQUFwQjtBQUE2QjtBQUNwRCxVQUFJbytCLE1BQU05aUMsRUFBRTQzQixNQUFSLENBQUosRUFBcUI7QUFBRW1NLDJCQUFtQjlqQyxJQUFuQixDQUF3QnlFLEtBQXhCO0FBQWlDO0FBQ3pEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBU3cvQixRQUFULENBQW1CeC9CLEtBQW5CLEVBQTBCO0FBQ3hCLFFBQUkxRSxDQUFKO0FBQ0EsUUFBSTZrQyxXQUFXbmdDLEtBQWY7QUFDQSxXQUFPbWdDLFFBQVAsRUFBaUI7QUFDZixVQUFJL0IsTUFBTTlpQyxJQUFJNmtDLFNBQVNwWSxPQUFuQixLQUErQnFXLE1BQU05aUMsSUFBSUEsRUFBRW1NLFFBQUYsQ0FBVzI0QixRQUFyQixDQUFuQyxFQUFtRTtBQUNqRXZDLGdCQUFRWixZQUFSLENBQXFCajlCLE1BQU04bkIsR0FBM0IsRUFBZ0N4c0IsQ0FBaEMsRUFBbUMsRUFBbkM7QUFDRDtBQUNENmtDLGlCQUFXQSxTQUFTbmhDLE1BQXBCO0FBQ0Q7QUFDRDtBQUNBLFFBQUlvL0IsTUFBTTlpQyxJQUFJb3dCLGNBQVYsS0FDQXB3QixNQUFNMEUsTUFBTStuQixPQURaLElBRUFxVyxNQUFNOWlDLElBQUlBLEVBQUVtTSxRQUFGLENBQVcyNEIsUUFBckIsQ0FGSixFQUVvQztBQUNsQ3ZDLGNBQVFaLFlBQVIsQ0FBcUJqOUIsTUFBTThuQixHQUEzQixFQUFnQ3hzQixDQUFoQyxFQUFtQyxFQUFuQztBQUNEO0FBQ0Y7O0FBRUQsV0FBUytrQyxTQUFULENBQW9Cek4sU0FBcEIsRUFBK0JDLE1BQS9CLEVBQXVDL0osTUFBdkMsRUFBK0N3WCxRQUEvQyxFQUF5RDFCLE1BQXpELEVBQWlFUyxrQkFBakUsRUFBcUY7QUFDbkYsV0FBT2lCLFlBQVkxQixNQUFuQixFQUEyQixFQUFFMEIsUUFBN0IsRUFBdUM7QUFDckNsQixnQkFBVXRXLE9BQU93WCxRQUFQLENBQVYsRUFBNEJqQixrQkFBNUIsRUFBZ0R6TSxTQUFoRCxFQUEyREMsTUFBM0Q7QUFDRDtBQUNGOztBQUVELFdBQVMwTixpQkFBVCxDQUE0QnZnQyxLQUE1QixFQUFtQztBQUNqQyxRQUFJMUUsQ0FBSixFQUFPc1IsQ0FBUDtBQUNBLFFBQUkzTixPQUFPZSxNQUFNZixJQUFqQjtBQUNBLFFBQUltL0IsTUFBTW4vQixJQUFOLENBQUosRUFBaUI7QUFDZixVQUFJbS9CLE1BQU05aUMsSUFBSTJELEtBQUthLElBQWYsS0FBd0JzK0IsTUFBTTlpQyxJQUFJQSxFQUFFK0UsT0FBWixDQUE1QixFQUFrRDtBQUFFL0UsVUFBRTBFLEtBQUY7QUFBVztBQUMvRCxXQUFLMUUsSUFBSSxDQUFULEVBQVlBLElBQUl1YSxJQUFJeFYsT0FBSixDQUFZekYsTUFBNUIsRUFBb0MsRUFBRVUsQ0FBdEMsRUFBeUM7QUFBRXVhLFlBQUl4VixPQUFKLENBQVkvRSxDQUFaLEVBQWUwRSxLQUFmO0FBQXdCO0FBQ3BFO0FBQ0QsUUFBSW8rQixNQUFNOWlDLElBQUkwRSxNQUFNakIsUUFBaEIsQ0FBSixFQUErQjtBQUM3QixXQUFLNk4sSUFBSSxDQUFULEVBQVlBLElBQUk1TSxNQUFNakIsUUFBTixDQUFlbkUsTUFBL0IsRUFBdUMsRUFBRWdTLENBQXpDLEVBQTRDO0FBQzFDMnpCLDBCQUFrQnZnQyxNQUFNakIsUUFBTixDQUFlNk4sQ0FBZixDQUFsQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTNHpCLFlBQVQsQ0FBdUI1TixTQUF2QixFQUFrQzlKLE1BQWxDLEVBQTBDd1gsUUFBMUMsRUFBb0QxQixNQUFwRCxFQUE0RDtBQUMxRCxXQUFPMEIsWUFBWTFCLE1BQW5CLEVBQTJCLEVBQUUwQixRQUE3QixFQUF1QztBQUNyQyxVQUFJRyxLQUFLM1gsT0FBT3dYLFFBQVAsQ0FBVDtBQUNBLFVBQUlsQyxNQUFNcUMsRUFBTixDQUFKLEVBQWU7QUFDYixZQUFJckMsTUFBTXFDLEdBQUcxN0IsR0FBVCxDQUFKLEVBQW1CO0FBQ2pCMjdCLG9DQUEwQkQsRUFBMUI7QUFDQUYsNEJBQWtCRSxFQUFsQjtBQUNELFNBSEQsTUFHTztBQUFFO0FBQ1B2QixxQkFBV3VCLEdBQUczWSxHQUFkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBUzRZLHlCQUFULENBQW9DMWdDLEtBQXBDLEVBQTJDMmdDLEVBQTNDLEVBQStDO0FBQzdDLFFBQUl2QyxNQUFNdUMsRUFBTixLQUFhdkMsTUFBTXArQixNQUFNZixJQUFaLENBQWpCLEVBQW9DO0FBQ2xDLFVBQUlzckIsWUFBWTFVLElBQUlzRCxNQUFKLENBQVd2ZSxNQUFYLEdBQW9CLENBQXBDO0FBQ0EsVUFBSXdqQyxNQUFNdUMsRUFBTixDQUFKLEVBQWU7QUFDYjtBQUNBO0FBQ0FBLFdBQUdwVyxTQUFILElBQWdCQSxTQUFoQjtBQUNELE9BSkQsTUFJTztBQUNMO0FBQ0FvVyxhQUFLM0IsV0FBV2gvQixNQUFNOG5CLEdBQWpCLEVBQXNCeUMsU0FBdEIsQ0FBTDtBQUNEO0FBQ0Q7QUFDQSxVQUFJNlQsTUFBTTlpQyxJQUFJMEUsTUFBTW1vQixpQkFBaEIsS0FBc0NpVyxNQUFNOWlDLElBQUlBLEVBQUVxeEIsTUFBWixDQUF0QyxJQUE2RHlSLE1BQU05aUMsRUFBRTJELElBQVIsQ0FBakUsRUFBZ0Y7QUFDOUV5aEMsa0NBQTBCcGxDLENBQTFCLEVBQTZCcWxDLEVBQTdCO0FBQ0Q7QUFDRCxXQUFLcmxDLElBQUksQ0FBVCxFQUFZQSxJQUFJdWEsSUFBSXNELE1BQUosQ0FBV3ZlLE1BQTNCLEVBQW1DLEVBQUVVLENBQXJDLEVBQXdDO0FBQ3RDdWEsWUFBSXNELE1BQUosQ0FBVzdkLENBQVgsRUFBYzBFLEtBQWQsRUFBcUIyZ0MsRUFBckI7QUFDRDtBQUNELFVBQUl2QyxNQUFNOWlDLElBQUkwRSxNQUFNZixJQUFOLENBQVdhLElBQXJCLEtBQThCcytCLE1BQU05aUMsSUFBSUEsRUFBRTZkLE1BQVosQ0FBbEMsRUFBdUQ7QUFDckQ3ZCxVQUFFMEUsS0FBRixFQUFTMmdDLEVBQVQ7QUFDRCxPQUZELE1BRU87QUFDTEE7QUFDRDtBQUNGLEtBdEJELE1Bc0JPO0FBQ0x6QixpQkFBV2wvQixNQUFNOG5CLEdBQWpCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTOFksY0FBVCxDQUF5QmhPLFNBQXpCLEVBQW9DaU8sS0FBcEMsRUFBMkNDLEtBQTNDLEVBQWtEekIsa0JBQWxELEVBQXNFMEIsVUFBdEUsRUFBa0Y7QUFDaEYsUUFBSUMsY0FBYyxDQUFsQjtBQUNBLFFBQUlDLGNBQWMsQ0FBbEI7QUFDQSxRQUFJQyxZQUFZTCxNQUFNam1DLE1BQU4sR0FBZSxDQUEvQjtBQUNBLFFBQUl1bUMsZ0JBQWdCTixNQUFNLENBQU4sQ0FBcEI7QUFDQSxRQUFJTyxjQUFjUCxNQUFNSyxTQUFOLENBQWxCO0FBQ0EsUUFBSUcsWUFBWVAsTUFBTWxtQyxNQUFOLEdBQWUsQ0FBL0I7QUFDQSxRQUFJMG1DLGdCQUFnQlIsTUFBTSxDQUFOLENBQXBCO0FBQ0EsUUFBSVMsY0FBY1QsTUFBTU8sU0FBTixDQUFsQjtBQUNBLFFBQUlHLFdBQUosRUFBaUJDLFFBQWpCLEVBQTJCQyxTQUEzQixFQUFzQzdPLE1BQXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUk4TyxVQUFVLENBQUNaLFVBQWY7O0FBRUEsV0FBT0MsZUFBZUUsU0FBZixJQUE0QkQsZUFBZUksU0FBbEQsRUFBNkQ7QUFDM0QsVUFBSWxELFFBQVFnRCxhQUFSLENBQUosRUFBNEI7QUFDMUJBLHdCQUFnQk4sTUFBTSxFQUFFRyxXQUFSLENBQWhCLENBRDBCLENBQ1k7QUFDdkMsT0FGRCxNQUVPLElBQUk3QyxRQUFRaUQsV0FBUixDQUFKLEVBQTBCO0FBQy9CQSxzQkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDRCxPQUZNLE1BRUEsSUFBSTVDLFVBQVU2QyxhQUFWLEVBQXlCRyxhQUF6QixDQUFKLEVBQTZDO0FBQ2xETSxtQkFBV1QsYUFBWCxFQUEwQkcsYUFBMUIsRUFBeUNqQyxrQkFBekM7QUFDQThCLHdCQUFnQk4sTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0FNLHdCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsT0FKTSxNQUlBLElBQUkzQyxVQUFVOEMsV0FBVixFQUF1QkcsV0FBdkIsQ0FBSixFQUF5QztBQUM5Q0ssbUJBQVdSLFdBQVgsRUFBd0JHLFdBQXhCLEVBQXFDbEMsa0JBQXJDO0FBQ0ErQixzQkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDQUssc0JBQWNULE1BQU0sRUFBRU8sU0FBUixDQUFkO0FBQ0QsT0FKTSxNQUlBLElBQUkvQyxVQUFVNkMsYUFBVixFQUF5QkksV0FBekIsQ0FBSixFQUEyQztBQUFFO0FBQ2xESyxtQkFBV1QsYUFBWCxFQUEwQkksV0FBMUIsRUFBdUNsQyxrQkFBdkM7QUFDQXNDLG1CQUFXOUQsUUFBUVIsWUFBUixDQUFxQnpLLFNBQXJCLEVBQWdDdU8sY0FBY3JaLEdBQTlDLEVBQW1EK1YsUUFBUUgsV0FBUixDQUFvQjBELFlBQVl0WixHQUFoQyxDQUFuRCxDQUFYO0FBQ0FxWix3QkFBZ0JOLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNBTyxzQkFBY1QsTUFBTSxFQUFFTyxTQUFSLENBQWQ7QUFDRCxPQUxNLE1BS0EsSUFBSS9DLFVBQVU4QyxXQUFWLEVBQXVCRSxhQUF2QixDQUFKLEVBQTJDO0FBQUU7QUFDbERNLG1CQUFXUixXQUFYLEVBQXdCRSxhQUF4QixFQUF1Q2pDLGtCQUF2QztBQUNBc0MsbUJBQVc5RCxRQUFRUixZQUFSLENBQXFCekssU0FBckIsRUFBZ0N3TyxZQUFZdFosR0FBNUMsRUFBaURxWixjQUFjclosR0FBL0QsQ0FBWDtBQUNBc1osc0JBQWNQLE1BQU0sRUFBRUssU0FBUixDQUFkO0FBQ0FJLHdCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsT0FMTSxNQUtBO0FBQ0wsWUFBSTlDLFFBQVFxRCxXQUFSLENBQUosRUFBMEI7QUFBRUEsd0JBQWM5QyxrQkFBa0JtQyxLQUFsQixFQUF5QkcsV0FBekIsRUFBc0NFLFNBQXRDLENBQWQ7QUFBaUU7QUFDN0ZPLG1CQUFXckQsTUFBTWtELGNBQWN6L0IsR0FBcEIsSUFBMkIyL0IsWUFBWUYsY0FBY3ovQixHQUExQixDQUEzQixHQUE0RCxJQUF2RTtBQUNBLFlBQUlzOEIsUUFBUXNELFFBQVIsQ0FBSixFQUF1QjtBQUFFO0FBQ3ZCckMsb0JBQVVrQyxhQUFWLEVBQXlCakMsa0JBQXpCLEVBQTZDek0sU0FBN0MsRUFBd0R1TyxjQUFjclosR0FBdEU7QUFDQXdaLDBCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsU0FIRCxNQUdPO0FBQ0xTLHNCQUFZYixNQUFNWSxRQUFOLENBQVo7QUFDQTtBQUNBLGNBQUlsb0MsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQzgvQixTQUE5QyxFQUF5RDtBQUN2RHJqQyxpQkFDRSx3RUFDQSw2Q0FGRjtBQUlEO0FBQ0QsY0FBSWlnQyxVQUFVb0QsU0FBVixFQUFxQkosYUFBckIsQ0FBSixFQUF5QztBQUN2Q00sdUJBQVdGLFNBQVgsRUFBc0JKLGFBQXRCLEVBQXFDakMsa0JBQXJDO0FBQ0F3QixrQkFBTVksUUFBTixJQUFrQm5oQyxTQUFsQjtBQUNBcWhDLHVCQUFXOUQsUUFBUVIsWUFBUixDQUFxQnpLLFNBQXJCLEVBQWdDME8sY0FBY3haLEdBQTlDLEVBQW1EcVosY0FBY3JaLEdBQWpFLENBQVg7QUFDQXdaLDRCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsV0FMRCxNQUtPO0FBQ0w7QUFDQTdCLHNCQUFVa0MsYUFBVixFQUF5QmpDLGtCQUF6QixFQUE2Q3pNLFNBQTdDLEVBQXdEdU8sY0FBY3JaLEdBQXRFO0FBQ0F3Wiw0QkFBZ0JSLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsUUFBSUQsY0FBY0UsU0FBbEIsRUFBNkI7QUFDM0JyTyxlQUFTc0wsUUFBUTJDLE1BQU1PLFlBQVksQ0FBbEIsQ0FBUixJQUFnQyxJQUFoQyxHQUF1Q1AsTUFBTU8sWUFBWSxDQUFsQixFQUFxQnZaLEdBQXJFO0FBQ0F1WSxnQkFBVXpOLFNBQVYsRUFBcUJDLE1BQXJCLEVBQTZCaU8sS0FBN0IsRUFBb0NHLFdBQXBDLEVBQWlESSxTQUFqRCxFQUE0RGhDLGtCQUE1RDtBQUNELEtBSEQsTUFHTyxJQUFJNEIsY0FBY0ksU0FBbEIsRUFBNkI7QUFDbENiLG1CQUFhNU4sU0FBYixFQUF3QmlPLEtBQXhCLEVBQStCRyxXQUEvQixFQUE0Q0UsU0FBNUM7QUFDRDtBQUNGOztBQUVELFdBQVNVLFVBQVQsQ0FBcUJ4aEMsUUFBckIsRUFBK0JKLEtBQS9CLEVBQXNDcS9CLGtCQUF0QyxFQUEwRDBCLFVBQTFELEVBQXNFO0FBQ3BFLFFBQUkzZ0MsYUFBYUosS0FBakIsRUFBd0I7QUFDdEI7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSXErQixPQUFPcitCLE1BQU1xRyxRQUFiLEtBQ0FnNEIsT0FBT2orQixTQUFTaUcsUUFBaEIsQ0FEQSxJQUVBckcsTUFBTTZCLEdBQU4sS0FBY3pCLFNBQVN5QixHQUZ2QixLQUdDdzhCLE9BQU9yK0IsTUFBTXNvQixRQUFiLEtBQTBCK1YsT0FBT3IrQixNQUFNdW9CLE1BQWIsQ0FIM0IsQ0FBSixFQUdzRDtBQUNwRHZvQixZQUFNOG5CLEdBQU4sR0FBWTFuQixTQUFTMG5CLEdBQXJCO0FBQ0E5bkIsWUFBTW1vQixpQkFBTixHQUEwQi9uQixTQUFTK25CLGlCQUFuQztBQUNBO0FBQ0Q7QUFDRCxRQUFJN3NCLENBQUo7QUFDQSxRQUFJMkQsT0FBT2UsTUFBTWYsSUFBakI7QUFDQSxRQUFJbS9CLE1BQU1uL0IsSUFBTixLQUFlbS9CLE1BQU05aUMsSUFBSTJELEtBQUthLElBQWYsQ0FBZixJQUF1Q3MrQixNQUFNOWlDLElBQUlBLEVBQUU2RSxRQUFaLENBQTNDLEVBQWtFO0FBQ2hFN0UsUUFBRThFLFFBQUYsRUFBWUosS0FBWjtBQUNEO0FBQ0QsUUFBSThuQixNQUFNOW5CLE1BQU04bkIsR0FBTixHQUFZMW5CLFNBQVMwbkIsR0FBL0I7QUFDQSxRQUFJK1ksUUFBUXpnQyxTQUFTckIsUUFBckI7QUFDQSxRQUFJMGhDLEtBQUt6Z0MsTUFBTWpCLFFBQWY7QUFDQSxRQUFJcS9CLE1BQU1uL0IsSUFBTixLQUFlOGdDLFlBQVkvL0IsS0FBWixDQUFuQixFQUF1QztBQUNyQyxXQUFLMUUsSUFBSSxDQUFULEVBQVlBLElBQUl1YSxJQUFJNkssTUFBSixDQUFXOWxCLE1BQTNCLEVBQW1DLEVBQUVVLENBQXJDLEVBQXdDO0FBQUV1YSxZQUFJNkssTUFBSixDQUFXcGxCLENBQVgsRUFBYzhFLFFBQWQsRUFBd0JKLEtBQXhCO0FBQWlDO0FBQzNFLFVBQUlvK0IsTUFBTTlpQyxJQUFJMkQsS0FBS2EsSUFBZixLQUF3QnMrQixNQUFNOWlDLElBQUlBLEVBQUVvbEIsTUFBWixDQUE1QixFQUFpRDtBQUFFcGxCLFVBQUU4RSxRQUFGLEVBQVlKLEtBQVo7QUFBcUI7QUFDekU7QUFDRCxRQUFJbStCLFFBQVFuK0IsTUFBTTZuQixJQUFkLENBQUosRUFBeUI7QUFDdkIsVUFBSXVXLE1BQU15QyxLQUFOLEtBQWdCekMsTUFBTXFDLEVBQU4sQ0FBcEIsRUFBK0I7QUFDN0IsWUFBSUksVUFBVUosRUFBZCxFQUFrQjtBQUFFRyx5QkFBZTlZLEdBQWYsRUFBb0IrWSxLQUFwQixFQUEyQkosRUFBM0IsRUFBK0JwQixrQkFBL0IsRUFBbUQwQixVQUFuRDtBQUFpRTtBQUN0RixPQUZELE1BRU8sSUFBSTNDLE1BQU1xQyxFQUFOLENBQUosRUFBZTtBQUNwQixZQUFJckMsTUFBTWgrQixTQUFTeW5CLElBQWYsQ0FBSixFQUEwQjtBQUFFZ1csa0JBQVFGLGNBQVIsQ0FBdUI3VixHQUF2QixFQUE0QixFQUE1QjtBQUFrQztBQUM5RHVZLGtCQUFVdlksR0FBVixFQUFlLElBQWYsRUFBcUIyWSxFQUFyQixFQUF5QixDQUF6QixFQUE0QkEsR0FBRzdsQyxNQUFILEdBQVksQ0FBeEMsRUFBMkN5a0Msa0JBQTNDO0FBQ0QsT0FITSxNQUdBLElBQUlqQixNQUFNeUMsS0FBTixDQUFKLEVBQWtCO0FBQ3ZCTCxxQkFBYTFZLEdBQWIsRUFBa0IrWSxLQUFsQixFQUF5QixDQUF6QixFQUE0QkEsTUFBTWptQyxNQUFOLEdBQWUsQ0FBM0M7QUFDRCxPQUZNLE1BRUEsSUFBSXdqQyxNQUFNaCtCLFNBQVN5bkIsSUFBZixDQUFKLEVBQTBCO0FBQy9CZ1csZ0JBQVFGLGNBQVIsQ0FBdUI3VixHQUF2QixFQUE0QixFQUE1QjtBQUNEO0FBQ0YsS0FYRCxNQVdPLElBQUkxbkIsU0FBU3luQixJQUFULEtBQWtCN25CLE1BQU02bkIsSUFBNUIsRUFBa0M7QUFDdkNnVyxjQUFRRixjQUFSLENBQXVCN1YsR0FBdkIsRUFBNEI5bkIsTUFBTTZuQixJQUFsQztBQUNEO0FBQ0QsUUFBSXVXLE1BQU1uL0IsSUFBTixDQUFKLEVBQWlCO0FBQ2YsVUFBSW0vQixNQUFNOWlDLElBQUkyRCxLQUFLYSxJQUFmLEtBQXdCcytCLE1BQU05aUMsSUFBSUEsRUFBRXVtQyxTQUFaLENBQTVCLEVBQW9EO0FBQUV2bUMsVUFBRThFLFFBQUYsRUFBWUosS0FBWjtBQUFxQjtBQUM1RTtBQUNGOztBQUVELFdBQVM4aEMsZ0JBQVQsQ0FBMkI5aEMsS0FBM0IsRUFBa0N6RixLQUFsQyxFQUF5Q3duQyxPQUF6QyxFQUFrRDtBQUNoRDtBQUNBO0FBQ0EsUUFBSTFELE9BQU8wRCxPQUFQLEtBQW1CM0QsTUFBTXArQixNQUFNaEIsTUFBWixDQUF2QixFQUE0QztBQUMxQ2dCLFlBQU1oQixNQUFOLENBQWFDLElBQWIsQ0FBa0I2Z0MsYUFBbEIsR0FBa0N2bEMsS0FBbEM7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLLElBQUllLElBQUksQ0FBYixFQUFnQkEsSUFBSWYsTUFBTUssTUFBMUIsRUFBa0MsRUFBRVUsQ0FBcEMsRUFBdUM7QUFDckNmLGNBQU1lLENBQU4sRUFBUzJELElBQVQsQ0FBY2EsSUFBZCxDQUFtQm96QixNQUFuQixDQUEwQjM0QixNQUFNZSxDQUFOLENBQTFCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQUkwbUMsU0FBUyxLQUFiO0FBQ0E7QUFDQTtBQUNBLE1BQUlDLG1CQUFtQm5wQixRQUFRLCtDQUFSLENBQXZCOztBQUVBO0FBQ0EsV0FBU29wQixPQUFULENBQWtCcGEsR0FBbEIsRUFBdUI5bkIsS0FBdkIsRUFBOEJxL0Isa0JBQTlCLEVBQWtEO0FBQ2hELFFBQUk5bEMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSSxDQUFDdWdDLGdCQUFnQnJhLEdBQWhCLEVBQXFCOW5CLEtBQXJCLENBQUwsRUFBa0M7QUFDaEMsZUFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNEQSxVQUFNOG5CLEdBQU4sR0FBWUEsR0FBWjtBQUNBLFFBQUkvaUIsTUFBTS9FLE1BQU0rRSxHQUFoQjtBQUNBLFFBQUk5RixPQUFPZSxNQUFNZixJQUFqQjtBQUNBLFFBQUlGLFdBQVdpQixNQUFNakIsUUFBckI7QUFDQSxRQUFJcS9CLE1BQU1uL0IsSUFBTixDQUFKLEVBQWlCO0FBQ2YsVUFBSW0vQixNQUFNOWlDLElBQUkyRCxLQUFLYSxJQUFmLEtBQXdCcytCLE1BQU05aUMsSUFBSUEsRUFBRXlFLElBQVosQ0FBNUIsRUFBK0M7QUFBRXpFLFVBQUUwRSxLQUFGLEVBQVMsSUFBVCxDQUFjLGVBQWQ7QUFBaUM7QUFDbEYsVUFBSW8rQixNQUFNOWlDLElBQUkwRSxNQUFNbW9CLGlCQUFoQixDQUFKLEVBQXdDO0FBQ3RDO0FBQ0F5WCxzQkFBYzUvQixLQUFkLEVBQXFCcS9CLGtCQUFyQjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxRQUFJakIsTUFBTXI1QixHQUFOLENBQUosRUFBZ0I7QUFDZCxVQUFJcTVCLE1BQU1yL0IsUUFBTixDQUFKLEVBQXFCO0FBQ25CO0FBQ0EsWUFBSSxDQUFDK29CLElBQUlzYSxhQUFKLEVBQUwsRUFBMEI7QUFDeEIzQyx5QkFBZXovQixLQUFmLEVBQXNCakIsUUFBdEIsRUFBZ0NzZ0Msa0JBQWhDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsY0FBSWdELGdCQUFnQixJQUFwQjtBQUNBLGNBQUl4RyxZQUFZL1QsSUFBSXdhLFVBQXBCO0FBQ0EsZUFBSyxJQUFJclgsTUFBTSxDQUFmLEVBQWtCQSxNQUFNbHNCLFNBQVNuRSxNQUFqQyxFQUF5Q3F3QixLQUF6QyxFQUFnRDtBQUM5QyxnQkFBSSxDQUFDNFEsU0FBRCxJQUFjLENBQUNxRyxRQUFRckcsU0FBUixFQUFtQjk4QixTQUFTa3NCLEdBQVQsQ0FBbkIsRUFBa0NvVSxrQkFBbEMsQ0FBbkIsRUFBMEU7QUFDeEVnRCw4QkFBZ0IsS0FBaEI7QUFDQTtBQUNEO0FBQ0R4Ryx3QkFBWUEsVUFBVTZCLFdBQXRCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsY0FBSSxDQUFDMkUsYUFBRCxJQUFrQnhHLFNBQXRCLEVBQWlDO0FBQy9CLGdCQUFJdGlDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQ0EsT0FBT3RELE9BQVAsS0FBbUIsV0FEbkIsSUFFQSxDQUFDMGpDLE1BRkwsRUFFYTtBQUNYQSx1QkFBUyxJQUFUO0FBQ0ExakMsc0JBQVFELElBQVIsQ0FBYSxVQUFiLEVBQXlCeXBCLEdBQXpCO0FBQ0F4cEIsc0JBQVFELElBQVIsQ0FBYSxxQ0FBYixFQUFvRHlwQixJQUFJeWEsVUFBeEQsRUFBb0V4akMsUUFBcEU7QUFDRDtBQUNELG1CQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFJcS9CLE1BQU1uL0IsSUFBTixDQUFKLEVBQWlCO0FBQ2YsYUFBSyxJQUFJNEMsR0FBVCxJQUFnQjVDLElBQWhCLEVBQXNCO0FBQ3BCLGNBQUksQ0FBQ2dqQyxpQkFBaUJwZ0MsR0FBakIsQ0FBTCxFQUE0QjtBQUMxQjY5Qiw4QkFBa0IxL0IsS0FBbEIsRUFBeUJxL0Isa0JBQXpCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRixLQXJDRCxNQXFDTyxJQUFJdlgsSUFBSTdvQixJQUFKLEtBQWFlLE1BQU02bkIsSUFBdkIsRUFBNkI7QUFDbENDLFVBQUk3b0IsSUFBSixHQUFXZSxNQUFNNm5CLElBQWpCO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFTc2EsZUFBVCxDQUEwQjFaLElBQTFCLEVBQWdDem9CLEtBQWhDLEVBQXVDO0FBQ3JDLFFBQUlvK0IsTUFBTXArQixNQUFNK0UsR0FBWixDQUFKLEVBQXNCO0FBQ3BCLGFBQ0UvRSxNQUFNK0UsR0FBTixDQUFVUCxPQUFWLENBQWtCLGVBQWxCLE1BQXVDLENBQXZDLElBQ0F4RSxNQUFNK0UsR0FBTixDQUFVa1UsV0FBVixRQUE2QndQLEtBQUtzVSxPQUFMLElBQWdCdFUsS0FBS3NVLE9BQUwsQ0FBYTlqQixXQUFiLEVBQTdDLENBRkY7QUFJRCxLQUxELE1BS087QUFDTCxhQUFPd1AsS0FBSytaLFFBQUwsTUFBbUJ4aUMsTUFBTXFvQixTQUFOLEdBQWtCLENBQWxCLEdBQXNCLENBQXpDLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sU0FBU29hLEtBQVQsQ0FBZ0JyaUMsUUFBaEIsRUFBMEJKLEtBQTFCLEVBQWlDc3NCLFNBQWpDLEVBQTRDeVUsVUFBNUMsRUFBd0RuTyxTQUF4RCxFQUFtRUMsTUFBbkUsRUFBMkU7QUFDaEYsUUFBSXNMLFFBQVFuK0IsS0FBUixDQUFKLEVBQW9CO0FBQ2xCLFVBQUlvK0IsTUFBTWgrQixRQUFOLENBQUosRUFBcUI7QUFBRW1nQywwQkFBa0JuZ0MsUUFBbEI7QUFBOEI7QUFDckQ7QUFDRDs7QUFFRCxRQUFJc2lDLGlCQUFpQixLQUFyQjtBQUNBLFFBQUlyRCxxQkFBcUIsRUFBekI7O0FBRUEsUUFBSWxCLFFBQVEvOUIsUUFBUixDQUFKLEVBQXVCO0FBQ3JCO0FBQ0FzaUMsdUJBQWlCLElBQWpCO0FBQ0F0RCxnQkFBVXAvQixLQUFWLEVBQWlCcS9CLGtCQUFqQixFQUFxQ3pNLFNBQXJDLEVBQWdEQyxNQUFoRDtBQUNELEtBSkQsTUFJTztBQUNMLFVBQUk4UCxnQkFBZ0J2RSxNQUFNaCtCLFNBQVNvaUMsUUFBZixDQUFwQjtBQUNBLFVBQUksQ0FBQ0csYUFBRCxJQUFrQnJFLFVBQVVsK0IsUUFBVixFQUFvQkosS0FBcEIsQ0FBdEIsRUFBa0Q7QUFDaEQ7QUFDQTRoQyxtQkFBV3hoQyxRQUFYLEVBQXFCSixLQUFyQixFQUE0QnEvQixrQkFBNUIsRUFBZ0QwQixVQUFoRDtBQUNELE9BSEQsTUFHTztBQUNMLFlBQUk0QixhQUFKLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQUl2aUMsU0FBU29pQyxRQUFULEtBQXNCLENBQXRCLElBQTJCcGlDLFNBQVN3aUMsWUFBVCxDQUFzQixpQkFBdEIsQ0FBL0IsRUFBeUU7QUFDdkV4aUMscUJBQVN5aUMsZUFBVCxDQUF5QixpQkFBekI7QUFDQXZXLHdCQUFZLElBQVo7QUFDRDtBQUNELGNBQUkrUixPQUFPL1IsU0FBUCxDQUFKLEVBQXVCO0FBQ3JCLGdCQUFJNFYsUUFBUTloQyxRQUFSLEVBQWtCSixLQUFsQixFQUF5QnEvQixrQkFBekIsQ0FBSixFQUFrRDtBQUNoRHlDLCtCQUFpQjloQyxLQUFqQixFQUF3QnEvQixrQkFBeEIsRUFBNEMsSUFBNUM7QUFDQSxxQkFBT2ovQixRQUFQO0FBQ0QsYUFIRCxNQUdPLElBQUk3RyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRHZELG1CQUNFLCtEQUNBLDhEQURBLEdBRUEsK0RBRkEsR0FHQSw0REFIQSxHQUlBLDBCQUxGO0FBT0Q7QUFDRjtBQUNEO0FBQ0E7QUFDQStCLHFCQUFXMitCLFlBQVkzK0IsUUFBWixDQUFYO0FBQ0Q7QUFDRDtBQUNBLFlBQUkwaUMsU0FBUzFpQyxTQUFTMG5CLEdBQXRCO0FBQ0EsWUFBSWliLGNBQWNsRixRQUFRakMsVUFBUixDQUFtQmtILE1BQW5CLENBQWxCO0FBQ0ExRCxrQkFDRXAvQixLQURGLEVBRUVxL0Isa0JBRkY7QUFHRTtBQUNBO0FBQ0E7QUFDQXlELGVBQU9FLFFBQVAsR0FBa0IsSUFBbEIsR0FBeUJELFdBTjNCLEVBT0VsRixRQUFRSCxXQUFSLENBQW9Cb0YsTUFBcEIsQ0FQRjs7QUFVQSxZQUFJMUUsTUFBTXArQixNQUFNaEIsTUFBWixDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFJbWhDLFdBQVduZ0MsTUFBTWhCLE1BQXJCO0FBQ0EsaUJBQU9taEMsUUFBUCxFQUFpQjtBQUNmQSxxQkFBU3JZLEdBQVQsR0FBZTluQixNQUFNOG5CLEdBQXJCO0FBQ0FxWSx1QkFBV0EsU0FBU25oQyxNQUFwQjtBQUNEO0FBQ0QsY0FBSStnQyxZQUFZLy9CLEtBQVosQ0FBSixFQUF3QjtBQUN0QixpQkFBSyxJQUFJMUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdWEsSUFBSXpNLE1BQUosQ0FBV3hPLE1BQS9CLEVBQXVDLEVBQUVVLENBQXpDLEVBQTRDO0FBQzFDdWEsa0JBQUl6TSxNQUFKLENBQVc5TixDQUFYLEVBQWM0aUMsU0FBZCxFQUF5QmwrQixNQUFNaEIsTUFBL0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBSW8vQixNQUFNMkUsV0FBTixDQUFKLEVBQXdCO0FBQ3RCdkMsdUJBQWF1QyxXQUFiLEVBQTBCLENBQUMzaUMsUUFBRCxDQUExQixFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QztBQUNELFNBRkQsTUFFTyxJQUFJZytCLE1BQU1oK0IsU0FBUzJFLEdBQWYsQ0FBSixFQUF5QjtBQUM5Qnc3Qiw0QkFBa0JuZ0MsUUFBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQwaEMscUJBQWlCOWhDLEtBQWpCLEVBQXdCcS9CLGtCQUF4QixFQUE0Q3FELGNBQTVDO0FBQ0EsV0FBTzFpQyxNQUFNOG5CLEdBQWI7QUFDRCxHQW5GRDtBQW9GRDs7QUFFRDs7QUFFQSxJQUFJcEQsYUFBYTtBQUNmdGIsVUFBUTY1QixnQkFETztBQUVmdmlCLFVBQVF1aUIsZ0JBRk87QUFHZjVpQyxXQUFTLFNBQVM2aUMsZ0JBQVQsQ0FBMkJsakMsS0FBM0IsRUFBa0M7QUFDekNpakMscUJBQWlCampDLEtBQWpCLEVBQXdCaytCLFNBQXhCO0FBQ0Q7QUFMYyxDQUFqQjs7QUFRQSxTQUFTK0UsZ0JBQVQsQ0FBMkI3aUMsUUFBM0IsRUFBcUNKLEtBQXJDLEVBQTRDO0FBQzFDLE1BQUlJLFNBQVNuQixJQUFULENBQWN5bEIsVUFBZCxJQUE0QjFrQixNQUFNZixJQUFOLENBQVd5bEIsVUFBM0MsRUFBdUQ7QUFDckQySCxZQUFRanNCLFFBQVIsRUFBa0JKLEtBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTcXNCLE9BQVQsQ0FBa0Jqc0IsUUFBbEIsRUFBNEJKLEtBQTVCLEVBQW1DO0FBQ2pDLE1BQUltakMsV0FBVy9pQyxhQUFhODlCLFNBQTVCO0FBQ0EsTUFBSWtGLFlBQVlwakMsVUFBVWsrQixTQUExQjtBQUNBLE1BQUltRixVQUFVQyxzQkFBc0JsakMsU0FBU25CLElBQVQsQ0FBY3lsQixVQUFwQyxFQUFnRHRrQixTQUFTMm5CLE9BQXpELENBQWQ7QUFDQSxNQUFJd2IsVUFBVUQsc0JBQXNCdGpDLE1BQU1mLElBQU4sQ0FBV3lsQixVQUFqQyxFQUE2QzFrQixNQUFNK25CLE9BQW5ELENBQWQ7O0FBRUEsTUFBSXliLGlCQUFpQixFQUFyQjtBQUNBLE1BQUlDLG9CQUFvQixFQUF4Qjs7QUFFQSxNQUFJNWhDLEdBQUosRUFBUzZoQyxNQUFULEVBQWlCNW1DLEdBQWpCO0FBQ0EsT0FBSytFLEdBQUwsSUFBWTBoQyxPQUFaLEVBQXFCO0FBQ25CRyxhQUFTTCxRQUFReGhDLEdBQVIsQ0FBVDtBQUNBL0UsVUFBTXltQyxRQUFRMWhDLEdBQVIsQ0FBTjtBQUNBLFFBQUksQ0FBQzZoQyxNQUFMLEVBQWE7QUFDWDtBQUNBQyxpQkFBVzdtQyxHQUFYLEVBQWdCLE1BQWhCLEVBQXdCa0QsS0FBeEIsRUFBK0JJLFFBQS9CO0FBQ0EsVUFBSXRELElBQUl3WSxHQUFKLElBQVd4WSxJQUFJd1ksR0FBSixDQUFRaU0sUUFBdkIsRUFBaUM7QUFDL0JpaUIsdUJBQWVqb0MsSUFBZixDQUFvQnVCLEdBQXBCO0FBQ0Q7QUFDRixLQU5ELE1BTU87QUFDTDtBQUNBQSxVQUFJcXpCLFFBQUosR0FBZXVULE9BQU9ubUMsS0FBdEI7QUFDQW9tQyxpQkFBVzdtQyxHQUFYLEVBQWdCLFFBQWhCLEVBQTBCa0QsS0FBMUIsRUFBaUNJLFFBQWpDO0FBQ0EsVUFBSXRELElBQUl3WSxHQUFKLElBQVd4WSxJQUFJd1ksR0FBSixDQUFRc3VCLGdCQUF2QixFQUF5QztBQUN2Q0gsMEJBQWtCbG9DLElBQWxCLENBQXVCdUIsR0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSTBtQyxlQUFlNW9DLE1BQW5CLEVBQTJCO0FBQ3pCLFFBQUlpcEMsYUFBYSxZQUFZO0FBQzNCLFdBQUssSUFBSXZvQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrb0MsZUFBZTVvQyxNQUFuQyxFQUEyQ1UsR0FBM0MsRUFBZ0Q7QUFDOUNxb0MsbUJBQVdILGVBQWVsb0MsQ0FBZixDQUFYLEVBQThCLFVBQTlCLEVBQTBDMEUsS0FBMUMsRUFBaURJLFFBQWpEO0FBQ0Q7QUFDRixLQUpEO0FBS0EsUUFBSStpQyxRQUFKLEVBQWM7QUFDWjFaLHFCQUFlenBCLE1BQU1mLElBQU4sQ0FBV2EsSUFBWCxLQUFvQkUsTUFBTWYsSUFBTixDQUFXYSxJQUFYLEdBQWtCLEVBQXRDLENBQWYsRUFBMEQsUUFBMUQsRUFBb0UrakMsVUFBcEU7QUFDRCxLQUZELE1BRU87QUFDTEE7QUFDRDtBQUNGOztBQUVELE1BQUlKLGtCQUFrQjdvQyxNQUF0QixFQUE4QjtBQUM1QjZ1QixtQkFBZXpwQixNQUFNZixJQUFOLENBQVdhLElBQVgsS0FBb0JFLE1BQU1mLElBQU4sQ0FBV2EsSUFBWCxHQUFrQixFQUF0QyxDQUFmLEVBQTBELFdBQTFELEVBQXVFLFlBQVk7QUFDakYsV0FBSyxJQUFJeEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbW9DLGtCQUFrQjdvQyxNQUF0QyxFQUE4Q1UsR0FBOUMsRUFBbUQ7QUFDakRxb0MsbUJBQVdGLGtCQUFrQm5vQyxDQUFsQixDQUFYLEVBQWlDLGtCQUFqQyxFQUFxRDBFLEtBQXJELEVBQTRESSxRQUE1RDtBQUNEO0FBQ0YsS0FKRDtBQUtEOztBQUVELE1BQUksQ0FBQytpQyxRQUFMLEVBQWU7QUFDYixTQUFLdGhDLEdBQUwsSUFBWXdoQyxPQUFaLEVBQXFCO0FBQ25CLFVBQUksQ0FBQ0UsUUFBUTFoQyxHQUFSLENBQUwsRUFBbUI7QUFDakI7QUFDQThoQyxtQkFBV04sUUFBUXhoQyxHQUFSLENBQVgsRUFBeUIsUUFBekIsRUFBbUN6QixRQUFuQyxFQUE2Q0EsUUFBN0MsRUFBdURnakMsU0FBdkQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJVSxpQkFBaUJ6bUMsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQXJCOztBQUVBLFNBQVNrNkIscUJBQVQsQ0FDRTdlLElBREYsRUFFRWhGLEVBRkYsRUFHRTtBQUNBLE1BQUkzZCxNQUFNekUsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQVY7QUFDQSxNQUFJLENBQUNxYixJQUFMLEVBQVc7QUFDVCxXQUFPM2lCLEdBQVA7QUFDRDtBQUNELE1BQUl4RyxDQUFKLEVBQU93QixHQUFQO0FBQ0EsT0FBS3hCLElBQUksQ0FBVCxFQUFZQSxJQUFJbXBCLEtBQUs3cEIsTUFBckIsRUFBNkJVLEdBQTdCLEVBQWtDO0FBQ2hDd0IsVUFBTTJuQixLQUFLbnBCLENBQUwsQ0FBTjtBQUNBLFFBQUksQ0FBQ3dCLElBQUlpbkMsU0FBVCxFQUFvQjtBQUNsQmpuQyxVQUFJaW5DLFNBQUosR0FBZ0JELGNBQWhCO0FBQ0Q7QUFDRGhpQyxRQUFJa2lDLGNBQWNsbkMsR0FBZCxDQUFKLElBQTBCQSxHQUExQjtBQUNBQSxRQUFJd1ksR0FBSixHQUFVNFAsYUFBYXpGLEdBQUdoWSxRQUFoQixFQUEwQixZQUExQixFQUF3QzNLLElBQUlILElBQTVDLEVBQWtELElBQWxELENBQVY7QUFDRDtBQUNELFNBQU9tRixHQUFQO0FBQ0Q7O0FBRUQsU0FBU2tpQyxhQUFULENBQXdCbG5DLEdBQXhCLEVBQTZCO0FBQzNCLFNBQU9BLElBQUltbkMsT0FBSixJQUFpQm5uQyxJQUFJSCxJQUFMLEdBQWEsR0FBYixHQUFvQlUsT0FBT3FGLElBQVAsQ0FBWTVGLElBQUlpbkMsU0FBSixJQUFpQixFQUE3QixFQUFpQ3poQyxJQUFqQyxDQUFzQyxHQUF0QyxDQUEzQztBQUNEOztBQUVELFNBQVNxaEMsVUFBVCxDQUFxQjdtQyxHQUFyQixFQUEwQmdELElBQTFCLEVBQWdDRSxLQUFoQyxFQUF1Q0ksUUFBdkMsRUFBaURnakMsU0FBakQsRUFBNEQ7QUFDMUQsTUFBSXZ3QixLQUFLL1YsSUFBSXdZLEdBQUosSUFBV3hZLElBQUl3WSxHQUFKLENBQVF4VixJQUFSLENBQXBCO0FBQ0EsTUFBSStTLEVBQUosRUFBUTtBQUNOQSxPQUFHN1MsTUFBTThuQixHQUFULEVBQWNockIsR0FBZCxFQUFtQmtELEtBQW5CLEVBQTBCSSxRQUExQixFQUFvQ2dqQyxTQUFwQztBQUNEO0FBQ0Y7O0FBRUQsSUFBSWMsY0FBYyxDQUNoQnBsQyxHQURnQixFQUVoQjRsQixVQUZnQixDQUFsQjs7QUFLQTs7QUFFQSxTQUFTeWYsV0FBVCxDQUFzQi9qQyxRQUF0QixFQUFnQ0osS0FBaEMsRUFBdUM7QUFDckMsTUFBSSxDQUFDSSxTQUFTbkIsSUFBVCxDQUFjaUgsS0FBZixJQUF3QixDQUFDbEcsTUFBTWYsSUFBTixDQUFXaUgsS0FBeEMsRUFBK0M7QUFDN0M7QUFDRDtBQUNELE1BQUlyRSxHQUFKLEVBQVMwbkIsR0FBVCxFQUFjQyxHQUFkO0FBQ0EsTUFBSTFCLE1BQU05bkIsTUFBTThuQixHQUFoQjtBQUNBLE1BQUlzYyxXQUFXaGtDLFNBQVNuQixJQUFULENBQWNpSCxLQUFkLElBQXVCLEVBQXRDO0FBQ0EsTUFBSUEsUUFBUWxHLE1BQU1mLElBQU4sQ0FBV2lILEtBQVgsSUFBb0IsRUFBaEM7QUFDQTtBQUNBLE1BQUlBLE1BQU1vYixNQUFWLEVBQWtCO0FBQ2hCcGIsWUFBUWxHLE1BQU1mLElBQU4sQ0FBV2lILEtBQVgsR0FBbUJJLE9BQU8sRUFBUCxFQUFXSixLQUFYLENBQTNCO0FBQ0Q7O0FBRUQsT0FBS3JFLEdBQUwsSUFBWXFFLEtBQVosRUFBbUI7QUFDakJxakIsVUFBTXJqQixNQUFNckUsR0FBTixDQUFOO0FBQ0EybkIsVUFBTTRhLFNBQVN2aUMsR0FBVCxDQUFOO0FBQ0EsUUFBSTJuQixRQUFRRCxHQUFaLEVBQWlCO0FBQ2Y4YSxjQUFRdmMsR0FBUixFQUFham1CLEdBQWIsRUFBa0IwbkIsR0FBbEI7QUFDRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBLE1BQUk1TSxTQUFTelcsTUFBTTNJLEtBQU4sS0FBZ0I2bUMsU0FBUzdtQyxLQUF0QyxFQUE2QztBQUMzQzhtQyxZQUFRdmMsR0FBUixFQUFhLE9BQWIsRUFBc0I1aEIsTUFBTTNJLEtBQTVCO0FBQ0Q7QUFDRCxPQUFLc0UsR0FBTCxJQUFZdWlDLFFBQVosRUFBc0I7QUFDcEIsUUFBSWwrQixNQUFNckUsR0FBTixLQUFjLElBQWxCLEVBQXdCO0FBQ3RCLFVBQUkyNUIsUUFBUTM1QixHQUFSLENBQUosRUFBa0I7QUFDaEJpbUIsWUFBSXdjLGlCQUFKLENBQXNCL0ksT0FBdEIsRUFBK0JFLGFBQWE1NUIsR0FBYixDQUEvQjtBQUNELE9BRkQsTUFFTyxJQUFJLENBQUN3NUIsaUJBQWlCeDVCLEdBQWpCLENBQUwsRUFBNEI7QUFDakNpbUIsWUFBSSthLGVBQUosQ0FBb0JoaEMsR0FBcEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTd2lDLE9BQVQsQ0FBa0IzekIsRUFBbEIsRUFBc0I3TyxHQUF0QixFQUEyQnRFLEtBQTNCLEVBQWtDO0FBQ2hDLE1BQUkrOUIsY0FBY3o1QixHQUFkLENBQUosRUFBd0I7QUFDdEI7QUFDQTtBQUNBLFFBQUk2NUIsaUJBQWlCbitCLEtBQWpCLENBQUosRUFBNkI7QUFDM0JtVCxTQUFHbXlCLGVBQUgsQ0FBbUJoaEMsR0FBbkI7QUFDRCxLQUZELE1BRU87QUFDTDZPLFNBQUd1c0IsWUFBSCxDQUFnQnA3QixHQUFoQixFQUFxQkEsR0FBckI7QUFDRDtBQUNGLEdBUkQsTUFRTyxJQUFJdzVCLGlCQUFpQng1QixHQUFqQixDQUFKLEVBQTJCO0FBQ2hDNk8sT0FBR3VzQixZQUFILENBQWdCcDdCLEdBQWhCLEVBQXFCNjVCLGlCQUFpQm4rQixLQUFqQixLQUEyQkEsVUFBVSxPQUFyQyxHQUErQyxPQUEvQyxHQUF5RCxNQUE5RTtBQUNELEdBRk0sTUFFQSxJQUFJaStCLFFBQVEzNUIsR0FBUixDQUFKLEVBQWtCO0FBQ3ZCLFFBQUk2NUIsaUJBQWlCbitCLEtBQWpCLENBQUosRUFBNkI7QUFDM0JtVCxTQUFHNHpCLGlCQUFILENBQXFCL0ksT0FBckIsRUFBOEJFLGFBQWE1NUIsR0FBYixDQUE5QjtBQUNELEtBRkQsTUFFTztBQUNMNk8sU0FBRzZ6QixjQUFILENBQWtCaEosT0FBbEIsRUFBMkIxNUIsR0FBM0IsRUFBZ0N0RSxLQUFoQztBQUNEO0FBQ0YsR0FOTSxNQU1BO0FBQ0wsUUFBSW0rQixpQkFBaUJuK0IsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm1ULFNBQUdteUIsZUFBSCxDQUFtQmhoQyxHQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMNk8sU0FBR3VzQixZQUFILENBQWdCcDdCLEdBQWhCLEVBQXFCdEUsS0FBckI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsSUFBSTJJLFFBQVE7QUFDVmtELFVBQVErNkIsV0FERTtBQUVWempCLFVBQVF5akI7QUFGRSxDQUFaOztBQUtBOztBQUVBLFNBQVNLLFdBQVQsQ0FBc0Jwa0MsUUFBdEIsRUFBZ0NKLEtBQWhDLEVBQXVDO0FBQ3JDLE1BQUkwUSxLQUFLMVEsTUFBTThuQixHQUFmO0FBQ0EsTUFBSTdvQixPQUFPZSxNQUFNZixJQUFqQjtBQUNBLE1BQUl3bEMsVUFBVXJrQyxTQUFTbkIsSUFBdkI7QUFDQSxNQUFJLENBQUNBLEtBQUsrOEIsV0FBTixJQUFxQixDQUFDLzhCLEtBQUtnSCxLQUEzQixLQUNDLENBQUN3K0IsT0FBRCxJQUFhLENBQUNBLFFBQVF6SSxXQUFULElBQXdCLENBQUN5SSxRQUFReCtCLEtBRC9DLENBQUosRUFDNEQ7QUFDMUQ7QUFDRDs7QUFFRCxNQUFJeStCLE1BQU0vSSxpQkFBaUIzN0IsS0FBakIsQ0FBVjs7QUFFQTtBQUNBLE1BQUkya0Msa0JBQWtCajBCLEdBQUdrMEIsa0JBQXpCO0FBQ0EsTUFBSUQsZUFBSixFQUFxQjtBQUNuQkQsVUFBTTdwQyxPQUFPNnBDLEdBQVAsRUFBWXhJLGVBQWV5SSxlQUFmLENBQVosQ0FBTjtBQUNEOztBQUVEO0FBQ0EsTUFBSUQsUUFBUWgwQixHQUFHbTBCLFVBQWYsRUFBMkI7QUFDekJuMEIsT0FBR3VzQixZQUFILENBQWdCLE9BQWhCLEVBQXlCeUgsR0FBekI7QUFDQWgwQixPQUFHbTBCLFVBQUgsR0FBZ0JILEdBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJSSxRQUFRO0FBQ1YxN0IsVUFBUW83QixXQURFO0FBRVY5akIsVUFBUThqQjtBQUZFLENBQVo7O0FBS0E7O0FBRUEsSUFBSU8sc0JBQXNCLGVBQTFCOztBQUVBLFNBQVNDLFlBQVQsQ0FBdUJDLEdBQXZCLEVBQTRCO0FBQzFCLE1BQUlDLFdBQVcsS0FBZjtBQUNBLE1BQUlDLFdBQVcsS0FBZjtBQUNBLE1BQUlDLG1CQUFtQixLQUF2QjtBQUNBLE1BQUlDLFVBQVUsS0FBZDtBQUNBLE1BQUlDLFFBQVEsQ0FBWjtBQUNBLE1BQUlDLFNBQVMsQ0FBYjtBQUNBLE1BQUlDLFFBQVEsQ0FBWjtBQUNBLE1BQUlDLGtCQUFrQixDQUF0QjtBQUNBLE1BQUk1a0MsQ0FBSixFQUFPOFQsSUFBUCxFQUFhclosQ0FBYixFQUFnQjR6QixVQUFoQixFQUE0QndXLE9BQTVCOztBQUVBLE9BQUtwcUMsSUFBSSxDQUFULEVBQVlBLElBQUkycEMsSUFBSXJxQyxNQUFwQixFQUE0QlUsR0FBNUIsRUFBaUM7QUFDL0JxWixXQUFPOVQsQ0FBUDtBQUNBQSxRQUFJb2tDLElBQUlua0MsVUFBSixDQUFleEYsQ0FBZixDQUFKO0FBQ0EsUUFBSTRwQyxRQUFKLEVBQWM7QUFDWixVQUFJcmtDLE1BQU0sSUFBTixJQUFjOFQsU0FBUyxJQUEzQixFQUFpQztBQUFFdXdCLG1CQUFXLEtBQVg7QUFBbUI7QUFDdkQsS0FGRCxNQUVPLElBQUlDLFFBQUosRUFBYztBQUNuQixVQUFJdGtDLE1BQU0sSUFBTixJQUFjOFQsU0FBUyxJQUEzQixFQUFpQztBQUFFd3dCLG1CQUFXLEtBQVg7QUFBbUI7QUFDdkQsS0FGTSxNQUVBLElBQUlDLGdCQUFKLEVBQXNCO0FBQzNCLFVBQUl2a0MsTUFBTSxJQUFOLElBQWM4VCxTQUFTLElBQTNCLEVBQWlDO0FBQUV5d0IsMkJBQW1CLEtBQW5CO0FBQTJCO0FBQy9ELEtBRk0sTUFFQSxJQUFJQyxPQUFKLEVBQWE7QUFDbEIsVUFBSXhrQyxNQUFNLElBQU4sSUFBYzhULFNBQVMsSUFBM0IsRUFBaUM7QUFBRTB3QixrQkFBVSxLQUFWO0FBQWtCO0FBQ3RELEtBRk0sTUFFQSxJQUNMeGtDLE1BQU0sSUFBTixJQUFjO0FBQ2Rva0MsUUFBSW5rQyxVQUFKLENBQWV4RixJQUFJLENBQW5CLE1BQTBCLElBRDFCLElBRUEycEMsSUFBSW5rQyxVQUFKLENBQWV4RixJQUFJLENBQW5CLE1BQTBCLElBRjFCLElBR0EsQ0FBQ2dxQyxLQUhELElBR1UsQ0FBQ0MsTUFIWCxJQUdxQixDQUFDQyxLQUpqQixFQUtMO0FBQ0EsVUFBSXRXLGVBQWU1dUIsU0FBbkIsRUFBOEI7QUFDNUI7QUFDQW1sQywwQkFBa0JucUMsSUFBSSxDQUF0QjtBQUNBNHpCLHFCQUFhK1YsSUFBSXBpQyxLQUFKLENBQVUsQ0FBVixFQUFhdkgsQ0FBYixFQUFnQnlHLElBQWhCLEVBQWI7QUFDRCxPQUpELE1BSU87QUFDTDRqQztBQUNEO0FBQ0YsS0FiTSxNQWFBO0FBQ0wsY0FBUTlrQyxDQUFSO0FBQ0UsYUFBSyxJQUFMO0FBQVdza0MscUJBQVcsSUFBWCxDQUFpQixNQUQ5QixDQUM0QztBQUMxQyxhQUFLLElBQUw7QUFBV0QscUJBQVcsSUFBWCxDQUFpQixNQUY5QixDQUU0QztBQUMxQyxhQUFLLElBQUw7QUFBV0UsNkJBQW1CLElBQW5CLENBQXlCLE1BSHRDLENBRzRDO0FBQzFDLGFBQUssSUFBTDtBQUFXSSxrQkFBUyxNQUp0QixDQUk0QztBQUMxQyxhQUFLLElBQUw7QUFBV0Esa0JBQVMsTUFMdEIsQ0FLNEM7QUFDMUMsYUFBSyxJQUFMO0FBQVdELG1CQUFVLE1BTnZCLENBTTRDO0FBQzFDLGFBQUssSUFBTDtBQUFXQSxtQkFBVSxNQVB2QixDQU80QztBQUMxQyxhQUFLLElBQUw7QUFBV0Qsa0JBQVMsTUFSdEIsQ0FRNEM7QUFDMUMsYUFBSyxJQUFMO0FBQVdBLGtCQUFTLE1BVHRCLENBUzRDO0FBVDVDO0FBV0EsVUFBSXprQyxNQUFNLElBQVYsRUFBZ0I7QUFBRTtBQUNoQixZQUFJK0wsSUFBSXRSLElBQUksQ0FBWjtBQUNBLFlBQUl5aUIsSUFBSyxLQUFLLENBQWQ7QUFDQTtBQUNBLGVBQU9uUixLQUFLLENBQVosRUFBZUEsR0FBZixFQUFvQjtBQUNsQm1SLGNBQUlrbkIsSUFBSTM4QixNQUFKLENBQVdzRSxDQUFYLENBQUo7QUFDQSxjQUFJbVIsTUFBTSxHQUFWLEVBQWU7QUFBRTtBQUFPO0FBQ3pCO0FBQ0QsWUFBSSxDQUFDQSxDQUFELElBQU0sQ0FBQ2duQixvQkFBb0I5OUIsSUFBcEIsQ0FBeUI4VyxDQUF6QixDQUFYLEVBQXdDO0FBQ3RDc25CLG9CQUFVLElBQVY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJblcsZUFBZTV1QixTQUFuQixFQUE4QjtBQUM1QjR1QixpQkFBYStWLElBQUlwaUMsS0FBSixDQUFVLENBQVYsRUFBYXZILENBQWIsRUFBZ0J5RyxJQUFoQixFQUFiO0FBQ0QsR0FGRCxNQUVPLElBQUkwakMsb0JBQW9CLENBQXhCLEVBQTJCO0FBQ2hDRTtBQUNEOztBQUVELFdBQVNBLFVBQVQsR0FBdUI7QUFDckIsS0FBQ0QsWUFBWUEsVUFBVSxFQUF0QixDQUFELEVBQTRCbnFDLElBQTVCLENBQWlDMHBDLElBQUlwaUMsS0FBSixDQUFVNGlDLGVBQVYsRUFBMkJucUMsQ0FBM0IsRUFBOEJ5RyxJQUE5QixFQUFqQztBQUNBMGpDLHNCQUFrQm5xQyxJQUFJLENBQXRCO0FBQ0Q7O0FBRUQsTUFBSW9xQyxPQUFKLEVBQWE7QUFDWCxTQUFLcHFDLElBQUksQ0FBVCxFQUFZQSxJQUFJb3FDLFFBQVE5cUMsTUFBeEIsRUFBZ0NVLEdBQWhDLEVBQXFDO0FBQ25DNHpCLG1CQUFhMFcsV0FBVzFXLFVBQVgsRUFBdUJ3VyxRQUFRcHFDLENBQVIsQ0FBdkIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTzR6QixVQUFQO0FBQ0Q7O0FBRUQsU0FBUzBXLFVBQVQsQ0FBcUJYLEdBQXJCLEVBQTBCbGlDLE1BQTFCLEVBQWtDO0FBQ2hDLE1BQUl6SCxJQUFJeUgsT0FBT3lCLE9BQVAsQ0FBZSxHQUFmLENBQVI7QUFDQSxNQUFJbEosSUFBSSxDQUFSLEVBQVc7QUFDVDtBQUNBLFdBQVEsVUFBVXlILE1BQVYsR0FBbUIsTUFBbkIsR0FBNEJraUMsR0FBNUIsR0FBa0MsR0FBMUM7QUFDRCxHQUhELE1BR087QUFDTCxRQUFJdG9DLE9BQU9vRyxPQUFPRixLQUFQLENBQWEsQ0FBYixFQUFnQnZILENBQWhCLENBQVg7QUFDQSxRQUFJSCxPQUFPNEgsT0FBT0YsS0FBUCxDQUFhdkgsSUFBSSxDQUFqQixDQUFYO0FBQ0EsV0FBUSxVQUFVcUIsSUFBVixHQUFpQixNQUFqQixHQUEwQnNvQyxHQUExQixHQUFnQyxHQUFoQyxHQUFzQzlwQyxJQUE5QztBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsU0FBUzBxQyxRQUFULENBQW1Ccm1CLEdBQW5CLEVBQXdCO0FBQ3RCbGhCLFVBQVE0ZixLQUFSLENBQWUscUJBQXFCc0IsR0FBcEM7QUFDRDs7QUFFRCxTQUFTc21CLG1CQUFULENBQ0VqckIsT0FERixFQUVFaFosR0FGRixFQUdFO0FBQ0EsU0FBT2daLFVBQ0hBLFFBQVFsWSxHQUFSLENBQVksVUFBVXNJLENBQVYsRUFBYTtBQUFFLFdBQU9BLEVBQUVwSixHQUFGLENBQVA7QUFBZ0IsR0FBM0MsRUFBNkNrQixNQUE3QyxDQUFvRCxVQUFVK1MsQ0FBVixFQUFhO0FBQUUsV0FBT0EsQ0FBUDtBQUFXLEdBQTlFLENBREcsR0FFSCxFQUZKO0FBR0Q7O0FBRUQsU0FBU2l3QixPQUFULENBQWtCcjFCLEVBQWxCLEVBQXNCL1QsSUFBdEIsRUFBNEJZLEtBQTVCLEVBQW1DO0FBQ2pDLEdBQUNtVCxHQUFHalMsS0FBSCxLQUFhaVMsR0FBR2pTLEtBQUgsR0FBVyxFQUF4QixDQUFELEVBQThCbEQsSUFBOUIsQ0FBbUMsRUFBRW9CLE1BQU1BLElBQVIsRUFBY1ksT0FBT0EsS0FBckIsRUFBbkM7QUFDRDs7QUFFRCxTQUFTeW9DLE9BQVQsQ0FBa0J0MUIsRUFBbEIsRUFBc0IvVCxJQUF0QixFQUE0QlksS0FBNUIsRUFBbUM7QUFDakMsR0FBQ21ULEdBQUd4SyxLQUFILEtBQWF3SyxHQUFHeEssS0FBSCxHQUFXLEVBQXhCLENBQUQsRUFBOEIzSyxJQUE5QixDQUFtQyxFQUFFb0IsTUFBTUEsSUFBUixFQUFjWSxPQUFPQSxLQUFyQixFQUFuQztBQUNEOztBQUVELFNBQVMwb0MsWUFBVCxDQUNFdjFCLEVBREYsRUFFRS9ULElBRkYsRUFHRXNuQyxPQUhGLEVBSUUxbUMsS0FKRixFQUtFMm9DLEdBTEYsRUFNRW5DLFNBTkYsRUFPRTtBQUNBLEdBQUNyekIsR0FBR2dVLFVBQUgsS0FBa0JoVSxHQUFHZ1UsVUFBSCxHQUFnQixFQUFsQyxDQUFELEVBQXdDbnBCLElBQXhDLENBQTZDLEVBQUVvQixNQUFNQSxJQUFSLEVBQWNzbkMsU0FBU0EsT0FBdkIsRUFBZ0MxbUMsT0FBT0EsS0FBdkMsRUFBOEMyb0MsS0FBS0EsR0FBbkQsRUFBd0RuQyxXQUFXQSxTQUFuRSxFQUE3QztBQUNEOztBQUVELFNBQVNvQyxVQUFULENBQ0V6MUIsRUFERixFQUVFL1QsSUFGRixFQUdFWSxLQUhGLEVBSUV3bUMsU0FKRixFQUtFcUMsU0FMRixFQU1FO0FBQ0E7QUFDQSxNQUFJckMsYUFBYUEsVUFBVXo0QixPQUEzQixFQUFvQztBQUNsQyxXQUFPeTRCLFVBQVV6NEIsT0FBakI7QUFDQTNPLFdBQU8sTUFBTUEsSUFBYixDQUZrQyxDQUVmO0FBQ3BCO0FBQ0QsTUFBSW9uQyxhQUFhQSxVQUFVMW5DLElBQTNCLEVBQWlDO0FBQy9CLFdBQU8wbkMsVUFBVTFuQyxJQUFqQjtBQUNBTSxXQUFPLE1BQU1BLElBQWIsQ0FGK0IsQ0FFWjtBQUNwQjtBQUNELE1BQUkwcEMsTUFBSjtBQUNBLE1BQUl0QyxhQUFhQSxVQUFVdUMsTUFBM0IsRUFBbUM7QUFDakMsV0FBT3ZDLFVBQVV1QyxNQUFqQjtBQUNBRCxhQUFTMzFCLEdBQUc2MUIsWUFBSCxLQUFvQjcxQixHQUFHNjFCLFlBQUgsR0FBa0IsRUFBdEMsQ0FBVDtBQUNELEdBSEQsTUFHTztBQUNMRixhQUFTMzFCLEdBQUcyMUIsTUFBSCxLQUFjMzFCLEdBQUcyMUIsTUFBSCxHQUFZLEVBQTFCLENBQVQ7QUFDRDtBQUNELE1BQUlHLGFBQWEsRUFBRWpwQyxPQUFPQSxLQUFULEVBQWdCd21DLFdBQVdBLFNBQTNCLEVBQWpCO0FBQ0EsTUFBSTdjLFdBQVdtZixPQUFPMXBDLElBQVAsQ0FBZjtBQUNBO0FBQ0EsTUFBSXZCLE1BQU1tSCxPQUFOLENBQWMya0IsUUFBZCxDQUFKLEVBQTZCO0FBQzNCa2YsZ0JBQVlsZixTQUFTcmpCLE9BQVQsQ0FBaUIyaUMsVUFBakIsQ0FBWixHQUEyQ3RmLFNBQVMzckIsSUFBVCxDQUFjaXJDLFVBQWQsQ0FBM0M7QUFDRCxHQUZELE1BRU8sSUFBSXRmLFFBQUosRUFBYztBQUNuQm1mLFdBQU8xcEMsSUFBUCxJQUFleXBDLFlBQVksQ0FBQ0ksVUFBRCxFQUFhdGYsUUFBYixDQUFaLEdBQXFDLENBQUNBLFFBQUQsRUFBV3NmLFVBQVgsQ0FBcEQ7QUFDRCxHQUZNLE1BRUE7QUFDTEgsV0FBTzFwQyxJQUFQLElBQWU2cEMsVUFBZjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsY0FBVCxDQUNFLzFCLEVBREYsRUFFRS9ULElBRkYsRUFHRStwQyxTQUhGLEVBSUU7QUFDQSxNQUFJQyxlQUNGQyxpQkFBaUJsMkIsRUFBakIsRUFBcUIsTUFBTS9ULElBQTNCLEtBQ0FpcUMsaUJBQWlCbDJCLEVBQWpCLEVBQXFCLFlBQVkvVCxJQUFqQyxDQUZGO0FBR0EsTUFBSWdxQyxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsV0FBTzNCLGFBQWEyQixZQUFiLENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSUQsY0FBYyxLQUFsQixFQUF5QjtBQUM5QixRQUFJRyxjQUFjRCxpQkFBaUJsMkIsRUFBakIsRUFBcUIvVCxJQUFyQixDQUFsQjtBQUNBLFFBQUlrcUMsZUFBZSxJQUFuQixFQUF5QjtBQUN2QixhQUFPbjZCLEtBQUtDLFNBQUwsQ0FBZWs2QixXQUFmLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0QsZ0JBQVQsQ0FBMkJsMkIsRUFBM0IsRUFBK0IvVCxJQUEvQixFQUFxQztBQUNuQyxNQUFJMEYsR0FBSjtBQUNBLE1BQUksQ0FBQ0EsTUFBTXFPLEdBQUdvMkIsUUFBSCxDQUFZbnFDLElBQVosQ0FBUCxLQUE2QixJQUFqQyxFQUF1QztBQUNyQyxRQUFJcWMsT0FBT3RJLEdBQUdxMkIsU0FBZDtBQUNBLFNBQUssSUFBSXpyQyxJQUFJLENBQVIsRUFBVzJlLElBQUlqQixLQUFLcGUsTUFBekIsRUFBaUNVLElBQUkyZSxDQUFyQyxFQUF3QzNlLEdBQXhDLEVBQTZDO0FBQzNDLFVBQUkwZCxLQUFLMWQsQ0FBTCxFQUFRcUIsSUFBUixLQUFpQkEsSUFBckIsRUFBMkI7QUFDekJxYyxhQUFLSyxNQUFMLENBQVkvZCxDQUFaLEVBQWUsQ0FBZjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBTytHLEdBQVA7QUFDRDs7QUFFRDs7QUFFQTs7O0FBR0EsU0FBUzJrQyxpQkFBVCxDQUNFdDJCLEVBREYsRUFFRW5ULEtBRkYsRUFHRXdtQyxTQUhGLEVBSUU7QUFDQSxNQUFJamxDLE1BQU1pbEMsYUFBYSxFQUF2QjtBQUNBLE1BQUlrRCxTQUFTbm9DLElBQUltb0MsTUFBakI7QUFDQSxNQUFJbGxDLE9BQU9qRCxJQUFJaUQsSUFBZjs7QUFFQSxNQUFJbWxDLHNCQUFzQixLQUExQjtBQUNBLE1BQUlDLGtCQUFrQkQsbUJBQXRCO0FBQ0EsTUFBSW5sQyxJQUFKLEVBQVU7QUFDUm9sQyxzQkFDRSxhQUFhRCxtQkFBYixHQUFtQyxlQUFuQyxHQUNFLElBREYsR0FDU0EsbUJBRFQsR0FDK0IsU0FEL0IsR0FFRSxJQUZGLEdBRVNBLG1CQUZULEdBRStCLEdBSGpDO0FBSUQ7QUFDRCxNQUFJRCxNQUFKLEVBQVk7QUFDVkUsc0JBQWtCLFFBQVFBLGVBQVIsR0FBMEIsR0FBNUM7QUFDRDtBQUNELE1BQUlDLGFBQWFDLGtCQUFrQjlwQyxLQUFsQixFQUF5QjRwQyxlQUF6QixDQUFqQjs7QUFFQXoyQixLQUFHZ2pCLEtBQUgsR0FBVztBQUNUbjJCLFdBQVEsTUFBTUEsS0FBTixHQUFjLEdBRGI7QUFFVDJ4QixnQkFBYSxPQUFPM3hCLEtBQVAsR0FBZSxJQUZuQjtBQUdUNDNCLGNBQVcsZUFBZStSLG1CQUFmLEdBQXFDLEtBQXJDLEdBQTZDRSxVQUE3QyxHQUEwRDtBQUg1RCxHQUFYO0FBS0Q7O0FBRUQ7OztBQUdBLFNBQVNDLGlCQUFULENBQ0U5cEMsS0FERixFQUVFNnBDLFVBRkYsRUFHRTtBQUNBLE1BQUlFLFVBQVVDLFdBQVdocUMsS0FBWCxDQUFkO0FBQ0EsTUFBSStwQyxRQUFRRSxHQUFSLEtBQWdCLElBQXBCLEVBQTBCO0FBQ3hCLFdBQVFqcUMsUUFBUSxHQUFSLEdBQWM2cEMsVUFBdEI7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLGlCQUFrQkUsUUFBUXJDLEdBQTFCLEdBQWlDLFlBQWpDLEdBQWlEcUMsUUFBUUUsR0FBekQsR0FBZ0UsR0FBaEUsR0FDTCw2QkFESyxHQUVIanFDLEtBRkcsR0FFSyxHQUZMLEdBRVc2cEMsVUFGWCxHQUV3QixHQUZ4QixHQUdMLDhCQUhLLEdBRzRCQSxVQUg1QixHQUd5QyxJQUhoRDtBQUlEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBSXBzQyxHQUFKO0FBQ0EsSUFBSWtHLEdBQUo7QUFDQSxJQUFJdW1DLEdBQUo7QUFDQSxJQUFJMTlCLE9BQUo7QUFDQSxJQUFJMjlCLGFBQUo7QUFDQSxJQUFJQyxnQkFBSjs7QUFFQSxTQUFTSixVQUFULENBQXFCbGxDLEdBQXJCLEVBQTBCO0FBQ3hCbkIsUUFBTW1CLEdBQU47QUFDQXJILFFBQU1rRyxJQUFJdEcsTUFBVjtBQUNBbVAsWUFBVTI5QixnQkFBZ0JDLG1CQUFtQixDQUE3Qzs7QUFFQSxNQUFJdGxDLElBQUltQyxPQUFKLENBQVksR0FBWixJQUFtQixDQUFuQixJQUF3Qm5DLElBQUl1bEMsV0FBSixDQUFnQixHQUFoQixJQUF1QjVzQyxNQUFNLENBQXpELEVBQTREO0FBQzFELFdBQU87QUFDTGlxQyxXQUFLNWlDLEdBREE7QUFFTG1sQyxXQUFLO0FBRkEsS0FBUDtBQUlEOztBQUVELFNBQU8sQ0FBQ0ssS0FBUixFQUFlO0FBQ2JKLFVBQU1yOEIsTUFBTjtBQUNBO0FBQ0EsUUFBSTA4QixjQUFjTCxHQUFkLENBQUosRUFBd0I7QUFDdEJNLGtCQUFZTixHQUFaO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFFBQVEsSUFBWixFQUFrQjtBQUN2Qk8sbUJBQWFQLEdBQWI7QUFDRDtBQUNGOztBQUVELFNBQU87QUFDTHhDLFNBQUs1aUMsSUFBSTRsQyxTQUFKLENBQWMsQ0FBZCxFQUFpQlAsYUFBakIsQ0FEQTtBQUVMRixTQUFLbmxDLElBQUk0bEMsU0FBSixDQUFjUCxnQkFBZ0IsQ0FBOUIsRUFBaUNDLGdCQUFqQztBQUZBLEdBQVA7QUFJRDs7QUFFRCxTQUFTdjhCLElBQVQsR0FBaUI7QUFDZixTQUFPbEssSUFBSUosVUFBSixDQUFlLEVBQUVpSixPQUFqQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzg5QixHQUFULEdBQWdCO0FBQ2QsU0FBTzk5QixXQUFXL08sR0FBbEI7QUFDRDs7QUFFRCxTQUFTOHNDLGFBQVQsQ0FBd0JMLEdBQXhCLEVBQTZCO0FBQzNCLFNBQU9BLFFBQVEsSUFBUixJQUFnQkEsUUFBUSxJQUEvQjtBQUNEOztBQUVELFNBQVNPLFlBQVQsQ0FBdUJQLEdBQXZCLEVBQTRCO0FBQzFCLE1BQUlTLFlBQVksQ0FBaEI7QUFDQVIsa0JBQWdCMzlCLE9BQWhCO0FBQ0EsU0FBTyxDQUFDODlCLEtBQVIsRUFBZTtBQUNiSixVQUFNcjhCLE1BQU47QUFDQSxRQUFJMDhCLGNBQWNMLEdBQWQsQ0FBSixFQUF3QjtBQUN0Qk0sa0JBQVlOLEdBQVo7QUFDQTtBQUNEO0FBQ0QsUUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQUVTO0FBQWM7QUFDbEMsUUFBSVQsUUFBUSxJQUFaLEVBQWtCO0FBQUVTO0FBQWM7QUFDbEMsUUFBSUEsY0FBYyxDQUFsQixFQUFxQjtBQUNuQlAseUJBQW1CNTlCLE9BQW5CO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU2crQixXQUFULENBQXNCTixHQUF0QixFQUEyQjtBQUN6QixNQUFJVSxjQUFjVixHQUFsQjtBQUNBLFNBQU8sQ0FBQ0ksS0FBUixFQUFlO0FBQ2JKLFVBQU1yOEIsTUFBTjtBQUNBLFFBQUlxOEIsUUFBUVUsV0FBWixFQUF5QjtBQUN2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxJQUFJQyxNQUFKOztBQUVBO0FBQ0E7QUFDQSxJQUFJQyxjQUFjLEtBQWxCO0FBQ0EsSUFBSUMsdUJBQXVCLEtBQTNCOztBQUVBLFNBQVM1VSxLQUFULENBQ0VoakIsRUFERixFQUVFNVQsR0FGRixFQUdFeXJDLEtBSEYsRUFJRTtBQUNBSCxXQUFTRyxLQUFUO0FBQ0EsTUFBSWhyQyxRQUFRVCxJQUFJUyxLQUFoQjtBQUNBLE1BQUl3bUMsWUFBWWpuQyxJQUFJaW5DLFNBQXBCO0FBQ0EsTUFBSWgvQixNQUFNMkwsR0FBRzNMLEdBQWI7QUFDQSxNQUFJckcsT0FBT2dTLEdBQUdvMkIsUUFBSCxDQUFZcG9DLElBQXZCOztBQUVBLE1BQUluRixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxRQUFJNG1DLGNBQWM5M0IsR0FBR28yQixRQUFILENBQVksYUFBWixLQUE4QnAyQixHQUFHbzJCLFFBQUgsQ0FBWSxPQUFaLENBQWhEO0FBQ0EsUUFBSS9oQyxRQUFRLE9BQVIsSUFBbUJ5akMsV0FBdkIsRUFBb0M7QUFDbENKLGFBQ0Usb0JBQW9CSSxXQUFwQixHQUFrQyxlQUFsQyxHQUFvRGpyQyxLQUFwRCxHQUE0RCxRQUE1RCxHQUNBLDBFQUZGO0FBSUQ7QUFDRDtBQUNBO0FBQ0EsUUFBSXdILFFBQVEsT0FBUixJQUFtQnJHLFNBQVMsTUFBaEMsRUFBd0M7QUFDdEMwcEMsYUFDRSxNQUFPMTNCLEdBQUczTCxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDeEgsS0FBakMsR0FBeUMsc0JBQXpDLEdBQ0EsZ0VBRkY7QUFJRDtBQUNGOztBQUVELE1BQUl3SCxRQUFRLFFBQVosRUFBc0I7QUFDcEIwakMsY0FBVS8zQixFQUFWLEVBQWNuVCxLQUFkLEVBQXFCd21DLFNBQXJCO0FBQ0QsR0FGRCxNQUVPLElBQUloL0IsUUFBUSxPQUFSLElBQW1CckcsU0FBUyxVQUFoQyxFQUE0QztBQUNqRGdxQyxxQkFBaUJoNEIsRUFBakIsRUFBcUJuVCxLQUFyQixFQUE0QndtQyxTQUE1QjtBQUNELEdBRk0sTUFFQSxJQUFJaC9CLFFBQVEsT0FBUixJQUFtQnJHLFNBQVMsT0FBaEMsRUFBeUM7QUFDOUNpcUMsa0JBQWNqNEIsRUFBZCxFQUFrQm5ULEtBQWxCLEVBQXlCd21DLFNBQXpCO0FBQ0QsR0FGTSxNQUVBLElBQUloL0IsUUFBUSxPQUFSLElBQW1CQSxRQUFRLFVBQS9CLEVBQTJDO0FBQ2hENmpDLG9CQUFnQmw0QixFQUFoQixFQUFvQm5ULEtBQXBCLEVBQTJCd21DLFNBQTNCO0FBQ0QsR0FGTSxNQUVBLElBQUksQ0FBQ3ZqQyxPQUFPa2IsYUFBUCxDQUFxQjNXLEdBQXJCLENBQUwsRUFBZ0M7QUFDckNpaUMsc0JBQWtCdDJCLEVBQWxCLEVBQXNCblQsS0FBdEIsRUFBNkJ3bUMsU0FBN0I7QUFDQTtBQUNBLFdBQU8sS0FBUDtBQUNELEdBSk0sTUFJQSxJQUFJeHFDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEd21DLFdBQ0UsTUFBTzEzQixHQUFHM0wsR0FBVixHQUFpQixhQUFqQixHQUFpQ3hILEtBQWpDLEdBQXlDLE9BQXpDLEdBQ0EsaURBREEsR0FFQSxnRUFGQSxHQUdBLHNFQUpGO0FBTUQ7O0FBRUQ7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTbXJDLGdCQUFULENBQ0VoNEIsRUFERixFQUVFblQsS0FGRixFQUdFd21DLFNBSEYsRUFJRTtBQUNBLE1BQUlrRCxTQUFTbEQsYUFBYUEsVUFBVWtELE1BQXBDO0FBQ0EsTUFBSTRCLGVBQWVwQyxlQUFlLzFCLEVBQWYsRUFBbUIsT0FBbkIsS0FBK0IsTUFBbEQ7QUFDQSxNQUFJbzRCLG1CQUFtQnJDLGVBQWUvMUIsRUFBZixFQUFtQixZQUFuQixLQUFvQyxNQUEzRDtBQUNBLE1BQUlxNEIsb0JBQW9CdEMsZUFBZS8xQixFQUFmLEVBQW1CLGFBQW5CLEtBQXFDLE9BQTdEO0FBQ0FxMUIsVUFBUXIxQixFQUFSLEVBQVksU0FBWixFQUNFLG1CQUFtQm5ULEtBQW5CLEdBQTJCLEdBQTNCLEdBQ0UsTUFERixHQUNXQSxLQURYLEdBQ21CLEdBRG5CLEdBQ3lCc3JDLFlBRHpCLEdBQ3dDLE1BRHhDLElBRUlDLHFCQUFxQixNQUFyQixHQUNLLE9BQU92ckMsS0FBUCxHQUFlLEdBRHBCLEdBRUssU0FBU0EsS0FBVCxHQUFpQixHQUFqQixHQUF1QnVyQyxnQkFBdkIsR0FBMEMsR0FKbkQsQ0FERjtBQVFBM0MsYUFBV3oxQixFQUFYLEVBQWU0M0Isb0JBQWYsRUFDRSxhQUFhL3FDLEtBQWIsR0FBcUIsR0FBckIsR0FDSSxxQkFESixHQUVJLG9CQUZKLEdBRTJCdXJDLGdCQUYzQixHQUU4QyxLQUY5QyxHQUVzREMsaUJBRnRELEdBRTBFLElBRjFFLEdBR0EseUJBSEEsR0FJRSxVQUpGLElBSWdCOUIsU0FBUyxRQUFRNEIsWUFBUixHQUF1QixHQUFoQyxHQUFzQ0EsWUFKdEQsSUFJc0UsR0FKdEUsR0FLTSxrQkFMTixHQU1FLGtCQU5GLEdBTXVCdHJDLEtBTnZCLEdBTStCLG9CQU4vQixHQU9FLGdCQVBGLEdBT3FCQSxLQVByQixHQU82Qiw4Q0FQN0IsR0FRQSxRQVJBLEdBUVdBLEtBUlgsR0FRbUIsT0FUckIsRUFVRSxJQVZGLEVBVVEsSUFWUjtBQVlEOztBQUVELFNBQVNvckMsYUFBVCxDQUNJajRCLEVBREosRUFFSW5ULEtBRkosRUFHSXdtQyxTQUhKLEVBSUU7QUFDQSxNQUFJa0QsU0FBU2xELGFBQWFBLFVBQVVrRCxNQUFwQztBQUNBLE1BQUk0QixlQUFlcEMsZUFBZS8xQixFQUFmLEVBQW1CLE9BQW5CLEtBQStCLE1BQWxEO0FBQ0FtNEIsaUJBQWU1QixTQUFVLFFBQVE0QixZQUFSLEdBQXVCLEdBQWpDLEdBQXdDQSxZQUF2RDtBQUNBOUMsVUFBUXIxQixFQUFSLEVBQVksU0FBWixFQUF3QixRQUFRblQsS0FBUixHQUFnQixHQUFoQixHQUFzQnNyQyxZQUF0QixHQUFxQyxHQUE3RDtBQUNBMUMsYUFBV3oxQixFQUFYLEVBQWU0M0Isb0JBQWYsRUFBcUNqQixrQkFBa0I5cEMsS0FBbEIsRUFBeUJzckMsWUFBekIsQ0FBckMsRUFBNkUsSUFBN0UsRUFBbUYsSUFBbkY7QUFDRDs7QUFFRCxTQUFTSixTQUFULENBQ0kvM0IsRUFESixFQUVJblQsS0FGSixFQUdJd21DLFNBSEosRUFJRTtBQUNBLE1BQUlrRCxTQUFTbEQsYUFBYUEsVUFBVWtELE1BQXBDO0FBQ0EsTUFBSStCLGNBQWMsMkJBQ2hCLDZEQURnQixHQUVoQixrRUFGZ0IsR0FHaEIsU0FIZ0IsSUFHSC9CLFNBQVMsU0FBVCxHQUFxQixLQUhsQixJQUcyQixJQUg3Qzs7QUFLQSxNQUFJRyxhQUFhLDJEQUFqQjtBQUNBLE1BQUk2QixPQUFPLHlCQUF5QkQsV0FBekIsR0FBdUMsR0FBbEQ7QUFDQUMsU0FBT0EsT0FBTyxHQUFQLEdBQWM1QixrQkFBa0I5cEMsS0FBbEIsRUFBeUI2cEMsVUFBekIsQ0FBckI7QUFDQWpCLGFBQVd6MUIsRUFBWCxFQUFlLFFBQWYsRUFBeUJ1NEIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckM7QUFDRDs7QUFFRCxTQUFTTCxlQUFULENBQ0VsNEIsRUFERixFQUVFblQsS0FGRixFQUdFd21DLFNBSEYsRUFJRTtBQUNBLE1BQUlybEMsT0FBT2dTLEdBQUdvMkIsUUFBSCxDQUFZcG9DLElBQXZCO0FBQ0EsTUFBSUksTUFBTWlsQyxhQUFhLEVBQXZCO0FBQ0EsTUFBSXZVLE9BQU8xd0IsSUFBSTB3QixJQUFmO0FBQ0EsTUFBSXlYLFNBQVNub0MsSUFBSW1vQyxNQUFqQjtBQUNBLE1BQUlsbEMsT0FBT2pELElBQUlpRCxJQUFmO0FBQ0EsTUFBSW1uQyx1QkFBdUIsQ0FBQzFaLElBQUQsSUFBUzl3QixTQUFTLE9BQTdDO0FBQ0EsTUFBSTBHLFFBQVFvcUIsT0FDUixRQURRLEdBRVI5d0IsU0FBUyxPQUFULEdBQ0UycEMsV0FERixHQUVFLE9BSk47O0FBTUEsTUFBSWxCLGtCQUFrQixxQkFBdEI7QUFDQSxNQUFJcGxDLElBQUosRUFBVTtBQUNSb2xDLHNCQUFrQiw0QkFBbEI7QUFDRDtBQUNELE1BQUlGLE1BQUosRUFBWTtBQUNWRSxzQkFBa0IsUUFBUUEsZUFBUixHQUEwQixHQUE1QztBQUNEOztBQUVELE1BQUk4QixPQUFPNUIsa0JBQWtCOXBDLEtBQWxCLEVBQXlCNHBDLGVBQXpCLENBQVg7QUFDQSxNQUFJK0Isb0JBQUosRUFBMEI7QUFDeEJELFdBQU8sdUNBQXVDQSxJQUE5QztBQUNEOztBQUVEbEQsVUFBUXIxQixFQUFSLEVBQVksT0FBWixFQUFzQixNQUFNblQsS0FBTixHQUFjLEdBQXBDO0FBQ0E0b0MsYUFBV3oxQixFQUFYLEVBQWV0TCxLQUFmLEVBQXNCNmpDLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDLElBQWxDO0FBQ0EsTUFBSWxuQyxRQUFRa2xDLE1BQVIsSUFBa0J2b0MsU0FBUyxRQUEvQixFQUF5QztBQUN2Q3luQyxlQUFXejFCLEVBQVgsRUFBZSxNQUFmLEVBQXVCLGdCQUF2QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTeTRCLGVBQVQsQ0FBMEJodEMsRUFBMUIsRUFBOEI7QUFDNUIsTUFBSWlKLEtBQUo7QUFDQTtBQUNBLE1BQUlqSixHQUFHa3NDLFdBQUgsQ0FBSixFQUFxQjtBQUNuQjtBQUNBampDLFlBQVFzWCxPQUFPLFFBQVAsR0FBa0IsT0FBMUI7QUFDQXZnQixPQUFHaUosS0FBSCxJQUFZLEdBQUd2SyxNQUFILENBQVVzQixHQUFHa3NDLFdBQUgsQ0FBVixFQUEyQmxzQyxHQUFHaUosS0FBSCxLQUFhLEVBQXhDLENBQVo7QUFDQSxXQUFPakosR0FBR2tzQyxXQUFILENBQVA7QUFDRDtBQUNELE1BQUlsc0MsR0FBR21zQyxvQkFBSCxDQUFKLEVBQThCO0FBQzVCO0FBQ0FsakMsWUFBUTJYLFdBQVcsT0FBWCxHQUFxQixRQUE3QjtBQUNBNWdCLE9BQUdpSixLQUFILElBQVksR0FBR3ZLLE1BQUgsQ0FBVXNCLEdBQUdtc0Msb0JBQUgsQ0FBVixFQUFvQ25zQyxHQUFHaUosS0FBSCxLQUFhLEVBQWpELENBQVo7QUFDQSxXQUFPakosR0FBR21zQyxvQkFBSCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJYyxRQUFKOztBQUVBLFNBQVNDLEtBQVQsQ0FDRWprQyxLQURGLEVBRUVVLE9BRkYsRUFHRXpKLElBSEYsRUFJRWlQLE9BSkYsRUFLRTtBQUNBLE1BQUlqUCxJQUFKLEVBQVU7QUFDUixRQUFJaXRDLGFBQWF4akMsT0FBakI7QUFDQSxRQUFJK2EsVUFBVXVvQixRQUFkLENBRlEsQ0FFZ0I7QUFDeEJ0akMsY0FBVSxVQUFVeWpDLEVBQVYsRUFBYztBQUN0QixVQUFJem5DLE1BQU16RyxVQUFVVCxNQUFWLEtBQXFCLENBQXJCLEdBQ04wdUMsV0FBV0MsRUFBWCxDQURNLEdBRU5ELFdBQVczdEMsS0FBWCxDQUFpQixJQUFqQixFQUF1Qk4sU0FBdkIsQ0FGSjtBQUdBLFVBQUl5RyxRQUFRLElBQVosRUFBa0I7QUFDaEIwbkMsaUJBQVNwa0MsS0FBVCxFQUFnQlUsT0FBaEIsRUFBeUJ3RixPQUF6QixFQUFrQ3VWLE9BQWxDO0FBQ0Q7QUFDRixLQVBEO0FBUUQ7QUFDRHVvQixXQUFTMTVCLGdCQUFULENBQTBCdEssS0FBMUIsRUFBaUNVLE9BQWpDLEVBQTBDd0YsT0FBMUM7QUFDRDs7QUFFRCxTQUFTaytCLFFBQVQsQ0FDRXBrQyxLQURGLEVBRUVVLE9BRkYsRUFHRXdGLE9BSEYsRUFJRXVWLE9BSkYsRUFLRTtBQUNBLEdBQUNBLFdBQVd1b0IsUUFBWixFQUFzQkssbUJBQXRCLENBQTBDcmtDLEtBQTFDLEVBQWlEVSxPQUFqRCxFQUEwRHdGLE9BQTFEO0FBQ0Q7O0FBRUQsU0FBU28rQixrQkFBVCxDQUE2QnRwQyxRQUE3QixFQUF1Q0osS0FBdkMsRUFBOEM7QUFDNUMsTUFBSSxDQUFDSSxTQUFTbkIsSUFBVCxDQUFjOUMsRUFBZixJQUFxQixDQUFDNkQsTUFBTWYsSUFBTixDQUFXOUMsRUFBckMsRUFBeUM7QUFDdkM7QUFDRDtBQUNELE1BQUlBLEtBQUs2RCxNQUFNZixJQUFOLENBQVc5QyxFQUFYLElBQWlCLEVBQTFCO0FBQ0EsTUFBSWt0QixRQUFRanBCLFNBQVNuQixJQUFULENBQWM5QyxFQUFkLElBQW9CLEVBQWhDO0FBQ0FpdEMsYUFBV3BwQyxNQUFNOG5CLEdBQWpCO0FBQ0FxaEIsa0JBQWdCaHRDLEVBQWhCO0FBQ0FpdEIsa0JBQWdCanRCLEVBQWhCLEVBQW9Ca3RCLEtBQXBCLEVBQTJCZ2dCLEtBQTNCLEVBQWtDRyxRQUFsQyxFQUE0Q3hwQyxNQUFNK25CLE9BQWxEO0FBQ0Q7O0FBRUQsSUFBSXNlLFNBQVM7QUFDWGo5QixVQUFRc2dDLGtCQURHO0FBRVhocEIsVUFBUWdwQjtBQUZHLENBQWI7O0FBS0E7O0FBRUEsU0FBU0MsY0FBVCxDQUF5QnZwQyxRQUF6QixFQUFtQ0osS0FBbkMsRUFBMEM7QUFDeEMsTUFBSSxDQUFDSSxTQUFTbkIsSUFBVCxDQUFjdzFCLFFBQWYsSUFBMkIsQ0FBQ3owQixNQUFNZixJQUFOLENBQVd3MUIsUUFBM0MsRUFBcUQ7QUFDbkQ7QUFDRDtBQUNELE1BQUk1eUIsR0FBSixFQUFTMG5CLEdBQVQ7QUFDQSxNQUFJekIsTUFBTTluQixNQUFNOG5CLEdBQWhCO0FBQ0EsTUFBSThoQixXQUFXeHBDLFNBQVNuQixJQUFULENBQWN3MUIsUUFBZCxJQUEwQixFQUF6QztBQUNBLE1BQUloMkIsUUFBUXVCLE1BQU1mLElBQU4sQ0FBV3cxQixRQUFYLElBQXVCLEVBQW5DO0FBQ0E7QUFDQSxNQUFJaDJCLE1BQU02aUIsTUFBVixFQUFrQjtBQUNoQjdpQixZQUFRdUIsTUFBTWYsSUFBTixDQUFXdzFCLFFBQVgsR0FBc0JudUIsT0FBTyxFQUFQLEVBQVc3SCxLQUFYLENBQTlCO0FBQ0Q7O0FBRUQsT0FBS29ELEdBQUwsSUFBWStuQyxRQUFaLEVBQXNCO0FBQ3BCLFFBQUluckMsTUFBTW9ELEdBQU4sS0FBYyxJQUFsQixFQUF3QjtBQUN0QmltQixVQUFJam1CLEdBQUosSUFBVyxFQUFYO0FBQ0Q7QUFDRjtBQUNELE9BQUtBLEdBQUwsSUFBWXBELEtBQVosRUFBbUI7QUFDakI4cUIsVUFBTTlxQixNQUFNb0QsR0FBTixDQUFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSUEsUUFBUSxhQUFSLElBQXlCQSxRQUFRLFdBQXJDLEVBQWtEO0FBQ2hELFVBQUk3QixNQUFNakIsUUFBVixFQUFvQjtBQUFFaUIsY0FBTWpCLFFBQU4sQ0FBZW5FLE1BQWYsR0FBd0IsQ0FBeEI7QUFBNEI7QUFDbEQsVUFBSTJ1QixRQUFRcWdCLFNBQVMvbkMsR0FBVCxDQUFaLEVBQTJCO0FBQUU7QUFBVTtBQUN4Qzs7QUFFRCxRQUFJQSxRQUFRLE9BQVosRUFBcUI7QUFDbkI7QUFDQTtBQUNBaW1CLFVBQUkraEIsTUFBSixHQUFhdGdCLEdBQWI7QUFDQTtBQUNBLFVBQUl1Z0IsU0FBU3ZnQixPQUFPLElBQVAsR0FBYyxFQUFkLEdBQW1CNXFCLE9BQU80cUIsR0FBUCxDQUFoQztBQUNBLFVBQUl3Z0Isa0JBQWtCamlCLEdBQWxCLEVBQXVCOW5CLEtBQXZCLEVBQThCOHBDLE1BQTlCLENBQUosRUFBMkM7QUFDekNoaUIsWUFBSXZxQixLQUFKLEdBQVl1c0MsTUFBWjtBQUNEO0FBQ0YsS0FURCxNQVNPO0FBQ0xoaUIsVUFBSWptQixHQUFKLElBQVcwbkIsR0FBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O0FBR0EsU0FBU3dnQixpQkFBVCxDQUNFamlCLEdBREYsRUFFRTluQixLQUZGLEVBR0VncUMsUUFIRixFQUlFO0FBQ0EsU0FBUSxDQUFDbGlCLElBQUltaUIsU0FBTCxLQUNOanFDLE1BQU0rRSxHQUFOLEtBQWMsUUFBZCxJQUNBbWxDLFFBQVFwaUIsR0FBUixFQUFha2lCLFFBQWIsQ0FEQSxJQUVBRyxlQUFlcmlCLEdBQWYsRUFBb0JraUIsUUFBcEIsQ0FITSxDQUFSO0FBS0Q7O0FBRUQsU0FBU0UsT0FBVCxDQUFrQnBpQixHQUFsQixFQUF1QmtpQixRQUF2QixFQUFpQztBQUMvQjtBQUNBLFNBQU9yNUIsU0FBU3k1QixhQUFULEtBQTJCdGlCLEdBQTNCLElBQWtDQSxJQUFJdnFCLEtBQUosS0FBY3lzQyxRQUF2RDtBQUNEOztBQUVELFNBQVNHLGNBQVQsQ0FBeUJyaUIsR0FBekIsRUFBOEIzRSxNQUE5QixFQUFzQztBQUNwQyxNQUFJNWxCLFFBQVF1cUIsSUFBSXZxQixLQUFoQjtBQUNBLE1BQUl3bUMsWUFBWWpjLElBQUl1aUIsV0FBcEIsQ0FGb0MsQ0FFSDtBQUNqQyxNQUFLdEcsYUFBYUEsVUFBVWtELE1BQXhCLElBQW1DbmYsSUFBSXBwQixJQUFKLEtBQWEsUUFBcEQsRUFBOEQ7QUFDNUQsV0FBT2lhLFNBQVNwYixLQUFULE1BQW9Cb2IsU0FBU3dLLE1BQVQsQ0FBM0I7QUFDRDtBQUNELE1BQUk0Z0IsYUFBYUEsVUFBVWhpQyxJQUEzQixFQUFpQztBQUMvQixXQUFPeEUsTUFBTXdFLElBQU4sT0FBaUJvaEIsT0FBT3BoQixJQUFQLEVBQXhCO0FBQ0Q7QUFDRCxTQUFPeEUsVUFBVTRsQixNQUFqQjtBQUNEOztBQUVELElBQUlzUixXQUFXO0FBQ2JyckIsVUFBUXVnQyxjQURLO0FBRWJqcEIsVUFBUWlwQjtBQUZLLENBQWY7O0FBS0E7O0FBRUEsSUFBSVcsaUJBQWlCOXdCLE9BQU8sVUFBVSt3QixPQUFWLEVBQW1CO0FBQzdDLE1BQUl6b0MsTUFBTSxFQUFWO0FBQ0EsTUFBSTBvQyxnQkFBZ0IsZUFBcEI7QUFDQSxNQUFJQyxvQkFBb0IsT0FBeEI7QUFDQUYsVUFBUXZvQyxLQUFSLENBQWN3b0MsYUFBZCxFQUE2QnZvQyxPQUE3QixDQUFxQyxVQUFVbVgsSUFBVixFQUFnQjtBQUNuRCxRQUFJQSxJQUFKLEVBQVU7QUFDUixVQUFJOFcsTUFBTTlXLEtBQUtwWCxLQUFMLENBQVd5b0MsaUJBQVgsQ0FBVjtBQUNBdmEsVUFBSXQxQixNQUFKLEdBQWEsQ0FBYixLQUFtQmtILElBQUlvdUIsSUFBSSxDQUFKLEVBQU9udUIsSUFBUCxFQUFKLElBQXFCbXVCLElBQUksQ0FBSixFQUFPbnVCLElBQVAsRUFBeEM7QUFDRDtBQUNGLEdBTEQ7QUFNQSxTQUFPRCxHQUFQO0FBQ0QsQ0FYb0IsQ0FBckI7O0FBYUE7QUFDQSxTQUFTNG9DLGtCQUFULENBQTZCenJDLElBQTdCLEVBQW1DO0FBQ2pDLE1BQUkwckMsUUFBUUMsc0JBQXNCM3JDLEtBQUswckMsS0FBM0IsQ0FBWjtBQUNBO0FBQ0E7QUFDQSxTQUFPMXJDLEtBQUs0ckMsV0FBTCxHQUNIdmtDLE9BQU9ySCxLQUFLNHJDLFdBQVosRUFBeUJGLEtBQXpCLENBREcsR0FFSEEsS0FGSjtBQUdEOztBQUVEO0FBQ0EsU0FBU0MscUJBQVQsQ0FBZ0NFLFlBQWhDLEVBQThDO0FBQzVDLE1BQUkxdkMsTUFBTW1ILE9BQU4sQ0FBY3VvQyxZQUFkLENBQUosRUFBaUM7QUFDL0IsV0FBT3J3QixTQUFTcXdCLFlBQVQsQ0FBUDtBQUNEO0FBQ0QsTUFBSSxPQUFPQSxZQUFQLEtBQXdCLFFBQTVCLEVBQXNDO0FBQ3BDLFdBQU9SLGVBQWVRLFlBQWYsQ0FBUDtBQUNEO0FBQ0QsU0FBT0EsWUFBUDtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU0MsUUFBVCxDQUFtQi9xQyxLQUFuQixFQUEwQmdyQyxVQUExQixFQUFzQztBQUNwQyxNQUFJbHBDLE1BQU0sRUFBVjtBQUNBLE1BQUltcEMsU0FBSjs7QUFFQSxNQUFJRCxVQUFKLEVBQWdCO0FBQ2QsUUFBSW5QLFlBQVk3N0IsS0FBaEI7QUFDQSxXQUFPNjdCLFVBQVUxVCxpQkFBakIsRUFBb0M7QUFDbEMwVCxrQkFBWUEsVUFBVTFULGlCQUFWLENBQTRCd0UsTUFBeEM7QUFDQSxVQUFJa1AsVUFBVTU4QixJQUFWLEtBQW1CZ3NDLFlBQVlQLG1CQUFtQjdPLFVBQVU1OEIsSUFBN0IsQ0FBL0IsQ0FBSixFQUF3RTtBQUN0RXFILGVBQU94RSxHQUFQLEVBQVltcEMsU0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFLQSxZQUFZUCxtQkFBbUIxcUMsTUFBTWYsSUFBekIsQ0FBakIsRUFBa0Q7QUFDaERxSCxXQUFPeEUsR0FBUCxFQUFZbXBDLFNBQVo7QUFDRDs7QUFFRCxNQUFJclAsYUFBYTU3QixLQUFqQjtBQUNBLFNBQVE0N0IsYUFBYUEsV0FBVzU4QixNQUFoQyxFQUF5QztBQUN2QyxRQUFJNDhCLFdBQVczOEIsSUFBWCxLQUFvQmdzQyxZQUFZUCxtQkFBbUI5TyxXQUFXMzhCLElBQTlCLENBQWhDLENBQUosRUFBMEU7QUFDeEVxSCxhQUFPeEUsR0FBUCxFQUFZbXBDLFNBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBT25wQyxHQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsSUFBSW9wQyxXQUFXLEtBQWY7QUFDQSxJQUFJQyxjQUFjLGdCQUFsQjtBQUNBLElBQUlDLFVBQVUsVUFBVTE2QixFQUFWLEVBQWMvVCxJQUFkLEVBQW9CMEYsR0FBcEIsRUFBeUI7QUFDckM7QUFDQSxNQUFJNm9DLFNBQVNqa0MsSUFBVCxDQUFjdEssSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCK1QsT0FBR2k2QixLQUFILENBQVNVLFdBQVQsQ0FBcUIxdUMsSUFBckIsRUFBMkIwRixHQUEzQjtBQUNELEdBRkQsTUFFTyxJQUFJOG9DLFlBQVlsa0MsSUFBWixDQUFpQjVFLEdBQWpCLENBQUosRUFBMkI7QUFDaENxTyxPQUFHaTZCLEtBQUgsQ0FBU1UsV0FBVCxDQUFxQjF1QyxJQUFyQixFQUEyQjBGLElBQUlqQixPQUFKLENBQVkrcEMsV0FBWixFQUF5QixFQUF6QixDQUEzQixFQUF5RCxXQUF6RDtBQUNELEdBRk0sTUFFQTtBQUNMejZCLE9BQUdpNkIsS0FBSCxDQUFTVyxVQUFVM3VDLElBQVYsQ0FBVCxJQUE0QjBGLEdBQTVCO0FBQ0Q7QUFDRixDQVREOztBQVdBLElBQUlrcEMsV0FBVyxDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLElBQWxCLENBQWY7O0FBRUEsSUFBSUMsTUFBSjtBQUNBLElBQUlGLFlBQVk5eEIsT0FBTyxVQUFVaU0sSUFBVixFQUFnQjtBQUNyQytsQixXQUFTQSxVQUFVNzZCLFNBQVN1akIsYUFBVCxDQUF1QixLQUF2QixDQUFuQjtBQUNBek8sU0FBTzlMLFNBQVM4TCxJQUFULENBQVA7QUFDQSxNQUFJQSxTQUFTLFFBQVQsSUFBc0JBLFFBQVErbEIsT0FBT2IsS0FBekMsRUFBaUQ7QUFDL0MsV0FBT2xsQixJQUFQO0FBQ0Q7QUFDRCxNQUFJZ21CLFFBQVFobUIsS0FBS25kLE1BQUwsQ0FBWSxDQUFaLEVBQWU2RCxXQUFmLEtBQStCc1osS0FBSzVpQixLQUFMLENBQVcsQ0FBWCxDQUEzQztBQUNBLE9BQUssSUFBSXZILElBQUksQ0FBYixFQUFnQkEsSUFBSWl3QyxTQUFTM3dDLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4QyxRQUFJb3dDLFdBQVdILFNBQVNqd0MsQ0FBVCxJQUFjbXdDLEtBQTdCO0FBQ0EsUUFBSUMsWUFBWUYsT0FBT2IsS0FBdkIsRUFBOEI7QUFDNUIsYUFBT2UsUUFBUDtBQUNEO0FBQ0Y7QUFDRixDQWJlLENBQWhCOztBQWVBLFNBQVNDLFdBQVQsQ0FBc0J2ckMsUUFBdEIsRUFBZ0NKLEtBQWhDLEVBQXVDO0FBQ3JDLE1BQUlmLE9BQU9lLE1BQU1mLElBQWpCO0FBQ0EsTUFBSXdsQyxVQUFVcmtDLFNBQVNuQixJQUF2Qjs7QUFFQSxNQUFJLENBQUNBLEtBQUs0ckMsV0FBTixJQUFxQixDQUFDNXJDLEtBQUswckMsS0FBM0IsSUFDQSxDQUFDbEcsUUFBUW9HLFdBRFQsSUFDd0IsQ0FBQ3BHLFFBQVFrRyxLQURyQyxFQUM0QztBQUMxQztBQUNEOztBQUVELE1BQUlwaEIsR0FBSixFQUFTNXNCLElBQVQ7QUFDQSxNQUFJK1QsS0FBSzFRLE1BQU04bkIsR0FBZjtBQUNBLE1BQUk4akIsaUJBQWlCeHJDLFNBQVNuQixJQUFULENBQWM0ckMsV0FBbkM7QUFDQSxNQUFJZ0Isa0JBQWtCenJDLFNBQVNuQixJQUFULENBQWMwckMsS0FBZCxJQUF1QixFQUE3Qzs7QUFFQTtBQUNBLE1BQUltQixXQUFXRixrQkFBa0JDLGVBQWpDOztBQUVBLE1BQUlsQixRQUFRQyxzQkFBc0I1cUMsTUFBTWYsSUFBTixDQUFXMHJDLEtBQWpDLEtBQTJDLEVBQXZEOztBQUVBM3FDLFFBQU1mLElBQU4sQ0FBVzByQyxLQUFYLEdBQW1CQSxNQUFNcnBCLE1BQU4sR0FBZWhiLE9BQU8sRUFBUCxFQUFXcWtDLEtBQVgsQ0FBZixHQUFtQ0EsS0FBdEQ7O0FBRUEsTUFBSW9CLFdBQVdoQixTQUFTL3FDLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBZjs7QUFFQSxPQUFLckQsSUFBTCxJQUFhbXZDLFFBQWIsRUFBdUI7QUFDckIsUUFBSUMsU0FBU3B2QyxJQUFULEtBQWtCLElBQXRCLEVBQTRCO0FBQzFCeXVDLGNBQVExNkIsRUFBUixFQUFZL1QsSUFBWixFQUFrQixFQUFsQjtBQUNEO0FBQ0Y7QUFDRCxPQUFLQSxJQUFMLElBQWFvdkMsUUFBYixFQUF1QjtBQUNyQnhpQixVQUFNd2lCLFNBQVNwdkMsSUFBVCxDQUFOO0FBQ0EsUUFBSTRzQixRQUFRdWlCLFNBQVNudkMsSUFBVCxDQUFaLEVBQTRCO0FBQzFCO0FBQ0F5dUMsY0FBUTE2QixFQUFSLEVBQVkvVCxJQUFaLEVBQWtCNHNCLE9BQU8sSUFBUCxHQUFjLEVBQWQsR0FBbUJBLEdBQXJDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELElBQUlvaEIsUUFBUTtBQUNWdmhDLFVBQVF1aUMsV0FERTtBQUVWanJCLFVBQVFpckI7QUFGRSxDQUFaOztBQUtBOztBQUVBOzs7O0FBSUEsU0FBU0ssUUFBVCxDQUFtQnQ3QixFQUFuQixFQUF1QmcwQixHQUF2QixFQUE0QjtBQUMxQjtBQUNBLE1BQUksQ0FBQ0EsR0FBRCxJQUFRLEVBQUVBLE1BQU1BLElBQUkzaUMsSUFBSixFQUFSLENBQVosRUFBaUM7QUFDL0I7QUFDRDs7QUFFRDtBQUNBLE1BQUkyTyxHQUFHdTdCLFNBQVAsRUFBa0I7QUFDaEIsUUFBSXZILElBQUlsZ0MsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6QmtnQyxVQUFJMWlDLEtBQUosQ0FBVSxLQUFWLEVBQWlCQyxPQUFqQixDQUF5QixVQUFVcEIsQ0FBVixFQUFhO0FBQUUsZUFBTzZQLEdBQUd1N0IsU0FBSCxDQUFhaHRCLEdBQWIsQ0FBaUJwZSxDQUFqQixDQUFQO0FBQTZCLE9BQXJFO0FBQ0QsS0FGRCxNQUVPO0FBQ0w2UCxTQUFHdTdCLFNBQUgsQ0FBYWh0QixHQUFiLENBQWlCeWxCLEdBQWpCO0FBQ0Q7QUFDRixHQU5ELE1BTU87QUFDTCxRQUFJbmIsTUFBTSxPQUFPN1ksR0FBRzFKLFlBQUgsQ0FBZ0IsT0FBaEIsS0FBNEIsRUFBbkMsSUFBeUMsR0FBbkQ7QUFDQSxRQUFJdWlCLElBQUkva0IsT0FBSixDQUFZLE1BQU1rZ0MsR0FBTixHQUFZLEdBQXhCLElBQStCLENBQW5DLEVBQXNDO0FBQ3BDaDBCLFNBQUd1c0IsWUFBSCxDQUFnQixPQUFoQixFQUF5QixDQUFDMVQsTUFBTW1iLEdBQVAsRUFBWTNpQyxJQUFaLEVBQXpCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7O0FBSUEsU0FBU21xQyxXQUFULENBQXNCeDdCLEVBQXRCLEVBQTBCZzBCLEdBQTFCLEVBQStCO0FBQzdCO0FBQ0EsTUFBSSxDQUFDQSxHQUFELElBQVEsRUFBRUEsTUFBTUEsSUFBSTNpQyxJQUFKLEVBQVIsQ0FBWixFQUFpQztBQUMvQjtBQUNEOztBQUVEO0FBQ0EsTUFBSTJPLEdBQUd1N0IsU0FBUCxFQUFrQjtBQUNoQixRQUFJdkgsSUFBSWxnQyxPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCa2dDLFVBQUkxaUMsS0FBSixDQUFVLEtBQVYsRUFBaUJDLE9BQWpCLENBQXlCLFVBQVVwQixDQUFWLEVBQWE7QUFBRSxlQUFPNlAsR0FBR3U3QixTQUFILENBQWE5eUIsTUFBYixDQUFvQnRZLENBQXBCLENBQVA7QUFBZ0MsT0FBeEU7QUFDRCxLQUZELE1BRU87QUFDTDZQLFNBQUd1N0IsU0FBSCxDQUFhOXlCLE1BQWIsQ0FBb0J1ckIsR0FBcEI7QUFDRDtBQUNGLEdBTkQsTUFNTztBQUNMLFFBQUluYixNQUFNLE9BQU83WSxHQUFHMUosWUFBSCxDQUFnQixPQUFoQixLQUE0QixFQUFuQyxJQUF5QyxHQUFuRDtBQUNBLFFBQUltbEMsTUFBTSxNQUFNekgsR0FBTixHQUFZLEdBQXRCO0FBQ0EsV0FBT25iLElBQUkva0IsT0FBSixDQUFZMm5DLEdBQVosS0FBb0IsQ0FBM0IsRUFBOEI7QUFDNUI1aUIsWUFBTUEsSUFBSW5vQixPQUFKLENBQVkrcUMsR0FBWixFQUFpQixHQUFqQixDQUFOO0FBQ0Q7QUFDRHo3QixPQUFHdXNCLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIxVCxJQUFJeG5CLElBQUosRUFBekI7QUFDRDtBQUNGOztBQUVEOztBQUVBLFNBQVNxcUMsaUJBQVQsQ0FBNEJDLE1BQTVCLEVBQW9DO0FBQ2xDLE1BQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1g7QUFDRDtBQUNEO0FBQ0EsTUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFFBQUl2cUMsTUFBTSxFQUFWO0FBQ0EsUUFBSXVxQyxPQUFPQyxHQUFQLEtBQWUsS0FBbkIsRUFBMEI7QUFDeEJobUMsYUFBT3hFLEdBQVAsRUFBWXlxQyxrQkFBa0JGLE9BQU8xdkMsSUFBUCxJQUFlLEdBQWpDLENBQVo7QUFDRDtBQUNEMkosV0FBT3hFLEdBQVAsRUFBWXVxQyxNQUFaO0FBQ0EsV0FBT3ZxQyxHQUFQO0FBQ0QsR0FQRCxNQU9PLElBQUksT0FBT3VxQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQ3JDLFdBQU9FLGtCQUFrQkYsTUFBbEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsSUFBSUUsb0JBQW9CL3lCLE9BQU8sVUFBVTdjLElBQVYsRUFBZ0I7QUFDN0MsU0FBTztBQUNMNnZDLGdCQUFhN3ZDLE9BQU8sUUFEZjtBQUVMOHZDLGtCQUFlOXZDLE9BQU8sV0FGakI7QUFHTCt2QyxzQkFBbUIvdkMsT0FBTyxlQUhyQjtBQUlMZ3dDLGdCQUFhaHdDLE9BQU8sUUFKZjtBQUtMaXdDLGtCQUFlandDLE9BQU8sV0FMakI7QUFNTGt3QyxzQkFBbUJsd0MsT0FBTztBQU5yQixHQUFQO0FBUUQsQ0FUdUIsQ0FBeEI7O0FBV0EsSUFBSW13QyxnQkFBZ0I3a0MsYUFBYSxDQUFDMFUsS0FBbEM7QUFDQSxJQUFJb3dCLGFBQWEsWUFBakI7QUFDQSxJQUFJQyxZQUFZLFdBQWhCOztBQUVBO0FBQ0EsSUFBSUMsaUJBQWlCLFlBQXJCO0FBQ0EsSUFBSUMscUJBQXFCLGVBQXpCO0FBQ0EsSUFBSUMsZ0JBQWdCLFdBQXBCO0FBQ0EsSUFBSUMsb0JBQW9CLGNBQXhCO0FBQ0EsSUFBSU4sYUFBSixFQUFtQjtBQUNqQjtBQUNBLE1BQUk1a0MsT0FBT21sQyxlQUFQLEtBQTJCL3NDLFNBQTNCLElBQ0Y0SCxPQUFPb2xDLHFCQUFQLEtBQWlDaHRDLFNBRG5DLEVBQzhDO0FBQzVDMnNDLHFCQUFpQixrQkFBakI7QUFDQUMseUJBQXFCLHFCQUFyQjtBQUNEO0FBQ0QsTUFBSWhsQyxPQUFPcWxDLGNBQVAsS0FBMEJqdEMsU0FBMUIsSUFDRjRILE9BQU9zbEMsb0JBQVAsS0FBZ0NsdEMsU0FEbEMsRUFDNkM7QUFDM0M2c0Msb0JBQWdCLGlCQUFoQjtBQUNBQyx3QkFBb0Isb0JBQXBCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLElBQUlLLE1BQU14bEMsYUFBYUMsT0FBT3dsQyxxQkFBcEIsR0FDTnhsQyxPQUFPd2xDLHFCQUFQLENBQTZCeDRCLElBQTdCLENBQWtDaE4sTUFBbEMsQ0FETSxHQUVObk8sVUFGSjs7QUFJQSxTQUFTNHpDLFNBQVQsQ0FBb0I5NkIsRUFBcEIsRUFBd0I7QUFDdEI0NkIsTUFBSSxZQUFZO0FBQ2RBLFFBQUk1NkIsRUFBSjtBQUNELEdBRkQ7QUFHRDs7QUFFRCxTQUFTKzZCLGtCQUFULENBQTZCbDlCLEVBQTdCLEVBQWlDZzBCLEdBQWpDLEVBQXNDO0FBQ3BDLEdBQUNoMEIsR0FBR2swQixrQkFBSCxLQUEwQmwwQixHQUFHazBCLGtCQUFILEdBQXdCLEVBQWxELENBQUQsRUFBd0RycEMsSUFBeEQsQ0FBNkRtcEMsR0FBN0Q7QUFDQXNILFdBQVN0N0IsRUFBVCxFQUFhZzBCLEdBQWI7QUFDRDs7QUFFRCxTQUFTbUoscUJBQVQsQ0FBZ0NuOUIsRUFBaEMsRUFBb0NnMEIsR0FBcEMsRUFBeUM7QUFDdkMsTUFBSWgwQixHQUFHazBCLGtCQUFQLEVBQTJCO0FBQ3pCenJCLFdBQU96SSxHQUFHazBCLGtCQUFWLEVBQThCRixHQUE5QjtBQUNEO0FBQ0R3SCxjQUFZeDdCLEVBQVosRUFBZ0JnMEIsR0FBaEI7QUFDRDs7QUFFRCxTQUFTb0osa0JBQVQsQ0FDRXA5QixFQURGLEVBRUUyVixZQUZGLEVBR0V2VCxFQUhGLEVBSUU7QUFDQSxNQUFJaFUsTUFBTWl2QyxrQkFBa0JyOUIsRUFBbEIsRUFBc0IyVixZQUF0QixDQUFWO0FBQ0EsTUFBSTNuQixPQUFPSSxJQUFJSixJQUFmO0FBQ0EsTUFBSTNELFVBQVUrRCxJQUFJL0QsT0FBbEI7QUFDQSxNQUFJaXpDLFlBQVlsdkMsSUFBSWt2QyxTQUFwQjtBQUNBLE1BQUksQ0FBQ3R2QyxJQUFMLEVBQVc7QUFBRSxXQUFPb1UsSUFBUDtBQUFhO0FBQzFCLE1BQUkxTixRQUFRMUcsU0FBU3F1QyxVQUFULEdBQXNCRyxrQkFBdEIsR0FBMkNFLGlCQUF2RDtBQUNBLE1BQUlhLFFBQVEsQ0FBWjtBQUNBLE1BQUl4Z0MsTUFBTSxZQUFZO0FBQ3BCaUQsT0FBRys0QixtQkFBSCxDQUF1QnJrQyxLQUF2QixFQUE4QjhvQyxLQUE5QjtBQUNBcDdCO0FBQ0QsR0FIRDtBQUlBLE1BQUlvN0IsUUFBUSxVQUFVbDBDLENBQVYsRUFBYTtBQUN2QixRQUFJQSxFQUFFdUssTUFBRixLQUFhbU0sRUFBakIsRUFBcUI7QUFDbkIsVUFBSSxFQUFFdTlCLEtBQUYsSUFBV0QsU0FBZixFQUEwQjtBQUN4QnZnQztBQUNEO0FBQ0Y7QUFDRixHQU5EO0FBT0ExVCxhQUFXLFlBQVk7QUFDckIsUUFBSWswQyxRQUFRRCxTQUFaLEVBQXVCO0FBQ3JCdmdDO0FBQ0Q7QUFDRixHQUpELEVBSUcxUyxVQUFVLENBSmI7QUFLQTJWLEtBQUdoQixnQkFBSCxDQUFvQnRLLEtBQXBCLEVBQTJCOG9DLEtBQTNCO0FBQ0Q7O0FBRUQsSUFBSUMsY0FBYyx3QkFBbEI7O0FBRUEsU0FBU0osaUJBQVQsQ0FBNEJyOUIsRUFBNUIsRUFBZ0MyVixZQUFoQyxFQUE4QztBQUM1QyxNQUFJK25CLFNBQVNsbUMsT0FBT21tQyxnQkFBUCxDQUF3QjM5QixFQUF4QixDQUFiO0FBQ0EsTUFBSTQ5QixtQkFBbUJGLE9BQU9uQixpQkFBaUIsT0FBeEIsRUFBaUNqckMsS0FBakMsQ0FBdUMsSUFBdkMsQ0FBdkI7QUFDQSxNQUFJdXNDLHNCQUFzQkgsT0FBT25CLGlCQUFpQixVQUF4QixFQUFvQ2pyQyxLQUFwQyxDQUEwQyxJQUExQyxDQUExQjtBQUNBLE1BQUl3c0Msb0JBQW9CQyxXQUFXSCxnQkFBWCxFQUE2QkMsbUJBQTdCLENBQXhCO0FBQ0EsTUFBSUcsa0JBQWtCTixPQUFPakIsZ0JBQWdCLE9BQXZCLEVBQWdDbnJDLEtBQWhDLENBQXNDLElBQXRDLENBQXRCO0FBQ0EsTUFBSTJzQyxxQkFBcUJQLE9BQU9qQixnQkFBZ0IsVUFBdkIsRUFBbUNuckMsS0FBbkMsQ0FBeUMsSUFBekMsQ0FBekI7QUFDQSxNQUFJNHNDLG1CQUFtQkgsV0FBV0MsZUFBWCxFQUE0QkMsa0JBQTVCLENBQXZCOztBQUVBLE1BQUlqd0MsSUFBSjtBQUNBLE1BQUkzRCxVQUFVLENBQWQ7QUFDQSxNQUFJaXpDLFlBQVksQ0FBaEI7QUFDQTtBQUNBLE1BQUkzbkIsaUJBQWlCMG1CLFVBQXJCLEVBQWlDO0FBQy9CLFFBQUl5QixvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDekI5dkMsYUFBT3F1QyxVQUFQO0FBQ0FoeUMsZ0JBQVV5ekMsaUJBQVY7QUFDQVIsa0JBQVlPLG9CQUFvQjN6QyxNQUFoQztBQUNEO0FBQ0YsR0FORCxNQU1PLElBQUl5ckIsaUJBQWlCMm1CLFNBQXJCLEVBQWdDO0FBQ3JDLFFBQUk0QixtQkFBbUIsQ0FBdkIsRUFBMEI7QUFDeEJsd0MsYUFBT3N1QyxTQUFQO0FBQ0FqeUMsZ0JBQVU2ekMsZ0JBQVY7QUFDQVosa0JBQVlXLG1CQUFtQi96QyxNQUEvQjtBQUNEO0FBQ0YsR0FOTSxNQU1BO0FBQ0xHLGNBQVVnYSxLQUFLRCxHQUFMLENBQVMwNUIsaUJBQVQsRUFBNEJJLGdCQUE1QixDQUFWO0FBQ0Fsd0MsV0FBTzNELFVBQVUsQ0FBVixHQUNIeXpDLG9CQUFvQkksZ0JBQXBCLEdBQ0U3QixVQURGLEdBRUVDLFNBSEMsR0FJSCxJQUpKO0FBS0FnQixnQkFBWXR2QyxPQUNSQSxTQUFTcXVDLFVBQVQsR0FDRXdCLG9CQUFvQjN6QyxNQUR0QixHQUVFK3pDLG1CQUFtQi96QyxNQUhiLEdBSVIsQ0FKSjtBQUtEO0FBQ0QsTUFBSWkwQyxlQUNGbndDLFNBQVNxdUMsVUFBVCxJQUNBb0IsWUFBWWxuQyxJQUFaLENBQWlCbW5DLE9BQU9uQixpQkFBaUIsVUFBeEIsQ0FBakIsQ0FGRjtBQUdBLFNBQU87QUFDTHZ1QyxVQUFNQSxJQUREO0FBRUwzRCxhQUFTQSxPQUZKO0FBR0xpekMsZUFBV0EsU0FITjtBQUlMYSxrQkFBY0E7QUFKVCxHQUFQO0FBTUQ7O0FBRUQsU0FBU0osVUFBVCxDQUFxQkssTUFBckIsRUFBNkJDLFNBQTdCLEVBQXdDO0FBQ3RDO0FBQ0EsU0FBT0QsT0FBT2wwQyxNQUFQLEdBQWdCbTBDLFVBQVVuMEMsTUFBakMsRUFBeUM7QUFDdkNrMEMsYUFBU0EsT0FBT2owQyxNQUFQLENBQWNpMEMsTUFBZCxDQUFUO0FBQ0Q7O0FBRUQsU0FBTy81QixLQUFLRCxHQUFMLENBQVNuWixLQUFULENBQWUsSUFBZixFQUFxQm96QyxVQUFVcHNDLEdBQVYsQ0FBYyxVQUFVc3hCLENBQVYsRUFBYTM0QixDQUFiLEVBQWdCO0FBQ3hELFdBQU8wekMsS0FBSy9hLENBQUwsSUFBVSthLEtBQUtGLE9BQU94ekMsQ0FBUCxDQUFMLENBQWpCO0FBQ0QsR0FGMkIsQ0FBckIsQ0FBUDtBQUdEOztBQUVELFNBQVMwekMsSUFBVCxDQUFlQyxDQUFmLEVBQWtCO0FBQ2hCLFNBQU9DLE9BQU9ELEVBQUVwc0MsS0FBRixDQUFRLENBQVIsRUFBVyxDQUFDLENBQVosQ0FBUCxJQUF5QixJQUFoQztBQUNEOztBQUVEOztBQUVBLFNBQVNzc0MsS0FBVCxDQUFnQm52QyxLQUFoQixFQUF1Qm92QyxhQUF2QixFQUFzQztBQUNwQyxNQUFJMStCLEtBQUsxUSxNQUFNOG5CLEdBQWY7O0FBRUE7QUFDQSxNQUFJcFgsR0FBR3N5QixRQUFQLEVBQWlCO0FBQ2Z0eUIsT0FBR3N5QixRQUFILENBQVlxTSxTQUFaLEdBQXdCLElBQXhCO0FBQ0EzK0IsT0FBR3N5QixRQUFIO0FBQ0Q7O0FBRUQsTUFBSS9qQyxPQUFPbXRDLGtCQUFrQnBzQyxNQUFNZixJQUFOLENBQVdnaEMsVUFBN0IsQ0FBWDtBQUNBLE1BQUksQ0FBQ2hoQyxJQUFMLEVBQVc7QUFDVDtBQUNEOztBQUVEO0FBQ0EsTUFBSXlSLEdBQUc0K0IsUUFBSCxJQUFlNStCLEdBQUc4eEIsUUFBSCxLQUFnQixDQUFuQyxFQUFzQztBQUNwQztBQUNEOztBQUVELE1BQUk4SixNQUFNcnRDLEtBQUtxdEMsR0FBZjtBQUNBLE1BQUk1dEMsT0FBT08sS0FBS1AsSUFBaEI7QUFDQSxNQUFJOHRDLGFBQWF2dEMsS0FBS3V0QyxVQUF0QjtBQUNBLE1BQUlDLGVBQWV4dEMsS0FBS3d0QyxZQUF4QjtBQUNBLE1BQUlDLG1CQUFtQnp0QyxLQUFLeXRDLGdCQUE1QjtBQUNBLE1BQUk2QyxjQUFjdHdDLEtBQUtzd0MsV0FBdkI7QUFDQSxNQUFJQyxnQkFBZ0J2d0MsS0FBS3V3QyxhQUF6QjtBQUNBLE1BQUlDLG9CQUFvQnh3QyxLQUFLd3dDLGlCQUE3QjtBQUNBLE1BQUkvbEMsY0FBY3pLLEtBQUt5SyxXQUF2QjtBQUNBLE1BQUl5bEMsUUFBUWx3QyxLQUFLa3dDLEtBQWpCO0FBQ0EsTUFBSU8sYUFBYXp3QyxLQUFLeXdDLFVBQXRCO0FBQ0EsTUFBSUMsaUJBQWlCMXdDLEtBQUswd0MsY0FBMUI7QUFDQSxNQUFJQyxlQUFlM3dDLEtBQUsyd0MsWUFBeEI7QUFDQSxNQUFJQyxTQUFTNXdDLEtBQUs0d0MsTUFBbEI7QUFDQSxNQUFJQyxjQUFjN3dDLEtBQUs2d0MsV0FBdkI7QUFDQSxNQUFJQyxrQkFBa0I5d0MsS0FBSzh3QyxlQUEzQjtBQUNBLE1BQUlDLFdBQVcvd0MsS0FBSyt3QyxRQUFwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlqb0IsVUFBVTJELGNBQWQ7QUFDQSxNQUFJdWtCLGlCQUFpQnZrQixlQUFlbHNCLE1BQXBDO0FBQ0EsU0FBT3l3QyxrQkFBa0JBLGVBQWVqeEMsTUFBeEMsRUFBZ0Q7QUFDOUNpeEMscUJBQWlCQSxlQUFlanhDLE1BQWhDO0FBQ0Erb0IsY0FBVWtvQixlQUFlbG9CLE9BQXpCO0FBQ0Q7O0FBRUQsTUFBSW1vQixXQUFXLENBQUNub0IsUUFBUWtFLFVBQVQsSUFBdUIsQ0FBQ2pzQixNQUFNb29CLFlBQTdDOztBQUVBLE1BQUk4bkIsWUFBWSxDQUFDTCxNQUFiLElBQXVCQSxXQUFXLEVBQXRDLEVBQTBDO0FBQ3hDO0FBQ0Q7O0FBRUQsTUFBSU0sYUFBYUQsWUFBWVgsV0FBWixHQUNiQSxXQURhLEdBRWIvQyxVQUZKO0FBR0EsTUFBSXJuQyxjQUFjK3FDLFlBQVlULGlCQUFaLEdBQ2RBLGlCQURjLEdBRWQvQyxnQkFGSjtBQUdBLE1BQUkwRCxVQUFVRixZQUFZVixhQUFaLEdBQ1ZBLGFBRFUsR0FFVi9DLFlBRko7O0FBSUEsTUFBSTRELGtCQUFrQkgsV0FDakJOLGdCQUFnQmxtQyxXQURDLEdBRWxCQSxXQUZKO0FBR0EsTUFBSTRtQyxZQUFZSixXQUNYLE9BQU9MLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDVixLQUQ3QixHQUVaQSxLQUZKO0FBR0EsTUFBSW9CLGlCQUFpQkwsV0FDaEJKLGVBQWVKLFVBREMsR0FFakJBLFVBRko7QUFHQSxNQUFJYyxxQkFBcUJOLFdBQ3BCSCxtQkFBbUJKLGNBREMsR0FFckJBLGNBRko7O0FBSUEsTUFBSWMsd0JBQXdCOTNCLFNBQzFCbkksU0FBU3cvQixRQUFULElBQ0lBLFNBQVNiLEtBRGIsR0FFSWEsUUFIc0IsQ0FBNUI7O0FBTUEsTUFBSXoyQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzZ1Qyx5QkFBeUIsSUFBdEUsRUFBNEU7QUFDMUVDLGtCQUFjRCxxQkFBZCxFQUFxQyxPQUFyQyxFQUE4Q3p3QyxLQUE5QztBQUNEOztBQUVELE1BQUkyd0MsYUFBYXJFLFFBQVEsS0FBUixJQUFpQixDQUFDM3ZCLEtBQW5DO0FBQ0EsTUFBSWkwQixtQkFBbUJDLHVCQUF1QlAsU0FBdkIsQ0FBdkI7O0FBRUEsTUFBSXg5QixLQUFLcEMsR0FBRzQrQixRQUFILEdBQWNqekMsS0FBSyxZQUFZO0FBQ3RDLFFBQUlzMEMsVUFBSixFQUFnQjtBQUNkOUMsNEJBQXNCbjlCLEVBQXRCLEVBQTBCMC9CLE9BQTFCO0FBQ0F2Qyw0QkFBc0JuOUIsRUFBdEIsRUFBMEJ2TCxXQUExQjtBQUNEO0FBQ0QsUUFBSTJOLEdBQUd1OEIsU0FBUCxFQUFrQjtBQUNoQixVQUFJc0IsVUFBSixFQUFnQjtBQUNkOUMsOEJBQXNCbjlCLEVBQXRCLEVBQTBCeS9CLFVBQTFCO0FBQ0Q7QUFDREssNEJBQXNCQSxtQkFBbUI5L0IsRUFBbkIsQ0FBdEI7QUFDRCxLQUxELE1BS087QUFDTDYvQix3QkFBa0JBLGVBQWU3L0IsRUFBZixDQUFsQjtBQUNEO0FBQ0RBLE9BQUc0K0IsUUFBSCxHQUFjLElBQWQ7QUFDRCxHQWRzQixDQUF2Qjs7QUFnQkEsTUFBSSxDQUFDdHZDLE1BQU1mLElBQU4sQ0FBVzZ4QyxJQUFoQixFQUFzQjtBQUNwQjtBQUNBcm5CLG1CQUFlenBCLE1BQU1mLElBQU4sQ0FBV2EsSUFBWCxLQUFvQkUsTUFBTWYsSUFBTixDQUFXYSxJQUFYLEdBQWtCLEVBQXRDLENBQWYsRUFBMEQsUUFBMUQsRUFBb0UsWUFBWTtBQUM5RSxVQUFJZCxTQUFTMFIsR0FBR2tyQixVQUFoQjtBQUNBLFVBQUltVixjQUFjL3hDLFVBQVVBLE9BQU9neUMsUUFBakIsSUFBNkJoeUMsT0FBT2d5QyxRQUFQLENBQWdCaHhDLE1BQU02QixHQUF0QixDQUEvQztBQUNBLFVBQUlrdkMsZUFDQUEsWUFBWWhzQyxHQUFaLEtBQW9CL0UsTUFBTStFLEdBRDFCLElBRUFnc0MsWUFBWWpwQixHQUFaLENBQWdCa2IsUUFGcEIsRUFFOEI7QUFDNUIrTixvQkFBWWpwQixHQUFaLENBQWdCa2IsUUFBaEI7QUFDRDtBQUNEc04sbUJBQWFBLFVBQVU1L0IsRUFBVixFQUFjb0MsRUFBZCxDQUFiO0FBQ0QsS0FURDtBQVVEOztBQUVEO0FBQ0F1OUIscUJBQW1CQSxnQkFBZ0IzL0IsRUFBaEIsQ0FBbkI7QUFDQSxNQUFJaWdDLFVBQUosRUFBZ0I7QUFDZC9DLHVCQUFtQmw5QixFQUFuQixFQUF1QnkvQixVQUF2QjtBQUNBdkMsdUJBQW1CbDlCLEVBQW5CLEVBQXVCdkwsV0FBdkI7QUFDQXdvQyxjQUFVLFlBQVk7QUFDcEJDLHlCQUFtQmw5QixFQUFuQixFQUF1QjAvQixPQUF2QjtBQUNBdkMsNEJBQXNCbjlCLEVBQXRCLEVBQTBCeS9CLFVBQTFCO0FBQ0EsVUFBSSxDQUFDcjlCLEdBQUd1OEIsU0FBSixJQUFpQixDQUFDdUIsZ0JBQXRCLEVBQXdDO0FBQ3RDLFlBQUlLLGdCQUFnQlIscUJBQWhCLENBQUosRUFBNEM7QUFDMUMxMkMscUJBQVcrWSxFQUFYLEVBQWUyOUIscUJBQWY7QUFDRCxTQUZELE1BRU87QUFDTDNDLDZCQUFtQnA5QixFQUFuQixFQUF1QmhTLElBQXZCLEVBQTZCb1UsRUFBN0I7QUFDRDtBQUNGO0FBQ0YsS0FWRDtBQVdEOztBQUVELE1BQUk5UyxNQUFNZixJQUFOLENBQVc2eEMsSUFBZixFQUFxQjtBQUNuQjFCLHFCQUFpQkEsZUFBakI7QUFDQWtCLGlCQUFhQSxVQUFVNS9CLEVBQVYsRUFBY29DLEVBQWQsQ0FBYjtBQUNEOztBQUVELE1BQUksQ0FBQzY5QixVQUFELElBQWUsQ0FBQ0MsZ0JBQXBCLEVBQXNDO0FBQ3BDOTlCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbytCLEtBQVQsQ0FBZ0JseEMsS0FBaEIsRUFBdUIyZ0MsRUFBdkIsRUFBMkI7QUFDekIsTUFBSWp3QixLQUFLMVEsTUFBTThuQixHQUFmOztBQUVBO0FBQ0EsTUFBSXBYLEdBQUc0K0IsUUFBUCxFQUFpQjtBQUNmNStCLE9BQUc0K0IsUUFBSCxDQUFZRCxTQUFaLEdBQXdCLElBQXhCO0FBQ0EzK0IsT0FBRzQrQixRQUFIO0FBQ0Q7O0FBRUQsTUFBSXJ3QyxPQUFPbXRDLGtCQUFrQnBzQyxNQUFNZixJQUFOLENBQVdnaEMsVUFBN0IsQ0FBWDtBQUNBLE1BQUksQ0FBQ2hoQyxJQUFMLEVBQVc7QUFDVCxXQUFPMGhDLElBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUlqd0IsR0FBR3N5QixRQUFILElBQWV0eUIsR0FBRzh4QixRQUFILEtBQWdCLENBQW5DLEVBQXNDO0FBQ3BDO0FBQ0Q7O0FBRUQsTUFBSThKLE1BQU1ydEMsS0FBS3F0QyxHQUFmO0FBQ0EsTUFBSTV0QyxPQUFPTyxLQUFLUCxJQUFoQjtBQUNBLE1BQUlpdUMsYUFBYTF0QyxLQUFLMHRDLFVBQXRCO0FBQ0EsTUFBSUMsZUFBZTN0QyxLQUFLMnRDLFlBQXhCO0FBQ0EsTUFBSUMsbUJBQW1CNXRDLEtBQUs0dEMsZ0JBQTVCO0FBQ0EsTUFBSXNFLGNBQWNseUMsS0FBS2t5QyxXQUF2QjtBQUNBLE1BQUlELFFBQVFqeUMsS0FBS2l5QyxLQUFqQjtBQUNBLE1BQUlFLGFBQWFueUMsS0FBS215QyxVQUF0QjtBQUNBLE1BQUlDLGlCQUFpQnB5QyxLQUFLb3lDLGNBQTFCO0FBQ0EsTUFBSUMsYUFBYXJ5QyxLQUFLcXlDLFVBQXRCO0FBQ0EsTUFBSXRCLFdBQVcvd0MsS0FBSyt3QyxRQUFwQjs7QUFFQSxNQUFJVyxhQUFhckUsUUFBUSxLQUFSLElBQWlCLENBQUMzdkIsS0FBbkM7QUFDQSxNQUFJaTBCLG1CQUFtQkMsdUJBQXVCSyxLQUF2QixDQUF2Qjs7QUFFQSxNQUFJSyx3QkFBd0I1NEIsU0FDMUJuSSxTQUFTdy9CLFFBQVQsSUFDSUEsU0FBU2tCLEtBRGIsR0FFSWxCLFFBSHNCLENBQTVCOztBQU1BLE1BQUl6MkMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUMydkMseUJBQXlCLElBQXRFLEVBQTRFO0FBQzFFYixrQkFBY2EscUJBQWQsRUFBcUMsT0FBckMsRUFBOEN2eEMsS0FBOUM7QUFDRDs7QUFFRCxNQUFJOFMsS0FBS3BDLEdBQUdzeUIsUUFBSCxHQUFjM21DLEtBQUssWUFBWTtBQUN0QyxRQUFJcVUsR0FBR2tyQixVQUFILElBQWlCbHJCLEdBQUdrckIsVUFBSCxDQUFjb1YsUUFBbkMsRUFBNkM7QUFDM0N0Z0MsU0FBR2tyQixVQUFILENBQWNvVixRQUFkLENBQXVCaHhDLE1BQU02QixHQUE3QixJQUFvQyxJQUFwQztBQUNEO0FBQ0QsUUFBSTh1QyxVQUFKLEVBQWdCO0FBQ2Q5Qyw0QkFBc0JuOUIsRUFBdEIsRUFBMEJrOEIsWUFBMUI7QUFDQWlCLDRCQUFzQm45QixFQUF0QixFQUEwQm04QixnQkFBMUI7QUFDRDtBQUNELFFBQUkvNUIsR0FBR3U4QixTQUFQLEVBQWtCO0FBQ2hCLFVBQUlzQixVQUFKLEVBQWdCO0FBQ2Q5Qyw4QkFBc0JuOUIsRUFBdEIsRUFBMEJpOEIsVUFBMUI7QUFDRDtBQUNEMEUsd0JBQWtCQSxlQUFlM2dDLEVBQWYsQ0FBbEI7QUFDRCxLQUxELE1BS087QUFDTGl3QjtBQUNBeVEsb0JBQWNBLFdBQVcxZ0MsRUFBWCxDQUFkO0FBQ0Q7QUFDREEsT0FBR3N5QixRQUFILEdBQWMsSUFBZDtBQUNELEdBbEJzQixDQUF2Qjs7QUFvQkEsTUFBSXNPLFVBQUosRUFBZ0I7QUFDZEEsZUFBV0UsWUFBWDtBQUNELEdBRkQsTUFFTztBQUNMQTtBQUNEOztBQUVELFdBQVNBLFlBQVQsR0FBeUI7QUFDdkI7QUFDQSxRQUFJMStCLEdBQUd1OEIsU0FBUCxFQUFrQjtBQUNoQjtBQUNEO0FBQ0Q7QUFDQSxRQUFJLENBQUNydkMsTUFBTWYsSUFBTixDQUFXNnhDLElBQWhCLEVBQXNCO0FBQ3BCLE9BQUNwZ0MsR0FBR2tyQixVQUFILENBQWNvVixRQUFkLEtBQTJCdGdDLEdBQUdrckIsVUFBSCxDQUFjb1YsUUFBZCxHQUF5QixFQUFwRCxDQUFELEVBQTBEaHhDLE1BQU02QixHQUFoRSxJQUF1RTdCLEtBQXZFO0FBQ0Q7QUFDRG14QyxtQkFBZUEsWUFBWXpnQyxFQUFaLENBQWY7QUFDQSxRQUFJaWdDLFVBQUosRUFBZ0I7QUFDZC9DLHlCQUFtQmw5QixFQUFuQixFQUF1Qmk4QixVQUF2QjtBQUNBaUIseUJBQW1CbDlCLEVBQW5CLEVBQXVCbThCLGdCQUF2QjtBQUNBYyxnQkFBVSxZQUFZO0FBQ3BCQywyQkFBbUJsOUIsRUFBbkIsRUFBdUJrOEIsWUFBdkI7QUFDQWlCLDhCQUFzQm45QixFQUF0QixFQUEwQmk4QixVQUExQjtBQUNBLFlBQUksQ0FBQzc1QixHQUFHdThCLFNBQUosSUFBaUIsQ0FBQ3VCLGdCQUF0QixFQUF3QztBQUN0QyxjQUFJSyxnQkFBZ0JNLHFCQUFoQixDQUFKLEVBQTRDO0FBQzFDeDNDLHVCQUFXK1ksRUFBWCxFQUFleStCLHFCQUFmO0FBQ0QsV0FGRCxNQUVPO0FBQ0x6RCwrQkFBbUJwOUIsRUFBbkIsRUFBdUJoUyxJQUF2QixFQUE2Qm9VLEVBQTdCO0FBQ0Q7QUFDRjtBQUNGLE9BVkQ7QUFXRDtBQUNEbytCLGFBQVNBLE1BQU14Z0MsRUFBTixFQUFVb0MsRUFBVixDQUFUO0FBQ0EsUUFBSSxDQUFDNjlCLFVBQUQsSUFBZSxDQUFDQyxnQkFBcEIsRUFBc0M7QUFDcEM5OUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxTQUFTNDlCLGFBQVQsQ0FBd0JydUMsR0FBeEIsRUFBNkIxRixJQUE3QixFQUFtQ3FELEtBQW5DLEVBQTBDO0FBQ3hDLE1BQUksT0FBT3FDLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQmhFLFNBQ0UsMkJBQTJCMUIsSUFBM0IsR0FBa0Msb0NBQWxDLEdBQ0EsTUFEQSxHQUNVK1AsS0FBS0MsU0FBTCxDQUFldEssR0FBZixDQURWLEdBQ2lDLEdBRm5DLEVBR0VyQyxNQUFNK25CLE9BSFI7QUFLRCxHQU5ELE1BTU8sSUFBSWxQLE1BQU14VyxHQUFOLENBQUosRUFBZ0I7QUFDckJoRSxTQUNFLDJCQUEyQjFCLElBQTNCLEdBQWtDLHFCQUFsQyxHQUNBLDZDQUZGLEVBR0VxRCxNQUFNK25CLE9BSFI7QUFLRDtBQUNGOztBQUVELFNBQVNrcEIsZUFBVCxDQUEwQjV1QyxHQUExQixFQUErQjtBQUM3QixTQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUN3VyxNQUFNeFcsR0FBTixDQUFuQztBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTd3VDLHNCQUFULENBQWlDaCtCLEVBQWpDLEVBQXFDO0FBQ25DLE1BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQUUsV0FBTyxLQUFQO0FBQWM7QUFDekIsTUFBSTQrQixhQUFhNStCLEdBQUdxVyxHQUFwQjtBQUNBLE1BQUl1b0IsVUFBSixFQUFnQjtBQUNkO0FBQ0EsV0FBT1osdUJBQ0x6MUMsTUFBTW1ILE9BQU4sQ0FBY2t2QyxVQUFkLElBQ0lBLFdBQVcsQ0FBWCxDQURKLEdBRUlBLFVBSEMsQ0FBUDtBQUtELEdBUEQsTUFPTztBQUNMLFdBQU8sQ0FBQzUrQixHQUFHcUgsT0FBSCxJQUFjckgsR0FBR2pZLE1BQWxCLElBQTRCLENBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTODJDLE1BQVQsQ0FBaUI1N0IsQ0FBakIsRUFBb0I5VixLQUFwQixFQUEyQjtBQUN6QixNQUFJLENBQUNBLE1BQU1mLElBQU4sQ0FBVzZ4QyxJQUFoQixFQUFzQjtBQUNwQjNCLFVBQU1udkMsS0FBTjtBQUNEO0FBQ0Y7O0FBRUQsSUFBSWlnQyxhQUFhaDRCLFlBQVk7QUFDM0JtQixVQUFRc29DLE1BRG1CO0FBRTNCeFIsWUFBVXdSLE1BRmlCO0FBRzNCdjRCLFVBQVEsU0FBU21RLFNBQVQsQ0FBb0J0cEIsS0FBcEIsRUFBMkIyZ0MsRUFBM0IsRUFBK0I7QUFDckM7QUFDQSxRQUFJLENBQUMzZ0MsTUFBTWYsSUFBTixDQUFXNnhDLElBQWhCLEVBQXNCO0FBQ3BCSSxZQUFNbHhDLEtBQU4sRUFBYTJnQyxFQUFiO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRjtBQVYwQixDQUFaLEdBV2IsRUFYSjs7QUFhQSxJQUFJZ1Isa0JBQWtCLENBQ3BCenJDLEtBRG9CLEVBRXBCNCtCLEtBRm9CLEVBR3BCdUIsTUFIb0IsRUFJcEI1UixRQUpvQixFQUtwQmtXLEtBTG9CLEVBTXBCMUssVUFOb0IsQ0FBdEI7O0FBU0E7O0FBRUE7QUFDQTtBQUNBLElBQUlwbEIsVUFBVTgyQixnQkFBZ0I5MkMsTUFBaEIsQ0FBdUJxcEMsV0FBdkIsQ0FBZDs7QUFFQSxJQUFJekIsUUFBUTVELG9CQUFvQixFQUFFaEIsU0FBU0EsT0FBWCxFQUFvQmhqQixTQUFTQSxPQUE3QixFQUFwQixDQUFaOztBQUVBOzs7OztBQUtBO0FBQ0EsSUFBSThCLEtBQUosRUFBVztBQUNUO0FBQ0FoTSxXQUFTakIsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDLFlBQVk7QUFDdkQsUUFBSWdCLEtBQUtDLFNBQVN5NUIsYUFBbEI7QUFDQSxRQUFJMTVCLE1BQU1BLEdBQUdraEMsTUFBYixFQUFxQjtBQUNuQkMsY0FBUW5oQyxFQUFSLEVBQVksT0FBWjtBQUNEO0FBQ0YsR0FMRDtBQU1EOztBQUVELElBQUlvaEMsVUFBVTtBQUNadndCLFlBQVUsU0FBU0EsUUFBVCxDQUFtQjdRLEVBQW5CLEVBQXVCaFUsT0FBdkIsRUFBZ0NzRCxLQUFoQyxFQUF1QztBQUMvQyxRQUFJQSxNQUFNK0UsR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCLFVBQUkrTixLQUFLLFlBQVk7QUFDbkJpL0Isb0JBQVlyaEMsRUFBWixFQUFnQmhVLE9BQWhCLEVBQXlCc0QsTUFBTStuQixPQUEvQjtBQUNELE9BRkQ7QUFHQWpWO0FBQ0E7QUFDQSxVQUFJNEosUUFBUUUsTUFBWixFQUFvQjtBQUNsQjdpQixtQkFBVytZLEVBQVgsRUFBZSxDQUFmO0FBQ0Q7QUFDRixLQVRELE1BU08sSUFBSTlTLE1BQU0rRSxHQUFOLEtBQWMsVUFBZCxJQUE0QjJMLEdBQUdoUyxJQUFILEtBQVksTUFBeEMsSUFBa0RnUyxHQUFHaFMsSUFBSCxLQUFZLFVBQWxFLEVBQThFO0FBQ25GZ1MsU0FBRzI1QixXQUFILEdBQWlCM3RDLFFBQVFxbkMsU0FBekI7QUFDQSxVQUFJLENBQUNybkMsUUFBUXFuQyxTQUFSLENBQWtCdlUsSUFBdkIsRUFBNkI7QUFDM0IsWUFBSSxDQUFDM1MsU0FBTCxFQUFnQjtBQUNkbk0sYUFBR2hCLGdCQUFILENBQW9CLGtCQUFwQixFQUF3Q3NpQyxrQkFBeEM7QUFDQXRoQyxhQUFHaEIsZ0JBQUgsQ0FBb0IsZ0JBQXBCLEVBQXNDdWlDLGdCQUF0QztBQUNEO0FBQ0Q7QUFDQSxZQUFJdDFCLEtBQUosRUFBVztBQUNUak0sYUFBR2toQyxNQUFILEdBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBeEJXO0FBeUJaaE8sb0JBQWtCLFNBQVNBLGdCQUFULENBQTJCbHpCLEVBQTNCLEVBQStCaFUsT0FBL0IsRUFBd0NzRCxLQUF4QyxFQUErQztBQUMvRCxRQUFJQSxNQUFNK0UsR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCZ3RDLGtCQUFZcmhDLEVBQVosRUFBZ0JoVSxPQUFoQixFQUF5QnNELE1BQU0rbkIsT0FBL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUltcUIsWUFBWXhoQyxHQUFHc3NCLFFBQUgsR0FDWnRnQyxRQUFRYSxLQUFSLENBQWNvTSxJQUFkLENBQW1CLFVBQVVrSSxDQUFWLEVBQWE7QUFBRSxlQUFPc2dDLG9CQUFvQnRnQyxDQUFwQixFQUF1Qm5CLEdBQUcvSyxPQUExQixDQUFQO0FBQTRDLE9BQTlFLENBRFksR0FFWmpKLFFBQVFhLEtBQVIsS0FBa0JiLFFBQVF5ekIsUUFBMUIsSUFBc0NnaUIsb0JBQW9CejFDLFFBQVFhLEtBQTVCLEVBQW1DbVQsR0FBRy9LLE9BQXRDLENBRjFDO0FBR0EsVUFBSXVzQyxTQUFKLEVBQWU7QUFDYkwsZ0JBQVFuaEMsRUFBUixFQUFZLFFBQVo7QUFDRDtBQUNGO0FBQ0Y7QUF2Q1csQ0FBZDs7QUEwQ0EsU0FBU3FoQyxXQUFULENBQXNCcmhDLEVBQXRCLEVBQTBCaFUsT0FBMUIsRUFBbUMraUIsRUFBbkMsRUFBdUM7QUFDckMsTUFBSWxpQixRQUFRYixRQUFRYSxLQUFwQjtBQUNBLE1BQUk2MEMsYUFBYTFoQyxHQUFHc3NCLFFBQXBCO0FBQ0EsTUFBSW9WLGNBQWMsQ0FBQ2gzQyxNQUFNbUgsT0FBTixDQUFjaEYsS0FBZCxDQUFuQixFQUF5QztBQUN2Q2hFLFlBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsZ0NBQWlDM0IsUUFBUXd5QixVQUF6QyxHQUF1RCxNQUF2RCxHQUNBLGtEQURBLEdBQ3NEN3hCLE9BQU8zQixTQUFQLENBQWlCcUYsUUFBakIsQ0FBMEIzRyxJQUExQixDQUErQm1ELEtBQS9CLEVBQXNDc0YsS0FBdEMsQ0FBNEMsQ0FBNUMsRUFBK0MsQ0FBQyxDQUFoRCxDQUZmLEVBR3ZDNGMsRUFIdUMsQ0FBekM7QUFLQTtBQUNEO0FBQ0QsTUFBSW9kLFFBQUosRUFBY3dWLE1BQWQ7QUFDQSxPQUFLLElBQUkvMkMsSUFBSSxDQUFSLEVBQVcyZSxJQUFJdkosR0FBRy9LLE9BQUgsQ0FBVy9LLE1BQS9CLEVBQXVDVSxJQUFJMmUsQ0FBM0MsRUFBOEMzZSxHQUE5QyxFQUFtRDtBQUNqRCsyQyxhQUFTM2hDLEdBQUcvSyxPQUFILENBQVdySyxDQUFYLENBQVQ7QUFDQSxRQUFJODJDLFVBQUosRUFBZ0I7QUFDZHZWLGlCQUFXMWhCLGFBQWE1ZCxLQUFiLEVBQW9CKzBDLFNBQVNELE1BQVQsQ0FBcEIsSUFBd0MsQ0FBQyxDQUFwRDtBQUNBLFVBQUlBLE9BQU94VixRQUFQLEtBQW9CQSxRQUF4QixFQUFrQztBQUNoQ3dWLGVBQU94VixRQUFQLEdBQWtCQSxRQUFsQjtBQUNEO0FBQ0YsS0FMRCxNQUtPO0FBQ0wsVUFBSTdoQixXQUFXczNCLFNBQVNELE1BQVQsQ0FBWCxFQUE2QjkwQyxLQUE3QixDQUFKLEVBQXlDO0FBQ3ZDLFlBQUltVCxHQUFHNmhDLGFBQUgsS0FBcUJqM0MsQ0FBekIsRUFBNEI7QUFDMUJvVixhQUFHNmhDLGFBQUgsR0FBbUJqM0MsQ0FBbkI7QUFDRDtBQUNEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsTUFBSSxDQUFDODJDLFVBQUwsRUFBaUI7QUFDZjFoQyxPQUFHNmhDLGFBQUgsR0FBbUIsQ0FBQyxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0osbUJBQVQsQ0FBOEI1MEMsS0FBOUIsRUFBcUNvSSxPQUFyQyxFQUE4QztBQUM1QyxPQUFLLElBQUlySyxJQUFJLENBQVIsRUFBVzJlLElBQUl0VSxRQUFRL0ssTUFBNUIsRUFBb0NVLElBQUkyZSxDQUF4QyxFQUEyQzNlLEdBQTNDLEVBQWdEO0FBQzlDLFFBQUkwZixXQUFXczNCLFNBQVMzc0MsUUFBUXJLLENBQVIsQ0FBVCxDQUFYLEVBQWlDaUMsS0FBakMsQ0FBSixFQUE2QztBQUMzQyxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBUyswQyxRQUFULENBQW1CRCxNQUFuQixFQUEyQjtBQUN6QixTQUFPLFlBQVlBLE1BQVosR0FDSEEsT0FBT3hJLE1BREosR0FFSHdJLE9BQU85MEMsS0FGWDtBQUdEOztBQUVELFNBQVN5MEMsa0JBQVQsQ0FBNkJoNEMsQ0FBN0IsRUFBZ0M7QUFDOUJBLElBQUV1SyxNQUFGLENBQVMwbEMsU0FBVCxHQUFxQixJQUFyQjtBQUNEOztBQUVELFNBQVNnSSxnQkFBVCxDQUEyQmo0QyxDQUEzQixFQUE4QjtBQUM1QkEsSUFBRXVLLE1BQUYsQ0FBUzBsQyxTQUFULEdBQXFCLEtBQXJCO0FBQ0E0SCxVQUFRNzNDLEVBQUV1SyxNQUFWLEVBQWtCLE9BQWxCO0FBQ0Q7O0FBRUQsU0FBU3N0QyxPQUFULENBQWtCbmhDLEVBQWxCLEVBQXNCaFMsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSTFFLElBQUkyVyxTQUFTNmhDLFdBQVQsQ0FBcUIsWUFBckIsQ0FBUjtBQUNBeDRDLElBQUV5NEMsU0FBRixDQUFZL3pDLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEI7QUFDQWdTLEtBQUdnaUMsYUFBSCxDQUFpQjE0QyxDQUFqQjtBQUNEOztBQUVEOztBQUVBO0FBQ0EsU0FBUzI0QyxVQUFULENBQXFCM3lDLEtBQXJCLEVBQTRCO0FBQzFCLFNBQU9BLE1BQU1tb0IsaUJBQU4sS0FBNEIsQ0FBQ25vQixNQUFNZixJQUFQLElBQWUsQ0FBQ2UsTUFBTWYsSUFBTixDQUFXZ2hDLFVBQXZELElBQ0gwUyxXQUFXM3lDLE1BQU1tb0IsaUJBQU4sQ0FBd0J3RSxNQUFuQyxDQURHLEdBRUgzc0IsS0FGSjtBQUdEOztBQUVELElBQUk4d0MsT0FBTztBQUNUNTdCLFFBQU0sU0FBU0EsSUFBVCxDQUFleEUsRUFBZixFQUFtQjVSLEdBQW5CLEVBQXdCa0IsS0FBeEIsRUFBK0I7QUFDbkMsUUFBSXpDLFFBQVF1QixJQUFJdkIsS0FBaEI7O0FBRUF5QyxZQUFRMnlDLFdBQVczeUMsS0FBWCxDQUFSO0FBQ0EsUUFBSWlnQyxhQUFhamdDLE1BQU1mLElBQU4sSUFBY2UsTUFBTWYsSUFBTixDQUFXZ2hDLFVBQTFDO0FBQ0EsUUFBSTJTLGtCQUFrQmxpQyxHQUFHbWlDLGtCQUFILEdBQ3BCbmlDLEdBQUdpNkIsS0FBSCxDQUFTbUksT0FBVCxLQUFxQixNQUFyQixHQUE4QixFQUE5QixHQUFtQ3BpQyxHQUFHaTZCLEtBQUgsQ0FBU21JLE9BRDlDO0FBRUEsUUFBSXYxQyxTQUFTMGlDLFVBQVQsSUFBdUIsQ0FBQ3RqQixLQUE1QixFQUFtQztBQUNqQzNjLFlBQU1mLElBQU4sQ0FBVzZ4QyxJQUFYLEdBQWtCLElBQWxCO0FBQ0EzQixZQUFNbnZDLEtBQU4sRUFBYSxZQUFZO0FBQ3ZCMFEsV0FBR2k2QixLQUFILENBQVNtSSxPQUFULEdBQW1CRixlQUFuQjtBQUNELE9BRkQ7QUFHRCxLQUxELE1BS087QUFDTGxpQyxTQUFHaTZCLEtBQUgsQ0FBU21JLE9BQVQsR0FBbUJ2MUMsUUFBUXExQyxlQUFSLEdBQTBCLE1BQTdDO0FBQ0Q7QUFDRixHQWhCUTs7QUFrQlRseUIsVUFBUSxTQUFTQSxNQUFULENBQWlCaFEsRUFBakIsRUFBcUI1UixHQUFyQixFQUEwQmtCLEtBQTFCLEVBQWlDO0FBQ3ZDLFFBQUl6QyxRQUFRdUIsSUFBSXZCLEtBQWhCO0FBQ0EsUUFBSTR5QixXQUFXcnhCLElBQUlxeEIsUUFBbkI7O0FBRUE7QUFDQSxRQUFJNXlCLFVBQVU0eUIsUUFBZCxFQUF3QjtBQUFFO0FBQVE7QUFDbENud0IsWUFBUTJ5QyxXQUFXM3lDLEtBQVgsQ0FBUjtBQUNBLFFBQUlpZ0MsYUFBYWpnQyxNQUFNZixJQUFOLElBQWNlLE1BQU1mLElBQU4sQ0FBV2doQyxVQUExQztBQUNBLFFBQUlBLGNBQWMsQ0FBQ3RqQixLQUFuQixFQUEwQjtBQUN4QjNjLFlBQU1mLElBQU4sQ0FBVzZ4QyxJQUFYLEdBQWtCLElBQWxCO0FBQ0EsVUFBSXZ6QyxLQUFKLEVBQVc7QUFDVDR4QyxjQUFNbnZDLEtBQU4sRUFBYSxZQUFZO0FBQ3ZCMFEsYUFBR2k2QixLQUFILENBQVNtSSxPQUFULEdBQW1CcGlDLEdBQUdtaUMsa0JBQXRCO0FBQ0QsU0FGRDtBQUdELE9BSkQsTUFJTztBQUNMM0IsY0FBTWx4QyxLQUFOLEVBQWEsWUFBWTtBQUN2QjBRLGFBQUdpNkIsS0FBSCxDQUFTbUksT0FBVCxHQUFtQixNQUFuQjtBQUNELFNBRkQ7QUFHRDtBQUNGLEtBWEQsTUFXTztBQUNMcGlDLFNBQUdpNkIsS0FBSCxDQUFTbUksT0FBVCxHQUFtQnYxQyxRQUFRbVQsR0FBR21pQyxrQkFBWCxHQUFnQyxNQUFuRDtBQUNEO0FBQ0YsR0F4Q1E7O0FBMENURSxVQUFRLFNBQVNBLE1BQVQsQ0FDTnJpQyxFQURNLEVBRU5oVSxPQUZNLEVBR05zRCxLQUhNLEVBSU5JLFFBSk0sRUFLTmdqQyxTQUxNLEVBTU47QUFDQSxRQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZDF5QixTQUFHaTZCLEtBQUgsQ0FBU21JLE9BQVQsR0FBbUJwaUMsR0FBR21pQyxrQkFBdEI7QUFDRDtBQUNGO0FBcERRLENBQVg7O0FBdURBLElBQUlHLHFCQUFxQjtBQUN2QnRmLFNBQU9vZSxPQURnQjtBQUV2QmhCLFFBQU1BO0FBRmlCLENBQXpCOztBQUtBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSW1DLGtCQUFrQjtBQUNwQnQyQyxRQUFNZ0MsTUFEYztBQUVwQmt4QyxVQUFRNXFDLE9BRlk7QUFHcEJxbkMsT0FBS3JuQyxPQUhlO0FBSXBCNlMsUUFBTW5aLE1BSmM7QUFLcEJELFFBQU1DLE1BTGM7QUFNcEI2dEMsY0FBWTd0QyxNQU5RO0FBT3BCZ3VDLGNBQVlodUMsTUFQUTtBQVFwQjh0QyxnQkFBYzl0QyxNQVJNO0FBU3BCaXVDLGdCQUFjanVDLE1BVE07QUFVcEIrdEMsb0JBQWtCL3RDLE1BVkU7QUFXcEJrdUMsb0JBQWtCbHVDLE1BWEU7QUFZcEI0d0MsZUFBYTV3QyxNQVpPO0FBYXBCOHdDLHFCQUFtQjl3QyxNQWJDO0FBY3BCNndDLGlCQUFlN3dDLE1BZEs7QUFlcEJxeEMsWUFBVSxDQUFDZCxNQUFELEVBQVN2d0MsTUFBVCxFQUFpQnRCLE1BQWpCO0FBZlUsQ0FBdEI7O0FBa0JBO0FBQ0E7QUFDQSxTQUFTNjFDLFlBQVQsQ0FBdUJsekMsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSW16QyxjQUFjbnpDLFNBQVNBLE1BQU1nb0IsZ0JBQWpDO0FBQ0EsTUFBSW1yQixlQUFlQSxZQUFZOTFCLElBQVosQ0FBaUIxWCxPQUFqQixDQUF5QmltQixRQUE1QyxFQUFzRDtBQUNwRCxXQUFPc25CLGFBQWEvb0IsdUJBQXVCZ3BCLFlBQVlwMEMsUUFBbkMsQ0FBYixDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT2lCLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNvekMscUJBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0FBQ3BDLE1BQUlwMEMsT0FBTyxFQUFYO0FBQ0EsTUFBSTBHLFVBQVUwdEMsS0FBSzVyQyxRQUFuQjtBQUNBO0FBQ0EsT0FBSyxJQUFJNUYsR0FBVCxJQUFnQjhELFFBQVEwZCxTQUF4QixFQUFtQztBQUNqQ3BrQixTQUFLNEMsR0FBTCxJQUFZd3hDLEtBQUt4eEMsR0FBTCxDQUFaO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsTUFBSTBvQixZQUFZNWtCLFFBQVE2a0IsZ0JBQXhCO0FBQ0EsT0FBSyxJQUFJOG9CLEtBQVQsSUFBa0Ivb0IsU0FBbEIsRUFBNkI7QUFDM0J0ckIsU0FBSzBhLFNBQVMyNUIsS0FBVCxDQUFMLElBQXdCL29CLFVBQVUrb0IsS0FBVixDQUF4QjtBQUNEO0FBQ0QsU0FBT3IwQyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU3MwQyxXQUFULENBQXNCMTBDLENBQXRCLEVBQXlCMjBDLFFBQXpCLEVBQW1DO0FBQ2pDLFNBQU8sa0JBQWlCdnNDLElBQWpCLENBQXNCdXNDLFNBQVN6dUMsR0FBL0IsSUFDSGxHLEVBQUUsWUFBRixDQURHLEdBRUg7QUFGSjtBQUdEOztBQUVELFNBQVM0MEMsbUJBQVQsQ0FBOEJ6ekMsS0FBOUIsRUFBcUM7QUFDbkMsU0FBUUEsUUFBUUEsTUFBTWhCLE1BQXRCLEVBQStCO0FBQzdCLFFBQUlnQixNQUFNZixJQUFOLENBQVdnaEMsVUFBZixFQUEyQjtBQUN6QixhQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU3lULFdBQVQsQ0FBc0J4ekMsS0FBdEIsRUFBNkJ5ekMsUUFBN0IsRUFBdUM7QUFDckMsU0FBT0EsU0FBUzl4QyxHQUFULEtBQWlCM0IsTUFBTTJCLEdBQXZCLElBQThCOHhDLFNBQVM1dUMsR0FBVCxLQUFpQjdFLE1BQU02RSxHQUE1RDtBQUNEOztBQUVELElBQUk2dUMsYUFBYTtBQUNmajNDLFFBQU0sWUFEUztBQUVmOEIsU0FBT3cwQyxlQUZRO0FBR2ZybkIsWUFBVSxJQUhLOztBQUtmaHRCLFVBQVEsU0FBU0EsTUFBVCxDQUFpQkMsQ0FBakIsRUFBb0I7QUFDMUIsUUFBSXdHLFNBQVMsSUFBYjs7QUFFQSxRQUFJdEcsV0FBVyxLQUFLcUgsTUFBTCxDQUFZNUksT0FBM0I7QUFDQSxRQUFJLENBQUN1QixRQUFMLEVBQWU7QUFDYjtBQUNEOztBQUVEO0FBQ0FBLGVBQVdBLFNBQVNnRSxNQUFULENBQWdCLFVBQVVsQyxDQUFWLEVBQWE7QUFBRSxhQUFPQSxFQUFFa0UsR0FBVDtBQUFlLEtBQTlDLENBQVg7QUFDQTtBQUNBLFFBQUksQ0FBQ2hHLFNBQVNuRSxNQUFkLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJckIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUM3QyxTQUFTbkUsTUFBVCxHQUFrQixDQUEvRCxFQUFrRTtBQUNoRXlELFdBQ0UsNERBQ0EsK0JBRkYsRUFHRSxLQUFLcUIsT0FIUDtBQUtEOztBQUVELFFBQUlvWSxPQUFPLEtBQUtBLElBQWhCOztBQUVBO0FBQ0EsUUFBSXZlLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQ0FrVyxJQURBLElBQ1FBLFNBQVMsUUFEakIsSUFDNkJBLFNBQVMsUUFEMUMsRUFDb0Q7QUFDbER6WixXQUNFLGdDQUFnQ3laLElBRGxDLEVBRUUsS0FBS3BZLE9BRlA7QUFJRDs7QUFFRCxRQUFJOHpDLFdBQVd6MEMsU0FBUyxDQUFULENBQWY7O0FBRUE7QUFDQTtBQUNBLFFBQUkwMEMsb0JBQW9CLEtBQUtqMEMsTUFBekIsQ0FBSixFQUFzQztBQUNwQyxhQUFPZzBDLFFBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsUUFBSXR6QyxRQUFRZ3pDLGFBQWFNLFFBQWIsQ0FBWjtBQUNBO0FBQ0EsUUFBSSxDQUFDdHpDLEtBQUwsRUFBWTtBQUNWLGFBQU9zekMsUUFBUDtBQUNEOztBQUVELFFBQUksS0FBS0ssUUFBVCxFQUFtQjtBQUNqQixhQUFPTixZQUFZMTBDLENBQVosRUFBZTIwQyxRQUFmLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFJdHpCLEtBQUssa0JBQW1CLEtBQUt1TixJQUF4QixHQUFnQyxHQUF6QztBQUNBdnRCLFVBQU0yQixHQUFOLEdBQVkzQixNQUFNMkIsR0FBTixJQUFhLElBQWIsR0FDUnFlLEtBQUtoZ0IsTUFBTTZFLEdBREgsR0FFUndVLFlBQVlyWixNQUFNMkIsR0FBbEIsSUFDR2xELE9BQU91QixNQUFNMkIsR0FBYixFQUFrQjJDLE9BQWxCLENBQTBCMGIsRUFBMUIsTUFBa0MsQ0FBbEMsR0FBc0NoZ0IsTUFBTTJCLEdBQTVDLEdBQWtEcWUsS0FBS2hnQixNQUFNMkIsR0FEaEUsR0FFRTNCLE1BQU0yQixHQUpaOztBQU1BLFFBQUk1QyxPQUFPLENBQUNpQixNQUFNakIsSUFBTixLQUFlaUIsTUFBTWpCLElBQU4sR0FBYSxFQUE1QixDQUFELEVBQWtDZ2hDLFVBQWxDLEdBQStDbVQsc0JBQXNCLElBQXRCLENBQTFEO0FBQ0EsUUFBSVUsY0FBYyxLQUFLbm5CLE1BQXZCO0FBQ0EsUUFBSWduQixXQUFXVCxhQUFhWSxXQUFiLENBQWY7O0FBRUE7QUFDQTtBQUNBLFFBQUk1ekMsTUFBTWpCLElBQU4sQ0FBV3lsQixVQUFYLElBQXlCeGtCLE1BQU1qQixJQUFOLENBQVd5bEIsVUFBWCxDQUFzQi9hLElBQXRCLENBQTJCLFVBQVVzcUIsQ0FBVixFQUFhO0FBQUUsYUFBT0EsRUFBRXQzQixJQUFGLEtBQVcsTUFBbEI7QUFBMkIsS0FBckUsQ0FBN0IsRUFBcUc7QUFDbkd1RCxZQUFNakIsSUFBTixDQUFXNnhDLElBQVgsR0FBa0IsSUFBbEI7QUFDRDs7QUFFRCxRQUFJNkMsWUFBWUEsU0FBUzEwQyxJQUFyQixJQUE2QixDQUFDeTBDLFlBQVl4ekMsS0FBWixFQUFtQnl6QyxRQUFuQixDQUFsQyxFQUFnRTtBQUM5RDtBQUNBO0FBQ0EsVUFBSWxQLFVBQVVrUCxhQUFhQSxTQUFTMTBDLElBQVQsQ0FBY2doQyxVQUFkLEdBQTJCMzVCLE9BQU8sRUFBUCxFQUFXckgsSUFBWCxDQUF4QyxDQUFkO0FBQ0E7QUFDQSxVQUFJNlksU0FBUyxRQUFiLEVBQXVCO0FBQ3JCO0FBQ0EsYUFBSys3QixRQUFMLEdBQWdCLElBQWhCO0FBQ0FwcUIsdUJBQWVnYixPQUFmLEVBQXdCLFlBQXhCLEVBQXNDLFlBQVk7QUFDaERwL0IsaUJBQU93dUMsUUFBUCxHQUFrQixLQUFsQjtBQUNBeHVDLGlCQUFPNG5CLFlBQVA7QUFDRCxTQUhEO0FBSUEsZUFBT3NtQixZQUFZMTBDLENBQVosRUFBZTIwQyxRQUFmLENBQVA7QUFDRCxPQVJELE1BUU8sSUFBSTE3QixTQUFTLFFBQWIsRUFBdUI7QUFDNUIsWUFBSWk4QixZQUFKO0FBQ0EsWUFBSXZDLGVBQWUsWUFBWTtBQUFFdUM7QUFBaUIsU0FBbEQ7QUFDQXRxQix1QkFBZXhxQixJQUFmLEVBQXFCLFlBQXJCLEVBQW1DdXlDLFlBQW5DO0FBQ0EvbkIsdUJBQWV4cUIsSUFBZixFQUFxQixnQkFBckIsRUFBdUN1eUMsWUFBdkM7QUFDQS9uQix1QkFBZWdiLE9BQWYsRUFBd0IsWUFBeEIsRUFBc0MsVUFBVXlNLEtBQVYsRUFBaUI7QUFBRTZDLHlCQUFlN0MsS0FBZjtBQUF1QixTQUFoRjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT3NDLFFBQVA7QUFDRDtBQXZHYyxDQUFqQjs7QUEwR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLzBDLFFBQVE2SCxPQUFPO0FBQ2pCdkIsT0FBS3BHLE1BRFk7QUFFakJxMUMsYUFBV3IxQztBQUZNLENBQVAsRUFHVHMwQyxlQUhTLENBQVo7O0FBS0EsT0FBT3gwQyxNQUFNcVosSUFBYjs7QUFFQSxJQUFJbThCLGtCQUFrQjtBQUNwQngxQyxTQUFPQSxLQURhOztBQUdwQkcsVUFBUSxTQUFTQSxNQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUMxQixRQUFJa0csTUFBTSxLQUFLQSxHQUFMLElBQVksS0FBS3ZGLE1BQUwsQ0FBWVAsSUFBWixDQUFpQjhGLEdBQTdCLElBQW9DLE1BQTlDO0FBQ0EsUUFBSXBDLE1BQU10RixPQUFPK0wsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFFBQUk4cUMsZUFBZSxLQUFLQSxZQUFMLEdBQW9CLEtBQUtuMUMsUUFBNUM7QUFDQSxRQUFJbzFDLGNBQWMsS0FBSy90QyxNQUFMLENBQVk1SSxPQUFaLElBQXVCLEVBQXpDO0FBQ0EsUUFBSXVCLFdBQVcsS0FBS0EsUUFBTCxHQUFnQixFQUEvQjtBQUNBLFFBQUlxMUMsaUJBQWlCaEIsc0JBQXNCLElBQXRCLENBQXJCOztBQUVBLFNBQUssSUFBSTkzQyxJQUFJLENBQWIsRUFBZ0JBLElBQUk2NEMsWUFBWXY1QyxNQUFoQyxFQUF3Q1UsR0FBeEMsRUFBNkM7QUFDM0MsVUFBSXVGLElBQUlzekMsWUFBWTc0QyxDQUFaLENBQVI7QUFDQSxVQUFJdUYsRUFBRWtFLEdBQU4sRUFBVztBQUNULFlBQUlsRSxFQUFFZ0IsR0FBRixJQUFTLElBQVQsSUFBaUJsRCxPQUFPa0MsRUFBRWdCLEdBQVQsRUFBYzJDLE9BQWQsQ0FBc0IsU0FBdEIsTUFBcUMsQ0FBMUQsRUFBNkQ7QUFDM0R6RixtQkFBU3hELElBQVQsQ0FBY3NGLENBQWQ7QUFDQThCLGNBQUk5QixFQUFFZ0IsR0FBTixJQUFhaEIsQ0FBYixDQUNDLENBQUNBLEVBQUU1QixJQUFGLEtBQVc0QixFQUFFNUIsSUFBRixHQUFTLEVBQXBCLENBQUQsRUFBMEJnaEMsVUFBMUIsR0FBdUNtVSxjQUF2QztBQUNGLFNBSkQsTUFJTyxJQUFJNzZDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hELGNBQUkwSyxPQUFPekwsRUFBRW1uQixnQkFBYjtBQUNBLGNBQUlyckIsT0FBTzJQLE9BQVFBLEtBQUsrUSxJQUFMLENBQVUxWCxPQUFWLENBQWtCaEosSUFBbEIsSUFBMEIyUCxLQUFLdkgsR0FBL0IsSUFBc0MsRUFBOUMsR0FBb0RsRSxFQUFFa0UsR0FBakU7QUFDQTFHLGVBQU0saURBQWlEMUIsSUFBakQsR0FBd0QsR0FBOUQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSXUzQyxZQUFKLEVBQWtCO0FBQ2hCLFVBQUlHLE9BQU8sRUFBWDtBQUNBLFVBQUlDLFVBQVUsRUFBZDtBQUNBLFdBQUssSUFBSXJwQixNQUFNLENBQWYsRUFBa0JBLE1BQU1pcEIsYUFBYXQ1QyxNQUFyQyxFQUE2Q3F3QixLQUE3QyxFQUFvRDtBQUNsRCxZQUFJc3BCLE1BQU1MLGFBQWFqcEIsR0FBYixDQUFWO0FBQ0FzcEIsWUFBSXQxQyxJQUFKLENBQVNnaEMsVUFBVCxHQUFzQm1VLGNBQXRCO0FBQ0FHLFlBQUl0MUMsSUFBSixDQUFTdTFDLEdBQVQsR0FBZUQsSUFBSXpzQixHQUFKLENBQVF0VyxxQkFBUixFQUFmO0FBQ0EsWUFBSTdPLElBQUk0eEMsSUFBSTF5QyxHQUFSLENBQUosRUFBa0I7QUFDaEJ3eUMsZUFBSzk0QyxJQUFMLENBQVVnNUMsR0FBVjtBQUNELFNBRkQsTUFFTztBQUNMRCxrQkFBUS80QyxJQUFSLENBQWFnNUMsR0FBYjtBQUNEO0FBQ0Y7QUFDRCxXQUFLRixJQUFMLEdBQVl4MUMsRUFBRWtHLEdBQUYsRUFBTyxJQUFQLEVBQWFzdkMsSUFBYixDQUFaO0FBQ0EsV0FBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRUQsV0FBT3oxQyxFQUFFa0csR0FBRixFQUFPLElBQVAsRUFBYWhHLFFBQWIsQ0FBUDtBQUNELEdBNUNtQjs7QUE4Q3BCMDFDLGdCQUFjLFNBQVNBLFlBQVQsR0FBeUI7QUFDckM7QUFDQSxTQUFLNW5CLFNBQUwsQ0FDRSxLQUFLRixNQURQLEVBRUUsS0FBSzBuQixJQUZQLEVBR0UsS0FIRixFQUdTO0FBQ1AsUUFKRixDQUlPO0FBSlA7QUFNQSxTQUFLMW5CLE1BQUwsR0FBYyxLQUFLMG5CLElBQW5CO0FBQ0QsR0F2RG1COztBQXlEcEJ0Z0MsV0FBUyxTQUFTQSxPQUFULEdBQW9CO0FBQzNCLFFBQUloVixXQUFXLEtBQUttMUMsWUFBcEI7QUFDQSxRQUFJRixZQUFZLEtBQUtBLFNBQUwsSUFBbUIsQ0FBQyxLQUFLcjNDLElBQUwsSUFBYSxHQUFkLElBQXFCLE9BQXhEO0FBQ0EsUUFBSSxDQUFDb0MsU0FBU25FLE1BQVYsSUFBb0IsQ0FBQyxLQUFLODVDLE9BQUwsQ0FBYTMxQyxTQUFTLENBQVQsRUFBWStvQixHQUF6QixFQUE4QmtzQixTQUE5QixDQUF6QixFQUFtRTtBQUNqRTtBQUNEOztBQUVEO0FBQ0E7QUFDQWoxQyxhQUFTa0QsT0FBVCxDQUFpQjB5QyxjQUFqQjtBQUNBNTFDLGFBQVNrRCxPQUFULENBQWlCMnlDLGNBQWpCO0FBQ0E3MUMsYUFBU2tELE9BQVQsQ0FBaUI0eUMsZ0JBQWpCOztBQUVBO0FBQ0EsUUFBSUMsT0FBT25rQyxTQUFTbWtDLElBQXBCO0FBQ0EsUUFBSUMsSUFBSUQsS0FBS0UsWUFBYixDQWYyQixDQWVBOztBQUUzQmoyQyxhQUFTa0QsT0FBVCxDQUFpQixVQUFVcEIsQ0FBVixFQUFhO0FBQzVCLFVBQUlBLEVBQUU1QixJQUFGLENBQU9nMkMsS0FBWCxFQUFrQjtBQUNoQixZQUFJdmtDLEtBQUs3UCxFQUFFaW5CLEdBQVg7QUFDQSxZQUFJbW5CLElBQUl2K0IsR0FBR2k2QixLQUFYO0FBQ0FpRCwyQkFBbUJsOUIsRUFBbkIsRUFBdUJzakMsU0FBdkI7QUFDQS9FLFVBQUVpRyxTQUFGLEdBQWNqRyxFQUFFa0csZUFBRixHQUFvQmxHLEVBQUVtRyxrQkFBRixHQUF1QixFQUF6RDtBQUNBMWtDLFdBQUdoQixnQkFBSCxDQUFvQnc5QixrQkFBcEIsRUFBd0N4OEIsR0FBRzJrQyxPQUFILEdBQWEsU0FBU3ZpQyxFQUFULENBQWE5WSxDQUFiLEVBQWdCO0FBQ25FLGNBQUksQ0FBQ0EsQ0FBRCxJQUFNLGFBQWFpTixJQUFiLENBQWtCak4sRUFBRXM3QyxZQUFwQixDQUFWLEVBQTZDO0FBQzNDNWtDLGVBQUcrNEIsbUJBQUgsQ0FBdUJ5RCxrQkFBdkIsRUFBMkNwNkIsRUFBM0M7QUFDQXBDLGVBQUcya0MsT0FBSCxHQUFhLElBQWI7QUFDQXhILGtDQUFzQm45QixFQUF0QixFQUEwQnNqQyxTQUExQjtBQUNEO0FBQ0YsU0FORDtBQU9EO0FBQ0YsS0FkRDtBQWVELEdBekZtQjs7QUEyRnBCN3ZCLFdBQVM7QUFDUHV3QixhQUFTLFNBQVNBLE9BQVQsQ0FBa0Joa0MsRUFBbEIsRUFBc0JzakMsU0FBdEIsRUFBaUM7QUFDeEM7QUFDQSxVQUFJLENBQUNsSCxhQUFMLEVBQW9CO0FBQ2xCLGVBQU8sS0FBUDtBQUNEO0FBQ0QsVUFBSSxLQUFLeUksUUFBTCxJQUFpQixJQUFyQixFQUEyQjtBQUN6QixlQUFPLEtBQUtBLFFBQVo7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJQyxRQUFROWtDLEdBQUcra0MsU0FBSCxFQUFaO0FBQ0EsVUFBSS9rQyxHQUFHazBCLGtCQUFQLEVBQTJCO0FBQ3pCbDBCLFdBQUdrMEIsa0JBQUgsQ0FBc0IzaUMsT0FBdEIsQ0FBOEIsVUFBVXlpQyxHQUFWLEVBQWU7QUFBRXdILHNCQUFZc0osS0FBWixFQUFtQjlRLEdBQW5CO0FBQTBCLFNBQXpFO0FBQ0Q7QUFDRHNILGVBQVN3SixLQUFULEVBQWdCeEIsU0FBaEI7QUFDQXdCLFlBQU03SyxLQUFOLENBQVltSSxPQUFaLEdBQXNCLE1BQXRCO0FBQ0EsV0FBS3JtQixHQUFMLENBQVNnUixXQUFULENBQXFCK1gsS0FBckI7QUFDQSxVQUFJaHZCLE9BQU91bkIsa0JBQWtCeUgsS0FBbEIsQ0FBWDtBQUNBLFdBQUsvb0IsR0FBTCxDQUFTK1EsV0FBVCxDQUFxQmdZLEtBQXJCO0FBQ0EsYUFBUSxLQUFLRCxRQUFMLEdBQWdCL3VCLEtBQUtxb0IsWUFBN0I7QUFDRDtBQXhCTTtBQTNGVyxDQUF0Qjs7QUF1SEEsU0FBUzhGLGNBQVQsQ0FBeUI5ekMsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxNQUFJQSxFQUFFaW5CLEdBQUYsQ0FBTXV0QixPQUFWLEVBQW1CO0FBQ2pCeDBDLE1BQUVpbkIsR0FBRixDQUFNdXRCLE9BQU47QUFDRDtBQUNEO0FBQ0EsTUFBSXgwQyxFQUFFaW5CLEdBQUYsQ0FBTXduQixRQUFWLEVBQW9CO0FBQ2xCenVDLE1BQUVpbkIsR0FBRixDQUFNd25CLFFBQU47QUFDRDtBQUNGOztBQUVELFNBQVNzRixjQUFULENBQXlCL3pDLENBQXpCLEVBQTRCO0FBQzFCQSxJQUFFNUIsSUFBRixDQUFPeTJDLE1BQVAsR0FBZ0I3MEMsRUFBRWluQixHQUFGLENBQU10VyxxQkFBTixFQUFoQjtBQUNEOztBQUVELFNBQVNxakMsZ0JBQVQsQ0FBMkJoMEMsQ0FBM0IsRUFBOEI7QUFDNUIsTUFBSTgwQyxTQUFTOTBDLEVBQUU1QixJQUFGLENBQU91MUMsR0FBcEI7QUFDQSxNQUFJa0IsU0FBUzcwQyxFQUFFNUIsSUFBRixDQUFPeTJDLE1BQXBCO0FBQ0EsTUFBSUUsS0FBS0QsT0FBT2prQyxJQUFQLEdBQWNna0MsT0FBT2hrQyxJQUE5QjtBQUNBLE1BQUlta0MsS0FBS0YsT0FBT2hrQyxHQUFQLEdBQWErakMsT0FBTy9qQyxHQUE3QjtBQUNBLE1BQUlpa0MsTUFBTUMsRUFBVixFQUFjO0FBQ1poMUMsTUFBRTVCLElBQUYsQ0FBT2cyQyxLQUFQLEdBQWUsSUFBZjtBQUNBLFFBQUloRyxJQUFJcHVDLEVBQUVpbkIsR0FBRixDQUFNNmlCLEtBQWQ7QUFDQXNFLE1BQUVpRyxTQUFGLEdBQWNqRyxFQUFFa0csZUFBRixHQUFvQixlQUFlUyxFQUFmLEdBQW9CLEtBQXBCLEdBQTRCQyxFQUE1QixHQUFpQyxLQUFuRTtBQUNBNUcsTUFBRW1HLGtCQUFGLEdBQXVCLElBQXZCO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJVSxxQkFBcUI7QUFDdkJsQyxjQUFZQSxVQURXO0FBRXZCSyxtQkFBaUJBO0FBRk0sQ0FBekI7O0FBS0E7O0FBRUE7QUFDQWx2QixNQUFNdmtCLE1BQU4sQ0FBYXNiLFdBQWIsR0FBMkJBLFdBQTNCO0FBQ0FpSixNQUFNdmtCLE1BQU4sQ0FBYWtiLGFBQWIsR0FBNkJBLGFBQTdCO0FBQ0FxSixNQUFNdmtCLE1BQU4sQ0FBYW9iLGVBQWIsR0FBK0JBLGVBQS9CO0FBQ0FtSixNQUFNdmtCLE1BQU4sQ0FBYW1iLGdCQUFiLEdBQWdDQSxnQkFBaEM7O0FBRUE7QUFDQXJWLE9BQU95ZSxNQUFNcGYsT0FBTixDQUFjK2UsVUFBckIsRUFBaUNzdUIsa0JBQWpDO0FBQ0Exc0MsT0FBT3llLE1BQU1wZixPQUFOLENBQWMvRixVQUFyQixFQUFpQ2syQyxrQkFBakM7O0FBRUE7QUFDQS93QixNQUFNcnBCLFNBQU4sQ0FBZ0JteEIsU0FBaEIsR0FBNEI1a0IsWUFBWXc2QixLQUFaLEdBQW9Cdm1DLElBQWhEOztBQUVBO0FBQ0E2b0IsTUFBTXJwQixTQUFOLENBQWdCcTNCLE1BQWhCLEdBQXlCLFVBQ3ZCcmlCLEVBRHVCLEVBRXZCNGIsU0FGdUIsRUFHdkI7QUFDQTViLE9BQUtBLE1BQU16SSxTQUFOLEdBQWtCekcsTUFBTWtQLEVBQU4sQ0FBbEIsR0FBOEJwUSxTQUFuQztBQUNBLFNBQU9ndEIsZUFBZSxJQUFmLEVBQXFCNWMsRUFBckIsRUFBeUI0YixTQUF6QixDQUFQO0FBQ0QsQ0FORDs7QUFRQTtBQUNBO0FBQ0F2eUIsV0FBVyxZQUFZO0FBQ3JCLE1BQUl5RyxPQUFPOGEsUUFBWCxFQUFxQjtBQUNuQixRQUFJQSxRQUFKLEVBQWM7QUFDWkEsZUFBUzdlLElBQVQsQ0FBYyxNQUFkLEVBQXNCc29CLEtBQXRCO0FBQ0QsS0FGRCxNQUVPLElBQUl4ckIsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNtYixRQUE3QyxFQUF1RDtBQUM1RHplLGNBQVFBLFFBQVFrb0IsSUFBUixHQUFlLE1BQWYsR0FBd0IsS0FBaEMsRUFDRSwrRUFDQSx1Q0FGRjtBQUlEO0FBQ0Y7QUFDRCxNQUFJanRCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQ0FwQixPQUFPNmEsYUFBUCxLQUF5QixLQUR6QixJQUVBcFQsU0FGQSxJQUVhLE9BQU8zSixPQUFQLEtBQW1CLFdBRnBDLEVBRWlEO0FBQy9DQSxZQUFRQSxRQUFRa29CLElBQVIsR0FBZSxNQUFmLEdBQXdCLEtBQWhDLEVBQ0UsK0NBQ0EsdUVBREEsR0FFQSwwREFIRjtBQUtEO0FBQ0YsQ0FwQkQsRUFvQkcsQ0FwQkg7O0FBc0JBOztBQUVBO0FBQ0EsU0FBU3V2QixZQUFULENBQXVCQyxPQUF2QixFQUFnQ0MsT0FBaEMsRUFBeUM7QUFDdkMsTUFBSUMsTUFBTXZsQyxTQUFTdWpCLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjtBQUNBZ2lCLE1BQUlDLFNBQUosR0FBZ0IsY0FBY0gsT0FBZCxHQUF3QixLQUF4QztBQUNBLFNBQU9FLElBQUlDLFNBQUosQ0FBYzN4QyxPQUFkLENBQXNCeXhDLE9BQXRCLElBQWlDLENBQXhDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLElBQUlHLHVCQUF1Qm51QyxZQUFZOHRDLGFBQWEsSUFBYixFQUFtQixPQUFuQixDQUFaLEdBQTBDLEtBQXJFOztBQUVBOztBQUVBLElBQUlNLGFBQWF2OUIsUUFDZiw4REFDQSxrQ0FGZSxDQUFqQjs7QUFLQTtBQUNBO0FBQ0EsSUFBSXc5QixtQkFBbUJ4OUIsUUFDckIseURBRHFCLENBQXZCOztBQUlBO0FBQ0E7QUFDQSxJQUFJeTlCLG1CQUFtQno5QixRQUNyQix3RUFDQSxrRUFEQSxHQUVBLHVFQUZBLEdBR0EsMkVBSEEsR0FJQSxnQkFMcUIsQ0FBdkI7O0FBUUE7O0FBRUEsSUFBSTA5QixPQUFKOztBQUVBLFNBQVNuMUMsTUFBVCxDQUFpQm8xQyxJQUFqQixFQUF1QjtBQUNyQkQsWUFBVUEsV0FBVzdsQyxTQUFTdWpCLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBckI7QUFDQXNpQixVQUFRTCxTQUFSLEdBQW9CTSxJQUFwQjtBQUNBLFNBQU9ELFFBQVE1WSxXQUFmO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7Ozs7OztBQU9BO0FBQ0EsSUFBSThZLHVCQUF1QixnQkFBM0I7QUFDQSxJQUFJQyxtQkFBbUIsT0FBdkI7QUFDQSxJQUFJQyxtQkFBbUI7QUFDckI7QUFDQSxhQUFhenBDLE1BRlE7QUFHckI7QUFDQSxhQUFhQSxNQUpRO0FBS3JCO0FBQ0EsaUJBQWlCQSxNQU5JLENBQXZCO0FBUUEsSUFBSTBwQyxZQUFZLElBQUlqc0MsTUFBSixDQUNkLFVBQVU4ckMscUJBQXFCdnBDLE1BQS9CLEdBQ0EsVUFEQSxHQUNhd3BDLGlCQUFpQnhwQyxNQUQ5QixHQUN1QyxHQUR2QyxHQUVBLFNBRkEsR0FFWXlwQyxpQkFBaUJ0MEMsSUFBakIsQ0FBc0IsR0FBdEIsQ0FGWixHQUV5QyxLQUgzQixDQUFoQjs7QUFNQTtBQUNBO0FBQ0EsSUFBSXcwQyxTQUFTLHVCQUFiO0FBQ0EsSUFBSUMsZUFBZSxTQUFTRCxNQUFULEdBQWtCLE9BQWxCLEdBQTRCQSxNQUE1QixHQUFxQyxHQUF4RDtBQUNBLElBQUlFLGVBQWUsSUFBSXBzQyxNQUFKLENBQVcsT0FBT21zQyxZQUFsQixDQUFuQjtBQUNBLElBQUlFLGdCQUFnQixZQUFwQjtBQUNBLElBQUl0dkIsU0FBUyxJQUFJL2MsTUFBSixDQUFXLFVBQVVtc0MsWUFBVixHQUF5QixRQUFwQyxDQUFiO0FBQ0EsSUFBSUcsVUFBVSxvQkFBZDtBQUNBLElBQUlDLFVBQVUsT0FBZDtBQUNBLElBQUlDLHFCQUFxQixPQUF6Qjs7QUFFQSxJQUFJQyw0QkFBNEIsS0FBaEM7QUFDQSxJQUFJajJDLE9BQUosQ0FBWSxRQUFaLEVBQXNCLFVBQVU2SixDQUFWLEVBQWFxc0MsQ0FBYixFQUFnQjtBQUNwQ0QsOEJBQTRCQyxNQUFNLEVBQWxDO0FBQ0QsQ0FGRDs7QUFJQTtBQUNBLElBQUlDLHFCQUFxQnorQixRQUFRLHVCQUFSLEVBQWlDLElBQWpDLENBQXpCO0FBQ0EsSUFBSTArQixVQUFVLEVBQWQ7O0FBRUEsSUFBSUMsY0FBYztBQUNoQixVQUFRLEdBRFE7QUFFaEIsVUFBUSxHQUZRO0FBR2hCLFlBQVUsR0FITTtBQUloQixXQUFTLEdBSk87QUFLaEIsV0FBUztBQUxPLENBQWxCO0FBT0EsSUFBSUMsY0FBYyx1QkFBbEI7QUFDQSxJQUFJQywwQkFBMEIsMkJBQTlCOztBQUVBLFNBQVNDLFVBQVQsQ0FBcUJyNkMsS0FBckIsRUFBNEI2NEMsb0JBQTVCLEVBQWtEO0FBQ2hELE1BQUl0cEMsS0FBS3NwQyx1QkFBdUJ1Qix1QkFBdkIsR0FBaURELFdBQTFEO0FBQ0EsU0FBT242QyxNQUFNNkQsT0FBTixDQUFjMEwsRUFBZCxFQUFrQixVQUFVTSxLQUFWLEVBQWlCO0FBQUUsV0FBT3FxQyxZQUFZcnFDLEtBQVosQ0FBUDtBQUE0QixHQUFqRSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3lxQyxTQUFULENBQW9CcEIsSUFBcEIsRUFBMEI5d0MsT0FBMUIsRUFBbUM7QUFDakMsTUFBSTRDLFFBQVEsRUFBWjtBQUNBLE1BQUl1dkMsYUFBYW55QyxRQUFRbXlDLFVBQXpCO0FBQ0EsTUFBSUMsZ0JBQWdCcHlDLFFBQVEwd0MsVUFBUixJQUFzQjM3QixFQUExQztBQUNBLE1BQUlzOUIsc0JBQXNCcnlDLFFBQVEyd0MsZ0JBQVIsSUFBNEI1N0IsRUFBdEQ7QUFDQSxNQUFJdGQsUUFBUSxDQUFaO0FBQ0EsTUFBSThzQixJQUFKLEVBQVUrdEIsT0FBVjtBQUNBLFNBQU94QixJQUFQLEVBQWE7QUFDWHZzQixXQUFPdXNCLElBQVA7QUFDQTtBQUNBLFFBQUksQ0FBQ3dCLE9BQUQsSUFBWSxDQUFDVixtQkFBbUJVLE9BQW5CLENBQWpCLEVBQThDO0FBQzVDLFVBQUlDLFVBQVV6QixLQUFLanlDLE9BQUwsQ0FBYSxHQUFiLENBQWQ7QUFDQSxVQUFJMHpDLFlBQVksQ0FBaEIsRUFBbUI7QUFDakI7QUFDQSxZQUFJZixRQUFRbHdDLElBQVIsQ0FBYXd2QyxJQUFiLENBQUosRUFBd0I7QUFDdEIsY0FBSTBCLGFBQWExQixLQUFLanlDLE9BQUwsQ0FBYSxLQUFiLENBQWpCOztBQUVBLGNBQUkyekMsY0FBYyxDQUFsQixFQUFxQjtBQUNuQkMsb0JBQVFELGFBQWEsQ0FBckI7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxZQUFJZixtQkFBbUJud0MsSUFBbkIsQ0FBd0J3dkMsSUFBeEIsQ0FBSixFQUFtQztBQUNqQyxjQUFJNEIsaUJBQWlCNUIsS0FBS2p5QyxPQUFMLENBQWEsSUFBYixDQUFyQjs7QUFFQSxjQUFJNnpDLGtCQUFrQixDQUF0QixFQUF5QjtBQUN2QkQsb0JBQVFDLGlCQUFpQixDQUF6QjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFlBQUlDLGVBQWU3QixLQUFLcnBDLEtBQUwsQ0FBVzhwQyxPQUFYLENBQW5CO0FBQ0EsWUFBSW9CLFlBQUosRUFBa0I7QUFDaEJGLGtCQUFRRSxhQUFhLENBQWIsRUFBZ0IxOUMsTUFBeEI7QUFDQTtBQUNEOztBQUVEO0FBQ0EsWUFBSTI5QyxjQUFjOUIsS0FBS3JwQyxLQUFMLENBQVd1YSxNQUFYLENBQWxCO0FBQ0EsWUFBSTR3QixXQUFKLEVBQWlCO0FBQ2YsY0FBSUMsV0FBV3A3QyxLQUFmO0FBQ0FnN0Msa0JBQVFHLFlBQVksQ0FBWixFQUFlMzlDLE1BQXZCO0FBQ0E2OUMsc0JBQVlGLFlBQVksQ0FBWixDQUFaLEVBQTRCQyxRQUE1QixFQUFzQ3A3QyxLQUF0QztBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJczdDLGdCQUFnQkMsZUFBcEI7QUFDQSxZQUFJRCxhQUFKLEVBQW1CO0FBQ2pCRSx5QkFBZUYsYUFBZjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJN3dCLE9BQVEsS0FBSyxDQUFqQjtBQUFBLFVBQXFCZ3hCLFNBQVUsS0FBSyxDQUFwQztBQUFBLFVBQXdDenRDLE9BQVEsS0FBSyxDQUFyRDtBQUNBLFVBQUk4c0MsV0FBVyxDQUFmLEVBQWtCO0FBQ2hCVyxpQkFBU3BDLEtBQUs1ekMsS0FBTCxDQUFXcTFDLE9BQVgsQ0FBVDtBQUNBLGVBQ0UsQ0FBQ3Z3QixPQUFPMWdCLElBQVAsQ0FBWTR4QyxNQUFaLENBQUQsSUFDQSxDQUFDN0IsYUFBYS92QyxJQUFiLENBQWtCNHhDLE1BQWxCLENBREQsSUFFQSxDQUFDMUIsUUFBUWx3QyxJQUFSLENBQWE0eEMsTUFBYixDQUZELElBR0EsQ0FBQ3pCLG1CQUFtQm53QyxJQUFuQixDQUF3QjR4QyxNQUF4QixDQUpILEVBS0U7QUFDQTtBQUNBenRDLGlCQUFPeXRDLE9BQU9yMEMsT0FBUCxDQUFlLEdBQWYsRUFBb0IsQ0FBcEIsQ0FBUDtBQUNBLGNBQUk0RyxPQUFPLENBQVgsRUFBYztBQUFFO0FBQU87QUFDdkI4c0MscUJBQVc5c0MsSUFBWDtBQUNBeXRDLG1CQUFTcEMsS0FBSzV6QyxLQUFMLENBQVdxMUMsT0FBWCxDQUFUO0FBQ0Q7QUFDRHJ3QixlQUFPNHVCLEtBQUt4TyxTQUFMLENBQWUsQ0FBZixFQUFrQmlRLE9BQWxCLENBQVA7QUFDQUUsZ0JBQVFGLE9BQVI7QUFDRDs7QUFFRCxVQUFJQSxVQUFVLENBQWQsRUFBaUI7QUFDZnJ3QixlQUFPNHVCLElBQVA7QUFDQUEsZUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBSTl3QyxRQUFRbXpDLEtBQVIsSUFBaUJqeEIsSUFBckIsRUFBMkI7QUFDekJsaUIsZ0JBQVFtekMsS0FBUixDQUFjanhCLElBQWQ7QUFDRDtBQUNGLEtBMUVELE1BMEVPO0FBQ0wsVUFBSWt4QixhQUFhZCxRQUFRaC9CLFdBQVIsRUFBakI7QUFDQSxVQUFJKy9CLGVBQWV4QixRQUFRdUIsVUFBUixNQUF3QnZCLFFBQVF1QixVQUFSLElBQXNCLElBQUludUMsTUFBSixDQUFXLG9CQUFvQm11QyxVQUFwQixHQUFpQyxTQUE1QyxFQUF1RCxHQUF2RCxDQUE5QyxDQUFuQjtBQUNBLFVBQUlFLGVBQWUsQ0FBbkI7QUFDQSxVQUFJQyxPQUFPekMsS0FBS3IxQyxPQUFMLENBQWE0M0MsWUFBYixFQUEyQixVQUFVRyxHQUFWLEVBQWV0eEIsSUFBZixFQUFxQkYsTUFBckIsRUFBNkI7QUFDakVzeEIsdUJBQWV0eEIsT0FBTy9zQixNQUF0QjtBQUNBLFlBQUksQ0FBQzI4QyxtQkFBbUJ3QixVQUFuQixDQUFELElBQW1DQSxlQUFlLFVBQXRELEVBQWtFO0FBQ2hFbHhCLGlCQUFPQSxLQUNKem1CLE9BREksQ0FDSSxvQkFESixFQUMwQixJQUQxQixFQUVKQSxPQUZJLENBRUksMkJBRkosRUFFaUMsSUFGakMsQ0FBUDtBQUdEO0FBQ0QsWUFBSXVFLFFBQVFtekMsS0FBWixFQUFtQjtBQUNqQm56QyxrQkFBUW16QyxLQUFSLENBQWNqeEIsSUFBZDtBQUNEO0FBQ0QsZUFBTyxFQUFQO0FBQ0QsT0FYVSxDQUFYO0FBWUF6cUIsZUFBU3E1QyxLQUFLNzdDLE1BQUwsR0FBY3MrQyxLQUFLdCtDLE1BQTVCO0FBQ0E2N0MsYUFBT3lDLElBQVA7QUFDQVQsa0JBQVlNLFVBQVosRUFBd0IzN0MsUUFBUTY3QyxZQUFoQyxFQUE4Qzc3QyxLQUE5QztBQUNEOztBQUVELFFBQUlxNUMsU0FBU3ZzQixJQUFiLEVBQW1CO0FBQ2pCdmtCLGNBQVFtekMsS0FBUixJQUFpQm56QyxRQUFRbXpDLEtBQVIsQ0FBY3JDLElBQWQsQ0FBakI7QUFDQSxVQUFJbDlDLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDLENBQUMyRyxNQUFNM04sTUFBaEQsSUFBMEQrSyxRQUFRdEgsSUFBdEUsRUFBNEU7QUFDMUVzSCxnQkFBUXRILElBQVIsQ0FBYyw2Q0FBNkNvNEMsSUFBN0MsR0FBb0QsSUFBbEU7QUFDRDtBQUNEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBZ0M7O0FBRUEsV0FBU0wsT0FBVCxDQUFrQnRoQyxDQUFsQixFQUFxQjtBQUNuQjFaLGFBQVMwWixDQUFUO0FBQ0EyL0IsV0FBT0EsS0FBS3hPLFNBQUwsQ0FBZW54QixDQUFmLENBQVA7QUFDRDs7QUFFRCxXQUFTNmhDLGFBQVQsR0FBMEI7QUFDeEIsUUFBSXYrQixRQUFRcThCLEtBQUtycEMsS0FBTCxDQUFXNHBDLFlBQVgsQ0FBWjtBQUNBLFFBQUk1OEIsS0FBSixFQUFXO0FBQ1QsVUFBSWhOLFFBQVE7QUFDVjJ2QixpQkFBUzNpQixNQUFNLENBQU4sQ0FEQztBQUVWbFUsZUFBTyxFQUZHO0FBR1ZrVSxlQUFPaGQ7QUFIRyxPQUFaO0FBS0FnN0MsY0FBUWgrQixNQUFNLENBQU4sRUFBU3hmLE1BQWpCO0FBQ0EsVUFBSTZTLEdBQUosRUFBUzJ0QixJQUFUO0FBQ0EsYUFBTyxFQUFFM3RCLE1BQU1ncEMsS0FBS3JwQyxLQUFMLENBQVc2cEMsYUFBWCxDQUFSLE1BQXVDN2IsT0FBT3FiLEtBQUtycEMsS0FBTCxDQUFXeXBDLFNBQVgsQ0FBOUMsQ0FBUCxFQUE2RTtBQUMzRXVCLGdCQUFRaGQsS0FBSyxDQUFMLEVBQVF4Z0MsTUFBaEI7QUFDQXdTLGNBQU1sSCxLQUFOLENBQVkzSyxJQUFaLENBQWlCNi9CLElBQWpCO0FBQ0Q7QUFDRCxVQUFJM3RCLEdBQUosRUFBUztBQUNQTCxjQUFNZ3NDLFVBQU4sR0FBbUIzckMsSUFBSSxDQUFKLENBQW5CO0FBQ0EycUMsZ0JBQVEzcUMsSUFBSSxDQUFKLEVBQU83UyxNQUFmO0FBQ0F3UyxjQUFNSyxHQUFOLEdBQVlyUSxLQUFaO0FBQ0EsZUFBT2dRLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBU3dyQyxjQUFULENBQXlCeHJDLEtBQXpCLEVBQWdDO0FBQzlCLFFBQUkydkIsVUFBVTN2QixNQUFNMnZCLE9BQXBCO0FBQ0EsUUFBSXFjLGFBQWFoc0MsTUFBTWdzQyxVQUF2Qjs7QUFFQSxRQUFJdEIsVUFBSixFQUFnQjtBQUNkLFVBQUlHLFlBQVksR0FBWixJQUFtQjFCLGlCQUFpQnhaLE9BQWpCLENBQXZCLEVBQWtEO0FBQ2hEMGIsb0JBQVlSLE9BQVo7QUFDRDtBQUNELFVBQUlELG9CQUFvQmpiLE9BQXBCLEtBQWdDa2IsWUFBWWxiLE9BQWhELEVBQXlEO0FBQ3ZEMGIsb0JBQVkxYixPQUFaO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJc2MsUUFBUXRCLGNBQWNoYixPQUFkLEtBQTBCQSxZQUFZLE1BQVosSUFBc0JrYixZQUFZLE1BQTVELElBQXNFLENBQUMsQ0FBQ21CLFVBQXBGOztBQUVBLFFBQUluL0IsSUFBSTdNLE1BQU1sSCxLQUFOLENBQVl0TCxNQUFwQjtBQUNBLFFBQUlzTCxRQUFRLElBQUk5SyxLQUFKLENBQVU2ZSxDQUFWLENBQVo7QUFDQSxTQUFLLElBQUkzZSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyZSxDQUFwQixFQUF1QjNlLEdBQXZCLEVBQTRCO0FBQzFCLFVBQUlILE9BQU9pUyxNQUFNbEgsS0FBTixDQUFZNUssQ0FBWixDQUFYO0FBQ0E7QUFDQSxVQUFJKzdDLDZCQUE2Qmw4QyxLQUFLLENBQUwsRUFBUXFKLE9BQVIsQ0FBZ0IsSUFBaEIsTUFBMEIsQ0FBQyxDQUE1RCxFQUErRDtBQUM3RCxZQUFJckosS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxpQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsWUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxpQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsWUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxpQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDeEM7QUFDRCxVQUFJb0MsUUFBUXBDLEtBQUssQ0FBTCxLQUFXQSxLQUFLLENBQUwsQ0FBWCxJQUFzQkEsS0FBSyxDQUFMLENBQXRCLElBQWlDLEVBQTdDO0FBQ0ErSyxZQUFNNUssQ0FBTixJQUFXO0FBQ1RxQixjQUFNeEIsS0FBSyxDQUFMLENBREc7QUFFVG9DLGVBQU9xNkMsV0FDTHI2QyxLQURLLEVBRUxvSSxRQUFReXdDLG9CQUZIO0FBRkUsT0FBWDtBQU9EOztBQUVELFFBQUksQ0FBQ2lELEtBQUwsRUFBWTtBQUNWOXdDLFlBQU1oTixJQUFOLENBQVcsRUFBRXdKLEtBQUtnNEIsT0FBUCxFQUFnQnVjLGVBQWV2YyxRQUFROWpCLFdBQVIsRUFBL0IsRUFBc0QvUyxPQUFPQSxLQUE3RCxFQUFYO0FBQ0EreEMsZ0JBQVVsYixPQUFWO0FBQ0Q7O0FBRUQsUUFBSXAzQixRQUFReVUsS0FBWixFQUFtQjtBQUNqQnpVLGNBQVF5VSxLQUFSLENBQWMyaUIsT0FBZCxFQUF1QjcyQixLQUF2QixFQUE4Qm16QyxLQUE5QixFQUFxQ2pzQyxNQUFNZ04sS0FBM0MsRUFBa0RoTixNQUFNSyxHQUF4RDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2dyQyxXQUFULENBQXNCMWIsT0FBdEIsRUFBK0IzaUIsS0FBL0IsRUFBc0MzTSxHQUF0QyxFQUEyQztBQUN6QyxRQUFJK21DLEdBQUosRUFBUytFLGlCQUFUO0FBQ0EsUUFBSW4vQixTQUFTLElBQWIsRUFBbUI7QUFBRUEsY0FBUWhkLEtBQVI7QUFBZ0I7QUFDckMsUUFBSXFRLE9BQU8sSUFBWCxFQUFpQjtBQUFFQSxZQUFNclEsS0FBTjtBQUFjOztBQUVqQyxRQUFJMi9CLE9BQUosRUFBYTtBQUNYd2MsMEJBQW9CeGMsUUFBUTlqQixXQUFSLEVBQXBCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJOGpCLE9BQUosRUFBYTtBQUNYLFdBQUt5WCxNQUFNanNDLE1BQU0zTixNQUFOLEdBQWUsQ0FBMUIsRUFBNkI0NUMsT0FBTyxDQUFwQyxFQUF1Q0EsS0FBdkMsRUFBOEM7QUFDNUMsWUFBSWpzQyxNQUFNaXNDLEdBQU4sRUFBVzhFLGFBQVgsS0FBNkJDLGlCQUFqQyxFQUFvRDtBQUNsRDtBQUNEO0FBQ0Y7QUFDRixLQU5ELE1BTU87QUFDTDtBQUNBL0UsWUFBTSxDQUFOO0FBQ0Q7O0FBRUQsUUFBSUEsT0FBTyxDQUFYLEVBQWM7QUFDWjtBQUNBLFdBQUssSUFBSWw1QyxJQUFJaU4sTUFBTTNOLE1BQU4sR0FBZSxDQUE1QixFQUErQlUsS0FBS2s1QyxHQUFwQyxFQUF5Q2w1QyxHQUF6QyxFQUE4QztBQUM1QyxZQUFJL0IsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsS0FDQ3RHLElBQUlrNUMsR0FBSixJQUFXLENBQUN6WCxPQURiLEtBRUFwM0IsUUFBUXRILElBRlosRUFFa0I7QUFDaEJzSCxrQkFBUXRILElBQVIsQ0FDRyxVQUFXa0ssTUFBTWpOLENBQU4sRUFBU3lKLEdBQXBCLEdBQTJCLDRCQUQ5QjtBQUdEO0FBQ0QsWUFBSVksUUFBUThILEdBQVosRUFBaUI7QUFDZjlILGtCQUFROEgsR0FBUixDQUFZbEYsTUFBTWpOLENBQU4sRUFBU3lKLEdBQXJCLEVBQTBCcVYsS0FBMUIsRUFBaUMzTSxHQUFqQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQWxGLFlBQU0zTixNQUFOLEdBQWU0NUMsR0FBZjtBQUNBeUQsZ0JBQVV6RCxPQUFPanNDLE1BQU1pc0MsTUFBTSxDQUFaLEVBQWV6dkMsR0FBaEM7QUFDRCxLQWxCRCxNQWtCTyxJQUFJdzBDLHNCQUFzQixJQUExQixFQUFnQztBQUNyQyxVQUFJNXpDLFFBQVF5VSxLQUFaLEVBQW1CO0FBQ2pCelUsZ0JBQVF5VSxLQUFSLENBQWMyaUIsT0FBZCxFQUF1QixFQUF2QixFQUEyQixJQUEzQixFQUFpQzNpQixLQUFqQyxFQUF3QzNNLEdBQXhDO0FBQ0Q7QUFDRixLQUpNLE1BSUEsSUFBSThyQyxzQkFBc0IsR0FBMUIsRUFBK0I7QUFDcEMsVUFBSTV6QyxRQUFReVUsS0FBWixFQUFtQjtBQUNqQnpVLGdCQUFReVUsS0FBUixDQUFjMmlCLE9BQWQsRUFBdUIsRUFBdkIsRUFBMkIsS0FBM0IsRUFBa0MzaUIsS0FBbEMsRUFBeUMzTSxHQUF6QztBQUNEO0FBQ0QsVUFBSTlILFFBQVE4SCxHQUFaLEVBQWlCO0FBQ2Y5SCxnQkFBUThILEdBQVIsQ0FBWXN2QixPQUFaLEVBQXFCM2lCLEtBQXJCLEVBQTRCM00sR0FBNUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxJQUFJK3JDLGVBQWUsdUJBQW5CO0FBQ0EsSUFBSUMsZ0JBQWdCLHdCQUFwQjs7QUFFQSxJQUFJQyxhQUFhbGdDLE9BQU8sVUFBVW1nQyxVQUFWLEVBQXNCO0FBQzVDLE1BQUlDLE9BQU9ELFdBQVcsQ0FBWCxFQUFjdjRDLE9BQWQsQ0FBc0JxNEMsYUFBdEIsRUFBcUMsTUFBckMsQ0FBWDtBQUNBLE1BQUlJLFFBQVFGLFdBQVcsQ0FBWCxFQUFjdjRDLE9BQWQsQ0FBc0JxNEMsYUFBdEIsRUFBcUMsTUFBckMsQ0FBWjtBQUNBLFNBQU8sSUFBSTd1QyxNQUFKLENBQVdndkMsT0FBTyxlQUFQLEdBQXlCQyxLQUFwQyxFQUEyQyxHQUEzQyxDQUFQO0FBQ0QsQ0FKZ0IsQ0FBakI7O0FBTUEsU0FBU0MsU0FBVCxDQUNFanlCLElBREYsRUFFRTh4QixVQUZGLEVBR0U7QUFDQSxNQUFJSSxRQUFRSixhQUFhRCxXQUFXQyxVQUFYLENBQWIsR0FBc0NILFlBQWxEO0FBQ0EsTUFBSSxDQUFDTyxNQUFNOXlDLElBQU4sQ0FBVzRnQixJQUFYLENBQUwsRUFBdUI7QUFDckI7QUFDRDtBQUNELE1BQUloZCxTQUFTLEVBQWI7QUFDQSxNQUFJbXZDLFlBQVlELE1BQU1DLFNBQU4sR0FBa0IsQ0FBbEM7QUFDQSxNQUFJNXNDLEtBQUosRUFBV2hRLEtBQVg7QUFDQSxTQUFRZ1EsUUFBUTJzQyxNQUFNL3VDLElBQU4sQ0FBVzZjLElBQVgsQ0FBaEIsRUFBbUM7QUFDakN6cUIsWUFBUWdRLE1BQU1oUSxLQUFkO0FBQ0E7QUFDQSxRQUFJQSxRQUFRNDhDLFNBQVosRUFBdUI7QUFDckJudkMsYUFBT3RQLElBQVAsQ0FBWW1SLEtBQUtDLFNBQUwsQ0FBZWtiLEtBQUtobEIsS0FBTCxDQUFXbTNDLFNBQVgsRUFBc0I1OEMsS0FBdEIsQ0FBZixDQUFaO0FBQ0Q7QUFDRDtBQUNBLFFBQUk2bkMsTUFBTUQsYUFBYTUzQixNQUFNLENBQU4sRUFBU3JMLElBQVQsRUFBYixDQUFWO0FBQ0E4SSxXQUFPdFAsSUFBUCxDQUFhLFFBQVEwcEMsR0FBUixHQUFjLEdBQTNCO0FBQ0ErVSxnQkFBWTU4QyxRQUFRZ1EsTUFBTSxDQUFOLEVBQVN4UyxNQUE3QjtBQUNEO0FBQ0QsTUFBSW8vQyxZQUFZbnlCLEtBQUtqdEIsTUFBckIsRUFBNkI7QUFDM0JpUSxXQUFPdFAsSUFBUCxDQUFZbVIsS0FBS0MsU0FBTCxDQUFla2IsS0FBS2hsQixLQUFMLENBQVdtM0MsU0FBWCxDQUFmLENBQVo7QUFDRDtBQUNELFNBQU9udkMsT0FBT3ZJLElBQVAsQ0FBWSxHQUFaLENBQVA7QUFDRDs7QUFFRDs7QUFFQSxJQUFJMjNDLE9BQU8sV0FBWDtBQUNBLElBQUlDLFFBQVEsV0FBWjtBQUNBLElBQUlDLGFBQWEsMEJBQWpCO0FBQ0EsSUFBSUMsZ0JBQWdCLDRDQUFwQjs7QUFFQSxJQUFJQyxRQUFRLFFBQVo7QUFDQSxJQUFJQyxTQUFTLGFBQWI7QUFDQSxJQUFJQyxhQUFhLFVBQWpCOztBQUVBLElBQUlDLG1CQUFtQmhoQyxPQUFPblksTUFBUCxDQUF2Qjs7QUFFQTtBQUNBLElBQUlvNUMsTUFBSjtBQUNBLElBQUlkLFVBQUo7QUFDQSxJQUFJZSxVQUFKO0FBQ0EsSUFBSUMsYUFBSjtBQUNBLElBQUlDLGNBQUo7QUFDQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLG1CQUFKO0FBQ0EsSUFBSUMsdUJBQUo7O0FBRUE7OztBQUdBLFNBQVMzd0MsS0FBVCxDQUNFbk0sUUFERixFQUVFMEgsT0FGRixFQUdFO0FBQ0E4MEMsV0FBUzkwQyxRQUFRdEgsSUFBUixJQUFnQnduQyxRQUF6QjtBQUNBa1YsNEJBQTBCcDFDLFFBQVFpVyxlQUFSLElBQTJCbEIsRUFBckQ7QUFDQW9nQyx3QkFBc0JuMUMsUUFBUW1XLFdBQVIsSUFBdUJwQixFQUE3QztBQUNBbWdDLHFCQUFtQmwxQyxRQUFRODJCLFFBQVIsSUFBb0IvaEIsRUFBdkM7QUFDQWlnQyxrQkFBZ0I3VSxvQkFBb0JuZ0MsUUFBUWtWLE9BQTVCLEVBQXFDLGtCQUFyQyxDQUFoQjtBQUNBNi9CLGVBQWE1VSxvQkFBb0JuZ0MsUUFBUWtWLE9BQTVCLEVBQXFDLGVBQXJDLENBQWI7QUFDQSsvQixtQkFBaUI5VSxvQkFBb0JuZ0MsUUFBUWtWLE9BQTVCLEVBQXFDLG1CQUFyQyxDQUFqQjtBQUNBOCtCLGVBQWFoMEMsUUFBUWcwQyxVQUFyQjs7QUFFQSxNQUFJcHhDLFFBQVEsRUFBWjtBQUNBLE1BQUl5eUMscUJBQXFCcjFDLFFBQVFxMUMsa0JBQVIsS0FBK0IsS0FBeEQ7QUFDQSxNQUFJQyxJQUFKO0FBQ0EsTUFBSUMsYUFBSjtBQUNBLE1BQUlDLFNBQVMsS0FBYjtBQUNBLE1BQUloYyxRQUFRLEtBQVo7QUFDQSxNQUFJaWMsU0FBUyxLQUFiOztBQUVBLFdBQVNDLFFBQVQsQ0FBbUI3N0IsR0FBbkIsRUFBd0I7QUFDdEIsUUFBSSxDQUFDNDdCLE1BQUwsRUFBYTtBQUNYQSxlQUFTLElBQVQ7QUFDQVgsYUFBT2o3QixHQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTODdCLE1BQVQsQ0FBaUJDLE9BQWpCLEVBQTBCO0FBQ3hCO0FBQ0EsUUFBSUEsUUFBUWhjLEdBQVosRUFBaUI7QUFDZjRiLGVBQVMsS0FBVDtBQUNEO0FBQ0QsUUFBSU4saUJBQWlCVSxRQUFReDJDLEdBQXpCLENBQUosRUFBbUM7QUFDakNvNkIsY0FBUSxLQUFSO0FBQ0Q7QUFDRjs7QUFFRDBZLFlBQVU1NUMsUUFBVixFQUFvQjtBQUNsQkksVUFBTW84QyxNQURZO0FBRWxCM0MsZ0JBQVlueUMsUUFBUW15QyxVQUZGO0FBR2xCekIsZ0JBQVkxd0MsUUFBUTB3QyxVQUhGO0FBSWxCQyxzQkFBa0Izd0MsUUFBUTJ3QyxnQkFKUjtBQUtsQkYsMEJBQXNCendDLFFBQVF5d0Msb0JBTFo7QUFNbEJoOEIsV0FBTyxTQUFTQSxLQUFULENBQWdCclYsR0FBaEIsRUFBcUJtQixLQUFyQixFQUE0Qm16QyxLQUE1QixFQUFtQztBQUN4QztBQUNBO0FBQ0EsVUFBSXB4QixLQUFNaXpCLGlCQUFpQkEsY0FBY2p6QixFQUFoQyxJQUF1Qzh5Qix3QkFBd0JoMkMsR0FBeEIsQ0FBaEQ7O0FBRUE7QUFDQTtBQUNBLFVBQUkyWCxRQUFRdUwsT0FBTyxLQUFuQixFQUEwQjtBQUN4Qi9oQixnQkFBUXMxQyxjQUFjdDFDLEtBQWQsQ0FBUjtBQUNEOztBQUVELFVBQUlxMUMsVUFBVTtBQUNaNzhDLGNBQU0sQ0FETTtBQUVacUcsYUFBS0EsR0FGTztBQUdaZ2lDLG1CQUFXN2dDLEtBSEM7QUFJWjRnQyxrQkFBVTJVLGFBQWF2MUMsS0FBYixDQUpFO0FBS1psSCxnQkFBUWs4QyxhQUxJO0FBTVpuOEMsa0JBQVU7QUFORSxPQUFkO0FBUUEsVUFBSWtwQixFQUFKLEVBQVE7QUFDTnN6QixnQkFBUXR6QixFQUFSLEdBQWFBLEVBQWI7QUFDRDs7QUFFRCxVQUFJeXpCLGVBQWVILE9BQWYsS0FBMkIsQ0FBQ3QrQixtQkFBaEMsRUFBcUQ7QUFDbkRzK0IsZ0JBQVFJLFNBQVIsR0FBb0IsSUFBcEI7QUFDQXBpRCxnQkFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUM2NEMsT0FDdkMsdUVBQ0Esc0VBREEsR0FFQSxHQUZBLEdBRU0xMUMsR0FGTixHQUVZLEdBRlosR0FFa0IsK0JBSHFCLENBQXpDO0FBS0Q7O0FBRUQ7QUFDQSxXQUFLLElBQUl6SixJQUFJLENBQWIsRUFBZ0JBLElBQUlxL0MsY0FBYy8vQyxNQUFsQyxFQUEwQ1UsR0FBMUMsRUFBK0M7QUFDN0NxL0Msc0JBQWNyL0MsQ0FBZCxFQUFpQmlnRCxPQUFqQixFQUEwQjUxQyxPQUExQjtBQUNEOztBQUVELFVBQUksQ0FBQ3cxQyxNQUFMLEVBQWE7QUFDWFMsbUJBQVdMLE9BQVg7QUFDQSxZQUFJQSxRQUFRaGMsR0FBWixFQUFpQjtBQUNmNGIsbUJBQVMsSUFBVDtBQUNEO0FBQ0Y7QUFDRCxVQUFJTixpQkFBaUJVLFFBQVF4MkMsR0FBekIsQ0FBSixFQUFtQztBQUNqQ282QixnQkFBUSxJQUFSO0FBQ0Q7QUFDRCxVQUFJZ2MsTUFBSixFQUFZO0FBQ1ZVLHdCQUFnQk4sT0FBaEI7QUFDRCxPQUZELE1BRU87QUFDTE8sbUJBQVdQLE9BQVg7QUFDQVEsa0JBQVVSLE9BQVY7QUFDQVMsb0JBQVlULE9BQVo7QUFDQVUsbUJBQVdWLE9BQVg7O0FBRUE7QUFDQTtBQUNBQSxnQkFBUVcsS0FBUixHQUFnQixDQUFDWCxRQUFRMTVDLEdBQVQsSUFBZ0IsQ0FBQ3FFLE1BQU10TCxNQUF2Qzs7QUFFQXVoRCxtQkFBV1osT0FBWDtBQUNBYSxvQkFBWWIsT0FBWjtBQUNBYyx5QkFBaUJkLE9BQWpCO0FBQ0EsYUFBSyxJQUFJdHdCLE1BQU0sQ0FBZixFQUFrQkEsTUFBTXl2QixXQUFXOS9DLE1BQW5DLEVBQTJDcXdCLEtBQTNDLEVBQWtEO0FBQ2hEeXZCLHFCQUFXenZCLEdBQVgsRUFBZ0Jzd0IsT0FBaEIsRUFBeUI1MUMsT0FBekI7QUFDRDtBQUNEMjJDLHFCQUFhZixPQUFiO0FBQ0Q7O0FBRUQsZUFBU2dCLG9CQUFULENBQStCN3JDLEVBQS9CLEVBQW1DO0FBQ2pDLFlBQUluWCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxjQUFJOE8sR0FBRzNMLEdBQUgsS0FBVyxNQUFYLElBQXFCMkwsR0FBRzNMLEdBQUgsS0FBVyxVQUFwQyxFQUFnRDtBQUM5Q3MyQyxxQkFDRSxpQkFBa0IzcUMsR0FBRzNMLEdBQXJCLEdBQTRCLDZDQUE1QixHQUNBLHlCQUZGO0FBSUQ7QUFDRCxjQUFJMkwsR0FBR28yQixRQUFILENBQVk5M0IsY0FBWixDQUEyQixPQUEzQixDQUFKLEVBQXlDO0FBQ3ZDcXNDLHFCQUNFLGlFQUNBLCtCQUZGO0FBSUQ7QUFDRjtBQUNGOztBQUVEO0FBQ0EsVUFBSSxDQUFDSixJQUFMLEVBQVc7QUFDVEEsZUFBT00sT0FBUDtBQUNBZ0IsNkJBQXFCdEIsSUFBckI7QUFDRCxPQUhELE1BR08sSUFBSSxDQUFDMXlDLE1BQU0zTixNQUFYLEVBQW1CO0FBQ3hCO0FBQ0EsWUFBSXFnRCxLQUFLdUIsRUFBTCxLQUFZakIsUUFBUWtCLE1BQVIsSUFBa0JsQixRQUFRbUIsSUFBdEMsQ0FBSixFQUFpRDtBQUMvQ0gsK0JBQXFCaEIsT0FBckI7QUFDQW9CLHlCQUFlMUIsSUFBZixFQUFxQjtBQUNuQmhXLGlCQUFLc1csUUFBUWtCLE1BRE07QUFFbkJHLG1CQUFPckI7QUFGWSxXQUFyQjtBQUlELFNBTkQsTUFNTyxJQUFJaGlELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEeTVDLG1CQUNFLGlFQUNBLDhDQURBLEdBRUEsc0NBSEY7QUFLRDtBQUNGO0FBQ0QsVUFBSUgsaUJBQWlCLENBQUNLLFFBQVFJLFNBQTlCLEVBQXlDO0FBQ3ZDLFlBQUlKLFFBQVFrQixNQUFSLElBQWtCbEIsUUFBUW1CLElBQTlCLEVBQW9DO0FBQ2xDRyw4QkFBb0J0QixPQUFwQixFQUE2QkwsYUFBN0I7QUFDRCxTQUZELE1BRU8sSUFBSUssUUFBUXVCLFNBQVosRUFBdUI7QUFBRTtBQUM5QjVCLHdCQUFjZ0IsS0FBZCxHQUFzQixLQUF0QjtBQUNBLGNBQUl2L0MsT0FBTzQrQyxRQUFRd0IsVUFBUixJQUFzQixXQUFqQyxDQUE2QyxDQUFDN0IsY0FBY2p0QixXQUFkLEtBQThCaXRCLGNBQWNqdEIsV0FBZCxHQUE0QixFQUExRCxDQUFELEVBQWdFdHhCLElBQWhFLElBQXdFNCtDLE9BQXhFO0FBQzlDLFNBSE0sTUFHQTtBQUNMTCx3QkFBY244QyxRQUFkLENBQXVCeEQsSUFBdkIsQ0FBNEJnZ0QsT0FBNUI7QUFDQUEsa0JBQVF2OEMsTUFBUixHQUFpQms4QyxhQUFqQjtBQUNEO0FBQ0Y7QUFDRCxVQUFJLENBQUM3QixLQUFMLEVBQVk7QUFDVjZCLHdCQUFnQkssT0FBaEI7QUFDQWh6QyxjQUFNaE4sSUFBTixDQUFXZ2dELE9BQVg7QUFDRCxPQUhELE1BR087QUFDTEQsZUFBT0MsT0FBUDtBQUNEO0FBQ0Q7QUFDQSxXQUFLLElBQUl5QixNQUFNLENBQWYsRUFBa0JBLE1BQU1wQyxlQUFlaGdELE1BQXZDLEVBQStDb2lELEtBQS9DLEVBQXNEO0FBQ3BEcEMsdUJBQWVvQyxHQUFmLEVBQW9CekIsT0FBcEIsRUFBNkI1MUMsT0FBN0I7QUFDRDtBQUNGLEtBbklpQjs7QUFxSWxCOEgsU0FBSyxTQUFTQSxHQUFULEdBQWdCO0FBQ25CO0FBQ0EsVUFBSTh0QyxVQUFVaHpDLE1BQU1BLE1BQU0zTixNQUFOLEdBQWUsQ0FBckIsQ0FBZDtBQUNBLFVBQUlxaUQsV0FBVzFCLFFBQVF4OEMsUUFBUixDQUFpQnc4QyxRQUFReDhDLFFBQVIsQ0FBaUJuRSxNQUFqQixHQUEwQixDQUEzQyxDQUFmO0FBQ0EsVUFBSXFpRCxZQUFZQSxTQUFTditDLElBQVQsS0FBa0IsQ0FBOUIsSUFBbUN1K0MsU0FBU3AxQixJQUFULEtBQWtCLEdBQXJELElBQTRELENBQUNzWCxLQUFqRSxFQUF3RTtBQUN0RW9jLGdCQUFReDhDLFFBQVIsQ0FBaUJ5SixHQUFqQjtBQUNEO0FBQ0Q7QUFDQUQsWUFBTTNOLE1BQU4sSUFBZ0IsQ0FBaEI7QUFDQXNnRCxzQkFBZ0IzeUMsTUFBTUEsTUFBTTNOLE1BQU4sR0FBZSxDQUFyQixDQUFoQjtBQUNBMGdELGFBQU9DLE9BQVA7QUFDRCxLQWhKaUI7O0FBa0psQnpDLFdBQU8sU0FBU0EsS0FBVCxDQUFnQmp4QixJQUFoQixFQUFzQjtBQUMzQixVQUFJLENBQUNxekIsYUFBTCxFQUFvQjtBQUNsQixZQUFJM2hELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGNBQUlpbUIsU0FBUzVwQixRQUFiLEVBQXVCO0FBQ3JCbzlDLHFCQUNFLG9FQURGO0FBR0QsV0FKRCxNQUlPLElBQUt4ekIsT0FBT0EsS0FBSzlsQixJQUFMLEVBQVosRUFBMEI7QUFDL0JzNUMscUJBQ0csWUFBWXh6QixJQUFaLEdBQW1CLDBDQUR0QjtBQUdEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFVBQUluTCxRQUNBdytCLGNBQWNuMkMsR0FBZCxLQUFzQixVQUR0QixJQUVBbTJDLGNBQWNwVSxRQUFkLENBQXVCeU0sV0FBdkIsS0FBdUMxckIsSUFGM0MsRUFFaUQ7QUFDL0M7QUFDRDtBQUNELFVBQUk5b0IsV0FBV204QyxjQUFjbjhDLFFBQTdCO0FBQ0E4b0IsYUFBT3NYLFNBQVN0WCxLQUFLOWxCLElBQUwsRUFBVCxHQUNIeTRDLGlCQUFpQjN5QixJQUFqQjtBQUNGO0FBRkssUUFHSG16QixzQkFBc0JqOEMsU0FBU25FLE1BQS9CLEdBQXdDLEdBQXhDLEdBQThDLEVBSGxEO0FBSUEsVUFBSWl0QixJQUFKLEVBQVU7QUFDUixZQUFJcUgsVUFBSjtBQUNBLFlBQUksQ0FBQ2lzQixNQUFELElBQVd0ekIsU0FBUyxHQUFwQixLQUE0QnFILGFBQWE0cUIsVUFBVWp5QixJQUFWLEVBQWdCOHhCLFVBQWhCLENBQXpDLENBQUosRUFBMkU7QUFDekU1NkMsbUJBQVN4RCxJQUFULENBQWM7QUFDWm1ELGtCQUFNLENBRE07QUFFWnd3Qix3QkFBWUEsVUFGQTtBQUdackgsa0JBQU1BO0FBSE0sV0FBZDtBQUtELFNBTkQsTUFNTyxJQUFJQSxTQUFTLEdBQVQsSUFBZ0IsQ0FBQzlvQixTQUFTbkUsTUFBMUIsSUFBb0NtRSxTQUFTQSxTQUFTbkUsTUFBVCxHQUFrQixDQUEzQixFQUE4Qml0QixJQUE5QixLQUF1QyxHQUEvRSxFQUFvRjtBQUN6RjlvQixtQkFBU3hELElBQVQsQ0FBYztBQUNabUQsa0JBQU0sQ0FETTtBQUVabXBCLGtCQUFNQTtBQUZNLFdBQWQ7QUFJRDtBQUNGO0FBQ0Y7QUE1TGlCLEdBQXBCO0FBOExBLFNBQU9vekIsSUFBUDtBQUNEOztBQUVELFNBQVNXLFVBQVQsQ0FBcUJsckMsRUFBckIsRUFBeUI7QUFDdkIsTUFBSWsyQixpQkFBaUJsMkIsRUFBakIsRUFBcUIsT0FBckIsS0FBaUMsSUFBckMsRUFBMkM7QUFDekNBLE9BQUc2dUIsR0FBSCxHQUFTLElBQVQ7QUFDRDtBQUNGOztBQUVELFNBQVNzYyxlQUFULENBQTBCbnJDLEVBQTFCLEVBQThCO0FBQzVCLE1BQUl1SixJQUFJdkosR0FBR3EyQixTQUFILENBQWFuc0MsTUFBckI7QUFDQSxNQUFJcWYsQ0FBSixFQUFPO0FBQ0wsUUFBSS9ULFFBQVF3SyxHQUFHeEssS0FBSCxHQUFXLElBQUk5SyxLQUFKLENBQVU2ZSxDQUFWLENBQXZCO0FBQ0EsU0FBSyxJQUFJM2UsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMmUsQ0FBcEIsRUFBdUIzZSxHQUF2QixFQUE0QjtBQUMxQjRLLFlBQU01SyxDQUFOLElBQVc7QUFDVHFCLGNBQU0rVCxHQUFHcTJCLFNBQUgsQ0FBYXpyQyxDQUFiLEVBQWdCcUIsSUFEYjtBQUVUWSxlQUFPbVAsS0FBS0MsU0FBTCxDQUFlK0QsR0FBR3EyQixTQUFILENBQWF6ckMsQ0FBYixFQUFnQmlDLEtBQS9CO0FBRkUsT0FBWDtBQUlEO0FBQ0YsR0FSRCxNQVFPLElBQUksQ0FBQ21ULEdBQUc2dUIsR0FBUixFQUFhO0FBQ2xCO0FBQ0E3dUIsT0FBR3dyQyxLQUFILEdBQVcsSUFBWDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0QsVUFBVCxDQUFxQnZyQyxFQUFyQixFQUF5QjtBQUN2QixNQUFJdTBCLE1BQU13QixlQUFlLzFCLEVBQWYsRUFBbUIsS0FBbkIsQ0FBVjtBQUNBLE1BQUl1MEIsR0FBSixFQUFTO0FBQ1AsUUFBSTFyQyxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzhPLEdBQUczTCxHQUFILEtBQVcsVUFBeEQsRUFBb0U7QUFDbEUwMUMsYUFBTyxxRUFBUDtBQUNEO0FBQ0QvcEMsT0FBRzdPLEdBQUgsR0FBU29qQyxHQUFUO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTa1gsVUFBVCxDQUFxQnpyQyxFQUFyQixFQUF5QjtBQUN2QixNQUFJNVIsTUFBTTJuQyxlQUFlLzFCLEVBQWYsRUFBbUIsS0FBbkIsQ0FBVjtBQUNBLE1BQUk1UixHQUFKLEVBQVM7QUFDUDRSLE9BQUc1UixHQUFILEdBQVNBLEdBQVQ7QUFDQTRSLE9BQUd1dEIsUUFBSCxHQUFjaWYsV0FBV3hzQyxFQUFYLENBQWQ7QUFDRDtBQUNGOztBQUVELFNBQVNvckMsVUFBVCxDQUFxQnByQyxFQUFyQixFQUF5QjtBQUN2QixNQUFJdTBCLEdBQUo7QUFDQSxNQUFLQSxNQUFNMkIsaUJBQWlCbDJCLEVBQWpCLEVBQXFCLE9BQXJCLENBQVgsRUFBMkM7QUFDekMsUUFBSXlzQyxVQUFVbFksSUFBSTczQixLQUFKLENBQVUrc0MsVUFBVixDQUFkO0FBQ0EsUUFBSSxDQUFDZ0QsT0FBTCxFQUFjO0FBQ1o1akQsY0FBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUM2NEMsT0FDdEMsK0JBQStCeFYsR0FETyxDQUF6QztBQUdBO0FBQ0Q7QUFDRHYwQixPQUFHMHNDLEdBQUgsR0FBU0QsUUFBUSxDQUFSLEVBQVdwN0MsSUFBWCxFQUFUO0FBQ0EsUUFBSThILFFBQVFzekMsUUFBUSxDQUFSLEVBQVdwN0MsSUFBWCxFQUFaO0FBQ0EsUUFBSXM3QyxnQkFBZ0J4ekMsTUFBTXVELEtBQU4sQ0FBWWd0QyxhQUFaLENBQXBCO0FBQ0EsUUFBSWlELGFBQUosRUFBbUI7QUFDakIzc0MsU0FBRzdHLEtBQUgsR0FBV3d6QyxjQUFjLENBQWQsRUFBaUJ0N0MsSUFBakIsRUFBWDtBQUNBMk8sU0FBRzRzQyxTQUFILEdBQWVELGNBQWMsQ0FBZCxFQUFpQnQ3QyxJQUFqQixFQUFmO0FBQ0EsVUFBSXM3QyxjQUFjLENBQWQsQ0FBSixFQUFzQjtBQUNwQjNzQyxXQUFHNnNDLFNBQUgsR0FBZUYsY0FBYyxDQUFkLEVBQWlCdDdDLElBQWpCLEVBQWY7QUFDRDtBQUNGLEtBTkQsTUFNTztBQUNMMk8sU0FBRzdHLEtBQUgsR0FBV0EsS0FBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTa3lDLFNBQVQsQ0FBb0JyckMsRUFBcEIsRUFBd0I7QUFDdEIsTUFBSXUwQixNQUFNMkIsaUJBQWlCbDJCLEVBQWpCLEVBQXFCLE1BQXJCLENBQVY7QUFDQSxNQUFJdTBCLEdBQUosRUFBUztBQUNQdjBCLE9BQUc4ckMsRUFBSCxHQUFRdlgsR0FBUjtBQUNBMFgsbUJBQWVqc0MsRUFBZixFQUFtQjtBQUNqQnUwQixXQUFLQSxHQURZO0FBRWpCMlgsYUFBT2xzQztBQUZVLEtBQW5CO0FBSUQsR0FORCxNQU1PO0FBQ0wsUUFBSWsyQixpQkFBaUJsMkIsRUFBakIsRUFBcUIsUUFBckIsS0FBa0MsSUFBdEMsRUFBNEM7QUFDMUNBLFNBQUdnc0MsSUFBSCxHQUFVLElBQVY7QUFDRDtBQUNELFFBQUlELFNBQVM3VixpQkFBaUJsMkIsRUFBakIsRUFBcUIsV0FBckIsQ0FBYjtBQUNBLFFBQUkrckMsTUFBSixFQUFZO0FBQ1YvckMsU0FBRytyQyxNQUFILEdBQVlBLE1BQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0ksbUJBQVQsQ0FBOEJuc0MsRUFBOUIsRUFBa0MxUixNQUFsQyxFQUEwQztBQUN4QyxNQUFJMlYsT0FBTzZvQyxnQkFBZ0J4K0MsT0FBT0QsUUFBdkIsQ0FBWDtBQUNBLE1BQUk0VixRQUFRQSxLQUFLNm5DLEVBQWpCLEVBQXFCO0FBQ25CRyxtQkFBZWhvQyxJQUFmLEVBQXFCO0FBQ25Cc3dCLFdBQUt2MEIsR0FBRytyQyxNQURXO0FBRW5CRyxhQUFPbHNDO0FBRlksS0FBckI7QUFJRCxHQUxELE1BS08sSUFBSW5YLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hENjRDLFdBQ0UsUUFBUS9wQyxHQUFHK3JDLE1BQUgsR0FBYSxjQUFjL3JDLEdBQUcrckMsTUFBakIsR0FBMEIsR0FBdkMsR0FBOEMsTUFBdEQsSUFBZ0UsR0FBaEUsR0FDQSxtQkFEQSxHQUN1Qi9yQyxHQUFHM0wsR0FEMUIsR0FDaUMsK0JBRm5DO0FBSUQ7QUFDRjs7QUFFRCxTQUFTeTRDLGVBQVQsQ0FBMEJ6K0MsUUFBMUIsRUFBb0M7QUFDbEMsTUFBSXpELElBQUl5RCxTQUFTbkUsTUFBakI7QUFDQSxTQUFPVSxHQUFQLEVBQVk7QUFDVixRQUFJeUQsU0FBU3pELENBQVQsRUFBWW9ELElBQVosS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBT0ssU0FBU3pELENBQVQsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUkvQixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QzdDLFNBQVN6RCxDQUFULEVBQVl1c0IsSUFBWixLQUFxQixHQUFsRSxFQUF1RTtBQUNyRTR5QixlQUNFLFlBQWExN0MsU0FBU3pELENBQVQsRUFBWXVzQixJQUFaLENBQWlCOWxCLElBQWpCLEVBQWIsR0FBd0Msa0NBQXhDLEdBQ0Esa0JBRkY7QUFJRDtBQUNEaEQsZUFBU3lKLEdBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU20wQyxjQUFULENBQXlCanNDLEVBQXpCLEVBQTZCdlMsU0FBN0IsRUFBd0M7QUFDdEMsTUFBSSxDQUFDdVMsR0FBRytzQyxZQUFSLEVBQXNCO0FBQ3BCL3NDLE9BQUcrc0MsWUFBSCxHQUFrQixFQUFsQjtBQUNEO0FBQ0Qvc0MsS0FBRytzQyxZQUFILENBQWdCbGlELElBQWhCLENBQXFCNEMsU0FBckI7QUFDRDs7QUFFRCxTQUFTNjlDLFdBQVQsQ0FBc0J0ckMsRUFBdEIsRUFBMEI7QUFDeEIsTUFBSXNZLFVBQVU0ZCxpQkFBaUJsMkIsRUFBakIsRUFBcUIsUUFBckIsQ0FBZDtBQUNBLE1BQUlzWSxXQUFXLElBQWYsRUFBcUI7QUFDbkJ0WSxPQUFHclUsSUFBSCxHQUFVLElBQVY7QUFDRDtBQUNGOztBQUVELFNBQVMrL0MsV0FBVCxDQUFzQjFyQyxFQUF0QixFQUEwQjtBQUN4QixNQUFJQSxHQUFHM0wsR0FBSCxLQUFXLE1BQWYsRUFBdUI7QUFDckIyTCxPQUFHZ3RDLFFBQUgsR0FBY2pYLGVBQWUvMUIsRUFBZixFQUFtQixNQUFuQixDQUFkO0FBQ0EsUUFBSW5YLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDOE8sR0FBRzdPLEdBQWhELEVBQXFEO0FBQ25ENDRDLGFBQ0Usc0VBQ0Esa0RBREEsR0FFQSw0Q0FIRjtBQUtEO0FBQ0YsR0FURCxNQVNPO0FBQ0wsUUFBSXNDLGFBQWF0VyxlQUFlLzFCLEVBQWYsRUFBbUIsTUFBbkIsQ0FBakI7QUFDQSxRQUFJcXNDLFVBQUosRUFBZ0I7QUFDZHJzQyxTQUFHcXNDLFVBQUgsR0FBZ0JBLGVBQWUsSUFBZixHQUFzQixXQUF0QixHQUFvQ0EsVUFBcEQ7QUFDRDtBQUNELFFBQUlyc0MsR0FBRzNMLEdBQUgsS0FBVyxVQUFmLEVBQTJCO0FBQ3pCMkwsU0FBR29zQyxTQUFILEdBQWVsVyxpQkFBaUJsMkIsRUFBakIsRUFBcUIsT0FBckIsQ0FBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTMnJDLGdCQUFULENBQTJCM3JDLEVBQTNCLEVBQStCO0FBQzdCLE1BQUloVSxPQUFKO0FBQ0EsTUFBS0EsVUFBVStwQyxlQUFlLzFCLEVBQWYsRUFBbUIsSUFBbkIsQ0FBZixFQUEwQztBQUN4Q0EsT0FBRzFTLFNBQUgsR0FBZXRCLE9BQWY7QUFDRDtBQUNELE1BQUlrcUMsaUJBQWlCbDJCLEVBQWpCLEVBQXFCLGlCQUFyQixLQUEyQyxJQUEvQyxFQUFxRDtBQUNuREEsT0FBRzJqQixjQUFILEdBQW9CLElBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTaW9CLFlBQVQsQ0FBdUI1ckMsRUFBdkIsRUFBMkI7QUFDekIsTUFBSXNJLE9BQU90SSxHQUFHcTJCLFNBQWQ7QUFDQSxNQUFJenJDLENBQUosRUFBTzJlLENBQVAsRUFBVXRkLElBQVYsRUFBZ0JzbkMsT0FBaEIsRUFBeUIxbUMsS0FBekIsRUFBZ0N3bUMsU0FBaEMsRUFBMkM0WixNQUEzQztBQUNBLE9BQUtyaUQsSUFBSSxDQUFKLEVBQU8yZSxJQUFJakIsS0FBS3BlLE1BQXJCLEVBQTZCVSxJQUFJMmUsQ0FBakMsRUFBb0MzZSxHQUFwQyxFQUF5QztBQUN2Q3FCLFdBQU9zbkMsVUFBVWpyQixLQUFLMWQsQ0FBTCxFQUFRcUIsSUFBekI7QUFDQVksWUFBUXliLEtBQUsxZCxDQUFMLEVBQVFpQyxLQUFoQjtBQUNBLFFBQUkyOEMsTUFBTWp6QyxJQUFOLENBQVd0SyxJQUFYLENBQUosRUFBc0I7QUFDcEI7QUFDQStULFNBQUdrdEMsV0FBSCxHQUFpQixJQUFqQjtBQUNBO0FBQ0E3WixrQkFBWThaLGVBQWVsaEQsSUFBZixDQUFaO0FBQ0EsVUFBSW9uQyxTQUFKLEVBQWU7QUFDYnBuQyxlQUFPQSxLQUFLeUUsT0FBTCxDQUFhbTVDLFVBQWIsRUFBeUIsRUFBekIsQ0FBUDtBQUNEO0FBQ0QsVUFBSUQsT0FBT3J6QyxJQUFQLENBQVl0SyxJQUFaLENBQUosRUFBdUI7QUFBRTtBQUN2QkEsZUFBT0EsS0FBS3lFLE9BQUwsQ0FBYWs1QyxNQUFiLEVBQXFCLEVBQXJCLENBQVA7QUFDQS84QyxnQkFBUXluQyxhQUFhem5DLEtBQWIsQ0FBUjtBQUNBb2dELGlCQUFTLEtBQVQ7QUFDQSxZQUFJNVosU0FBSixFQUFlO0FBQ2IsY0FBSUEsVUFBVXRlLElBQWQsRUFBb0I7QUFDbEJrNEIscUJBQVMsSUFBVDtBQUNBaGhELG1CQUFPZ2QsU0FBU2hkLElBQVQsQ0FBUDtBQUNBLGdCQUFJQSxTQUFTLFdBQWIsRUFBMEI7QUFBRUEscUJBQU8sV0FBUDtBQUFxQjtBQUNsRDtBQUNELGNBQUlvbkMsVUFBVStaLEtBQWQsRUFBcUI7QUFDbkJuaEQsbUJBQU9nZCxTQUFTaGQsSUFBVCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFlBQUlnaEQsVUFBVTdDLG9CQUFvQnBxQyxHQUFHM0wsR0FBdkIsRUFBNEIyTCxHQUFHbzJCLFFBQUgsQ0FBWXBvQyxJQUF4QyxFQUE4Qy9CLElBQTlDLENBQWQsRUFBbUU7QUFDakVvcEMsa0JBQVFyMUIsRUFBUixFQUFZL1QsSUFBWixFQUFrQlksS0FBbEI7QUFDRCxTQUZELE1BRU87QUFDTHlvQyxrQkFBUXQxQixFQUFSLEVBQVkvVCxJQUFaLEVBQWtCWSxLQUFsQjtBQUNEO0FBQ0YsT0FuQkQsTUFtQk8sSUFBSTA4QyxLQUFLaHpDLElBQUwsQ0FBVXRLLElBQVYsQ0FBSixFQUFxQjtBQUFFO0FBQzVCQSxlQUFPQSxLQUFLeUUsT0FBTCxDQUFhNjRDLElBQWIsRUFBbUIsRUFBbkIsQ0FBUDtBQUNBOVQsbUJBQVd6MUIsRUFBWCxFQUFlL1QsSUFBZixFQUFxQlksS0FBckIsRUFBNEJ3bUMsU0FBNUI7QUFDRCxPQUhNLE1BR0E7QUFBRTtBQUNQcG5DLGVBQU9BLEtBQUt5RSxPQUFMLENBQWE4NEMsS0FBYixFQUFvQixFQUFwQixDQUFQO0FBQ0E7QUFDQSxZQUFJNkQsV0FBV3BoRCxLQUFLeVEsS0FBTCxDQUFXaXRDLEtBQVgsQ0FBZjtBQUNBLFlBQUluVSxNQUFNNlgsWUFBWUEsU0FBUyxDQUFULENBQXRCO0FBQ0EsWUFBSTdYLEdBQUosRUFBUztBQUNQdnBDLGlCQUFPQSxLQUFLa0csS0FBTCxDQUFXLENBQVgsRUFBYyxFQUFFcWpDLElBQUl0ckMsTUFBSixHQUFhLENBQWYsQ0FBZCxDQUFQO0FBQ0Q7QUFDRHFyQyxxQkFBYXYxQixFQUFiLEVBQWlCL1QsSUFBakIsRUFBdUJzbkMsT0FBdkIsRUFBZ0MxbUMsS0FBaEMsRUFBdUMyb0MsR0FBdkMsRUFBNENuQyxTQUE1QztBQUNBLFlBQUl4cUMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBekIsSUFBeUNqRixTQUFTLE9BQXRELEVBQStEO0FBQzdEcWhELDZCQUFtQnR0QyxFQUFuQixFQUF1Qm5ULEtBQXZCO0FBQ0Q7QUFDRjtBQUNGLEtBM0NELE1BMkNPO0FBQ0w7QUFDQSxVQUFJaEUsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsWUFBSXN0QixhQUFhNHFCLFVBQVV2OEMsS0FBVixFQUFpQm84QyxVQUFqQixDQUFqQjtBQUNBLFlBQUl6cUIsVUFBSixFQUFnQjtBQUNkdXJCLGlCQUNFOTlDLE9BQU8sS0FBUCxHQUFlWSxLQUFmLEdBQXVCLE1BQXZCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLHVEQUpGO0FBTUQ7QUFDRjtBQUNEeW9DLGNBQVF0MUIsRUFBUixFQUFZL1QsSUFBWixFQUFrQitQLEtBQUtDLFNBQUwsQ0FBZXBQLEtBQWYsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBUzIvQyxVQUFULENBQXFCeHNDLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQUkxUixTQUFTMFIsRUFBYjtBQUNBLFNBQU8xUixNQUFQLEVBQWU7QUFDYixRQUFJQSxPQUFPbytDLEdBQVAsS0FBZTk4QyxTQUFuQixFQUE4QjtBQUM1QixhQUFPLElBQVA7QUFDRDtBQUNEdEIsYUFBU0EsT0FBT0EsTUFBaEI7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVM2K0MsY0FBVCxDQUF5QmxoRCxJQUF6QixFQUErQjtBQUM3QixNQUFJeVEsUUFBUXpRLEtBQUt5USxLQUFMLENBQVdtdEMsVUFBWCxDQUFaO0FBQ0EsTUFBSW50QyxLQUFKLEVBQVc7QUFDVCxRQUFJaU4sTUFBTSxFQUFWO0FBQ0FqTixVQUFNbkwsT0FBTixDQUFjLFVBQVVnSixDQUFWLEVBQWE7QUFBRW9QLFVBQUlwUCxFQUFFcEksS0FBRixDQUFRLENBQVIsQ0FBSixJQUFrQixJQUFsQjtBQUF5QixLQUF0RDtBQUNBLFdBQU93WCxHQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTb2hDLFlBQVQsQ0FBdUJ2MUMsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSXZELE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSXJILElBQUksQ0FBUixFQUFXMmUsSUFBSS9ULE1BQU10TCxNQUExQixFQUFrQ1UsSUFBSTJlLENBQXRDLEVBQXlDM2UsR0FBekMsRUFBOEM7QUFDNUMsUUFBSS9CLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDZSxJQUFJdUQsTUFBTTVLLENBQU4sRUFBU3FCLElBQWIsQ0FBekMsSUFBK0QsQ0FBQytmLElBQXBFLEVBQTBFO0FBQ3hFKzlCLGFBQU8sMEJBQTBCdjBDLE1BQU01SyxDQUFOLEVBQVNxQixJQUExQztBQUNEO0FBQ0RnRyxRQUFJdUQsTUFBTTVLLENBQU4sRUFBU3FCLElBQWIsSUFBcUJ1SixNQUFNNUssQ0FBTixFQUFTaUMsS0FBOUI7QUFDRDtBQUNELFNBQU9vRixHQUFQO0FBQ0Q7O0FBRUQsU0FBUys0QyxjQUFULENBQXlCaHJDLEVBQXpCLEVBQTZCO0FBQzNCLFNBQ0VBLEdBQUczTCxHQUFILEtBQVcsT0FBWCxJQUNDMkwsR0FBRzNMLEdBQUgsS0FBVyxRQUFYLEtBQ0MsQ0FBQzJMLEdBQUdvMkIsUUFBSCxDQUFZcG9DLElBQWIsSUFDQWdTLEdBQUdvMkIsUUFBSCxDQUFZcG9DLElBQVosS0FBcUIsaUJBRnRCLENBRkg7QUFPRDs7QUFFRCxJQUFJdS9DLFVBQVUsY0FBZDtBQUNBLElBQUlDLGFBQWEsU0FBakI7O0FBRUE7QUFDQSxTQUFTMUMsYUFBVCxDQUF3QnQxQyxLQUF4QixFQUErQjtBQUM3QixNQUFJcEUsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJeEcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNEssTUFBTXRMLE1BQTFCLEVBQWtDVSxHQUFsQyxFQUF1QztBQUNyQyxRQUFJOC9CLE9BQU9sMUIsTUFBTTVLLENBQU4sQ0FBWDtBQUNBLFFBQUksQ0FBQzJpRCxRQUFRaDNDLElBQVIsQ0FBYW0wQixLQUFLeitCLElBQWxCLENBQUwsRUFBOEI7QUFDNUJ5K0IsV0FBS3orQixJQUFMLEdBQVl5K0IsS0FBS3orQixJQUFMLENBQVV5RSxPQUFWLENBQWtCODhDLFVBQWxCLEVBQThCLEVBQTlCLENBQVo7QUFDQXA4QyxVQUFJdkcsSUFBSixDQUFTNi9CLElBQVQ7QUFDRDtBQUNGO0FBQ0QsU0FBT3Q1QixHQUFQO0FBQ0Q7O0FBRUQsU0FBU2s4QyxrQkFBVCxDQUE2QnR0QyxFQUE3QixFQUFpQ25ULEtBQWpDLEVBQXdDO0FBQ3RDLE1BQUk0Z0QsTUFBTXp0QyxFQUFWO0FBQ0EsU0FBT3l0QyxHQUFQLEVBQVk7QUFDVixRQUFJQSxJQUFJZixHQUFKLElBQVdlLElBQUl0MEMsS0FBSixLQUFjdE0sS0FBN0IsRUFBb0M7QUFDbENrOUMsYUFDRSxNQUFPL3BDLEdBQUczTCxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDeEgsS0FBakMsR0FBeUMsT0FBekMsR0FDQSwrREFEQSxHQUVBLGlFQUZBLEdBR0Esb0VBSEEsR0FJQSxtRkFMRjtBQU9EO0FBQ0Q0Z0QsVUFBTUEsSUFBSW4vQyxNQUFWO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxJQUFJby9DLFdBQUo7QUFDQSxJQUFJQyxxQkFBSjs7QUFFQSxJQUFJQyxzQkFBc0I5a0MsT0FBTytrQyxlQUFQLENBQTFCOztBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQVNDLFFBQVQsQ0FBbUJ2RCxJQUFuQixFQUF5QnQxQyxPQUF6QixFQUFrQztBQUNoQyxNQUFJLENBQUNzMUMsSUFBTCxFQUFXO0FBQUU7QUFBUTtBQUNyQm1ELGdCQUFjRSxvQkFBb0IzNEMsUUFBUW9WLFVBQVIsSUFBc0IsRUFBMUMsQ0FBZDtBQUNBc2pDLDBCQUF3QjE0QyxRQUFRK1YsYUFBUixJQUF5QmhCLEVBQWpEO0FBQ0E7QUFDQStqQyxlQUFheEQsSUFBYjtBQUNBO0FBQ0F5RCxrQkFBZ0J6RCxJQUFoQixFQUFzQixLQUF0QjtBQUNEOztBQUVELFNBQVNzRCxlQUFULENBQTBCNzdDLElBQTFCLEVBQWdDO0FBQzlCLFNBQU9vVyxRQUNMLDZEQUNDcFcsT0FBTyxNQUFNQSxJQUFiLEdBQW9CLEVBRHJCLENBREssQ0FBUDtBQUlEOztBQUVELFNBQVMrN0MsWUFBVCxDQUF1QmgyQixJQUF2QixFQUE2QjtBQUMzQkEsT0FBS2syQixNQUFMLEdBQWN0NEMsU0FBU29pQixJQUFULENBQWQ7QUFDQSxNQUFJQSxLQUFLL3BCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxRQUNFLENBQUMyL0Msc0JBQXNCNTFCLEtBQUsxakIsR0FBM0IsQ0FBRCxJQUNBMGpCLEtBQUsxakIsR0FBTCxLQUFhLE1BRGIsSUFFQTBqQixLQUFLcWUsUUFBTCxDQUFjLGlCQUFkLEtBQW9DLElBSHRDLEVBSUU7QUFDQTtBQUNEO0FBQ0QsU0FBSyxJQUFJeHJDLElBQUksQ0FBUixFQUFXMmUsSUFBSXdPLEtBQUsxcEIsUUFBTCxDQUFjbkUsTUFBbEMsRUFBMENVLElBQUkyZSxDQUE5QyxFQUFpRDNlLEdBQWpELEVBQXNEO0FBQ3BELFVBQUk0RSxRQUFRdW9CLEtBQUsxcEIsUUFBTCxDQUFjekQsQ0FBZCxDQUFaO0FBQ0FtakQsbUJBQWF2K0MsS0FBYjtBQUNBLFVBQUksQ0FBQ0EsTUFBTXkrQyxNQUFYLEVBQW1CO0FBQ2pCbDJCLGFBQUtrMkIsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTRCxlQUFULENBQTBCajJCLElBQTFCLEVBQWdDOE4sT0FBaEMsRUFBeUM7QUFDdkMsTUFBSTlOLEtBQUsvcEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFFBQUkrcEIsS0FBS2syQixNQUFMLElBQWVsMkIsS0FBS3BzQixJQUF4QixFQUE4QjtBQUM1Qm9zQixXQUFLbTJCLFdBQUwsR0FBbUJyb0IsT0FBbkI7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQUk5TixLQUFLazJCLE1BQUwsSUFBZWwyQixLQUFLMXBCLFFBQUwsQ0FBY25FLE1BQTdCLElBQXVDLEVBQ3pDNnRCLEtBQUsxcEIsUUFBTCxDQUFjbkUsTUFBZCxLQUF5QixDQUF6QixJQUNBNnRCLEtBQUsxcEIsUUFBTCxDQUFjLENBQWQsRUFBaUJMLElBQWpCLEtBQTBCLENBRmUsQ0FBM0MsRUFHRztBQUNEK3BCLFdBQUtvMkIsVUFBTCxHQUFrQixJQUFsQjtBQUNBO0FBQ0QsS0FORCxNQU1PO0FBQ0xwMkIsV0FBS28yQixVQUFMLEdBQWtCLEtBQWxCO0FBQ0Q7QUFDRCxRQUFJcDJCLEtBQUsxcEIsUUFBVCxFQUFtQjtBQUNqQixXQUFLLElBQUl6RCxJQUFJLENBQVIsRUFBVzJlLElBQUl3TyxLQUFLMXBCLFFBQUwsQ0FBY25FLE1BQWxDLEVBQTBDVSxJQUFJMmUsQ0FBOUMsRUFBaUQzZSxHQUFqRCxFQUFzRDtBQUNwRG9qRCx3QkFBZ0JqMkIsS0FBSzFwQixRQUFMLENBQWN6RCxDQUFkLENBQWhCLEVBQWtDaTdCLFdBQVcsQ0FBQyxDQUFDOU4sS0FBSzIwQixHQUFwRDtBQUNEO0FBQ0Y7QUFDRCxRQUFJMzBCLEtBQUtnMUIsWUFBVCxFQUF1QjtBQUNyQnFCLGtDQUE0QnIyQixLQUFLZzFCLFlBQWpDLEVBQStDbG5CLE9BQS9DO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVN1b0IsMkJBQVQsQ0FBc0NDLGVBQXRDLEVBQXVEeG9CLE9BQXZELEVBQWdFO0FBQzlELE9BQUssSUFBSWo3QixJQUFJLENBQVIsRUFBV04sTUFBTStqRCxnQkFBZ0Jua0QsTUFBdEMsRUFBOENVLElBQUlOLEdBQWxELEVBQXVETSxHQUF2RCxFQUE0RDtBQUMxRG9qRCxvQkFBZ0JLLGdCQUFnQnpqRCxDQUFoQixFQUFtQnNoRCxLQUFuQyxFQUEwQ3JtQixPQUExQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU2x3QixRQUFULENBQW1Cb2lCLElBQW5CLEVBQXlCO0FBQ3ZCLE1BQUlBLEtBQUsvcEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQUU7QUFDckIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJK3BCLEtBQUsvcEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQUU7QUFDckIsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFPLENBQUMsRUFBRStwQixLQUFLOFcsR0FBTCxJQUNSLENBQUM5VyxLQUFLbTFCLFdBQU4sSUFBcUI7QUFDckIsR0FBQ24xQixLQUFLK3pCLEVBRE4sSUFDWSxDQUFDL3pCLEtBQUsyMEIsR0FEbEIsSUFDeUI7QUFDekIsR0FBQ2xrQyxhQUFhdVAsS0FBSzFqQixHQUFsQixDQUZELElBRTJCO0FBQzNCczVDLHdCQUFzQjUxQixLQUFLMWpCLEdBQTNCLENBSEEsSUFHbUM7QUFDbkMsR0FBQ2k2QywyQkFBMkJ2MkIsSUFBM0IsQ0FKRCxJQUtBcHJCLE9BQU9xRixJQUFQLENBQVkrbEIsSUFBWixFQUFrQnJrQixLQUFsQixDQUF3Qmc2QyxXQUF4QixDQU5NLENBQVI7QUFRRDs7QUFFRCxTQUFTWSwwQkFBVCxDQUFxQ3YyQixJQUFyQyxFQUEyQztBQUN6QyxTQUFPQSxLQUFLenBCLE1BQVosRUFBb0I7QUFDbEJ5cEIsV0FBT0EsS0FBS3pwQixNQUFaO0FBQ0EsUUFBSXlwQixLQUFLMWpCLEdBQUwsS0FBYSxVQUFqQixFQUE2QjtBQUMzQixhQUFPLEtBQVA7QUFDRDtBQUNELFFBQUkwakIsS0FBSzIwQixHQUFULEVBQWM7QUFDWixhQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsSUFBSTZCLFVBQVUsOENBQWQ7QUFDQSxJQUFJQyxlQUFlLDhGQUFuQjs7QUFFQTtBQUNBLElBQUl6akMsV0FBVztBQUNiMGpDLE9BQUssRUFEUTtBQUViQyxPQUFLLENBRlE7QUFHYmpRLFNBQU8sRUFITTtBQUlia1EsU0FBTyxFQUpNO0FBS2JDLE1BQUksRUFMUztBQU1iNXRDLFFBQU0sRUFOTztBQU9iNnRDLFNBQU8sRUFQTTtBQVFiQyxRQUFNLEVBUk87QUFTYixZQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFURyxDQUFmOztBQVlBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLFdBQVcsVUFBVXRoRCxTQUFWLEVBQXFCO0FBQUUsU0FBUSxRQUFRQSxTQUFSLEdBQW9CLGVBQTVCO0FBQStDLENBQXJGOztBQUVBLElBQUl1aEQsZUFBZTtBQUNqQkMsUUFBTSwyQkFEVztBQUVqQkMsV0FBUywwQkFGUTtBQUdqQkMsUUFBTUosU0FBUyx3Q0FBVCxDQUhXO0FBSWpCSyxRQUFNTCxTQUFTLGlCQUFULENBSlc7QUFLakJyOUMsU0FBT3E5QyxTQUFTLGtCQUFULENBTFU7QUFNakJNLE9BQUtOLFNBQVMsZ0JBQVQsQ0FOWTtBQU9qQm44QyxRQUFNbThDLFNBQVMsaUJBQVQsQ0FQVztBQVFqQi90QyxRQUFNK3RDLFNBQVMsMkNBQVQsQ0FSVztBQVNqQk8sVUFBUVAsU0FBUywyQ0FBVCxDQVRTO0FBVWpCRixTQUFPRSxTQUFTLDJDQUFUO0FBVlUsQ0FBbkI7O0FBYUEsU0FBU1EsV0FBVCxDQUFzQjVaLE1BQXRCLEVBQThCQyxNQUE5QixFQUFzQztBQUNwQyxNQUFJeGtDLE1BQU13a0MsU0FBUyxZQUFULEdBQXdCLE1BQWxDO0FBQ0EsT0FBSyxJQUFJM3BDLElBQVQsSUFBaUIwcEMsTUFBakIsRUFBeUI7QUFDdkJ2a0MsV0FBTyxPQUFPbkYsSUFBUCxHQUFjLEtBQWQsR0FBdUJ1akQsV0FBV3ZqRCxJQUFYLEVBQWlCMHBDLE9BQU8xcEMsSUFBUCxDQUFqQixDQUF2QixHQUF5RCxHQUFoRTtBQUNEO0FBQ0QsU0FBT21GLElBQUllLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7O0FBRUQsU0FBU3E5QyxVQUFULENBQ0V2akQsSUFERixFQUVFbUosT0FGRixFQUdFO0FBQ0EsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixXQUFPLGNBQVA7QUFDRDs7QUFFRCxNQUFJMUssTUFBTW1ILE9BQU4sQ0FBY3VELE9BQWQsQ0FBSixFQUE0QjtBQUMxQixXQUFRLE1BQU9BLFFBQVFuRCxHQUFSLENBQVksVUFBVW1ELE9BQVYsRUFBbUI7QUFBRSxhQUFPbzZDLFdBQVd2akQsSUFBWCxFQUFpQm1KLE9BQWpCLENBQVA7QUFBbUMsS0FBcEUsRUFBc0V4RCxJQUF0RSxDQUEyRSxHQUEzRSxDQUFQLEdBQTBGLEdBQWxHO0FBQ0Q7O0FBRUQsTUFBSTY5QyxlQUFlakIsYUFBYWo0QyxJQUFiLENBQWtCbkIsUUFBUXZJLEtBQTFCLENBQW5CO0FBQ0EsTUFBSTZpRCx1QkFBdUJuQixRQUFRaDRDLElBQVIsQ0FBYW5CLFFBQVF2SSxLQUFyQixDQUEzQjs7QUFFQSxNQUFJLENBQUN1SSxRQUFRaStCLFNBQWIsRUFBd0I7QUFDdEIsV0FBT29jLGdCQUFnQkMsb0JBQWhCLEdBQ0h0NkMsUUFBUXZJLEtBREwsR0FFRixzQkFBdUJ1SSxRQUFRdkksS0FBL0IsR0FBd0MsR0FGN0MsQ0FEc0IsQ0FHNEI7QUFDbkQsR0FKRCxNQUlPO0FBQ0wsUUFBSTByQyxPQUFPLEVBQVg7QUFDQSxRQUFJb1gsa0JBQWtCLEVBQXRCO0FBQ0EsUUFBSTM5QyxPQUFPLEVBQVg7QUFDQSxTQUFLLElBQUliLEdBQVQsSUFBZ0JpRSxRQUFRaStCLFNBQXhCLEVBQW1DO0FBQ2pDLFVBQUkyYixhQUFhNzlDLEdBQWIsQ0FBSixFQUF1QjtBQUNyQncrQywyQkFBbUJYLGFBQWE3OUMsR0FBYixDQUFuQjtBQUNBO0FBQ0EsWUFBSTRaLFNBQVM1WixHQUFULENBQUosRUFBbUI7QUFDakJhLGVBQUtuSCxJQUFMLENBQVVzRyxHQUFWO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTGEsYUFBS25ILElBQUwsQ0FBVXNHLEdBQVY7QUFDRDtBQUNGO0FBQ0QsUUFBSWEsS0FBSzlILE1BQVQsRUFBaUI7QUFDZnF1QyxjQUFRcVgsYUFBYTU5QyxJQUFiLENBQVI7QUFDRDtBQUNEO0FBQ0EsUUFBSTI5QyxlQUFKLEVBQXFCO0FBQ25CcFgsY0FBUW9YLGVBQVI7QUFDRDtBQUNELFFBQUlFLGNBQWNKLGVBQ2RyNkMsUUFBUXZJLEtBQVIsR0FBZ0IsVUFERixHQUVkNmlELHVCQUNHLE1BQU90NkMsUUFBUXZJLEtBQWYsR0FBd0IsV0FEM0IsR0FFRXVJLFFBQVF2SSxLQUpkO0FBS0EsV0FBUSxzQkFBc0IwckMsSUFBdEIsR0FBNkJzWCxXQUE3QixHQUEyQyxHQUFuRDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0QsWUFBVCxDQUF1QjU5QyxJQUF2QixFQUE2QjtBQUMzQixTQUFRLCtCQUFnQ0EsS0FBS0MsR0FBTCxDQUFTNjlDLGFBQVQsRUFBd0JsK0MsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FBaEMsR0FBc0UsZUFBOUU7QUFDRDs7QUFFRCxTQUFTaytDLGFBQVQsQ0FBd0IzK0MsR0FBeEIsRUFBNkI7QUFDM0IsTUFBSTQrQyxTQUFTQyxTQUFTNytDLEdBQVQsRUFBYyxFQUFkLENBQWI7QUFDQSxNQUFJNCtDLE1BQUosRUFBWTtBQUNWLFdBQVEsc0JBQXNCQSxNQUE5QjtBQUNEO0FBQ0QsTUFBSTUyQyxRQUFRNFIsU0FBUzVaLEdBQVQsQ0FBWjtBQUNBLFNBQVEsdUJBQXdCNkssS0FBS0MsU0FBTCxDQUFlOUssR0FBZixDQUF4QixJQUFnRGdJLFFBQVEsTUFBTTZDLEtBQUtDLFNBQUwsQ0FBZTlDLEtBQWYsQ0FBZCxHQUFzQyxFQUF0RixJQUE0RixHQUFwRztBQUNEOztBQUVEOztBQUVBLFNBQVM4MkMsTUFBVCxDQUFpQmp3QyxFQUFqQixFQUFxQjVULEdBQXJCLEVBQTBCO0FBQ3hCNFQsS0FBR2t3QyxRQUFILEdBQWMsVUFBVTNYLElBQVYsRUFBZ0I7QUFDNUIsV0FBUSxRQUFRQSxJQUFSLEdBQWUsSUFBZixHQUF1QnY0QixHQUFHM0wsR0FBMUIsR0FBaUMsSUFBakMsR0FBeUNqSSxJQUFJUyxLQUE3QyxJQUF1RFQsSUFBSWluQyxTQUFKLElBQWlCam5DLElBQUlpbkMsU0FBSixDQUFjdGUsSUFBL0IsR0FBc0MsT0FBdEMsR0FBZ0QsRUFBdkcsSUFBNkcsR0FBckg7QUFDRCxHQUZEO0FBR0Q7O0FBRUQ7O0FBRUEsSUFBSW83QixpQkFBaUI7QUFDbkIzckMsUUFBTXlyQyxNQURhO0FBRW5CRyxTQUFPNWtEO0FBRlksQ0FBckI7O0FBS0E7O0FBRUE7QUFDQSxJQUFJNmtELE1BQUo7QUFDQSxJQUFJQyxZQUFKO0FBQ0EsSUFBSUMsVUFBSjtBQUNBLElBQUlDLG9CQUFKO0FBQ0EsSUFBSUMsdUJBQUo7QUFDQSxJQUFJN3NCLGVBQUo7QUFDQSxJQUFJOHNCLFNBQUo7QUFDQSxJQUFJQyxjQUFKOztBQUVBLFNBQVNDLFFBQVQsQ0FDRUMsR0FERixFQUVFNTdDLE9BRkYsRUFHRTtBQUNBO0FBQ0EsTUFBSTY3QyxzQkFBc0JsdEIsZUFBMUI7QUFDQSxNQUFJbXRCLHlCQUF5Qm50QixrQkFBa0IsRUFBL0M7QUFDQSxNQUFJb3RCLGdCQUFnQk4sU0FBcEI7QUFDQUEsY0FBWSxDQUFaO0FBQ0FDLG1CQUFpQjE3QyxPQUFqQjtBQUNBbzdDLFdBQVNwN0MsUUFBUXRILElBQVIsSUFBZ0J3bkMsUUFBekI7QUFDQW1iLGlCQUFlbGIsb0JBQW9CbmdDLFFBQVFrVixPQUE1QixFQUFxQyxlQUFyQyxDQUFmO0FBQ0FvbUMsZUFBYW5iLG9CQUFvQm5nQyxRQUFRa1YsT0FBNUIsRUFBcUMsU0FBckMsQ0FBYjtBQUNBcW1DLHlCQUF1QnY3QyxRQUFRK2UsVUFBUixJQUFzQixFQUE3QztBQUNBeThCLDRCQUEwQng3QyxRQUFRK1YsYUFBUixJQUF5QmhCLEVBQW5EO0FBQ0EsTUFBSXV1QixPQUFPc1ksTUFBTUksV0FBV0osR0FBWCxDQUFOLEdBQXdCLFdBQW5DO0FBQ0FqdEIsb0JBQWtCa3RCLG1CQUFsQjtBQUNBSixjQUFZTSxhQUFaO0FBQ0EsU0FBTztBQUNMOWlELFlBQVMsdUJBQXVCcXFDLElBQXZCLEdBQThCLEdBRGxDO0FBRUwzVSxxQkFBaUJtdEI7QUFGWixHQUFQO0FBSUQ7O0FBRUQsU0FBU0UsVUFBVCxDQUFxQmp4QyxFQUFyQixFQUF5QjtBQUN2QixNQUFJQSxHQUFHbXVDLFVBQUgsSUFBaUIsQ0FBQ251QyxHQUFHa3hDLGVBQXpCLEVBQTBDO0FBQ3hDLFdBQU9DLFVBQVVueEMsRUFBVixDQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUlBLEdBQUdyVSxJQUFILElBQVcsQ0FBQ3FVLEdBQUdveEMsYUFBbkIsRUFBa0M7QUFDdkMsV0FBT0MsUUFBUXJ4QyxFQUFSLENBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSUEsR0FBRzBzQyxHQUFILElBQVUsQ0FBQzFzQyxHQUFHc3hDLFlBQWxCLEVBQWdDO0FBQ3JDLFdBQU9DLE9BQU92eEMsRUFBUCxDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlBLEdBQUc4ckMsRUFBSCxJQUFTLENBQUM5ckMsR0FBR3d4QyxXQUFqQixFQUE4QjtBQUNuQyxXQUFPQyxNQUFNenhDLEVBQU4sQ0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJQSxHQUFHM0wsR0FBSCxLQUFXLFVBQVgsSUFBeUIsQ0FBQzJMLEdBQUdxc0MsVUFBakMsRUFBNkM7QUFDbEQsV0FBT3FGLFlBQVkxeEMsRUFBWixLQUFtQixRQUExQjtBQUNELEdBRk0sTUFFQSxJQUFJQSxHQUFHM0wsR0FBSCxLQUFXLE1BQWYsRUFBdUI7QUFDNUIsV0FBT3M5QyxRQUFRM3hDLEVBQVIsQ0FBUDtBQUNELEdBRk0sTUFFQTtBQUNMO0FBQ0EsUUFBSXU0QixJQUFKO0FBQ0EsUUFBSXY0QixHQUFHMVMsU0FBUCxFQUFrQjtBQUNoQmlyQyxhQUFPcVosYUFBYTV4QyxHQUFHMVMsU0FBaEIsRUFBMkIwUyxFQUEzQixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSXpSLE9BQU95UixHQUFHd3JDLEtBQUgsR0FBVzU3QyxTQUFYLEdBQXVCaWlELFFBQVE3eEMsRUFBUixDQUFsQzs7QUFFQSxVQUFJM1IsV0FBVzJSLEdBQUcyakIsY0FBSCxHQUFvQixJQUFwQixHQUEyQit0QixZQUFZMXhDLEVBQVosRUFBZ0IsSUFBaEIsQ0FBMUM7QUFDQXU0QixhQUFPLFNBQVV2NEIsR0FBRzNMLEdBQWIsR0FBb0IsR0FBcEIsSUFBMkI5RixPQUFRLE1BQU1BLElBQWQsR0FBc0IsRUFBakQsS0FBd0RGLFdBQVksTUFBTUEsUUFBbEIsR0FBOEIsRUFBdEYsSUFBNEYsR0FBbkc7QUFDRDtBQUNEO0FBQ0EsU0FBSyxJQUFJekQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMGxELGFBQWFwbUQsTUFBakMsRUFBeUNVLEdBQXpDLEVBQThDO0FBQzVDMnRDLGFBQU8rWCxhQUFhMWxELENBQWIsRUFBZ0JvVixFQUFoQixFQUFvQnU0QixJQUFwQixDQUFQO0FBQ0Q7QUFDRCxXQUFPQSxJQUFQO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFNBQVM0WSxTQUFULENBQW9CbnhDLEVBQXBCLEVBQXdCO0FBQ3RCQSxLQUFHa3hDLGVBQUgsR0FBcUIsSUFBckI7QUFDQXR0QixrQkFBZ0IvNEIsSUFBaEIsQ0FBc0IsdUJBQXdCb21ELFdBQVdqeEMsRUFBWCxDQUF4QixHQUEwQyxHQUFoRTtBQUNBLFNBQVEsU0FBUzRqQixnQkFBZ0IxNUIsTUFBaEIsR0FBeUIsQ0FBbEMsS0FBd0M4VixHQUFHa3VDLFdBQUgsR0FBaUIsT0FBakIsR0FBMkIsRUFBbkUsSUFBeUUsR0FBakY7QUFDRDs7QUFFRDtBQUNBLFNBQVNtRCxPQUFULENBQWtCcnhDLEVBQWxCLEVBQXNCO0FBQ3BCQSxLQUFHb3hDLGFBQUgsR0FBbUIsSUFBbkI7QUFDQSxNQUFJcHhDLEdBQUc4ckMsRUFBSCxJQUFTLENBQUM5ckMsR0FBR3d4QyxXQUFqQixFQUE4QjtBQUM1QixXQUFPQyxNQUFNenhDLEVBQU4sQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJQSxHQUFHa3VDLFdBQVAsRUFBb0I7QUFDekIsUUFBSS84QyxNQUFNLEVBQVY7QUFDQSxRQUFJN0MsU0FBUzBSLEdBQUcxUixNQUFoQjtBQUNBLFdBQU9BLE1BQVAsRUFBZTtBQUNiLFVBQUlBLE9BQU9vK0MsR0FBWCxFQUFnQjtBQUNkdjdDLGNBQU03QyxPQUFPNkMsR0FBYjtBQUNBO0FBQ0Q7QUFDRDdDLGVBQVNBLE9BQU9BLE1BQWhCO0FBQ0Q7QUFDRCxRQUFJLENBQUM2QyxHQUFMLEVBQVU7QUFDUnRJLGNBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDbS9DLE9BQ3ZDLHNEQUR1QyxDQUF6QztBQUdBLGFBQU9ZLFdBQVdqeEMsRUFBWCxDQUFQO0FBQ0Q7QUFDRCxXQUFRLFFBQVNpeEMsV0FBV2p4QyxFQUFYLENBQVQsR0FBMkIsR0FBM0IsR0FBa0Mwd0MsV0FBbEMsSUFBa0R2L0MsTUFBTyxNQUFNQSxHQUFiLEdBQW9CLEVBQXRFLElBQTRFLEdBQXBGO0FBQ0QsR0FqQk0sTUFpQkE7QUFDTCxXQUFPZ2dELFVBQVVueEMsRUFBVixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTeXhDLEtBQVQsQ0FBZ0J6eEMsRUFBaEIsRUFBb0I7QUFDbEJBLEtBQUd3eEMsV0FBSCxHQUFpQixJQUFqQixDQURrQixDQUNLO0FBQ3ZCLFNBQU9NLGdCQUFnQjl4QyxHQUFHK3NDLFlBQUgsQ0FBZ0I1NkMsS0FBaEIsRUFBaEIsQ0FBUDtBQUNEOztBQUVELFNBQVMyL0MsZUFBVCxDQUEwQkMsVUFBMUIsRUFBc0M7QUFDcEMsTUFBSSxDQUFDQSxXQUFXN25ELE1BQWhCLEVBQXdCO0FBQ3RCLFdBQU8sTUFBUDtBQUNEOztBQUVELE1BQUl1RCxZQUFZc2tELFdBQVdyZ0QsS0FBWCxFQUFoQjtBQUNBLE1BQUlqRSxVQUFVOG1DLEdBQWQsRUFBbUI7QUFDakIsV0FBUSxNQUFPOW1DLFVBQVU4bUMsR0FBakIsR0FBd0IsSUFBeEIsR0FBZ0N5ZCxjQUFjdmtELFVBQVV5K0MsS0FBeEIsQ0FBaEMsR0FBa0UsR0FBbEUsR0FBeUU0RixnQkFBZ0JDLFVBQWhCLENBQWpGO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBUSxLQUFNQyxjQUFjdmtELFVBQVV5K0MsS0FBeEIsQ0FBZDtBQUNEOztBQUVEO0FBQ0EsV0FBUzhGLGFBQVQsQ0FBd0JoeUMsRUFBeEIsRUFBNEI7QUFDMUIsV0FBT0EsR0FBR3JVLElBQUgsR0FBVTBsRCxRQUFRcnhDLEVBQVIsQ0FBVixHQUF3Qml4QyxXQUFXanhDLEVBQVgsQ0FBL0I7QUFDRDtBQUNGOztBQUVELFNBQVN1eEMsTUFBVCxDQUFpQnZ4QyxFQUFqQixFQUFxQjtBQUNuQixNQUFJdTBCLE1BQU12MEIsR0FBRzBzQyxHQUFiO0FBQ0EsTUFBSXZ6QyxRQUFRNkcsR0FBRzdHLEtBQWY7QUFDQSxNQUFJeXpDLFlBQVk1c0MsR0FBRzRzQyxTQUFILEdBQWdCLE1BQU81c0MsR0FBRzRzQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBLE1BQUlDLFlBQVk3c0MsR0FBRzZzQyxTQUFILEdBQWdCLE1BQU83c0MsR0FBRzZzQyxTQUExQixHQUF3QyxFQUF4RDs7QUFFQSxNQUNFaGtELFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQ0ErZ0QsZUFBZWp5QyxFQUFmLENBREEsSUFDc0JBLEdBQUczTCxHQUFILEtBQVcsTUFEakMsSUFDMkMyTCxHQUFHM0wsR0FBSCxLQUFXLFVBRHRELElBQ29FLENBQUMyTCxHQUFHN08sR0FGMUUsRUFHRTtBQUNBay9DLFdBQ0UsTUFBT3J3QyxHQUFHM0wsR0FBVixHQUFpQixXQUFqQixHQUErQjhFLEtBQS9CLEdBQXVDLE1BQXZDLEdBQWdEbzdCLEdBQWhELEdBQXNELHFDQUF0RCxHQUNBLG1DQURBLEdBRUEsMERBSEYsRUFJRSxJQUpGLENBSU87QUFKUDtBQU1EOztBQUVEdjBCLEtBQUdzeEMsWUFBSCxHQUFrQixJQUFsQixDQWxCbUIsQ0FrQks7QUFDeEIsU0FBTyxTQUFTL2MsR0FBVCxHQUFlLElBQWYsR0FDTCxXQURLLEdBQ1NwN0IsS0FEVCxHQUNpQnl6QyxTQURqQixHQUM2QkMsU0FEN0IsR0FDeUMsSUFEekMsR0FFSCxTQUZHLEdBRVVvRSxXQUFXanhDLEVBQVgsQ0FGVixHQUdMLElBSEY7QUFJRDs7QUFFRCxTQUFTNnhDLE9BQVQsQ0FBa0I3eEMsRUFBbEIsRUFBc0I7QUFDcEIsTUFBSXpSLE9BQU8sR0FBWDs7QUFFQTtBQUNBO0FBQ0EsTUFBSXdsQixPQUFPbStCLGNBQWNseUMsRUFBZCxDQUFYO0FBQ0EsTUFBSStULElBQUosRUFBVTtBQUFFeGxCLFlBQVF3bEIsT0FBTyxHQUFmO0FBQXFCOztBQUVqQztBQUNBLE1BQUkvVCxHQUFHN08sR0FBUCxFQUFZO0FBQ1Y1QyxZQUFRLFNBQVV5UixHQUFHN08sR0FBYixHQUFvQixHQUE1QjtBQUNEO0FBQ0Q7QUFDQSxNQUFJNk8sR0FBRzVSLEdBQVAsRUFBWTtBQUNWRyxZQUFRLFNBQVV5UixHQUFHNVIsR0FBYixHQUFvQixHQUE1QjtBQUNEO0FBQ0QsTUFBSTRSLEdBQUd1dEIsUUFBUCxFQUFpQjtBQUNmaC9CLFlBQVEsZ0JBQVI7QUFDRDtBQUNEO0FBQ0EsTUFBSXlSLEdBQUc2dUIsR0FBUCxFQUFZO0FBQ1Z0Z0MsWUFBUSxXQUFSO0FBQ0Q7QUFDRDtBQUNBLE1BQUl5UixHQUFHMVMsU0FBUCxFQUFrQjtBQUNoQmlCLFlBQVEsV0FBWXlSLEdBQUczTCxHQUFmLEdBQXNCLEtBQTlCO0FBQ0Q7QUFDRDtBQUNBLE9BQUssSUFBSXpKLElBQUksQ0FBYixFQUFnQkEsSUFBSTJsRCxXQUFXcm1ELE1BQS9CLEVBQXVDVSxHQUF2QyxFQUE0QztBQUMxQzJELFlBQVFnaUQsV0FBVzNsRCxDQUFYLEVBQWNvVixFQUFkLENBQVI7QUFDRDtBQUNEO0FBQ0EsTUFBSUEsR0FBR3hLLEtBQVAsRUFBYztBQUNaakgsWUFBUSxZQUFhNGpELFNBQVNueUMsR0FBR3hLLEtBQVosQ0FBYixHQUFtQyxJQUEzQztBQUNEO0FBQ0Q7QUFDQSxNQUFJd0ssR0FBR2pTLEtBQVAsRUFBYztBQUNaUSxZQUFRLGVBQWdCNGpELFNBQVNueUMsR0FBR2pTLEtBQVosQ0FBaEIsR0FBc0MsSUFBOUM7QUFDRDtBQUNEO0FBQ0EsTUFBSWlTLEdBQUcyMUIsTUFBUCxFQUFlO0FBQ2JwbkMsWUFBU2doRCxZQUFZdnZDLEdBQUcyMUIsTUFBZixDQUFELEdBQTJCLEdBQW5DO0FBQ0Q7QUFDRCxNQUFJMzFCLEdBQUc2MUIsWUFBUCxFQUFxQjtBQUNuQnRuQyxZQUFTZ2hELFlBQVl2dkMsR0FBRzYxQixZQUFmLEVBQTZCLElBQTdCLENBQUQsR0FBdUMsR0FBL0M7QUFDRDtBQUNEO0FBQ0EsTUFBSTcxQixHQUFHcXNDLFVBQVAsRUFBbUI7QUFDakI5OUMsWUFBUSxVQUFXeVIsR0FBR3FzQyxVQUFkLEdBQTRCLEdBQXBDO0FBQ0Q7QUFDRDtBQUNBLE1BQUlyc0MsR0FBR3VkLFdBQVAsRUFBb0I7QUFDbEJodkIsWUFBUzZqRCxlQUFlcHlDLEdBQUd1ZCxXQUFsQixDQUFELEdBQW1DLEdBQTNDO0FBQ0Q7QUFDRDtBQUNBLE1BQUl2ZCxHQUFHZ2pCLEtBQVAsRUFBYztBQUNaejBCLFlBQVEsa0JBQW1CeVIsR0FBR2dqQixLQUFILENBQVNuMkIsS0FBNUIsR0FBcUMsWUFBckMsR0FBcURtVCxHQUFHZ2pCLEtBQUgsQ0FBU3lCLFFBQTlELEdBQTBFLGNBQTFFLEdBQTRGemtCLEdBQUdnakIsS0FBSCxDQUFTeEUsVUFBckcsR0FBbUgsSUFBM0g7QUFDRDtBQUNEO0FBQ0EsTUFBSXhlLEdBQUcyakIsY0FBUCxFQUF1QjtBQUNyQixRQUFJQSxpQkFBaUIwdUIsa0JBQWtCcnlDLEVBQWxCLENBQXJCO0FBQ0EsUUFBSTJqQixjQUFKLEVBQW9CO0FBQ2xCcDFCLGNBQVFvMUIsaUJBQWlCLEdBQXpCO0FBQ0Q7QUFDRjtBQUNEcDFCLFNBQU9BLEtBQUttQyxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixJQUF5QixHQUFoQztBQUNBO0FBQ0EsTUFBSXNQLEdBQUdrd0MsUUFBUCxFQUFpQjtBQUNmM2hELFdBQU95UixHQUFHa3dDLFFBQUgsQ0FBWTNoRCxJQUFaLENBQVA7QUFDRDtBQUNELFNBQU9BLElBQVA7QUFDRDs7QUFFRCxTQUFTMmpELGFBQVQsQ0FBd0JseUMsRUFBeEIsRUFBNEI7QUFDMUIsTUFBSStULE9BQU8vVCxHQUFHZ1UsVUFBZDtBQUNBLE1BQUksQ0FBQ0QsSUFBTCxFQUFXO0FBQUU7QUFBUTtBQUNyQixNQUFJM2lCLE1BQU0sY0FBVjtBQUNBLE1BQUlraEQsYUFBYSxLQUFqQjtBQUNBLE1BQUkxbkQsQ0FBSixFQUFPMmUsQ0FBUCxFQUFVbmQsR0FBVixFQUFlbW1ELFdBQWY7QUFDQSxPQUFLM25ELElBQUksQ0FBSixFQUFPMmUsSUFBSXdLLEtBQUs3cEIsTUFBckIsRUFBNkJVLElBQUkyZSxDQUFqQyxFQUFvQzNlLEdBQXBDLEVBQXlDO0FBQ3ZDd0IsVUFBTTJuQixLQUFLbnBCLENBQUwsQ0FBTjtBQUNBMm5ELGtCQUFjLElBQWQ7QUFDQSxRQUFJQyxNQUFNaEMscUJBQXFCcGtELElBQUlILElBQXpCLEtBQWtDa2tELGVBQWUvakQsSUFBSUgsSUFBbkIsQ0FBNUM7QUFDQSxRQUFJdW1ELEdBQUosRUFBUztBQUNQO0FBQ0E7QUFDQUQsb0JBQWMsQ0FBQyxDQUFDQyxJQUFJeHlDLEVBQUosRUFBUTVULEdBQVIsRUFBYWlrRCxNQUFiLENBQWhCO0FBQ0Q7QUFDRCxRQUFJa0MsV0FBSixFQUFpQjtBQUNmRCxtQkFBYSxJQUFiO0FBQ0FsaEQsYUFBTyxhQUFjaEYsSUFBSUgsSUFBbEIsR0FBMEIsZUFBMUIsR0FBNkNHLElBQUltbkMsT0FBakQsR0FBNEQsSUFBNUQsSUFBb0VubkMsSUFBSVMsS0FBSixHQUFhLGFBQWNULElBQUlTLEtBQWxCLEdBQTJCLGVBQTNCLEdBQThDbVAsS0FBS0MsU0FBTCxDQUFlN1AsSUFBSVMsS0FBbkIsQ0FBM0QsR0FBeUYsRUFBN0osS0FBb0tULElBQUlvcEMsR0FBSixHQUFXLFlBQWFwcEMsSUFBSW9wQyxHQUFqQixHQUF3QixJQUFuQyxHQUEyQyxFQUEvTSxLQUFzTnBwQyxJQUFJaW5DLFNBQUosR0FBaUIsZ0JBQWlCcjNCLEtBQUtDLFNBQUwsQ0FBZTdQLElBQUlpbkMsU0FBbkIsQ0FBbEMsR0FBb0UsRUFBMVIsSUFBZ1MsSUFBdlM7QUFDRDtBQUNGO0FBQ0QsTUFBSWlmLFVBQUosRUFBZ0I7QUFDZCxXQUFPbGhELElBQUllLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTa2dELGlCQUFULENBQTRCcnlDLEVBQTVCLEVBQWdDO0FBQzlCLE1BQUk2d0MsTUFBTTd3QyxHQUFHM1IsUUFBSCxDQUFZLENBQVosQ0FBVjtBQUNBLE1BQUl4RixRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixLQUNGOE8sR0FBRzNSLFFBQUgsQ0FBWW5FLE1BQVosR0FBcUIsQ0FBckIsSUFBMEIybUQsSUFBSTdpRCxJQUFKLEtBQWEsQ0FEckMsQ0FBSixFQUVHO0FBQ0RxaUQsV0FBTyxpRUFBUDtBQUNEO0FBQ0QsTUFBSVEsSUFBSTdpRCxJQUFKLEtBQWEsQ0FBakIsRUFBb0I7QUFDbEIsUUFBSXlrRCxrQkFBa0I3QixTQUFTQyxHQUFULEVBQWNGLGNBQWQsQ0FBdEI7QUFDQSxXQUFRLHVDQUF3QzhCLGdCQUFnQnZrRCxNQUF4RCxHQUFrRSxxQkFBbEUsR0FBMkZ1a0QsZ0JBQWdCN3VCLGVBQWhCLENBQWdDM3hCLEdBQWhDLENBQW9DLFVBQVVzbUMsSUFBVixFQUFnQjtBQUFFLGFBQVEsZ0JBQWdCQSxJQUFoQixHQUF1QixHQUEvQjtBQUFzQyxLQUE1RixFQUE4RjNtQyxJQUE5RixDQUFtRyxHQUFuRyxDQUEzRixHQUFzTSxJQUE5TTtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3dnRCxjQUFULENBQXlCejNCLEtBQXpCLEVBQWdDO0FBQzlCLFNBQVEscUJBQXNCaHVCLE9BQU9xRixJQUFQLENBQVkyb0IsS0FBWixFQUFtQjFvQixHQUFuQixDQUF1QixVQUFVZCxHQUFWLEVBQWU7QUFBRSxXQUFPdWhELGNBQWN2aEQsR0FBZCxFQUFtQndwQixNQUFNeHBCLEdBQU4sQ0FBbkIsQ0FBUDtBQUF3QyxHQUFoRixFQUFrRlMsSUFBbEYsQ0FBdUYsR0FBdkYsQ0FBdEIsR0FBcUgsSUFBN0g7QUFDRDs7QUFFRCxTQUFTOGdELGFBQVQsQ0FBd0J2aEQsR0FBeEIsRUFBNkI2TyxFQUE3QixFQUFpQztBQUMvQixTQUFPLE1BQU03TyxHQUFOLEdBQVksWUFBWixHQUE0QmxELE9BQU8rUixHQUFHbzJCLFFBQUgsQ0FBWXVjLEtBQW5CLENBQTVCLEdBQXlELElBQXpELEdBQ0wsU0FESyxJQUNRM3lDLEdBQUczTCxHQUFILEtBQVcsVUFBWCxHQUNUcTlDLFlBQVkxeEMsRUFBWixLQUFtQixRQURWLEdBRVRpeEMsV0FBV2p4QyxFQUFYLENBSEMsSUFHaUIsSUFIeEI7QUFJRDs7QUFFRCxTQUFTMHhDLFdBQVQsQ0FBc0IxeEMsRUFBdEIsRUFBMEI0eUMsU0FBMUIsRUFBcUM7QUFDbkMsTUFBSXZrRCxXQUFXMlIsR0FBRzNSLFFBQWxCO0FBQ0EsTUFBSUEsU0FBU25FLE1BQWIsRUFBcUI7QUFDbkIsUUFBSTJvRCxPQUFPeGtELFNBQVMsQ0FBVCxDQUFYO0FBQ0E7QUFDQSxRQUFJQSxTQUFTbkUsTUFBVCxLQUFvQixDQUFwQixJQUNBMm9ELEtBQUtuRyxHQURMLElBRUFtRyxLQUFLeCtDLEdBQUwsS0FBYSxVQUZiLElBR0F3K0MsS0FBS3grQyxHQUFMLEtBQWEsTUFIakIsRUFHeUI7QUFDdkIsYUFBTzQ4QyxXQUFXNEIsSUFBWCxDQUFQO0FBQ0Q7QUFDRCxRQUFJanVCLG9CQUFvQmd1QixZQUFZRSxxQkFBcUJ6a0QsUUFBckIsQ0FBWixHQUE2QyxDQUFyRTtBQUNBLFdBQVEsTUFBT0EsU0FBUzRELEdBQVQsQ0FBYThnRCxPQUFiLEVBQXNCbmhELElBQXRCLENBQTJCLEdBQTNCLENBQVAsR0FBMEMsR0FBMUMsSUFBaURnekIsb0JBQXFCLE1BQU1BLGlCQUEzQixHQUFnRCxFQUFqRyxDQUFSO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrdUIsb0JBQVQsQ0FBK0J6a0QsUUFBL0IsRUFBeUM7QUFDdkMsTUFBSStDLE1BQU0sQ0FBVjtBQUNBLE9BQUssSUFBSXhHLElBQUksQ0FBYixFQUFnQkEsSUFBSXlELFNBQVNuRSxNQUE3QixFQUFxQ1UsR0FBckMsRUFBMEM7QUFDeEMsUUFBSW9WLEtBQUszUixTQUFTekQsQ0FBVCxDQUFUO0FBQ0EsUUFBSW9WLEdBQUdoUyxJQUFILEtBQVksQ0FBaEIsRUFBbUI7QUFDakI7QUFDRDtBQUNELFFBQUlnbEQsbUJBQW1CaHpDLEVBQW5CLEtBQ0NBLEdBQUcrc0MsWUFBSCxJQUFtQi9zQyxHQUFHK3NDLFlBQUgsQ0FBZ0I5ekMsSUFBaEIsQ0FBcUIsVUFBVTlJLENBQVYsRUFBYTtBQUFFLGFBQU82aUQsbUJBQW1CN2lELEVBQUUrN0MsS0FBckIsQ0FBUDtBQUFxQyxLQUF6RSxDQUR4QixFQUNxRztBQUNuRzk2QyxZQUFNLENBQU47QUFDQTtBQUNEO0FBQ0QsUUFBSTZnRCxlQUFlanlDLEVBQWYsS0FDQ0EsR0FBRytzQyxZQUFILElBQW1CL3NDLEdBQUcrc0MsWUFBSCxDQUFnQjl6QyxJQUFoQixDQUFxQixVQUFVOUksQ0FBVixFQUFhO0FBQUUsYUFBTzhoRCxlQUFlOWhELEVBQUUrN0MsS0FBakIsQ0FBUDtBQUFpQyxLQUFyRSxDQUR4QixFQUNpRztBQUMvRjk2QyxZQUFNLENBQU47QUFDRDtBQUNGO0FBQ0QsU0FBT0EsR0FBUDtBQUNEOztBQUVELFNBQVM0aEQsa0JBQVQsQ0FBNkJoekMsRUFBN0IsRUFBaUM7QUFDL0IsU0FBT0EsR0FBRzBzQyxHQUFILEtBQVc5OEMsU0FBWCxJQUF3Qm9RLEdBQUczTCxHQUFILEtBQVcsVUFBbkMsSUFBaUQyTCxHQUFHM0wsR0FBSCxLQUFXLE1BQW5FO0FBQ0Q7O0FBRUQsU0FBUzQ5QyxjQUFULENBQXlCanlDLEVBQXpCLEVBQTZCO0FBQzNCLFNBQU8sQ0FBQ3l3Qyx3QkFBd0J6d0MsR0FBRzNMLEdBQTNCLENBQVI7QUFDRDs7QUFFRCxTQUFTMCtDLE9BQVQsQ0FBa0JoN0IsSUFBbEIsRUFBd0I7QUFDdEIsTUFBSUEsS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsV0FBT2lqRCxXQUFXbDVCLElBQVgsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9rN0IsUUFBUWw3QixJQUFSLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNrN0IsT0FBVCxDQUFrQjk3QixJQUFsQixFQUF3QjtBQUN0QixTQUFRLFNBQVNBLEtBQUtucEIsSUFBTCxLQUFjLENBQWQsR0FDYm1wQixLQUFLcUgsVUFEUSxDQUNHO0FBREgsSUFFYjAwQix5QkFBeUJsM0MsS0FBS0MsU0FBTCxDQUFla2IsS0FBS0EsSUFBcEIsQ0FBekIsQ0FGSSxJQUVtRCxHQUYzRDtBQUdEOztBQUVELFNBQVN3NkIsT0FBVCxDQUFrQjN4QyxFQUFsQixFQUFzQjtBQUNwQixNQUFJZ3RDLFdBQVdodEMsR0FBR2d0QyxRQUFILElBQWUsV0FBOUI7QUFDQSxNQUFJMytDLFdBQVdxakQsWUFBWTF4QyxFQUFaLENBQWY7QUFDQSxNQUFJNU8sTUFBTSxRQUFRNDdDLFFBQVIsSUFBb0IzK0MsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUFsRCxDQUFWO0FBQ0EsTUFBSW1ILFFBQVF3SyxHQUFHeEssS0FBSCxJQUFhLE1BQU93SyxHQUFHeEssS0FBSCxDQUFTdkQsR0FBVCxDQUFhLFVBQVVvQixDQUFWLEVBQWE7QUFBRSxXQUFTNFYsU0FBUzVWLEVBQUVwSCxJQUFYLENBQUQsR0FBcUIsR0FBckIsR0FBNEJvSCxFQUFFeEcsS0FBdEM7QUFBZ0QsR0FBNUUsRUFBOEUrRSxJQUE5RSxDQUFtRixHQUFuRixDQUFQLEdBQWtHLEdBQTNIO0FBQ0EsTUFBSXVoRCxVQUFVbnpDLEdBQUdvMkIsUUFBSCxDQUFZLFFBQVosQ0FBZDtBQUNBLE1BQUksQ0FBQzVnQyxTQUFTMjlDLE9BQVYsS0FBc0IsQ0FBQzlrRCxRQUEzQixFQUFxQztBQUNuQytDLFdBQU8sT0FBUDtBQUNEO0FBQ0QsTUFBSW9FLEtBQUosRUFBVztBQUNUcEUsV0FBTyxNQUFNb0UsS0FBYjtBQUNEO0FBQ0QsTUFBSTI5QyxPQUFKLEVBQWE7QUFDWC9oRCxXQUFPLENBQUNvRSxRQUFRLEVBQVIsR0FBYSxPQUFkLElBQXlCLEdBQXpCLEdBQStCMjlDLE9BQXRDO0FBQ0Q7QUFDRCxTQUFPL2hELE1BQU0sR0FBYjtBQUNEOztBQUVEO0FBQ0EsU0FBU3dnRCxZQUFULENBQXVCd0IsYUFBdkIsRUFBc0NwekMsRUFBdEMsRUFBMEM7QUFDeEMsTUFBSTNSLFdBQVcyUixHQUFHMmpCLGNBQUgsR0FBb0IsSUFBcEIsR0FBMkIrdEIsWUFBWTF4QyxFQUFaLEVBQWdCLElBQWhCLENBQTFDO0FBQ0EsU0FBUSxRQUFRb3pDLGFBQVIsR0FBd0IsR0FBeEIsR0FBK0J2QixRQUFRN3hDLEVBQVIsQ0FBL0IsSUFBK0MzUixXQUFZLE1BQU1BLFFBQWxCLEdBQThCLEVBQTdFLElBQW1GLEdBQTNGO0FBQ0Q7O0FBRUQsU0FBUzhqRCxRQUFULENBQW1CcGtELEtBQW5CLEVBQTBCO0FBQ3hCLE1BQUlxRCxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUl4RyxJQUFJLENBQWIsRUFBZ0JBLElBQUltRCxNQUFNN0QsTUFBMUIsRUFBa0NVLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUltcUIsT0FBT2huQixNQUFNbkQsQ0FBTixDQUFYO0FBQ0F3RyxXQUFPLE9BQVEyakIsS0FBSzlvQixJQUFiLEdBQXFCLEtBQXJCLEdBQThCaW5ELHlCQUF5Qm4rQixLQUFLbG9CLEtBQTlCLENBQTlCLEdBQXNFLEdBQTdFO0FBQ0Q7QUFDRCxTQUFPdUUsSUFBSWUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsU0FBUytnRCx3QkFBVCxDQUFtQy83QixJQUFuQyxFQUF5QztBQUN2QyxTQUFPQSxLQUNKem1CLE9BREksQ0FDSSxTQURKLEVBQ2UsU0FEZixFQUVKQSxPQUZJLENBRUksU0FGSixFQUVlLFNBRmYsQ0FBUDtBQUdEOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxJQUFJMmlELHNCQUFzQixJQUFJbjVDLE1BQUosQ0FBVyxRQUFRLENBQzNDLDRFQUNBLHFFQURBLEdBRUEsc0RBSDJDLEVBSTNDNUksS0FKMkMsQ0FJckMsR0FKcUMsRUFJaENNLElBSmdDLENBSTNCLFNBSjJCLENBQVIsR0FJTixLQUpMLENBQTFCOztBQU1BO0FBQ0EsSUFBSTBoRCxtQkFBbUIsSUFBSXA1QyxNQUFKLENBQVcsUUFDaEMsb0JBRHdDLENBRXhDNUksS0FGd0MsQ0FFbEMsR0FGa0MsRUFFN0JNLElBRjZCLENBRXhCLHVCQUZ3QixDQUFSLEdBRVcsbUJBRnRCLENBQXZCOztBQUlBO0FBQ0EsSUFBSTJoRCxVQUFVLGtCQUFkOztBQUVBO0FBQ0EsSUFBSUMsZ0JBQWdCLGdHQUFwQjs7QUFFQTtBQUNBLFNBQVNDLFlBQVQsQ0FBdUI1QyxHQUF2QixFQUE0QjtBQUMxQixNQUFJNkMsU0FBUyxFQUFiO0FBQ0EsTUFBSTdDLEdBQUosRUFBUztBQUNQOEMsY0FBVTlDLEdBQVYsRUFBZTZDLE1BQWY7QUFDRDtBQUNELFNBQU9BLE1BQVA7QUFDRDs7QUFFRCxTQUFTQyxTQUFULENBQW9CNTdCLElBQXBCLEVBQTBCMjdCLE1BQTFCLEVBQWtDO0FBQ2hDLE1BQUkzN0IsS0FBSy9wQixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsU0FBSyxJQUFJL0IsSUFBVCxJQUFpQjhyQixLQUFLcWUsUUFBdEIsRUFBZ0M7QUFDOUIsVUFBSW9ULE1BQU1qekMsSUFBTixDQUFXdEssSUFBWCxDQUFKLEVBQXNCO0FBQ3BCLFlBQUlZLFFBQVFrckIsS0FBS3FlLFFBQUwsQ0FBY25xQyxJQUFkLENBQVo7QUFDQSxZQUFJWSxLQUFKLEVBQVc7QUFDVCxjQUFJWixTQUFTLE9BQWIsRUFBc0I7QUFDcEIybkQscUJBQVM3N0IsSUFBVCxFQUFnQixhQUFhbHJCLEtBQWIsR0FBcUIsSUFBckMsRUFBNEM2bUQsTUFBNUM7QUFDRCxXQUZELE1BRU8sSUFBSW5LLEtBQUtoekMsSUFBTCxDQUFVdEssSUFBVixDQUFKLEVBQXFCO0FBQzFCNG5ELHVCQUFXaG5ELEtBQVgsRUFBbUJaLE9BQU8sS0FBUCxHQUFlWSxLQUFmLEdBQXVCLElBQTFDLEVBQWlENm1ELE1BQWpEO0FBQ0QsV0FGTSxNQUVBO0FBQ0xJLDRCQUFnQmpuRCxLQUFoQixFQUF3QlosT0FBTyxLQUFQLEdBQWVZLEtBQWYsR0FBdUIsSUFBL0MsRUFBc0Q2bUQsTUFBdEQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNELFFBQUkzN0IsS0FBSzFwQixRQUFULEVBQW1CO0FBQ2pCLFdBQUssSUFBSXpELElBQUksQ0FBYixFQUFnQkEsSUFBSW10QixLQUFLMXBCLFFBQUwsQ0FBY25FLE1BQWxDLEVBQTBDVSxHQUExQyxFQUErQztBQUM3QytvRCxrQkFBVTU3QixLQUFLMXBCLFFBQUwsQ0FBY3pELENBQWQsQ0FBVixFQUE0QjhvRCxNQUE1QjtBQUNEO0FBQ0Y7QUFDRixHQXBCRCxNQW9CTyxJQUFJMzdCLEtBQUsvcEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQzFCOGxELG9CQUFnQi83QixLQUFLeUcsVUFBckIsRUFBaUN6RyxLQUFLWixJQUF0QyxFQUE0Q3U4QixNQUE1QztBQUNEO0FBQ0Y7O0FBRUQsU0FBU0csVUFBVCxDQUFxQnRmLEdBQXJCLEVBQTBCcGQsSUFBMUIsRUFBZ0N1OEIsTUFBaEMsRUFBd0M7QUFDdEMsTUFBSUssZUFBZXhmLElBQUk3akMsT0FBSixDQUFZOGlELGFBQVosRUFBMkIsRUFBM0IsRUFBK0I5MkMsS0FBL0IsQ0FBcUM0MkMsZ0JBQXJDLENBQW5CO0FBQ0EsTUFBSVMsWUFBSixFQUFrQjtBQUNoQkwsV0FBTzdvRCxJQUFQLENBQ0UsNkRBQ0EsSUFEQSxHQUNRa3BELGFBQWEsQ0FBYixDQURSLEdBQzJCLG1CQUQzQixHQUNrRDU4QixLQUFLOWxCLElBQUwsRUFGcEQ7QUFJRDtBQUNEeWlELGtCQUFnQnZmLEdBQWhCLEVBQXFCcGQsSUFBckIsRUFBMkJ1OEIsTUFBM0I7QUFDRDs7QUFFRCxTQUFTRSxRQUFULENBQW1CNzdCLElBQW5CLEVBQXlCWixJQUF6QixFQUErQnU4QixNQUEvQixFQUF1QztBQUNyQ0ksa0JBQWdCLzdCLEtBQUsyMEIsR0FBTCxJQUFZLEVBQTVCLEVBQWdDdjFCLElBQWhDLEVBQXNDdThCLE1BQXRDO0FBQ0FNLGtCQUFnQmo4QixLQUFLNWUsS0FBckIsRUFBNEIsYUFBNUIsRUFBMkNnZSxJQUEzQyxFQUFpRHU4QixNQUFqRDtBQUNBTSxrQkFBZ0JqOEIsS0FBSzYwQixTQUFyQixFQUFnQyxnQkFBaEMsRUFBa0R6MUIsSUFBbEQsRUFBd0R1OEIsTUFBeEQ7QUFDQU0sa0JBQWdCajhCLEtBQUs4MEIsU0FBckIsRUFBZ0MsZ0JBQWhDLEVBQWtEMTFCLElBQWxELEVBQXdEdThCLE1BQXhEO0FBQ0Q7O0FBRUQsU0FBU00sZUFBVCxDQUEwQkMsS0FBMUIsRUFBaUNqbUQsSUFBakMsRUFBdUNtcEIsSUFBdkMsRUFBNkN1OEIsTUFBN0MsRUFBcUQ7QUFDbkQsTUFBSSxPQUFPTyxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLENBQUNWLFFBQVFoOUMsSUFBUixDQUFhMDlDLEtBQWIsQ0FBbEMsRUFBdUQ7QUFDckRQLFdBQU83b0QsSUFBUCxDQUFhLGFBQWFtRCxJQUFiLEdBQW9CLEtBQXBCLEdBQTRCaW1ELEtBQTVCLEdBQW9DLG9CQUFwQyxHQUE0RDk4QixLQUFLOWxCLElBQUwsRUFBekU7QUFDRDtBQUNGOztBQUVELFNBQVN5aUQsZUFBVCxDQUEwQnZmLEdBQTFCLEVBQStCcGQsSUFBL0IsRUFBcUN1OEIsTUFBckMsRUFBNkM7QUFDM0MsTUFBSTtBQUNGLFFBQUlRLFFBQUosQ0FBYyxZQUFZM2YsR0FBMUI7QUFDRCxHQUZELENBRUUsT0FBT2pyQyxDQUFQLEVBQVU7QUFDVixRQUFJeXFELGVBQWV4ZixJQUFJN2pDLE9BQUosQ0FBWThpRCxhQUFaLEVBQTJCLEVBQTNCLEVBQStCOTJDLEtBQS9CLENBQXFDMjJDLG1CQUFyQyxDQUFuQjtBQUNBLFFBQUlVLFlBQUosRUFBa0I7QUFDaEJMLGFBQU83b0QsSUFBUCxDQUNFLHNEQUNBLElBREEsR0FDUWtwRCxhQUFhLENBQWIsQ0FEUixHQUMyQixtQkFEM0IsR0FDa0Q1OEIsS0FBSzlsQixJQUFMLEVBRnBEO0FBSUQsS0FMRCxNQUtPO0FBQ0xxaUQsYUFBTzdvRCxJQUFQLENBQWEseUJBQTBCc3NCLEtBQUs5bEIsSUFBTCxFQUF2QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxTQUFTOGlELFdBQVQsQ0FDRTVtRCxRQURGLEVBRUUwSCxPQUZGLEVBR0U7QUFDQSxNQUFJNDdDLE1BQU1uM0MsTUFBTW5NLFNBQVM4RCxJQUFULEVBQU4sRUFBdUI0RCxPQUF2QixDQUFWO0FBQ0E2NEMsV0FBUytDLEdBQVQsRUFBYzU3QyxPQUFkO0FBQ0EsTUFBSXNqQyxPQUFPcVksU0FBU0MsR0FBVCxFQUFjNTdDLE9BQWQsQ0FBWDtBQUNBLFNBQU87QUFDTDQ3QyxTQUFLQSxHQURBO0FBRUwzaUQsWUFBUXFxQyxLQUFLcnFDLE1BRlI7QUFHTDAxQixxQkFBaUIyVSxLQUFLM1U7QUFIakIsR0FBUDtBQUtEOztBQUVELFNBQVN3d0IsWUFBVCxDQUF1QjdiLElBQXZCLEVBQTZCbWIsTUFBN0IsRUFBcUM7QUFDbkMsTUFBSTtBQUNGLFdBQU8sSUFBSVEsUUFBSixDQUFhM2IsSUFBYixDQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU9ockIsR0FBUCxFQUFZO0FBQ1ptbUMsV0FBTzdvRCxJQUFQLENBQVksRUFBRTBpQixLQUFLQSxHQUFQLEVBQVlnckIsTUFBTUEsSUFBbEIsRUFBWjtBQUNBLFdBQU8vc0MsSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzZvRCxjQUFULENBQXlCQyxXQUF6QixFQUFzQztBQUNwQyxNQUFJQyx1QkFBdUI1bkQsT0FBTytMLE1BQVAsQ0FBYyxJQUFkLENBQTNCOztBQUVBLFdBQVNrQixPQUFULENBQ0VyTSxRQURGLEVBRUUwSCxPQUZGLEVBR0U7QUFDQSxRQUFJdS9DLGVBQWU3bkQsT0FBTytMLE1BQVAsQ0FBYzQ3QyxXQUFkLENBQW5CO0FBQ0EsUUFBSVosU0FBUyxFQUFiO0FBQ0EsUUFBSWUsT0FBTyxFQUFYO0FBQ0FELGlCQUFhN21ELElBQWIsR0FBb0IsVUFBVW1oQixHQUFWLEVBQWU0bEMsTUFBZixFQUF1QjtBQUN6QyxPQUFDQSxTQUFTRCxJQUFULEdBQWdCZixNQUFqQixFQUF5QjdvRCxJQUF6QixDQUE4QmlrQixHQUE5QjtBQUNELEtBRkQ7O0FBSUEsUUFBSTdaLE9BQUosRUFBYTtBQUNYO0FBQ0EsVUFBSUEsUUFBUWtWLE9BQVosRUFBcUI7QUFDbkJxcUMscUJBQWFycUMsT0FBYixHQUF1QixDQUFDbXFDLFlBQVlucUMsT0FBWixJQUF1QixFQUF4QixFQUE0QmhnQixNQUE1QixDQUFtQzhLLFFBQVFrVixPQUEzQyxDQUF2QjtBQUNEO0FBQ0Q7QUFDQSxVQUFJbFYsUUFBUStlLFVBQVosRUFBd0I7QUFDdEJ3Z0MscUJBQWF4Z0MsVUFBYixHQUEwQnBlLE9BQ3hCakosT0FBTytMLE1BQVAsQ0FBYzQ3QyxZQUFZdGdDLFVBQTFCLENBRHdCLEVBRXhCL2UsUUFBUStlLFVBRmdCLENBQTFCO0FBSUQ7QUFDRDtBQUNBLFdBQUssSUFBSTdpQixHQUFULElBQWdCOEQsT0FBaEIsRUFBeUI7QUFDdkIsWUFBSTlELFFBQVEsU0FBUixJQUFxQkEsUUFBUSxZQUFqQyxFQUErQztBQUM3Q3FqRCx1QkFBYXJqRCxHQUFiLElBQW9COEQsUUFBUTlELEdBQVIsQ0FBcEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSXdqRCxXQUFXUixZQUFZNW1ELFFBQVosRUFBc0JpbkQsWUFBdEIsQ0FBZjtBQUNBLFFBQUkzckQsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN3aUQsYUFBTzdvRCxJQUFQLENBQVlJLEtBQVosQ0FBa0J5b0QsTUFBbEIsRUFBMEJELGFBQWFrQixTQUFTOUQsR0FBdEIsQ0FBMUI7QUFDRDtBQUNEOEQsYUFBU2pCLE1BQVQsR0FBa0JBLE1BQWxCO0FBQ0FpQixhQUFTRixJQUFULEdBQWdCQSxJQUFoQjtBQUNBLFdBQU9FLFFBQVA7QUFDRDs7QUFFRCxXQUFTQyxrQkFBVCxDQUNFcm5ELFFBREYsRUFFRTBILE9BRkYsRUFHRThaLEVBSEYsRUFJRTtBQUNBOVosY0FBVUEsV0FBVyxFQUFyQjs7QUFFQTtBQUNBLFFBQUlwTSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBLFVBQUk7QUFDRixZQUFJZ2pELFFBQUosQ0FBYSxVQUFiO0FBQ0QsT0FGRCxDQUVFLE9BQU81cUQsQ0FBUCxFQUFVO0FBQ1YsWUFBSUEsRUFBRStHLFFBQUYsR0FBYXFNLEtBQWIsQ0FBbUIsaUJBQW5CLENBQUosRUFBMkM7QUFDekMvTyxlQUNFLGlFQUNBLHVFQURBLEdBRUEsa0VBRkEsR0FHQSxpRUFIQSxHQUlBLGtDQUxGO0FBT0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsUUFBSXdELE1BQU04RCxRQUFRZzBDLFVBQVIsR0FDTmg3QyxPQUFPZ0gsUUFBUWcwQyxVQUFmLElBQTZCMTdDLFFBRHZCLEdBRU5BLFFBRko7QUFHQSxRQUFJZ25ELHFCQUFxQnBqRCxHQUFyQixDQUFKLEVBQStCO0FBQzdCLGFBQU9vakQscUJBQXFCcGpELEdBQXJCLENBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUl3akQsV0FBVy82QyxRQUFRck0sUUFBUixFQUFrQjBILE9BQWxCLENBQWY7O0FBRUE7QUFDQSxRQUFJcE0sUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSXlqRCxTQUFTakIsTUFBVCxJQUFtQmlCLFNBQVNqQixNQUFULENBQWdCeHBELE1BQXZDLEVBQStDO0FBQzdDeUQsYUFDRSxrQ0FBa0NKLFFBQWxDLEdBQTZDLE1BQTdDLEdBQ0FvbkQsU0FBU2pCLE1BQVQsQ0FBZ0J6aEQsR0FBaEIsQ0FBb0IsVUFBVTNJLENBQVYsRUFBYTtBQUFFLGlCQUFRLE9BQU9BLENBQWY7QUFBb0IsU0FBdkQsRUFBeURzSSxJQUF6RCxDQUE4RCxJQUE5RCxDQURBLEdBQ3NFLElBRnhFLEVBR0VtZCxFQUhGO0FBS0Q7QUFDRCxVQUFJNGxDLFNBQVNGLElBQVQsSUFBaUJFLFNBQVNGLElBQVQsQ0FBY3ZxRCxNQUFuQyxFQUEyQztBQUN6Q3lxRCxpQkFBU0YsSUFBVCxDQUFjbGpELE9BQWQsQ0FBc0IsVUFBVXVkLEdBQVYsRUFBZTtBQUFFLGlCQUFPTCxJQUFJSyxHQUFKLEVBQVNDLEVBQVQsQ0FBUDtBQUFzQixTQUE3RDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxRQUFJM2QsTUFBTSxFQUFWO0FBQ0EsUUFBSXlqRCxjQUFjLEVBQWxCO0FBQ0F6akQsUUFBSWxELE1BQUosR0FBYWttRCxhQUFhTyxTQUFTem1ELE1BQXRCLEVBQThCMm1ELFdBQTlCLENBQWI7QUFDQSxRQUFJdHJDLElBQUlvckMsU0FBUy93QixlQUFULENBQXlCMTVCLE1BQWpDO0FBQ0FrSCxRQUFJd3lCLGVBQUosR0FBc0IsSUFBSWw1QixLQUFKLENBQVU2ZSxDQUFWLENBQXRCO0FBQ0EsU0FBSyxJQUFJM2UsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMmUsQ0FBcEIsRUFBdUIzZSxHQUF2QixFQUE0QjtBQUMxQndHLFVBQUl3eUIsZUFBSixDQUFvQmg1QixDQUFwQixJQUF5QndwRCxhQUFhTyxTQUFTL3dCLGVBQVQsQ0FBeUJoNUIsQ0FBekIsQ0FBYixFQUEwQ2lxRCxXQUExQyxDQUF6QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWhzRCxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJLENBQUMsQ0FBQ3lqRCxTQUFTakIsTUFBVixJQUFvQixDQUFDaUIsU0FBU2pCLE1BQVQsQ0FBZ0J4cEQsTUFBdEMsS0FBaUQycUQsWUFBWTNxRCxNQUFqRSxFQUF5RTtBQUN2RXlELGFBQ0UsNENBQ0FrbkQsWUFBWTVpRCxHQUFaLENBQWdCLFVBQVU3RCxHQUFWLEVBQWU7QUFDN0IsY0FBSW1mLE1BQU1uZixJQUFJbWYsR0FBZDtBQUNBLGNBQUlnckIsT0FBT25xQyxJQUFJbXFDLElBQWY7O0FBRUEsaUJBQVNockIsSUFBSWxkLFFBQUosRUFBRCxHQUFtQixTQUFuQixHQUErQmtvQyxJQUEvQixHQUFzQyxJQUE5QztBQUNILFNBTEMsRUFLQzNtQyxJQUxELENBS00sSUFMTixDQUZGLEVBUUVtZCxFQVJGO0FBVUQ7QUFDRjs7QUFFRCxXQUFRd2xDLHFCQUFxQnBqRCxHQUFyQixJQUE0QkMsR0FBcEM7QUFDRDs7QUFFRCxTQUFPO0FBQ0x3SSxhQUFTQSxPQURKO0FBRUxnN0Msd0JBQW9CQTtBQUZmLEdBQVA7QUFJRDs7QUFFRDs7QUFFQSxTQUFTRSxhQUFULENBQXdCOTBDLEVBQXhCLEVBQTRCL0ssT0FBNUIsRUFBcUM7QUFDbkMsTUFBSXRILE9BQU9zSCxRQUFRdEgsSUFBUixJQUFnQnduQyxRQUEzQjtBQUNBLE1BQUk3SixjQUFjNEssaUJBQWlCbDJCLEVBQWpCLEVBQXFCLE9BQXJCLENBQWxCO0FBQ0EsTUFBSW5YLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDbzZCLFdBQTdDLEVBQTBEO0FBQ3hELFFBQUk5TSxhQUFhNHFCLFVBQVU5ZCxXQUFWLEVBQXVCcjJCLFFBQVFnMEMsVUFBL0IsQ0FBakI7QUFDQSxRQUFJenFCLFVBQUosRUFBZ0I7QUFDZDd3QixXQUNFLGFBQWEyOUIsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRCxNQUFJQSxXQUFKLEVBQWlCO0FBQ2Z0ckIsT0FBR3NyQixXQUFILEdBQWlCdHZCLEtBQUtDLFNBQUwsQ0FBZXF2QixXQUFmLENBQWpCO0FBQ0Q7QUFDRCxNQUFJeXBCLGVBQWVoZixlQUFlLzFCLEVBQWYsRUFBbUIsT0FBbkIsRUFBNEIsS0FBNUIsQ0FBa0MsZUFBbEMsQ0FBbkI7QUFDQSxNQUFJKzBDLFlBQUosRUFBa0I7QUFDaEIvMEMsT0FBRyswQyxZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsU0FBVCxDQUFvQmgxQyxFQUFwQixFQUF3QjtBQUN0QixNQUFJelIsT0FBTyxFQUFYO0FBQ0EsTUFBSXlSLEdBQUdzckIsV0FBUCxFQUFvQjtBQUNsQi84QixZQUFRLGlCQUFrQnlSLEdBQUdzckIsV0FBckIsR0FBb0MsR0FBNUM7QUFDRDtBQUNELE1BQUl0ckIsR0FBRyswQyxZQUFQLEVBQXFCO0FBQ25CeG1ELFlBQVEsV0FBWXlSLEdBQUcrMEMsWUFBZixHQUErQixHQUF2QztBQUNEO0FBQ0QsU0FBT3htRCxJQUFQO0FBQ0Q7O0FBRUQsSUFBSTBtRCxVQUFVO0FBQ1o1cUMsY0FBWSxDQUFDLGFBQUQsQ0FEQTtBQUVaeXFDLGlCQUFlQSxhQUZIO0FBR1pqRCxXQUFTbUQ7QUFIRyxDQUFkOztBQU1BOztBQUVBLFNBQVNFLGVBQVQsQ0FBMEJsMUMsRUFBMUIsRUFBOEIvSyxPQUE5QixFQUF1QztBQUNyQyxNQUFJdEgsT0FBT3NILFFBQVF0SCxJQUFSLElBQWdCd25DLFFBQTNCO0FBQ0EsTUFBSWdGLGNBQWNqRSxpQkFBaUJsMkIsRUFBakIsRUFBcUIsT0FBckIsQ0FBbEI7QUFDQSxNQUFJbTZCLFdBQUosRUFBaUI7QUFDZjtBQUNBLFFBQUl0eEMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSXN0QixhQUFhNHFCLFVBQVVqUCxXQUFWLEVBQXVCbGxDLFFBQVFnMEMsVUFBL0IsQ0FBakI7QUFDQSxVQUFJenFCLFVBQUosRUFBZ0I7QUFDZDd3QixhQUNFLGFBQWF3c0MsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRG42QixPQUFHbTZCLFdBQUgsR0FBaUJuK0IsS0FBS0MsU0FBTCxDQUFlMjlCLGVBQWVPLFdBQWYsQ0FBZixDQUFqQjtBQUNEOztBQUVELE1BQUlnYixlQUFlcGYsZUFBZS8xQixFQUFmLEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLENBQWtDLGVBQWxDLENBQW5CO0FBQ0EsTUFBSW0xQyxZQUFKLEVBQWtCO0FBQ2hCbjFDLE9BQUdtMUMsWUFBSCxHQUFrQkEsWUFBbEI7QUFDRDtBQUNGOztBQUVELFNBQVNDLFNBQVQsQ0FBb0JwMUMsRUFBcEIsRUFBd0I7QUFDdEIsTUFBSXpSLE9BQU8sRUFBWDtBQUNBLE1BQUl5UixHQUFHbTZCLFdBQVAsRUFBb0I7QUFDbEI1ckMsWUFBUSxpQkFBa0J5UixHQUFHbTZCLFdBQXJCLEdBQW9DLEdBQTVDO0FBQ0Q7QUFDRCxNQUFJbjZCLEdBQUdtMUMsWUFBUCxFQUFxQjtBQUNuQjVtRCxZQUFRLFlBQWF5UixHQUFHbTFDLFlBQWhCLEdBQWdDLElBQXhDO0FBQ0Q7QUFDRCxTQUFPNW1ELElBQVA7QUFDRDs7QUFFRCxJQUFJOG1ELFVBQVU7QUFDWmhyQyxjQUFZLENBQUMsYUFBRCxDQURBO0FBRVp5cUMsaUJBQWVJLGVBRkg7QUFHWnJELFdBQVN1RDtBQUhHLENBQWQ7O0FBTUEsSUFBSUUsWUFBWSxDQUNkTCxPQURjLEVBRWRJLE9BRmMsQ0FBaEI7O0FBS0E7O0FBRUEsU0FBU2wrQixJQUFULENBQWVuWCxFQUFmLEVBQW1CNVQsR0FBbkIsRUFBd0I7QUFDdEIsTUFBSUEsSUFBSVMsS0FBUixFQUFlO0FBQ2J3b0MsWUFBUXIxQixFQUFSLEVBQVksYUFBWixFQUE0QixRQUFTNVQsSUFBSVMsS0FBYixHQUFzQixHQUFsRDtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsU0FBU2s1QyxJQUFULENBQWUvbEMsRUFBZixFQUFtQjVULEdBQW5CLEVBQXdCO0FBQ3RCLE1BQUlBLElBQUlTLEtBQVIsRUFBZTtBQUNid29DLFlBQVFyMUIsRUFBUixFQUFZLFdBQVosRUFBMEIsUUFBUzVULElBQUlTLEtBQWIsR0FBc0IsR0FBaEQ7QUFDRDtBQUNGOztBQUVELElBQUkwb0QsZUFBZTtBQUNqQnZ5QixTQUFPQSxLQURVO0FBRWpCN0wsUUFBTUEsSUFGVztBQUdqQjR1QixRQUFNQTtBQUhXLENBQW5COztBQU1BOztBQUVBLElBQUl1TyxjQUFjO0FBQ2hCbE4sY0FBWSxJQURJO0FBRWhCajlCLFdBQVNtckMsU0FGTztBQUdoQnRoQyxjQUFZdWhDLFlBSEk7QUFJaEJ4cEIsWUFBVUEsUUFKTTtBQUtoQjRaLGNBQVlBLFVBTEk7QUFNaEJ2NkIsZUFBYUEsV0FORztBQU9oQnc2QixvQkFBa0JBLGdCQVBGO0FBUWhCNTZCLGlCQUFlQSxhQVJDO0FBU2hCRSxtQkFBaUJBLGVBVEQ7QUFVaEJiLGNBQVlILGNBQWNvckMsU0FBZDtBQVZJLENBQWxCOztBQWFBLElBQUlFLFFBQVFuQixlQUFlQyxXQUFmLENBQVo7QUFDQSxJQUFJTSxxQkFBcUJZLE1BQU1aLGtCQUEvQjs7QUFFQTs7QUFFQSxJQUFJYSxlQUFlM3NDLE9BQU8sVUFBVTBHLEVBQVYsRUFBYztBQUN0QyxNQUFJeFAsS0FBS2xQLE1BQU0wZSxFQUFOLENBQVQ7QUFDQSxTQUFPeFAsTUFBTUEsR0FBR3lsQyxTQUFoQjtBQUNELENBSGtCLENBQW5COztBQUtBLElBQUlpUSxRQUFRcmhDLE1BQU1ycEIsU0FBTixDQUFnQnEzQixNQUE1QjtBQUNBaE8sTUFBTXJwQixTQUFOLENBQWdCcTNCLE1BQWhCLEdBQXlCLFVBQ3ZCcmlCLEVBRHVCLEVBRXZCNGIsU0FGdUIsRUFHdkI7QUFDQTViLE9BQUtBLE1BQU1sUCxNQUFNa1AsRUFBTixDQUFYOztBQUVBO0FBQ0EsTUFBSUEsT0FBT0MsU0FBU21rQyxJQUFoQixJQUF3QnBrQyxPQUFPQyxTQUFTVyxlQUE1QyxFQUE2RDtBQUMzRC9YLFlBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDdkQsS0FDdkMsMEVBRHVDLENBQXpDO0FBR0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSXNILFVBQVUsS0FBSzhCLFFBQW5CO0FBQ0E7QUFDQSxNQUFJLENBQUM5QixRQUFRL0csTUFBYixFQUFxQjtBQUNuQixRQUFJWCxXQUFXMEgsUUFBUTFILFFBQXZCO0FBQ0EsUUFBSUEsUUFBSixFQUFjO0FBQ1osVUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLFlBQUlBLFNBQVNxSyxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQTNCLEVBQWdDO0FBQzlCcksscUJBQVdrb0QsYUFBYWxvRCxRQUFiLENBQVg7QUFDQTtBQUNBLGNBQUkxRSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDM0QsUUFBOUMsRUFBd0Q7QUFDdERJLGlCQUNHLDZDQUE4Q3NILFFBQVExSCxRQUR6RCxFQUVFLElBRkY7QUFJRDtBQUNGO0FBQ0YsT0FYRCxNQVdPLElBQUlBLFNBQVN1a0MsUUFBYixFQUF1QjtBQUM1QnZrQyxtQkFBV0EsU0FBU2s0QyxTQUFwQjtBQUNELE9BRk0sTUFFQTtBQUNMLFlBQUk1OEMsUUFBUXVDLEdBQVIsQ0FBWThGLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN2RCxlQUFLLDZCQUE2QkosUUFBbEMsRUFBNEMsSUFBNUM7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0YsS0FwQkQsTUFvQk8sSUFBSXlTLEVBQUosRUFBUTtBQUNielMsaUJBQVdvb0QsYUFBYTMxQyxFQUFiLENBQVg7QUFDRDtBQUNELFFBQUl6UyxRQUFKLEVBQWM7QUFDWjtBQUNBLFVBQUkxRSxRQUFRdUMsR0FBUixDQUFZOEYsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BCLE9BQU8yUixXQUFoRCxJQUErRGtWLElBQW5FLEVBQXlFO0FBQ3ZFQSxhQUFLLFNBQUw7QUFDRDs7QUFFRCxVQUFJdm9CLE1BQU13bUQsbUJBQW1Ccm5ELFFBQW5CLEVBQTZCO0FBQ3JDbTRDLDhCQUFzQkEsb0JBRGU7QUFFckN1RCxvQkFBWWgwQyxRQUFRZzBDO0FBRmlCLE9BQTdCLEVBR1AsSUFITyxDQUFWO0FBSUEsVUFBSS82QyxTQUFTRSxJQUFJRixNQUFqQjtBQUNBLFVBQUkwMUIsa0JBQWtCeDFCLElBQUl3MUIsZUFBMUI7QUFDQTN1QixjQUFRL0csTUFBUixHQUFpQkEsTUFBakI7QUFDQStHLGNBQVEydUIsZUFBUixHQUEwQkEsZUFBMUI7O0FBRUE7QUFDQSxVQUFJLzZCLFFBQVF1QyxHQUFSLENBQVk4RixRQUFaLEtBQXlCLFlBQXpCLElBQXlDcEIsT0FBTzJSLFdBQWhELElBQStEa1YsSUFBbkUsRUFBeUU7QUFDdkVBLGFBQUssYUFBTDtBQUNBQyxnQkFBVSxLQUFLa0csS0FBTixHQUFlLFVBQXhCLEVBQXFDLFNBQXJDLEVBQWdELGFBQWhEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBTzQ0QixNQUFNaHNELElBQU4sQ0FBVyxJQUFYLEVBQWlCc1csRUFBakIsRUFBcUI0YixTQUFyQixDQUFQO0FBQ0QsQ0FoRUQ7O0FBa0VBOzs7O0FBSUEsU0FBUys1QixZQUFULENBQXVCMzFDLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUlBLEdBQUc0MUMsU0FBUCxFQUFrQjtBQUNoQixXQUFPNTFDLEdBQUc0MUMsU0FBVjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQUlDLFlBQVk1MUMsU0FBU3VqQixhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FxeUIsY0FBVTlvQixXQUFWLENBQXNCL3NCLEdBQUcra0MsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxXQUFPOFEsVUFBVXBRLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRHB4QixNQUFNemEsT0FBTixHQUFnQmc3QyxrQkFBaEI7O0FBRUEsK0RBQWV2Z0MsS0FBZixFOzs7Ozs7O0FDemxTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaURBQWlELElBQUk7QUFDcEksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7OztBQzNCQSxJQUFJdXlCLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLc04sU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFFNEIsSUFBSCxFQUFTLE1BQVQsQ0FBdEM7QUFDQSxDQUhELENBR0UsT0FBTXhzRCxDQUFOLEVBQVM7QUFDVjtBQUNBLEtBQUcsT0FBT2tPLE1BQVAsS0FBa0IsUUFBckIsRUFDQ292QyxJQUFJcHZDLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUExTyxPQUFPQyxPQUFQLEdBQWlCNjlDLENBQWpCLEM7Ozs7Ozs7OztBQ3BCQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsY0FBSTcrQixHQUFKO0FBQ0EsY0FBSUEsR0FBSjs7QUFFQSxNQUFNZ3VDLFFBQVEsRUFBRXhvRCxVQUFVLDJCQUFaLEVBQWQ7QUFDQSxNQUFNeW9ELE1BQU0sRUFBRXpvRCxVQUFVLGtRQUFaLEVBQVo7QUFDQSxNQUFNMG9ELE1BQU0sRUFBRTFvRCxVQUFVLGtRQUFaLEVBQVo7QUFDQSxNQUFNMm9ELE1BQU0sRUFBRTNvRCxVQUFVLGtRQUFaLEVBQVo7O0FBRUEsTUFBTXFILFNBQVMsd0JBQWM7QUFDNUIwRCxTQUFRLENBQ1AsRUFBRXRJLE1BQU0sR0FBUixFQUFhK0ksVUFBVSxRQUF2QixFQURPLEVBRVA7QUFDQy9JLFFBQU0sUUFEUDtBQUVDMUMsYUFBV3lvRCxLQUZaO0FBR0NuakQsUUFBTTtBQUNMdWpELGVBQVk7QUFEUCxHQUhQO0FBTUM5bkQsWUFBVSxDQUNUO0FBQ0MyQixTQUFNLEVBRFA7QUFFQzFDLGNBQVcwb0Q7QUFGWixHQURTLEVBS1Q7QUFDQ2htRCxTQUFNLEtBRFA7QUFFQzFDLGNBQVcyb0QsR0FGWjtBQUdDcmpELFNBQU07QUFDTHVqRCxnQkFBWTtBQURQO0FBSFAsR0FMUyxFQVlUO0FBQ0NubUQsU0FBTSxLQURQO0FBRUMxQyxjQUFXNG9ELEdBRlo7QUFHQ3RqRCxTQUFNO0FBQ0x1akQsZ0JBQVk7QUFEUDtBQUhQLEdBWlM7QUFOWCxFQUZPO0FBRG9CLENBQWQsQ0FBZjs7QUFpQ0Esa0JBQVE7QUFDUHZoRCxPQURPO0FBRVAxRixhQUFZO0FBQ1hrbkQ7QUFEVyxFQUZMO0FBS1A3b0QsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFMSixDQUFSLEVBc0JHODBCLE1BdEJILENBc0JVLE1BdEJWLEU7Ozs7OztBQzlDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsREEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBLENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiYXBwLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGEwZTY3ZTM4MTdjMTkxMWFiYzRkIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRmYWN0b3J5KGV4cG9ydHMpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBtb2QgPSB7XG5cdFx0XHRleHBvcnRzOiB7fVxuXHRcdH07XG5cdFx0ZmFjdG9yeShtb2QuZXhwb3J0cyk7XG5cdFx0Z2xvYmFsLmluZGV4ID0gbW9kLmV4cG9ydHM7XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xuXHRcdGluc3RhbGwoVnVlKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhWdWUucHJvdG90eXBlLCB7XG5cdFx0XHRcdCRicmVhZGNydW1iczoge1xuXHRcdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLiRyb3V0ZS5tYXRjaGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdFZ1ZS5jb21wb25lbnQoJ2JyZWFkY3J1bWJzJywge1xuXHRcdFx0XHR0ZW1wbGF0ZTogYDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIiB2LWlmPVwiJGJyZWFkY3J1bWJzLmxlbmd0aFwiPjxsaSBjbGFzcz1cImJyZWFkY3J1bWItaXRlbVwiIHYtaWY9XCJjcnVtYi5tZXRhLmJyZWFkY3J1bWJcIiB2LWZvcj1cIihjcnVtYiwgaSkgaW4gJGJyZWFkY3J1bWJzXCI+PHJvdXRlci1saW5rIDp0bz1cIiB7IHBhdGg6IGNydW1iLnBhdGggfVwiPnt7IGNydW1iLm1ldGEuYnJlYWRjcnVtYiB9fTwvcm91dGVyLWxpbms+PC9saT48L29sPmBcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3Z1ZS0yLWJyZWFkY3J1bWJzL2xpYi9pbmRleC5qcyIsIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuMi4xXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBpbmplY3QgaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tzXG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgaG9va3MuaW5pdCA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLnByZXBhdGNoID0gZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLmRlc3Ryb3kgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgIGlmIChtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9PT0gdm5vZGUuY2hpbGQpIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIHdhcm4oZmFsc2UsIChcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIGV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29tZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdmFyIHBhcnNlZFF1ZXJ5O1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRRdWVyeSA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkUXVlcnlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0cmFRdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAocmVmKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBTdHJpbmcoYVtrZXldKSA9PT0gU3RyaW5nKGJba2V5XSk7IH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzIHx8IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyB8fCAncm91dGVyLWxpbmstYWN0aXZlJztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGggPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgOiByb3V0ZTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldClcbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmICh0aGlzLiRvcHRpb25zLnJvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICc/JyB8fCByZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuJykge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpKSB7XG4gICAgICByb3V0ZS5hbGlhcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgYWxpYXNSb3V0ZSwgcGFyZW50LCByZWNvcmQucGF0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IHJvdXRlLmFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCBhbGlhc1JvdXRlLCBwYXJlbnQsIHJlY29yZC5wYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbnZhciBpbmRleCQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGlzYXJyYXkgPSBpbmRleCQxO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5pbmRleC5wYXJzZSA9IHBhcnNlXzE7XG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xuaW5kZXgudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbmluZGV4LnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbnZhciByZWdleHBDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXggKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHJlZ2V4cENhY2hlW3BhdGhdO1xuICB2YXIga2V5cywgcmVnZXhwO1xuXG4gIGlmIChoaXQpIHtcbiAgICBrZXlzID0gaGl0LmtleXM7XG4gICAgcmVnZXhwID0gaGl0LnJlZ2V4cDtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gW107XG4gICAgcmVnZXhwID0gaW5kZXgocGF0aCwga2V5cyk7XG4gICAgcmVnZXhwQ2FjaGVbcGF0aF0gPSB7IGtleXM6IGtleXMsIHJlZ2V4cDogcmVnZXhwIH07XG4gIH1cblxuICByZXR1cm4geyBrZXlzOiBrZXlzLCByZWdleHA6IHJlZ2V4cCB9XG59XG5cbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBpbmRleC5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkocGFyc2VkUGF0aC5xdWVyeSwgbmV4dC5xdWVyeSk7XG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKHJvdXRlcykge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSk7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gZ2V0Um91dGVSZWdleChyZWNvcmQucGF0aCkua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gcGF0aE1hcCkge1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShwYXRoLCBsb2NhdGlvbi5wYXJhbXMsIGxvY2F0aW9uLnBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShwYXRoTWFwW3BhdGhdLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcGF0aG5hbWVcbikge1xuICB2YXIgcmVmID0gZ2V0Um91dGVSZWdleChwYXRoKTtcbiAgdmFyIHJlZ2V4cCA9IHJlZi5yZWdleHA7XG4gIHZhciBrZXlzID0gcmVmLmtleXM7XG4gIHZhciBtID0gcGF0aG5hbWUubWF0Y2gocmVnZXhwKTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHsgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDsgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gICAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICBjYihyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIG9uQWJvcnQpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkgeyBvbkFib3J0ICYmIG9uQWJvcnQoKTsgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHRvID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSA/IHRoaXMkMS5yZXBsYWNlKHRvKSA6IHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgbmV4dCh0byk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICBydW5RdWV1ZShlbnRlckd1YXJkcywgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgVnVlIG9wdGlvbnMgYXR0YWNoZWQsXG4gICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgLy8gcmVzb2x2ZWQuXG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgIWRlZi5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB3YXJuKGZhbHNlLCAoXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb24pKTtcbiAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIHRoaXMkMS5jdXJyZW50LCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICB2YXIgaSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaSA+PSAwID8gaSA6IDApICsgJyMnICsgcGF0aFxuICApO1xufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHt9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICB0aGlzLmJlZm9yZUhvb2tzLnB1c2goZm4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHRoaXMuYWZ0ZXJIb29rcy5wdXNoKGZuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHRvLCBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LCBhcHBlbmQpO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMi4yLjEnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuMi41XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBfdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklOR1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwb3NzaWJsZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgIHJldHVybiBhID09PSBiXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0ge1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICovXG4gIF9hc3NldFR5cGVzOiBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXSxcblxuICAvKipcbiAgICogTGlzdCBvZiBsaWZlY3ljbGUgaG9va3MuXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnXG4gIF0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBzY2hlZHVsZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxufTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7IGNiLmNhbGwoY3R4KTsgfVxuICAgICAgaWYgKF9yZXNvbHZlKSB7IF9yZXNvbHZlKGN0eCk7IH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBmb3JtYXRMb2NhdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBcIjxBbm9ueW1vdXM+XCIpIHtcbiAgICAgIHN0ciArPSBcIiAtIHVzZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbiBmb3IgYmV0dGVyIGRlYnVnZ2luZyBtZXNzYWdlcy5cIjtcbiAgICB9XG4gICAgcmV0dXJuIChcIlxcbihmb3VuZCBpbiBcIiArIHN0ciArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlLFxuICBpc1NldHRpbmdQcm9wczogZmFsc2Vcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXJcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGV4dGVuZHNGcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLm9wdGlvbnMsIHZtKVxuICAgICAgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUkMykge1xuICAgICAgICBtaXhpbiA9IG1peGluLm9wdGlvbnM7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnTnVtYmVyJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ251bWJlcicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnYm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXVxufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjpcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnNcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gJyc7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmICghY3VyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFvbGQpIHtcbiAgICAgIGlmICghY3VyLmZucykge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoIW9uW25hbWVdKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoIW9sZEhvb2spIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2xkSG9vay5mbnMgJiYgb2xkSG9vay5tZXJnZWQpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjID09IG51bGwgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIGxhc3QudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjLnRleHQgJiYgbGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGMudGFnICYmIGMua2V5ID09IG51bGwgJiYgbmVzdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAmJiBjLmNvbXBvbmVudE9wdGlvbnM7IH0pWzBdXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UkJDEpIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICB2YXIgbmFtZSwgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBjaGlsZC5kYXRhICYmIChuYW1lID0gY2hpbGQuZGF0YS5zbG90KSkge1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zXG4pIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tmbnNbaV1bMF1dID0gZm5zW2ldWzFdO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIHF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkLCB2bTtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgc2NoZWR1bGVyIGJlZm9yZSB1cGRhdGVkIGhvb2sgY2FsbGVkXG4gIHZhciBvbGRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIHVwZGF0ZWQgaG9va3NcbiAgaW5kZXggPSBvbGRRdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgd2F0Y2hlciA9IG9sZFF1ZXVlW2luZGV4XTtcbiAgICB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICBpZiAodGhpcy51c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG4gIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxufVxuXG52YXIgaXNSZXNlcnZlZFByb3AgPSB7IGtleTogMSwgcmVmOiAxLCBzbG90OiAxIH07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKCFDdG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoIUN0b3IuY2lkKSB7XG4gICAgaWYgKEN0b3IucmVzb2x2ZWQpIHtcbiAgICAgIEN0b3IgPSBDdG9yLnJlc29sdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGl0J3Mgb2sgdG8gcXVldWUgdGhpcyBvbiBldmVyeSByZW5kZXIgYmVjYXVzZVxuICAgICAgICAvLyAkZm9yY2VVcGRhdGUgaXMgYnVmZmVyZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICAgICAgY29udGV4dC4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFDdG9yKSB7XG4gICAgICAgIC8vIHJldHVybiBub3RoaW5nIGlmIHRoaXMgaXMgaW5kZWVkIGFuIGFzeW5jIGNvbXBvbmVudFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGRhdGEubW9kZWwpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAocHJvcE9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhKTtcbiAgICB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBkYXRhOiBkYXRhLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjYlxuKSB7XG4gIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VDdG9yLmV4dGVuZChyZXMpO1xuICAgICAgfVxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIC8vIGhhbmRsZSBwcm9taXNlXG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgIWZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wcyAoZGF0YSwgQ3RvciwgdGFnKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGF0dHJzLmhhc093blByb3BlcnR5KGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaGFzaCkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAob25bZXZlbnRdKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAodm5vZGUpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnICYmICFjaGlsZC5ucykge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcFxuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciBpbmplY3QgPSB2bS4kb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKSkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pbmFjdGl2ZSkge1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdkZWFjdGl2YXRlZCcpO1xuICAgIH1cbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjIuNSc7XG5cbi8qICAqL1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBjaGlsZC5jbGFzc1xuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGcm9tRGF0YSAoZGF0YSkge1xuICB2YXIgZHluYW1pY0NsYXNzID0gZGF0YS5jbGFzcztcbiAgdmFyIHN0YXRpY0NsYXNzID0gZGF0YS5zdGF0aWNDbGFzcztcbiAgaWYgKHN0YXRpY0NsYXNzIHx8IGR5bmFtaWNDbGFzcykge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0pIHtcbiAgICAgICAgaWYgKChzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWQpIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJlxuICAgICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnRcbikge1xuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgdmFsdWUgKyBcIj0kJGN9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChvbltSQU5HRV9UT0tFTl0pIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlLFxuICBjYXB0dXJlXG4pIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLm9uICYmICF2bm9kZS5kYXRhLm9uKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmRvbVByb3BzICYmICF2bm9kZS5kYXRhLmRvbVByb3BzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKHByb3BzLl9fb2JfXykge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmICghZGF0YS5zdGF0aWNTdHlsZSAmJiAhZGF0YS5zdHlsZSAmJlxuICAgICAgIW9sZERhdGEuc3RhdGljU3R5bGUgJiYgIW9sZERhdGEuc3R5bGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZFZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICB2bm9kZS5kYXRhLnN0eWxlID0gc3R5bGUuX19vYl9fID8gZXh0ZW5kKHt9LCBzdHlsZSkgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlW25hbWVdID09IG51bGwpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fbGVhdmVDYikge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9lbnRlckNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2xlYXZlQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRMZWF2ZUR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoIWZuKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaW52b2tlckZucykge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIHJldHVybiAvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZylcbiAgICA/IGgoJ2tlZXAtYWxpdmUnKVxuICAgIDogbnVsbFxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIj5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxufVxuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+Lz1dKykvO1xudmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xudmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5dO1xudmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG4gICdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG4gICcoPzpcXFxccyooJyArIHNpbmdsZUF0dHJBc3NpZ24uc291cmNlICsgJyknICtcbiAgJ1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG4pO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbidcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCQxID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCQxKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0JDEuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3Q7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgdGFnTmFtZSA9PT0gJ2h0bWwnICYmIGxhc3RUYWcgPT09ICdoZWFkJyB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5qb2luKCcrJylcbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoZXZlbnRzLCBuYXRpdmUpIHtcbiAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMztcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMyA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG4gICkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICByZXR1cm4gXCJbXCIgKyBrZXkgKyBcIixmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn1dXCJcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vfi92dWUvZGlzdC92dWUuZXNtLmpzIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgbnVsbCxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWZhNjZlYjhcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaG9tZS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkQ6XFxcXHNhbmQtYm94XFxcXGdpdFxcXFx2dWUtclxcXFxzcmNcXFxcaG9tZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBob21lLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xZmE2NmViOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTFmYTY2ZWI4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2hvbWUudnVlXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgVnVlUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xuaW1wb3J0IEhvbWUgZnJvbSAnLi9ob21lLnZ1ZSc7XG5pbXBvcnQgVnVlQnJlYWRjcnVtYnMgZnJvbSAndnVlLTItYnJlYWRjcnVtYnMnO1xuXG5WdWUudXNlKFZ1ZVJvdXRlcik7XG5WdWUudXNlKFZ1ZUJyZWFkY3J1bWJzKTtcblxuY29uc3QgRmVlZHMgPSB7IHRlbXBsYXRlOiAnPGRpdj48cm91dGVyLXZpZXcvPjwvZGl2PicgfTtcbmNvbnN0IEJpeiA9IHsgdGVtcGxhdGU6ICc8ZGl2PjxoMj5CaXo8L2gyPjxwPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBJcHNhIHZvbHVwdGF0ZSBxdWlhIHF1YXMgYXNzdW1lbmRhIGJlYXRhZSB2ZXJvPyBPbW5pcywgcHJhZXNlbnRpdW0uIE1hZ25pIG5lc2NpdW50IGFsaWFzIGVsaWdlbmRpIHN1c2NpcGl0IHZlbCBkb2xvciBhY2N1c2FudGl1bSwgaXRhcXVlIHBvc3NpbXVzIG51bGxhIG1haW9yZXMgbm9zdHJ1bS48L3A+PC9kaXY+JyB9O1xuY29uc3QgRm9vID0geyB0ZW1wbGF0ZTogJzxkaXY+PGgyPkZvbzwvaDI+PHA+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIElwc2Egdm9sdXB0YXRlIHF1aWEgcXVhcyBhc3N1bWVuZGEgYmVhdGFlIHZlcm8/IE9tbmlzLCBwcmFlc2VudGl1bS4gTWFnbmkgbmVzY2l1bnQgYWxpYXMgZWxpZ2VuZGkgc3VzY2lwaXQgdmVsIGRvbG9yIGFjY3VzYW50aXVtLCBpdGFxdWUgcG9zc2ltdXMgbnVsbGEgbWFpb3JlcyBub3N0cnVtLjwvcD48L2Rpdj4nIH07XG5jb25zdCBCYXIgPSB7IHRlbXBsYXRlOiAnPGRpdj48aDI+QmFyPC9oMj48cD5Mb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gSXBzYSB2b2x1cHRhdGUgcXVpYSBxdWFzIGFzc3VtZW5kYSBiZWF0YWUgdmVybz8gT21uaXMsIHByYWVzZW50aXVtLiBNYWduaSBuZXNjaXVudCBhbGlhcyBlbGlnZW5kaSBzdXNjaXBpdCB2ZWwgZG9sb3IgYWNjdXNhbnRpdW0sIGl0YXF1ZSBwb3NzaW11cyBudWxsYSBtYWlvcmVzIG5vc3RydW0uPC9wPjwvZGl2PicgfTtcblxuY29uc3Qgcm91dGVyID0gbmV3IFZ1ZVJvdXRlcih7XG5cdHJvdXRlczogW1xuXHRcdHsgcGF0aDogJy8nLCByZWRpcmVjdDogJy9mZWVkcycgfSxcblx0XHR7XG5cdFx0XHRwYXRoOiAnL2ZlZWRzJyxcblx0XHRcdGNvbXBvbmVudDogRmVlZHMsXG5cdFx0XHRtZXRhOiB7XG5cdFx0XHRcdGJyZWFkY3J1bWI6ICdGZWVkcydcblx0XHRcdH0sXG5cdFx0XHRjaGlsZHJlbjogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF0aDogJycsXG5cdFx0XHRcdFx0Y29tcG9uZW50OiBCaXpcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhdGg6ICdmb28nLFxuXHRcdFx0XHRcdGNvbXBvbmVudDogRm9vLFxuXHRcdFx0XHRcdG1ldGE6IHtcblx0XHRcdFx0XHRcdGJyZWFkY3J1bWI6ICdmb28nXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF0aDogJ2JhcicsXG5cdFx0XHRcdFx0Y29tcG9uZW50OiBCYXIsXG5cdFx0XHRcdFx0bWV0YToge1xuXHRcdFx0XHRcdFx0YnJlYWRjcnVtYjogJ2Jhcidcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9XG5cdF1cbn0pO1xuXG5uZXcgVnVlKHtcblx0cm91dGVyLFxuXHRjb21wb25lbnRzOiB7XG5cdFx0SG9tZTogSG9tZVxuXHR9LFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxkaXYgaWQ9XCJhcHBcIiBjbGFzcz1cImNvbnRhaW5lclwiPlxuXHRcdFx0PHVsIGNsYXNzPVwibmF2XCI+XG5cdFx0XHRcdDxsaSBjbGFzcz1cIm5hdi1pdGVtICBkcm9wZG93blwiPlxuXHRcdFx0XHRcdDxyb3V0ZXItbGluayB0bz1cIi9mZWVkc1wiIGNsYXNzPVwibmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCIgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIHJvbGU9XCJidXR0b25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPkZlZWRzPC9yb3V0ZXItbGluaz5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPlxuXHRcdFx0XHQ8cm91dGVyLWxpbmsgdG89XCIvZmVlZHMvZm9vXCIgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCI+Rm9vPC9yb3V0ZXItbGluaz5cblx0XHRcdFx0PHJvdXRlci1saW5rIHRvPVwiL2ZlZWRzL2JhclwiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiPkJhcjwvcm91dGVyLWxpbms+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdFx0PGJyZWFkY3J1bWJzLz5cblx0XHRcdDxyb3V0ZXItdmlldy8+XG5cdFx0XHQ8aHI+XG5cdFx0XHQ8SG9tZS8+XG5cdFx0PC9kaXY+XG5cdGBcbn0pLiRtb3VudCgnI2FwcCcpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAuanMiLCIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfdm0uX20oMClcbn0sc3RhdGljUmVuZGVyRm5zOiBbZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCdoMycsIFtfdm0uX3YoXCJIb21lIGNvbXBvbmVudFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygncCcsIFtfdm0uX3YoXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVuaWFtIG1vbGVzdGlhcyBhcGVyaWFtIG9kaXQgc2l0IGhhcnVtIHF1YW0sIGxhYm9ydW0gbWFnbmFtLiBWZXJpdGF0aXMgaXRhcXVlIHRlbXBvcmlidXMgdml0YWUgYmVhdGFlIHF1YW0gZWFxdWUgdm9sdXB0YXRlbSBhbGlhcyBlbmltPyBNYXhpbWUsIGl0YXF1ZS4gRXZlbmlldC5cIildKV0pXG59XX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMWZhNjZlYjhcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMWZhNjZlYjhcIn0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9ob21lLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9